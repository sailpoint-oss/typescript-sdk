/* tslint:disable */
/* eslint-disable */
/**
 * IdentityNow V3 API
 * Use these APIs to interact with the IdentityNow platform to achieve repeatable, automated processes with greater scalability. We encourage you to join the SailPoint Developer Community forum at https://developer.sailpoint.com/discuss to connect with other developers using our APIs.
 *
 * The version of the OpenAPI document: 3.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, operationServerMap  } from './base';

/**
 * 
 * @export
 * @interface Access
 */
export interface Access {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof Access
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof Access
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Access
     */
    'displayName'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof Access
     */
    'type'?: DtoType;
    /**
     * 
     * @type {string}
     * @memberof Access
     */
    'description'?: string | null;
}


/**
 * 
 * @export
 * @interface AccessConstraint
 */
export interface AccessConstraint {
    /**
     * Type of Access
     * @type {string}
     * @memberof AccessConstraint
     */
    'type': AccessConstraintTypeEnum;
    /**
     * Must be set only if operator is SELECTED.
     * @type {Array<string>}
     * @memberof AccessConstraint
     */
    'ids'?: Array<string>;
    /**
     * Used to determine whether the scope of the campaign should be reduced for selected ids or all.
     * @type {string}
     * @memberof AccessConstraint
     */
    'operator': AccessConstraintOperatorEnum;
}

export const AccessConstraintTypeEnum = {
    Entitlement: 'ENTITLEMENT',
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE'
} as const;

export type AccessConstraintTypeEnum = typeof AccessConstraintTypeEnum[keyof typeof AccessConstraintTypeEnum];
export const AccessConstraintOperatorEnum = {
    All: 'ALL',
    Selected: 'SELECTED'
} as const;

export type AccessConstraintOperatorEnum = typeof AccessConstraintOperatorEnum[keyof typeof AccessConstraintOperatorEnum];

/**
 * 
 * @export
 * @interface AccessCriteria
 */
export interface AccessCriteria {
    /**
     * Business name for the access construct list
     * @type {string}
     * @memberof AccessCriteria
     */
    'name'?: string;
    /**
     * List of criteria. There is a min of 1 and max of 50 items in the list.
     * @type {Array<AccessCriteriaCriteriaListInner>}
     * @memberof AccessCriteria
     */
    'criteriaList'?: Array<AccessCriteriaCriteriaListInner>;
}
/**
 * 
 * @export
 * @interface AccessCriteriaCriteriaListInner
 */
export interface AccessCriteriaCriteriaListInner {
    /**
     * Type of the propery to which this reference applies to
     * @type {string}
     * @memberof AccessCriteriaCriteriaListInner
     */
    'type'?: AccessCriteriaCriteriaListInnerTypeEnum;
    /**
     * ID of the object to which this reference applies to
     * @type {string}
     * @memberof AccessCriteriaCriteriaListInner
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies to
     * @type {string}
     * @memberof AccessCriteriaCriteriaListInner
     */
    'name'?: string;
}

export const AccessCriteriaCriteriaListInnerTypeEnum = {
    Entitlement: 'ENTITLEMENT'
} as const;

export type AccessCriteriaCriteriaListInnerTypeEnum = typeof AccessCriteriaCriteriaListInnerTypeEnum[keyof typeof AccessCriteriaCriteriaListInnerTypeEnum];

/**
 * Identity the access item is requested for.
 * @export
 * @interface AccessItemRequestedFor
 */
export interface AccessItemRequestedFor {
    /**
     * DTO type of identity the access item is requested for.
     * @type {string}
     * @memberof AccessItemRequestedFor
     */
    'type'?: AccessItemRequestedForTypeEnum;
    /**
     * ID of identity the access item is requested for.
     * @type {string}
     * @memberof AccessItemRequestedFor
     */
    'id'?: string;
    /**
     * Human-readable display name of identity the access item is requested for.
     * @type {string}
     * @memberof AccessItemRequestedFor
     */
    'name'?: string;
}

export const AccessItemRequestedForTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type AccessItemRequestedForTypeEnum = typeof AccessItemRequestedForTypeEnum[keyof typeof AccessItemRequestedForTypeEnum];

/**
 * Access item requester\'s identity.
 * @export
 * @interface AccessItemRequester
 */
export interface AccessItemRequester {
    /**
     * Access item requester\'s DTO type.
     * @type {string}
     * @memberof AccessItemRequester
     */
    'type'?: AccessItemRequesterTypeEnum;
    /**
     * Access item requester\'s identity ID.
     * @type {string}
     * @memberof AccessItemRequester
     */
    'id'?: string;
    /**
     * Access item owner\'s human-readable display name.
     * @type {string}
     * @memberof AccessItemRequester
     */
    'name'?: string;
}

export const AccessItemRequesterTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type AccessItemRequesterTypeEnum = typeof AccessItemRequesterTypeEnum[keyof typeof AccessItemRequesterTypeEnum];

/**
 * Identity who reviewed the access item request.
 * @export
 * @interface AccessItemReviewedBy
 */
export interface AccessItemReviewedBy {
    /**
     * DTO type of identity who reviewed the access item request.
     * @type {string}
     * @memberof AccessItemReviewedBy
     */
    'type'?: AccessItemReviewedByTypeEnum;
    /**
     * ID of identity who reviewed the access item request.
     * @type {string}
     * @memberof AccessItemReviewedBy
     */
    'id'?: string;
    /**
     * Human-readable display name of identity who reviewed the access item request.
     * @type {string}
     * @memberof AccessItemReviewedBy
     */
    'name'?: string;
}

export const AccessItemReviewedByTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type AccessItemReviewedByTypeEnum = typeof AccessItemReviewedByTypeEnum[keyof typeof AccessItemReviewedByTypeEnum];

/**
 * 
 * @export
 * @interface AccessProfile
 */
export interface AccessProfile {
    /**
     * The ID of the Access Profile
     * @type {string}
     * @memberof AccessProfile
     */
    'id'?: string;
    /**
     * Name of the Access Profile
     * @type {string}
     * @memberof AccessProfile
     */
    'name': string;
    /**
     * Information about the Access Profile
     * @type {string}
     * @memberof AccessProfile
     */
    'description'?: string | null;
    /**
     * Date the Access Profile was created
     * @type {string}
     * @memberof AccessProfile
     */
    'created'?: string;
    /**
     * Date the Access Profile was last modified.
     * @type {string}
     * @memberof AccessProfile
     */
    'modified'?: string;
    /**
     * Whether the Access Profile is enabled. If the Access Profile is enabled then you must include at least one Entitlement.
     * @type {boolean}
     * @memberof AccessProfile
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {OwnerReference}
     * @memberof AccessProfile
     */
    'owner': OwnerReference;
    /**
     * 
     * @type {AccessProfileSourceRef}
     * @memberof AccessProfile
     */
    'source': AccessProfileSourceRef;
    /**
     * A list of entitlements associated with the Access Profile. If enabled is false this is allowed to be empty otherwise it needs to contain at least one Entitlement.
     * @type {Array<EntitlementRef>}
     * @memberof AccessProfile
     */
    'entitlements'?: Array<EntitlementRef> | null;
    /**
     * Whether the Access Profile is requestable via access request. Currently, making an Access Profile non-requestable is only supported  for customers enabled with the new Request Center. Otherwise, attempting to create an Access Profile with a value  **false** in this field results in a 400 error.
     * @type {boolean}
     * @memberof AccessProfile
     */
    'requestable'?: boolean;
    /**
     * 
     * @type {Requestability}
     * @memberof AccessProfile
     */
    'accessRequestConfig'?: Requestability;
    /**
     * 
     * @type {Revocability}
     * @memberof AccessProfile
     */
    'revocationRequestConfig'?: Revocability;
    /**
     * List of IDs of segments, if any, to which this Access Profile is assigned.
     * @type {Array<string>}
     * @memberof AccessProfile
     */
    'segments'?: Array<string> | null;
    /**
     * 
     * @type {ProvisioningCriteriaLevel1}
     * @memberof AccessProfile
     */
    'provisioningCriteria'?: ProvisioningCriteriaLevel1 | null;
}
/**
 * 
 * @export
 * @interface AccessProfileApprovalScheme
 */
export interface AccessProfileApprovalScheme {
    /**
     * Describes the individual or group that is responsible for an approval step. Values are as follows. **APP_OWNER**: The owner of the Application  **OWNER**: Owner of the associated Access Profile or Role  **SOURCE_OWNER**: Owner of the Source associated with an Access Profile  **MANAGER**: Manager of the Identity making the request  **GOVERNANCE_GROUP**: A Governance Group, the ID of which is specified by the **approverId** field
     * @type {string}
     * @memberof AccessProfileApprovalScheme
     */
    'approverType'?: AccessProfileApprovalSchemeApproverTypeEnum;
    /**
     * Id of the specific approver, used only when approverType is GOVERNANCE_GROUP
     * @type {string}
     * @memberof AccessProfileApprovalScheme
     */
    'approverId'?: string | null;
}

export const AccessProfileApprovalSchemeApproverTypeEnum = {
    AppOwner: 'APP_OWNER',
    Owner: 'OWNER',
    SourceOwner: 'SOURCE_OWNER',
    Manager: 'MANAGER',
    GovernanceGroup: 'GOVERNANCE_GROUP'
} as const;

export type AccessProfileApprovalSchemeApproverTypeEnum = typeof AccessProfileApprovalSchemeApproverTypeEnum[keyof typeof AccessProfileApprovalSchemeApproverTypeEnum];

/**
 * 
 * @export
 * @interface AccessProfileBulkDeleteRequest
 */
export interface AccessProfileBulkDeleteRequest {
    /**
     * List of IDs of Access Profiles to be deleted.
     * @type {Array<string>}
     * @memberof AccessProfileBulkDeleteRequest
     */
    'accessProfileIds'?: Array<string>;
    /**
     * If **true**, silently skip over any of the specified Access Profiles if they cannot be deleted because they are in use. If **false**, no deletions will be attempted if any of the Access Profiles are in use.
     * @type {boolean}
     * @memberof AccessProfileBulkDeleteRequest
     */
    'bestEffortOnly'?: boolean;
}
/**
 * 
 * @export
 * @interface AccessProfileBulkDeleteResponse
 */
export interface AccessProfileBulkDeleteResponse {
    /**
     * ID of the task which is executing the bulk deletion. This can be passed to the **_/task-status** API to track status.
     * @type {string}
     * @memberof AccessProfileBulkDeleteResponse
     */
    'taskId'?: string;
    /**
     * List of IDs of Access Profiles which are pending deletion.
     * @type {Array<string>}
     * @memberof AccessProfileBulkDeleteResponse
     */
    'pending'?: Array<string>;
    /**
     * List of usages of Access Profiles targeted for deletion.
     * @type {Array<AccessProfileUsage>}
     * @memberof AccessProfileBulkDeleteResponse
     */
    'inUse'?: Array<AccessProfileUsage>;
}
/**
 * This is more of a complete representation of an access profile.  
 * @export
 * @interface AccessProfileDocument
 */
export interface AccessProfileDocument {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof AccessProfileDocument
     */
    'id': string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof AccessProfileDocument
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof AccessProfileDocument
     */
    '_type': DocumentType;
    /**
     * The description of the access item
     * @type {string}
     * @memberof AccessProfileDocument
     */
    'description'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccessProfileDocument
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccessProfileDocument
     */
    'modified'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccessProfileDocument
     */
    'synced'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof AccessProfileDocument
     */
    'enabled'?: boolean;
    /**
     * Indicates if the access can be requested
     * @type {boolean}
     * @memberof AccessProfileDocument
     */
    'requestable'?: boolean;
    /**
     * Indicates if comments are required when requesting access
     * @type {boolean}
     * @memberof AccessProfileDocument
     */
    'requestCommentsRequired'?: boolean;
    /**
     * 
     * @type {Owner}
     * @memberof AccessProfileDocument
     */
    'owner'?: Owner;
    /**
     * 
     * @type {Reference1}
     * @memberof AccessProfileDocument
     */
    'source'?: Reference1;
    /**
     * 
     * @type {Array<BaseEntitlement>}
     * @memberof AccessProfileDocument
     */
    'entitlements'?: Array<BaseEntitlement>;
    /**
     * 
     * @type {number}
     * @memberof AccessProfileDocument
     */
    'entitlementCount'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccessProfileDocument
     */
    'tags'?: Array<string>;
}


/**
 * EntitlementReference
 * @export
 * @interface AccessProfileEntitlement
 */
export interface AccessProfileEntitlement {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof AccessProfileEntitlement
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof AccessProfileEntitlement
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileEntitlement
     */
    'displayName'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof AccessProfileEntitlement
     */
    'type'?: DtoType;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileEntitlement
     */
    'description'?: string | null;
    /**
     * 
     * @type {Reference1}
     * @memberof AccessProfileEntitlement
     */
    'source'?: Reference1;
    /**
     * 
     * @type {boolean}
     * @memberof AccessProfileEntitlement
     */
    'privileged'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileEntitlement
     */
    'attribute'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileEntitlement
     */
    'value'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AccessProfileEntitlement
     */
    'standalone'?: boolean;
}


/**
 * 
 * @export
 * @interface AccessProfileRef
 */
export interface AccessProfileRef {
    /**
     * ID of the Access Profile
     * @type {string}
     * @memberof AccessProfileRef
     */
    'id'?: string;
    /**
     * Type of requested object. This field must be either left null or set to \'ACCESS_PROFILE\' when creating an Access Profile, otherwise a 400 Bad Request error will result.
     * @type {string}
     * @memberof AccessProfileRef
     */
    'type'?: AccessProfileRefTypeEnum;
    /**
     * Human-readable display name of the Access Profile. This field is ignored on input.
     * @type {string}
     * @memberof AccessProfileRef
     */
    'name'?: string;
}

export const AccessProfileRefTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE'
} as const;

export type AccessProfileRefTypeEnum = typeof AccessProfileRefTypeEnum[keyof typeof AccessProfileRefTypeEnum];

/**
 * Role
 * @export
 * @interface AccessProfileRole
 */
export interface AccessProfileRole {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof AccessProfileRole
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof AccessProfileRole
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileRole
     */
    'displayName'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof AccessProfileRole
     */
    'type'?: DtoType;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileRole
     */
    'description'?: string | null;
    /**
     * 
     * @type {DisplayReference}
     * @memberof AccessProfileRole
     */
    'owner'?: DisplayReference;
    /**
     * 
     * @type {boolean}
     * @memberof AccessProfileRole
     */
    'disabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AccessProfileRole
     */
    'revocable'?: boolean;
}


/**
 * 
 * @export
 * @interface AccessProfileSourceRef
 */
export interface AccessProfileSourceRef {
    /**
     * The ID of the Source with with which the Access Profile is associated
     * @type {string}
     * @memberof AccessProfileSourceRef
     */
    'id'?: string;
    /**
     * The type of the Source, will always be SOURCE
     * @type {string}
     * @memberof AccessProfileSourceRef
     */
    'type'?: AccessProfileSourceRefTypeEnum;
    /**
     * The display name of the associated Source
     * @type {string}
     * @memberof AccessProfileSourceRef
     */
    'name'?: string;
}

export const AccessProfileSourceRefTypeEnum = {
    Source: 'SOURCE'
} as const;

export type AccessProfileSourceRefTypeEnum = typeof AccessProfileSourceRefTypeEnum[keyof typeof AccessProfileSourceRefTypeEnum];

/**
 * This is a summary representation of an access profile.
 * @export
 * @interface AccessProfileSummary
 */
export interface AccessProfileSummary {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof AccessProfileSummary
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof AccessProfileSummary
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileSummary
     */
    'displayName'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof AccessProfileSummary
     */
    'type'?: DtoType;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileSummary
     */
    'description'?: string | null;
    /**
     * 
     * @type {Reference1}
     * @memberof AccessProfileSummary
     */
    'source'?: Reference1;
    /**
     * 
     * @type {DisplayReference}
     * @memberof AccessProfileSummary
     */
    'owner'?: DisplayReference;
    /**
     * 
     * @type {boolean}
     * @memberof AccessProfileSummary
     */
    'revocable'?: boolean;
}


/**
 * 
 * @export
 * @interface AccessProfileUsage
 */
export interface AccessProfileUsage {
    /**
     * ID of the Access Profile that is in use
     * @type {string}
     * @memberof AccessProfileUsage
     */
    'accessProfileId'?: string;
    /**
     * List of references to objects which are using the indicated Access Profile
     * @type {Array<AccessProfileUsageUsedByInner>}
     * @memberof AccessProfileUsage
     */
    'usedBy'?: Array<AccessProfileUsageUsedByInner>;
}
/**
 * Role using the access profile.
 * @export
 * @interface AccessProfileUsageUsedByInner
 */
export interface AccessProfileUsageUsedByInner {
    /**
     * DTO type of role using the access profile.
     * @type {string}
     * @memberof AccessProfileUsageUsedByInner
     */
    'type'?: AccessProfileUsageUsedByInnerTypeEnum;
    /**
     * ID of role using the access profile.
     * @type {string}
     * @memberof AccessProfileUsageUsedByInner
     */
    'id'?: string;
    /**
     * Display name of role using the access profile.
     * @type {string}
     * @memberof AccessProfileUsageUsedByInner
     */
    'name'?: string;
}

export const AccessProfileUsageUsedByInnerTypeEnum = {
    Role: 'ROLE'
} as const;

export type AccessProfileUsageUsedByInnerTypeEnum = typeof AccessProfileUsageUsedByInnerTypeEnum[keyof typeof AccessProfileUsageUsedByInnerTypeEnum];

/**
 * 
 * @export
 * @interface AccessRequest
 */
export interface AccessRequest {
    /**
     * A list of Identity IDs for whom the Access is requested. If it\'s a Revoke request, there can only be one Identity ID.
     * @type {Array<string>}
     * @memberof AccessRequest
     */
    'requestedFor': Array<string>;
    /**
     * 
     * @type {AccessRequestType}
     * @memberof AccessRequest
     */
    'requestType'?: AccessRequestType;
    /**
     * 
     * @type {Array<AccessRequestItem>}
     * @memberof AccessRequest
     */
    'requestedItems': Array<AccessRequestItem>;
    /**
     * Arbitrary key-value pairs. They will never be processed by the IdentityNow system but will be returned on associated APIs such as /account-activities.
     * @type {{ [key: string]: string; }}
     * @memberof AccessRequest
     */
    'clientMetadata'?: { [key: string]: string; };
}


/**
 * 
 * @export
 * @interface AccessRequestConfig
 */
export interface AccessRequestConfig {
    /**
     * If true, then approvals must be processed by external system.
     * @type {boolean}
     * @memberof AccessRequestConfig
     */
    'approvalsMustBeExternal'?: boolean;
    /**
     * If true and requester and reviewer are the same, then automatically approve the approval.
     * @type {boolean}
     * @memberof AccessRequestConfig
     */
    'autoApprovalEnabled'?: boolean;
    /**
     * 
     * @type {RequestOnBehalfOfConfig}
     * @memberof AccessRequestConfig
     */
    'requestOnBehalfOfConfig'?: RequestOnBehalfOfConfig;
    /**
     * 
     * @type {ApprovalReminderAndEscalationConfig}
     * @memberof AccessRequestConfig
     */
    'approvalReminderAndEscalationConfig'?: ApprovalReminderAndEscalationConfig;
    /**
     * 
     * @type {EntitlementRequestConfig}
     * @memberof AccessRequestConfig
     */
    'entitlementRequestConfig'?: EntitlementRequestConfig;
}
/**
 * 
 * @export
 * @interface AccessRequestItem
 */
export interface AccessRequestItem {
    /**
     * The type of the item being requested.
     * @type {string}
     * @memberof AccessRequestItem
     */
    'type': AccessRequestItemTypeEnum;
    /**
     * ID of Role, Access Profile or Entitlement being requested.
     * @type {string}
     * @memberof AccessRequestItem
     */
    'id': string;
    /**
     * Comment provided by requester. * Comment is required when the request is of type Revoke Access. 
     * @type {string}
     * @memberof AccessRequestItem
     */
    'comment'?: string;
    /**
     * Arbitrary key-value pairs. They will never be processed by the IdentityNow system but will be returned on associated APIs such as /account-activities and /access-request-status.
     * @type {{ [key: string]: string; }}
     * @memberof AccessRequestItem
     */
    'clientMetadata'?: { [key: string]: string; };
    /**
     * The date the role or access profile is no longer assigned to the specified identity. * Specify a date in the future. * The current SLA for the deprovisioning is 24 hours. * This date can be modified to either extend or decrease the duration of access item assignments for the specified identity. * Currently it is not supported for entitlements. 
     * @type {string}
     * @memberof AccessRequestItem
     */
    'removeDate'?: string;
}

export const AccessRequestItemTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE',
    Entitlement: 'ENTITLEMENT'
} as const;

export type AccessRequestItemTypeEnum = typeof AccessRequestItemTypeEnum[keyof typeof AccessRequestItemTypeEnum];

/**
 * Provides additional details about this access request phase.
 * @export
 * @interface AccessRequestPhases
 */
export interface AccessRequestPhases {
    /**
     * The time that this phase started.
     * @type {string}
     * @memberof AccessRequestPhases
     */
    'started'?: string;
    /**
     * The time that this phase finished.
     * @type {string}
     * @memberof AccessRequestPhases
     */
    'finished'?: string;
    /**
     * The name of this phase.
     * @type {string}
     * @memberof AccessRequestPhases
     */
    'name'?: string;
    /**
     * The state of this phase.
     * @type {string}
     * @memberof AccessRequestPhases
     */
    'state'?: AccessRequestPhasesStateEnum;
    /**
     * The state of this phase.
     * @type {string}
     * @memberof AccessRequestPhases
     */
    'result'?: AccessRequestPhasesResultEnum;
    /**
     * A reference to another object on the RequestedItemStatus that contains more details about the phase. Note that for the Provisioning phase, this will be empty if there are no manual work items.
     * @type {string}
     * @memberof AccessRequestPhases
     */
    'phaseReference'?: string;
}

export const AccessRequestPhasesStateEnum = {
    Pending: 'PENDING',
    Executing: 'EXECUTING',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED'
} as const;

export type AccessRequestPhasesStateEnum = typeof AccessRequestPhasesStateEnum[keyof typeof AccessRequestPhasesStateEnum];
export const AccessRequestPhasesResultEnum = {
    Successful: 'SUCCESSFUL',
    Failed: 'FAILED'
} as const;

export type AccessRequestPhasesResultEnum = typeof AccessRequestPhasesResultEnum[keyof typeof AccessRequestPhasesResultEnum];

/**
 * Access request type. Defaults to GRANT_ACCESS. REVOKE_ACCESS type can only have a single Identity ID in the requestedFor field.
 * @export
 * @enum {string}
 */

export const AccessRequestType = {
    GrantAccess: 'GRANT_ACCESS',
    RevokeAccess: 'REVOKE_ACCESS'
} as const;

export type AccessRequestType = typeof AccessRequestType[keyof typeof AccessRequestType];


/**
 * 
 * @export
 * @interface AccessReviewItem
 */
export interface AccessReviewItem {
    /**
     * 
     * @type {AccessSummary}
     * @memberof AccessReviewItem
     */
    'accessSummary'?: AccessSummary;
    /**
     * 
     * @type {CertificationIdentitySummary}
     * @memberof AccessReviewItem
     */
    'identitySummary'?: CertificationIdentitySummary;
    /**
     * The review item\'s id
     * @type {string}
     * @memberof AccessReviewItem
     */
    'id'?: string;
    /**
     * Whether the review item is complete
     * @type {boolean}
     * @memberof AccessReviewItem
     */
    'completed'?: boolean;
    /**
     * Indicates whether the review item is for new access to a source
     * @type {boolean}
     * @memberof AccessReviewItem
     */
    'newAccess'?: boolean;
    /**
     * 
     * @type {CertificationDecision}
     * @memberof AccessReviewItem
     */
    'decision'?: CertificationDecision;
    /**
     * Comments for this review item
     * @type {string}
     * @memberof AccessReviewItem
     */
    'comments'?: string | null;
}


/**
 * 
 * @export
 * @interface AccessReviewReassignment
 */
export interface AccessReviewReassignment {
    /**
     * 
     * @type {Array<ReassignReference>}
     * @memberof AccessReviewReassignment
     */
    'reassign': Array<ReassignReference>;
    /**
     * The ID of the identity to which the certification is reassigned
     * @type {string}
     * @memberof AccessReviewReassignment
     */
    'reassignTo': string;
    /**
     * The reason comment for why the reassign was made
     * @type {string}
     * @memberof AccessReviewReassignment
     */
    'reason': string;
}
/**
 * An object holding the access that is being reviewed
 * @export
 * @interface AccessSummary
 */
export interface AccessSummary {
    /**
     * 
     * @type {AccessSummaryAccess}
     * @memberof AccessSummary
     */
    'access'?: AccessSummaryAccess;
    /**
     * 
     * @type {ReviewableEntitlement}
     * @memberof AccessSummary
     */
    'entitlement'?: ReviewableEntitlement | null;
    /**
     * 
     * @type {ReviewableAccessProfile}
     * @memberof AccessSummary
     */
    'accessProfile'?: ReviewableAccessProfile;
    /**
     * 
     * @type {ReviewableRole}
     * @memberof AccessSummary
     */
    'role'?: ReviewableRole | null;
}
/**
 * 
 * @export
 * @interface AccessSummaryAccess
 */
export interface AccessSummaryAccess {
    /**
     * 
     * @type {DtoType}
     * @memberof AccessSummaryAccess
     */
    'type'?: DtoType;
    /**
     * The ID of the item being certified
     * @type {string}
     * @memberof AccessSummaryAccess
     */
    'id'?: string;
    /**
     * The name of the item being certified
     * @type {string}
     * @memberof AccessSummaryAccess
     */
    'name'?: string;
}


/**
 * Access type of API Client indicating online or offline use
 * @export
 * @enum {string}
 */

export const AccessType = {
    Online: 'ONLINE',
    Offline: 'OFFLINE'
} as const;

export type AccessType = typeof AccessType[keyof typeof AccessType];


/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof Account
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof Account
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof Account
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof Account
     */
    'modified'?: string;
    /**
     * The unique ID of the source this account belongs to
     * @type {string}
     * @memberof Account
     */
    'sourceId': string;
    /**
     * The display name of the source this account belongs to
     * @type {string}
     * @memberof Account
     */
    'sourceName': string;
    /**
     * The unique ID of the identity this account is correlated to
     * @type {string}
     * @memberof Account
     */
    'identityId'?: string;
    /**
     * The account attributes that are aggregated
     * @type {{ [key: string]: any; }}
     * @memberof Account
     */
    'attributes': { [key: string]: any; };
    /**
     * Indicates if this account is from an authoritative source
     * @type {boolean}
     * @memberof Account
     */
    'authoritative': boolean;
    /**
     * A description of the account
     * @type {string}
     * @memberof Account
     */
    'description'?: string | null;
    /**
     * Indicates if the account is currently disabled
     * @type {boolean}
     * @memberof Account
     */
    'disabled': boolean;
    /**
     * Indicates if the account is currently locked
     * @type {boolean}
     * @memberof Account
     */
    'locked': boolean;
    /**
     * The unique ID of the account generated by the source system
     * @type {string}
     * @memberof Account
     */
    'nativeIdentity': string;
    /**
     * If true, this is a user account within IdentityNow.  If false, this is an account from a source system.
     * @type {boolean}
     * @memberof Account
     */
    'systemAccount': boolean;
    /**
     * Indicates if this account is not correlated to an identity
     * @type {boolean}
     * @memberof Account
     */
    'uncorrelated': boolean;
    /**
     * The unique ID of the account as determined by the account schema
     * @type {string}
     * @memberof Account
     */
    'uuid'?: string | null;
    /**
     * Indicates if the account has been manually correlated to an identity
     * @type {boolean}
     * @memberof Account
     */
    'manuallyCorrelated': boolean;
    /**
     * Indicates if the account has entitlements
     * @type {boolean}
     * @memberof Account
     */
    'hasEntitlements': boolean;
}
/**
 * Object for specifying Actions to be performed on a specified list of sources\' account.
 * @export
 * @interface AccountAction
 */
export interface AccountAction {
    /**
     * Describes if action will be enabled or disabled
     * @type {string}
     * @memberof AccountAction
     */
    'action'?: AccountActionActionEnum;
    /**
     * List of unique source IDs. The sources must have the ENABLE feature or flat file source. See \"/sources\" endpoint for source features.
     * @type {Set<string>}
     * @memberof AccountAction
     */
    'sourceIds'?: Set<string>;
}

export const AccountActionActionEnum = {
    Enable: 'ENABLE',
    Disable: 'DISABLE'
} as const;

export type AccountActionActionEnum = typeof AccountActionActionEnum[keyof typeof AccountActionActionEnum];

/**
 * 
 * @export
 * @interface AccountActivity
 */
export interface AccountActivity {
    /**
     * Id of the account activity
     * @type {string}
     * @memberof AccountActivity
     */
    'id'?: string;
    /**
     * The name of the activity
     * @type {string}
     * @memberof AccountActivity
     */
    'name'?: string;
    /**
     * When the activity was first created
     * @type {string}
     * @memberof AccountActivity
     */
    'created'?: string;
    /**
     * When the activity was last modified
     * @type {string}
     * @memberof AccountActivity
     */
    'modified'?: string | null;
    /**
     * When the activity was completed
     * @type {string}
     * @memberof AccountActivity
     */
    'completed'?: string | null;
    /**
     * 
     * @type {CompletionStatus}
     * @memberof AccountActivity
     */
    'completionStatus'?: CompletionStatus | null;
    /**
     * The type of action the activity performed.  Please see the following list of types.  This list may grow over time.  - CloudAutomated - IdentityAttributeUpdate - appRequest - LifecycleStateChange - AccountStateUpdate - AccountAttributeUpdate - CloudPasswordRequest - Attribute Synchronization Refresh - Certification - Identity Refresh - Lifecycle Change Refresh   [Learn more here](https://documentation.sailpoint.com/saas/help/search/searchable-fields.html#searching-account-activity-data). 
     * @type {string}
     * @memberof AccountActivity
     */
    'type'?: string | null;
    /**
     * 
     * @type {IdentitySummary}
     * @memberof AccountActivity
     */
    'requesterIdentitySummary'?: IdentitySummary | null;
    /**
     * 
     * @type {IdentitySummary}
     * @memberof AccountActivity
     */
    'targetIdentitySummary'?: IdentitySummary | null;
    /**
     * A list of error messages, if any, that were encountered.
     * @type {Array<string>}
     * @memberof AccountActivity
     */
    'errors'?: Array<string> | null;
    /**
     * A list of warning messages, if any, that were encountered.
     * @type {Array<string>}
     * @memberof AccountActivity
     */
    'warnings'?: Array<string> | null;
    /**
     * Individual actions performed as part of this account activity
     * @type {Array<AccountActivityItem>}
     * @memberof AccountActivity
     */
    'items'?: Array<AccountActivityItem>;
    /**
     * 
     * @type {ExecutionStatus}
     * @memberof AccountActivity
     */
    'executionStatus'?: ExecutionStatus;
    /**
     * Arbitrary key-value pairs, if any were included in the corresponding access request
     * @type {{ [key: string]: string; }}
     * @memberof AccountActivity
     */
    'clientMetadata'?: { [key: string]: string; } | null;
}


/**
 * AccountActivity
 * @export
 * @interface AccountActivityDocument
 */
export interface AccountActivityDocument {
    /**
     * 
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof AccountActivityDocument
     */
    '_type': DocumentType;
    /**
     * The type of action that this activity performed
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'action'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'modified'?: string | null;
    /**
     * The current stage of the activity
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'stage'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'origin'?: string | null;
    /**
     * the current status of the activity
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'status'?: string;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountActivityDocument
     */
    'requester'?: AccountSource;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountActivityDocument
     */
    'recipient'?: AccountSource;
    /**
     * 
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'trackingNumber'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountActivityDocument
     */
    'errors'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountActivityDocument
     */
    'warnings'?: Array<string> | null;
    /**
     * 
     * @type {Array<Approval>}
     * @memberof AccountActivityDocument
     */
    'approvals'?: Array<Approval>;
    /**
     * 
     * @type {Array<OriginalRequest>}
     * @memberof AccountActivityDocument
     */
    'originalRequests'?: Array<OriginalRequest>;
    /**
     * 
     * @type {Array<ExpansionItem>}
     * @memberof AccountActivityDocument
     */
    'expansionItems'?: Array<ExpansionItem>;
    /**
     * 
     * @type {Array<AccountRequest>}
     * @memberof AccountActivityDocument
     */
    'accountRequests'?: Array<AccountRequest>;
    /**
     * 
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'sources'?: string;
}


/**
 * 
 * @export
 * @interface AccountActivityItem
 */
export interface AccountActivityItem {
    /**
     * Item id
     * @type {string}
     * @memberof AccountActivityItem
     */
    'id'?: string;
    /**
     * Human-readable display name of item
     * @type {string}
     * @memberof AccountActivityItem
     */
    'name'?: string;
    /**
     * Date and time item was requested
     * @type {string}
     * @memberof AccountActivityItem
     */
    'requested'?: string;
    /**
     * 
     * @type {WorkItemState}
     * @memberof AccountActivityItem
     */
    'approvalStatus'?: WorkItemState;
    /**
     * 
     * @type {ProvisioningState}
     * @memberof AccountActivityItem
     */
    'provisioningStatus'?: ProvisioningState;
    /**
     * 
     * @type {Comment}
     * @memberof AccountActivityItem
     */
    'requesterComment'?: Comment | null;
    /**
     * 
     * @type {IdentitySummary}
     * @memberof AccountActivityItem
     */
    'reviewerIdentitySummary'?: IdentitySummary | null;
    /**
     * 
     * @type {Comment}
     * @memberof AccountActivityItem
     */
    'reviewerComment'?: Comment | null;
    /**
     * 
     * @type {AccountActivityItemOperation}
     * @memberof AccountActivityItem
     */
    'operation'?: AccountActivityItemOperation;
    /**
     * Attribute to which account activity applies
     * @type {string}
     * @memberof AccountActivityItem
     */
    'attribute'?: string | null;
    /**
     * Value of attribute
     * @type {string}
     * @memberof AccountActivityItem
     */
    'value'?: string | null;
    /**
     * Native identity in the target system to which the account activity applies
     * @type {string}
     * @memberof AccountActivityItem
     */
    'nativeIdentity'?: string | null;
    /**
     * Id of Source to which account activity applies
     * @type {string}
     * @memberof AccountActivityItem
     */
    'sourceId'?: string;
    /**
     * 
     * @type {AccountRequestInfo}
     * @memberof AccountActivityItem
     */
    'accountRequestInfo'?: AccountRequestInfo | null;
    /**
     * Arbitrary key-value pairs, if any were included in the corresponding access request item
     * @type {{ [key: string]: string; }}
     * @memberof AccountActivityItem
     */
    'clientMetadata'?: { [key: string]: string; } | null;
    /**
     * The date the role or access profile is no longer assigned to the specified identity.
     * @type {string}
     * @memberof AccountActivityItem
     */
    'removeDate'?: string | null;
}


/**
 * Represents an operation in an account activity item
 * @export
 * @enum {string}
 */

export const AccountActivityItemOperation = {
    Add: 'ADD',
    Create: 'CREATE',
    Modify: 'MODIFY',
    Delete: 'DELETE',
    Disable: 'DISABLE',
    Enable: 'ENABLE',
    Unlock: 'UNLOCK',
    Lock: 'LOCK',
    Remove: 'REMOVE'
} as const;

export type AccountActivityItemOperation = typeof AccountActivityItemOperation[keyof typeof AccountActivityItemOperation];


/**
 * AccountActivity
 * @export
 * @interface AccountActivitySearchedItem
 */
export interface AccountActivitySearchedItem {
    /**
     * 
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof AccountActivitySearchedItem
     */
    '_type': DocumentType;
    /**
     * The type of action that this activity performed
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'action'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'modified'?: string | null;
    /**
     * The current stage of the activity
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'stage'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'origin'?: string | null;
    /**
     * the current status of the activity
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'status'?: string;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountActivitySearchedItem
     */
    'requester'?: AccountSource;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountActivitySearchedItem
     */
    'recipient'?: AccountSource;
    /**
     * 
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'trackingNumber'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountActivitySearchedItem
     */
    'errors'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountActivitySearchedItem
     */
    'warnings'?: Array<string> | null;
    /**
     * 
     * @type {Array<Approval>}
     * @memberof AccountActivitySearchedItem
     */
    'approvals'?: Array<Approval>;
    /**
     * 
     * @type {Array<OriginalRequest>}
     * @memberof AccountActivitySearchedItem
     */
    'originalRequests'?: Array<OriginalRequest>;
    /**
     * 
     * @type {Array<ExpansionItem>}
     * @memberof AccountActivitySearchedItem
     */
    'expansionItems'?: Array<ExpansionItem>;
    /**
     * 
     * @type {Array<AccountRequest>}
     * @memberof AccountActivitySearchedItem
     */
    'accountRequests'?: Array<AccountRequest>;
    /**
     * 
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'sources'?: string;
}


/**
 * 
 * @export
 * @interface AccountAttribute
 */
export interface AccountAttribute {
    /**
     * A reference to the source to search for the account
     * @type {string}
     * @memberof AccountAttribute
     */
    'sourceName': string;
    /**
     * The name of the attribute on the account to return. This should match the name of the account attribute name visible in the user interface, or on the source schema.
     * @type {string}
     * @memberof AccountAttribute
     */
    'attributeName': string;
    /**
     * The value of this configuration is a string name of the attribute to use when determining the ordering of returned accounts when there are multiple entries
     * @type {string}
     * @memberof AccountAttribute
     */
    'accountSortAttribute'?: string;
    /**
     * The value of this configuration is a boolean (true/false). Controls the order of the sort when there are multiple accounts. If not defined, the transform will default to false (ascending order)
     * @type {boolean}
     * @memberof AccountAttribute
     */
    'accountSortDescending'?: boolean;
    /**
     * The value of this configuration is a boolean (true/false). Controls which account to source a value from for an attribute.  If this flag is set to true, the transform returns the value from the first account in the list, even if it is null. If it is set to false, the transform returns the first non-null value. If not defined, the transform will default to false
     * @type {boolean}
     * @memberof AccountAttribute
     */
    'accountReturnFirstLink'?: boolean;
    /**
     * This expression queries the database to narrow search results. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the database.  The default filter will always include the source and identity, and any subsequent expressions will be combined in an AND operation to the existing search criteria. Only certain searchable attributes are available:  - `nativeIdentity` - the Account ID  - `displayName` - the Account Name  - `entitlements` - a boolean value to determine if the account has entitlements
     * @type {string}
     * @memberof AccountAttribute
     */
    'accountFilter'?: string;
    /**
     * This expression is used to search and filter accounts in memory. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the returned resultset.  All account attributes are available for filtering as this operation is performed in memory.
     * @type {string}
     * @memberof AccountAttribute
     */
    'accountPropertyFilter'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof AccountAttribute
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof AccountAttribute
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface AccountAttributes
 */
export interface AccountAttributes {
    /**
     * The schema attribute values for the account
     * @type {{ [key: string]: any; }}
     * @memberof AccountAttributes
     */
    'attributes': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface AccountAttributesCreate
 */
export interface AccountAttributesCreate {
    /**
     * 
     * @type {AccountAttributesCreateAttributes}
     * @memberof AccountAttributesCreate
     */
    'attributes': AccountAttributesCreateAttributes;
}
/**
 * The schema attribute values for the account
 * @export
 * @interface AccountAttributesCreateAttributes
 */
export interface AccountAttributesCreateAttributes {
    [key: string]: string;

    /**
     * Target source to create an account
     * @type {string}
     * @memberof AccountAttributesCreateAttributes
     */
    'sourceId': string;
}
/**
 * 
 * @export
 * @interface AccountRequest
 */
export interface AccountRequest {
    /**
     * Unique ID of the account
     * @type {string}
     * @memberof AccountRequest
     */
    'accountId'?: string;
    /**
     * 
     * @type {Array<AttributeRequest>}
     * @memberof AccountRequest
     */
    'attributeRequests'?: Array<AttributeRequest>;
    /**
     * The operation that was performed
     * @type {string}
     * @memberof AccountRequest
     */
    'op'?: string;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountRequest
     */
    'provisioningTarget'?: AccountSource;
    /**
     * 
     * @type {AccountRequestResult}
     * @memberof AccountRequest
     */
    'result'?: AccountRequestResult;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountRequest
     */
    'source'?: AccountSource;
}
/**
 * If an account activity item is associated with an access request, captures details of that request.
 * @export
 * @interface AccountRequestInfo
 */
export interface AccountRequestInfo {
    /**
     * Id of requested object
     * @type {string}
     * @memberof AccountRequestInfo
     */
    'requestedObjectId'?: string;
    /**
     * Human-readable name of requested object
     * @type {string}
     * @memberof AccountRequestInfo
     */
    'requestedObjectName'?: string;
    /**
     * 
     * @type {RequestableObjectType}
     * @memberof AccountRequestInfo
     */
    'requestedObjectType'?: RequestableObjectType;
}


/**
 * 
 * @export
 * @interface AccountRequestResult
 */
export interface AccountRequestResult {
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountRequestResult
     */
    'errors'?: Array<string>;
    /**
     * The status of the account request
     * @type {string}
     * @memberof AccountRequestResult
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountRequestResult
     */
    'ticketId'?: string | null;
}
/**
 * 
 * @export
 * @interface AccountSource
 */
export interface AccountSource {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof AccountSource
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof AccountSource
     */
    'name'?: string;
    /**
     * the type of source returned
     * @type {string}
     * @memberof AccountSource
     */
    'type'?: string;
}
/**
 * Request used for account enable/disable
 * @export
 * @interface AccountToggleRequest
 */
export interface AccountToggleRequest {
    /**
     * If set, an external process validates that the user wants to proceed with this request.
     * @type {string}
     * @memberof AccountToggleRequest
     */
    'externalVerificationId'?: string;
    /**
     * If set, provisioning updates the account attribute at the source.   This option is used when the account is not synced to ensure the attribute is updated. Providing \'true\' for an unlocked account will add and process \'Unlock\' operation by the workflow.
     * @type {boolean}
     * @memberof AccountToggleRequest
     */
    'forceProvisioning'?: boolean;
}
/**
 * Request used for account unlock
 * @export
 * @interface AccountUnlockRequest
 */
export interface AccountUnlockRequest {
    /**
     * If set, an external process validates that the user wants to proceed with this request.
     * @type {string}
     * @memberof AccountUnlockRequest
     */
    'externalVerificationId'?: string;
    /**
     * If set, the IDN account is unlocked after the workflow completes.
     * @type {boolean}
     * @memberof AccountUnlockRequest
     */
    'unlockIDNAccount'?: boolean;
    /**
     * If set, provisioning updates the account attribute at the source.   This option is used when the account is not synced to ensure the attribute is updated.
     * @type {boolean}
     * @memberof AccountUnlockRequest
     */
    'forceProvisioning'?: boolean;
}
/**
 * 
 * @export
 * @interface AccountUsage
 */
export interface AccountUsage {
    /**
     * The first day of the month for which activity is aggregated.
     * @type {string}
     * @memberof AccountUsage
     */
    'date'?: string;
    /**
     * The number of days within the month that the account was active in a source.
     * @type {number}
     * @memberof AccountUsage
     */
    'count'?: number;
}
/**
 * Accounts async response containing details on started async process
 * @export
 * @interface AccountsAsyncResult
 */
export interface AccountsAsyncResult {
    /**
     * id of the task
     * @type {string}
     * @memberof AccountsAsyncResult
     */
    'id': string;
}
/**
 * Arguments for Account Export (ACCOUNTS)
 * @export
 * @interface AccountsExportReportArguments
 */
export interface AccountsExportReportArguments {
    /**
     * Id of the authoritative source to export related accounts e.g. identities
     * @type {string}
     * @memberof AccountsExportReportArguments
     */
    'application': string;
    /**
     * Name of the authoritative source for accounts export
     * @type {string}
     * @memberof AccountsExportReportArguments
     */
    'sourceName': string;
    /**
     * Use it to set default s3 bucket where generated report will be saved.  In case this argument is false and \'s3Bucket\' argument is null or absent there will be default s3Bucket assigned to the report.
     * @type {boolean}
     * @memberof AccountsExportReportArguments
     */
    'defaultS3Bucket': boolean;
    /**
     * If you want to be specific you could use this argument with defaultS3Bucket = false.
     * @type {string}
     * @memberof AccountsExportReportArguments
     */
    's3Bucket'?: string;
}
/**
 * 
 * @export
 * @interface ActivateCampaignOptions
 */
export interface ActivateCampaignOptions {
    /**
     * The timezone must be in a valid ISO 8601 format. Timezones in ISO 8601 are represented as UTC (represented as \'Z\') or as an offset from UTC. The offset format can be +/-hh:mm, +/-hhmm, or +/-hh.
     * @type {string}
     * @memberof ActivateCampaignOptions
     */
    'timeZone'?: string;
}
/**
 * 
 * @export
 * @interface AdminReviewReassign
 */
export interface AdminReviewReassign {
    /**
     * List of certification IDs to reassign
     * @type {Array<string>}
     * @memberof AdminReviewReassign
     */
    'certificationIds'?: Array<string>;
    /**
     * 
     * @type {AdminReviewReassignReassignTo}
     * @memberof AdminReviewReassign
     */
    'reassignTo'?: AdminReviewReassignReassignTo;
    /**
     * Comment to explain why the certification was reassigned
     * @type {string}
     * @memberof AdminReviewReassign
     */
    'reason'?: string;
}
/**
 * 
 * @export
 * @interface AdminReviewReassignReassignTo
 */
export interface AdminReviewReassignReassignTo {
    /**
     * The identity ID to which the review is being assigned.
     * @type {string}
     * @memberof AdminReviewReassignReassignTo
     */
    'id'?: string;
    /**
     * The type of the ID provided.
     * @type {string}
     * @memberof AdminReviewReassignReassignTo
     */
    'type'?: AdminReviewReassignReassignToTypeEnum;
}

export const AdminReviewReassignReassignToTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type AdminReviewReassignReassignToTypeEnum = typeof AdminReviewReassignReassignToTypeEnum[keyof typeof AdminReviewReassignReassignToTypeEnum];

/**
 * 
 * @export
 * @interface AggregationResult
 */
export interface AggregationResult {
    /**
     * The document containing the results of the aggregation. This document is controlled by Elasticsearch and depends on the type of aggregation query that is run.  See Elasticsearch [Aggregations](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/search-aggregations.html) documentation for information. 
     * @type {object}
     * @memberof AggregationResult
     */
    'aggregations'?: object;
    /**
     * The results of the aggregation search query. 
     * @type {Array<SearchDocument>}
     * @memberof AggregationResult
     */
    'hits'?: Array<SearchDocument>;
}
/**
 * Enum representing the currently available query languages for aggregations, which are used to perform calculations or groupings on search results.  Additional values may be added in the future without notice. 
 * @export
 * @enum {string}
 */

export const AggregationType = {
    Dsl: 'DSL',
    Sailpoint: 'SAILPOINT'
} as const;

export type AggregationType = typeof AggregationType[keyof typeof AggregationType];


/**
 * 
 * @export
 * @interface Aggregations
 */
export interface Aggregations {
    /**
     * 
     * @type {NestedAggregation}
     * @memberof Aggregations
     */
    'nested'?: NestedAggregation;
    /**
     * 
     * @type {MetricAggregation}
     * @memberof Aggregations
     */
    'metric'?: MetricAggregation;
    /**
     * 
     * @type {FilterAggregation}
     * @memberof Aggregations
     */
    'filter'?: FilterAggregation;
    /**
     * 
     * @type {BucketAggregation}
     * @memberof Aggregations
     */
    'bucket'?: BucketAggregation;
}
/**
 * 
 * @export
 * @interface App
 */
export interface App {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof App
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof App
     */
    'name'?: string;
    /**
     * 
     * @type {Reference1}
     * @memberof App
     */
    'source'?: Reference1;
    /**
     * 
     * @type {AppAllOfAccount}
     * @memberof App
     */
    'account'?: AppAllOfAccount;
}
/**
 * 
 * @export
 * @interface AppAllOfAccount
 */
export interface AppAllOfAccount {
    /**
     * The SailPoint generated unique ID
     * @type {string}
     * @memberof AppAllOfAccount
     */
    'id'?: string;
    /**
     * The account ID generated by the source
     * @type {string}
     * @memberof AppAllOfAccount
     */
    'accountId'?: string;
}
/**
 * 
 * @export
 * @interface Approval
 */
export interface Approval {
    /**
     * 
     * @type {Array<ApprovalComment>}
     * @memberof Approval
     */
    'comments'?: Array<ApprovalComment>;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof Approval
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof Approval
     */
    'modified'?: string | null;
    /**
     * 
     * @type {AccountSource}
     * @memberof Approval
     */
    'owner'?: AccountSource;
    /**
     * The result of the approval
     * @type {string}
     * @memberof Approval
     */
    'result'?: string;
    /**
     * 
     * @type {string}
     * @memberof Approval
     */
    'type'?: string | null;
}
/**
 * 
 * @export
 * @interface ApprovalComment
 */
export interface ApprovalComment {
    /**
     * The comment text
     * @type {string}
     * @memberof ApprovalComment
     */
    'comment'?: string;
    /**
     * The name of the commenter
     * @type {string}
     * @memberof ApprovalComment
     */
    'commenter'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof ApprovalComment
     */
    'date'?: string | null;
}
/**
 * 
 * @export
 * @interface ApprovalForwardHistory
 */
export interface ApprovalForwardHistory {
    /**
     * Display name of approver from whom the approval was forwarded.
     * @type {string}
     * @memberof ApprovalForwardHistory
     */
    'oldApproverName'?: string;
    /**
     * Display name of approver to whom the approval was forwarded.
     * @type {string}
     * @memberof ApprovalForwardHistory
     */
    'newApproverName'?: string;
    /**
     * Comment made while forwarding.
     * @type {string}
     * @memberof ApprovalForwardHistory
     */
    'comment'?: string | null;
    /**
     * Time at which approval was forwarded.
     * @type {string}
     * @memberof ApprovalForwardHistory
     */
    'modified'?: string;
    /**
     * Display name of forwarder who forwarded the approval.
     * @type {string}
     * @memberof ApprovalForwardHistory
     */
    'forwarderName'?: string | null;
    /**
     * 
     * @type {ReassignmentType}
     * @memberof ApprovalForwardHistory
     */
    'reassignmentType'?: ReassignmentType;
}


/**
 * 
 * @export
 * @interface ApprovalItemDetails
 */
export interface ApprovalItemDetails {
    /**
     * The approval item\'s ID
     * @type {string}
     * @memberof ApprovalItemDetails
     */
    'id'?: string;
    /**
     * The account referenced by the approval item
     * @type {string}
     * @memberof ApprovalItemDetails
     */
    'account'?: string;
    /**
     * The name of the application/source
     * @type {string}
     * @memberof ApprovalItemDetails
     */
    'application'?: string;
    /**
     * The attribute\'s name
     * @type {string}
     * @memberof ApprovalItemDetails
     */
    'name'?: string;
    /**
     * The attribute\'s operation
     * @type {string}
     * @memberof ApprovalItemDetails
     */
    'operation'?: string;
    /**
     * The attribute\'s value
     * @type {string}
     * @memberof ApprovalItemDetails
     */
    'value'?: string;
    /**
     * 
     * @type {WorkItemState}
     * @memberof ApprovalItemDetails
     */
    'state'?: WorkItemState;
}


/**
 * 
 * @export
 * @interface ApprovalItems
 */
export interface ApprovalItems {
    /**
     * The approval item\'s ID
     * @type {string}
     * @memberof ApprovalItems
     */
    'id'?: string;
    /**
     * The account referenced by the approval item
     * @type {string}
     * @memberof ApprovalItems
     */
    'account'?: string;
    /**
     * The name of the application/source
     * @type {string}
     * @memberof ApprovalItems
     */
    'application'?: string;
    /**
     * The attribute\'s name
     * @type {string}
     * @memberof ApprovalItems
     */
    'name'?: string;
    /**
     * The attribute\'s operation
     * @type {string}
     * @memberof ApprovalItems
     */
    'operation'?: string;
    /**
     * The attribute\'s value
     * @type {string}
     * @memberof ApprovalItems
     */
    'value'?: string;
    /**
     * 
     * @type {WorkItemState}
     * @memberof ApprovalItems
     */
    'state'?: WorkItemState;
}


/**
 * 
 * @export
 * @interface ApprovalReminderAndEscalationConfig
 */
export interface ApprovalReminderAndEscalationConfig {
    /**
     * Number of days to wait before the first reminder. If no reminders are configured, then this is the number of days to wait before escalation.
     * @type {number}
     * @memberof ApprovalReminderAndEscalationConfig
     */
    'daysUntilEscalation'?: number;
    /**
     * Number of days to wait between reminder notifications.
     * @type {number}
     * @memberof ApprovalReminderAndEscalationConfig
     */
    'daysBetweenReminders'?: number;
    /**
     * Maximum number of reminder notification to send to the reviewer before approval escalation.
     * @type {number}
     * @memberof ApprovalReminderAndEscalationConfig
     */
    'maxReminders'?: number;
    /**
     * 
     * @type {IdentityReferenceWithNameAndEmail}
     * @memberof ApprovalReminderAndEscalationConfig
     */
    'fallbackApproverRef'?: IdentityReferenceWithNameAndEmail | null;
}
/**
 * Describes the individual or group that is responsible for an approval step.
 * @export
 * @enum {string}
 */

export const ApprovalScheme = {
    AppOwner: 'APP_OWNER',
    SourceOwner: 'SOURCE_OWNER',
    Manager: 'MANAGER',
    RoleOwner: 'ROLE_OWNER',
    AccessProfileOwner: 'ACCESS_PROFILE_OWNER',
    EntitlementOwner: 'ENTITLEMENT_OWNER',
    GovernanceGroup: 'GOVERNANCE_GROUP'
} as const;

export type ApprovalScheme = typeof ApprovalScheme[keyof typeof ApprovalScheme];


/**
 * 
 * @export
 * @interface ApprovalSchemeForRole
 */
export interface ApprovalSchemeForRole {
    /**
     * Describes the individual or group that is responsible for an approval step. Values are as follows.  **OWNER**: Owner of the associated Role  **MANAGER**: Manager of the Identity making the request  **GOVERNANCE_GROUP**: A Governance Group, the ID of which is specified by the **approverId** field
     * @type {string}
     * @memberof ApprovalSchemeForRole
     */
    'approverType'?: ApprovalSchemeForRoleApproverTypeEnum;
    /**
     * Id of the specific approver, used only when approverType is GOVERNANCE_GROUP
     * @type {string}
     * @memberof ApprovalSchemeForRole
     */
    'approverId'?: string | null;
}

export const ApprovalSchemeForRoleApproverTypeEnum = {
    Owner: 'OWNER',
    Manager: 'MANAGER',
    GovernanceGroup: 'GOVERNANCE_GROUP'
} as const;

export type ApprovalSchemeForRoleApproverTypeEnum = typeof ApprovalSchemeForRoleApproverTypeEnum[keyof typeof ApprovalSchemeForRoleApproverTypeEnum];

/**
 * Enum representing the non-employee request approval status
 * @export
 * @enum {string}
 */

export const ApprovalStatus = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    Pending: 'PENDING',
    NotReady: 'NOT_READY',
    Cancelled: 'CANCELLED'
} as const;

export type ApprovalStatus = typeof ApprovalStatus[keyof typeof ApprovalStatus];


/**
 * 
 * @export
 * @interface ApprovalStatusDto
 */
export interface ApprovalStatusDto {
    /**
     * True if the request for this item was forwarded from one owner to another.
     * @type {boolean}
     * @memberof ApprovalStatusDto
     */
    'forwarded'?: boolean;
    /**
     * 
     * @type {ApprovalStatusDtoOriginalOwner}
     * @memberof ApprovalStatusDto
     */
    'originalOwner'?: ApprovalStatusDtoOriginalOwner;
    /**
     * 
     * @type {AccessItemReviewedBy}
     * @memberof ApprovalStatusDto
     */
    'currentOwner'?: AccessItemReviewedBy;
    /**
     * Time at which item was modified.
     * @type {string}
     * @memberof ApprovalStatusDto
     */
    'modified'?: string;
    /**
     * 
     * @type {ManualWorkItemState}
     * @memberof ApprovalStatusDto
     */
    'status'?: ManualWorkItemState;
    /**
     * 
     * @type {ApprovalScheme}
     * @memberof ApprovalStatusDto
     */
    'scheme'?: ApprovalScheme;
    /**
     * If the request failed, includes any error messages that were generated.
     * @type {Array<ErrorMessageDto>}
     * @memberof ApprovalStatusDto
     */
    'errorMessages'?: Array<ErrorMessageDto>;
    /**
     * Comment, if any, provided by the approver.
     * @type {string}
     * @memberof ApprovalStatusDto
     */
    'comment'?: string;
    /**
     * The date the role or access profile is no longer assigned to the specified identity.
     * @type {string}
     * @memberof ApprovalStatusDto
     */
    'removeDate'?: string;
}


/**
 * Identity of orginal approval owner.
 * @export
 * @interface ApprovalStatusDtoOriginalOwner
 */
export interface ApprovalStatusDtoOriginalOwner {
    /**
     * DTO type of original approval owner\'s identity.
     * @type {string}
     * @memberof ApprovalStatusDtoOriginalOwner
     */
    'type'?: ApprovalStatusDtoOriginalOwnerTypeEnum;
    /**
     * ID of original approval owner\'s identity.
     * @type {string}
     * @memberof ApprovalStatusDtoOriginalOwner
     */
    'id'?: string;
    /**
     * Display name of original approval owner.
     * @type {string}
     * @memberof ApprovalStatusDtoOriginalOwner
     */
    'name'?: string;
}

export const ApprovalStatusDtoOriginalOwnerTypeEnum = {
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY'
} as const;

export type ApprovalStatusDtoOriginalOwnerTypeEnum = typeof ApprovalStatusDtoOriginalOwnerTypeEnum[keyof typeof ApprovalStatusDtoOriginalOwnerTypeEnum];

/**
 * 
 * @export
 * @interface ApprovalSummary
 */
export interface ApprovalSummary {
    /**
     * The number of pending access requests approvals.
     * @type {number}
     * @memberof ApprovalSummary
     */
    'pending'?: number;
    /**
     * The number of approved access requests approvals.
     * @type {number}
     * @memberof ApprovalSummary
     */
    'approved'?: number;
    /**
     * The number of rejected access requests approvals.
     * @type {number}
     * @memberof ApprovalSummary
     */
    'rejected'?: number;
}
/**
 * 
 * @export
 * @interface ArrayInner
 */
export interface ArrayInner {
}
/**
 * 
 * @export
 * @interface AttributeDefinition
 */
export interface AttributeDefinition {
    /**
     * The name of the attribute.
     * @type {string}
     * @memberof AttributeDefinition
     */
    'name'?: string;
    /**
     * 
     * @type {AttributeDefinitionType}
     * @memberof AttributeDefinition
     */
    'type'?: AttributeDefinitionType;
    /**
     * 
     * @type {AttributeDefinitionSchema}
     * @memberof AttributeDefinition
     */
    'schema'?: AttributeDefinitionSchema;
    /**
     * A human-readable description of the attribute.
     * @type {string}
     * @memberof AttributeDefinition
     */
    'description'?: string;
    /**
     * Flag indicating whether or not the attribute is multi-valued.
     * @type {boolean}
     * @memberof AttributeDefinition
     */
    'isMulti'?: boolean;
    /**
     * Flag indicating whether or not the attribute is an entitlement.
     * @type {boolean}
     * @memberof AttributeDefinition
     */
    'isEntitlement'?: boolean;
    /**
     * Flag indicating whether or not the attribute represents a group. This can only be `true` if `isEntitlement` is also `true` **and** there is a schema defined for the attribute.. 
     * @type {boolean}
     * @memberof AttributeDefinition
     */
    'isGroup'?: boolean;
}


/**
 * A reference to the schema on the source to the attribute values map to.
 * @export
 * @interface AttributeDefinitionSchema
 */
export interface AttributeDefinitionSchema {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof AttributeDefinitionSchema
     */
    'type'?: AttributeDefinitionSchemaTypeEnum;
    /**
     * The object ID this reference applies to.
     * @type {string}
     * @memberof AttributeDefinitionSchema
     */
    'id'?: string;
    /**
     * The human-readable display name of the object.
     * @type {string}
     * @memberof AttributeDefinitionSchema
     */
    'name'?: string;
}

export const AttributeDefinitionSchemaTypeEnum = {
    ConnectorSchema: 'CONNECTOR_SCHEMA'
} as const;

export type AttributeDefinitionSchemaTypeEnum = typeof AttributeDefinitionSchemaTypeEnum[keyof typeof AttributeDefinitionSchemaTypeEnum];

/**
 * The underlying type of the value which an AttributeDefinition represents.
 * @export
 * @enum {string}
 */

export const AttributeDefinitionType = {
    String: 'STRING',
    Long: 'LONG',
    Int: 'INT',
    Boolean: 'BOOLEAN'
} as const;

export type AttributeDefinitionType = typeof AttributeDefinitionType[keyof typeof AttributeDefinitionType];


/**
 * 
 * @export
 * @interface AttributeRequest
 */
export interface AttributeRequest {
    /**
     * The attribute name
     * @type {string}
     * @memberof AttributeRequest
     */
    'name'?: string;
    /**
     * The operation to perform
     * @type {string}
     * @memberof AttributeRequest
     */
    'op'?: string;
    /**
     * The value of the attribute
     * @type {string}
     * @memberof AttributeRequest
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface AuthUser
 */
export interface AuthUser {
    /**
     * Tenant name.
     * @type {string}
     * @memberof AuthUser
     */
    'tenant'?: string;
    /**
     * Identity ID.
     * @type {string}
     * @memberof AuthUser
     */
    'id'?: string;
    /**
     * Identity unique identitifier.
     * @type {string}
     * @memberof AuthUser
     */
    'uid'?: string;
    /**
     * ID of the auth profile associated with this auth user.
     * @type {string}
     * @memberof AuthUser
     */
    'profile'?: string;
    /**
     * Auth user employee number.
     * @type {string}
     * @memberof AuthUser
     */
    'identificationNumber'?: string;
    /**
     * Auth user\'s email.
     * @type {string}
     * @memberof AuthUser
     */
    'email'?: string;
    /**
     * Auth user\'s phone number.
     * @type {string}
     * @memberof AuthUser
     */
    'phone'?: string;
    /**
     * Auth user\'s work phone number.
     * @type {string}
     * @memberof AuthUser
     */
    'workPhone'?: string;
    /**
     * Auth user\'s personal email.
     * @type {string}
     * @memberof AuthUser
     */
    'personalEmail'?: string;
    /**
     * Auth user\'s first name.
     * @type {string}
     * @memberof AuthUser
     */
    'firstname'?: string;
    /**
     * Auth user\'s last name.
     * @type {string}
     * @memberof AuthUser
     */
    'lastname'?: string;
    /**
     * Auth user\'s name in displayed format.
     * @type {string}
     * @memberof AuthUser
     */
    'displayName'?: string;
    /**
     * Auth user\'s alias.
     * @type {string}
     * @memberof AuthUser
     */
    'alias'?: string;
    /**
     * the date of last password change
     * @type {string}
     * @memberof AuthUser
     */
    'lastPasswordChangeDate'?: string;
    /**
     * Timestamp of the last login (long type value).
     * @type {number}
     * @memberof AuthUser
     */
    'lastLoginTimestamp'?: number;
    /**
     * Timestamp of the current login (long type value).
     * @type {number}
     * @memberof AuthUser
     */
    'currentLoginTimestamp'?: number;
    /**
     * Array of capabilities for this auth user.
     * @type {Array<string>}
     * @memberof AuthUser
     */
    'capabilities'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Base64Decode
 */
export interface Base64Decode {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Base64Decode
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Base64Decode
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Base64Encode
 */
export interface Base64Encode {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Base64Encode
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Base64Encode
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface BaseAccess
 */
export interface BaseAccess {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof BaseAccess
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof BaseAccess
     */
    'name'?: string;
    /**
     * The description of the access item
     * @type {string}
     * @memberof BaseAccess
     */
    'description'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof BaseAccess
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof BaseAccess
     */
    'modified'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof BaseAccess
     */
    'synced'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseAccess
     */
    'enabled'?: boolean;
    /**
     * Indicates if the access can be requested
     * @type {boolean}
     * @memberof BaseAccess
     */
    'requestable'?: boolean;
    /**
     * Indicates if comments are required when requesting access
     * @type {boolean}
     * @memberof BaseAccess
     */
    'requestCommentsRequired'?: boolean;
    /**
     * 
     * @type {Owner}
     * @memberof BaseAccess
     */
    'owner'?: Owner;
}
/**
 * 
 * @export
 * @interface BaseAccount
 */
export interface BaseAccount {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof BaseAccount
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof BaseAccount
     */
    'name'?: string;
    /**
     * The ID of the account
     * @type {string}
     * @memberof BaseAccount
     */
    'accountId'?: string;
    /**
     * 
     * @type {AccountSource}
     * @memberof BaseAccount
     */
    'source'?: AccountSource;
    /**
     * Indicates if the account is disabled
     * @type {boolean}
     * @memberof BaseAccount
     */
    'disabled'?: boolean;
    /**
     * Indicates if the account is locked
     * @type {boolean}
     * @memberof BaseAccount
     */
    'locked'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BaseAccount
     */
    'privileged'?: boolean;
    /**
     * Indicates if the account has been manually correlated to an identity
     * @type {boolean}
     * @memberof BaseAccount
     */
    'manuallyCorrelated'?: boolean;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof BaseAccount
     */
    'passwordLastSet'?: string | null;
    /**
     * a map or dictionary of key/value pairs
     * @type {{ [key: string]: any; }}
     * @memberof BaseAccount
     */
    'entitlementAttributes'?: { [key: string]: any; } | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof BaseAccount
     */
    'created'?: string | null;
}
/**
 * 
 * @export
 * @interface BaseCommonDto
 */
export interface BaseCommonDto {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof BaseCommonDto
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof BaseCommonDto
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof BaseCommonDto
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof BaseCommonDto
     */
    'modified'?: string;
}
/**
 * 
 * @export
 * @interface BaseDocument
 */
export interface BaseDocument {
    /**
     * 
     * @type {string}
     * @memberof BaseDocument
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BaseDocument
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof BaseDocument
     */
    '_type': DocumentType;
}


/**
 * 
 * @export
 * @interface BaseEntitlement
 */
export interface BaseEntitlement {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof BaseEntitlement
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof BaseEntitlement
     */
    'name'?: string;
    /**
     * A description of the entitlement
     * @type {string}
     * @memberof BaseEntitlement
     */
    'description'?: string;
    /**
     * The name of the entitlement attribute
     * @type {string}
     * @memberof BaseEntitlement
     */
    'attribute'?: string;
    /**
     * The value of the entitlement
     * @type {string}
     * @memberof BaseEntitlement
     */
    'value'?: string;
}
/**
 * Before Provisioning Rule.
 * @export
 * @interface BeforeProvisioningRuleDto
 */
export interface BeforeProvisioningRuleDto {
    /**
     * Before Provisioning Rule DTO type.
     * @type {string}
     * @memberof BeforeProvisioningRuleDto
     */
    'type'?: BeforeProvisioningRuleDtoTypeEnum;
    /**
     * Before Provisioning Rule ID.
     * @type {string}
     * @memberof BeforeProvisioningRuleDto
     */
    'id'?: string;
    /**
     * Rule display name.
     * @type {string}
     * @memberof BeforeProvisioningRuleDto
     */
    'name'?: string;
}

export const BeforeProvisioningRuleDtoTypeEnum = {
    Rule: 'RULE'
} as const;

export type BeforeProvisioningRuleDtoTypeEnum = typeof BeforeProvisioningRuleDtoTypeEnum[keyof typeof BeforeProvisioningRuleDtoTypeEnum];

/**
 * 
 * @export
 * @interface Bound
 */
export interface Bound {
    /**
     * The value of the range\'s endpoint.
     * @type {string}
     * @memberof Bound
     */
    'value': string;
    /**
     * Indicates if the endpoint is included in the range.
     * @type {boolean}
     * @memberof Bound
     */
    'inclusive'?: boolean;
}
/**
 * The bucket to group the results of the aggregation query by.
 * @export
 * @interface BucketAggregation
 */
export interface BucketAggregation {
    /**
     * The name of the bucket aggregate to be included in the result.
     * @type {string}
     * @memberof BucketAggregation
     */
    'name': string;
    /**
     * 
     * @type {BucketType}
     * @memberof BucketAggregation
     */
    'type'?: BucketType;
    /**
     * The field to bucket on. Prefix the field name with \'@\' to reference a nested object.
     * @type {string}
     * @memberof BucketAggregation
     */
    'field': string;
    /**
     * Maximum number of buckets to include.
     * @type {number}
     * @memberof BucketAggregation
     */
    'size'?: number;
    /**
     * Minimum number of documents a bucket should have.
     * @type {number}
     * @memberof BucketAggregation
     */
    'minDocCount'?: number;
}


/**
 * Enum representing the currently supported bucket aggregation types. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const BucketType = {
    Terms: 'TERMS'
} as const;

export type BucketType = typeof BucketType[keyof typeof BucketType];


/**
 * 
 * @export
 * @interface BulkTaggedObject
 */
export interface BulkTaggedObject {
    /**
     * 
     * @type {Array<TaggedObjectDto>}
     * @memberof BulkTaggedObject
     */
    'objectRefs'?: Array<TaggedObjectDto>;
    /**
     * Label to be applied to an Object
     * @type {Array<string>}
     * @memberof BulkTaggedObject
     */
    'tags'?: Array<string>;
    /**
     * If APPEND, tags are appended to the list of tags for the object. A 400 error is returned if this would add duplicate tags to the object.  If MERGE, tags are merged with the existing tags. Duplicate tags are silently ignored.
     * @type {string}
     * @memberof BulkTaggedObject
     */
    'operation'?: BulkTaggedObjectOperationEnum;
}

export const BulkTaggedObjectOperationEnum = {
    Append: 'APPEND',
    Merge: 'MERGE'
} as const;

export type BulkTaggedObjectOperationEnum = typeof BulkTaggedObjectOperationEnum[keyof typeof BulkTaggedObjectOperationEnum];

/**
 * 
 * @export
 * @interface Campaign
 */
export interface Campaign {
    /**
     * Id of the campaign
     * @type {string}
     * @memberof Campaign
     */
    'id'?: string;
    /**
     * The campaign name. If this object is part of a template, special formatting applies; see the `/campaign-templates/{id}/generate` endpoint documentation for details.
     * @type {string}
     * @memberof Campaign
     */
    'name': string;
    /**
     * The campaign description. If this object is part of a template, special formatting applies; see the `/campaign-templates/{id}/generate` endpoint documentation for details.
     * @type {string}
     * @memberof Campaign
     */
    'description': string;
    /**
     * The campaign\'s completion deadline.  This date must be in the future in order to activate the campaign.  If you try to activate a campaign with a deadline of today or in the past, you will receive a 400 error response.
     * @type {string}
     * @memberof Campaign
     */
    'deadline'?: string;
    /**
     * The type of campaign. Could be extended in the future.
     * @type {string}
     * @memberof Campaign
     */
    'type': CampaignTypeEnum;
    /**
     * Enables email notification for this campaign
     * @type {boolean}
     * @memberof Campaign
     */
    'emailNotificationEnabled'?: boolean;
    /**
     * Allows auto revoke for this campaign
     * @type {boolean}
     * @memberof Campaign
     */
    'autoRevokeAllowed'?: boolean;
    /**
     * Enables IAI for this campaign. Accepts true even if the IAI product feature is off. If IAI is turned off then campaigns generated from this template will indicate false. The real value will then be returned if IAI is ever enabled for the org in the future.
     * @type {boolean}
     * @memberof Campaign
     */
    'recommendationsEnabled'?: boolean;
    /**
     * The campaign\'s current status.
     * @type {string}
     * @memberof Campaign
     */
    'status'?: CampaignStatusEnum;
    /**
     * The correlatedStatus of the campaign. Only SOURCE_OWNER campaigns can be Uncorrelated. An Uncorrelated certification campaign only includes Uncorrelated identities (An identity is uncorrelated if it has no accounts on an authoritative source).
     * @type {object}
     * @memberof Campaign
     */
    'correlatedStatus'?: CampaignCorrelatedStatusEnum;
    /**
     * Created time of the campaign
     * @type {string}
     * @memberof Campaign
     */
    'created'?: string;
    /**
     * The total number of certifications in this campaign.
     * @type {number}
     * @memberof Campaign
     */
    'totalCertifications'?: number;
    /**
     * The number of completed certifications in this campaign.
     * @type {number}
     * @memberof Campaign
     */
    'completedCertifications'?: number;
    /**
     * A list of errors and warnings that have accumulated.
     * @type {Array<CampaignAlert>}
     * @memberof Campaign
     */
    'alerts'?: Array<CampaignAlert>;
    /**
     * Modified time of the campaign
     * @type {string}
     * @memberof Campaign
     */
    'modified'?: string;
    /**
     * 
     * @type {CampaignAllOfFilter}
     * @memberof Campaign
     */
    'filter'?: CampaignAllOfFilter;
    /**
     * Determines if comments on sunset date changes are required.
     * @type {boolean}
     * @memberof Campaign
     */
    'sunsetCommentsRequired'?: boolean;
    /**
     * 
     * @type {CampaignAllOfSourceOwnerCampaignInfo}
     * @memberof Campaign
     */
    'sourceOwnerCampaignInfo'?: CampaignAllOfSourceOwnerCampaignInfo;
    /**
     * 
     * @type {CampaignAllOfSearchCampaignInfo}
     * @memberof Campaign
     */
    'searchCampaignInfo'?: CampaignAllOfSearchCampaignInfo;
    /**
     * 
     * @type {CampaignAllOfRoleCompositionCampaignInfo}
     * @memberof Campaign
     */
    'roleCompositionCampaignInfo'?: CampaignAllOfRoleCompositionCampaignInfo;
    /**
     * A list of sources in the campaign that contain \\\"orphan entitlements\\\" (entitlements without a corresponding Managed Attribute). An empty list indicates the campaign has no orphan entitlements. Null indicates there may be unknown orphan entitlements in the campaign (the campaign was created before this feature was implemented).
     * @type {Array<CampaignAllOfSourcesWithOrphanEntitlements>}
     * @memberof Campaign
     */
    'sourcesWithOrphanEntitlements'?: Array<CampaignAllOfSourcesWithOrphanEntitlements>;
    /**
     * Determines whether comments are required for decisions during certification reviews. You can require comments for all decisions, revoke-only decisions, or no decisions. By default, comments are not required for decisions.
     * @type {string}
     * @memberof Campaign
     */
    'mandatoryCommentRequirement'?: CampaignMandatoryCommentRequirementEnum;
}

export const CampaignTypeEnum = {
    Manager: 'MANAGER',
    SourceOwner: 'SOURCE_OWNER',
    Search: 'SEARCH',
    RoleComposition: 'ROLE_COMPOSITION'
} as const;

export type CampaignTypeEnum = typeof CampaignTypeEnum[keyof typeof CampaignTypeEnum];
export const CampaignStatusEnum = {
    Pending: 'PENDING',
    Staged: 'STAGED',
    Canceling: 'CANCELING',
    Activating: 'ACTIVATING',
    Active: 'ACTIVE',
    Completing: 'COMPLETING',
    Completed: 'COMPLETED',
    Error: 'ERROR',
    Archived: 'ARCHIVED'
} as const;

export type CampaignStatusEnum = typeof CampaignStatusEnum[keyof typeof CampaignStatusEnum];
export const CampaignCorrelatedStatusEnum = {
    Correlated: 'CORRELATED',
    Uncorrelated: 'UNCORRELATED'
} as const;

export type CampaignCorrelatedStatusEnum = typeof CampaignCorrelatedStatusEnum[keyof typeof CampaignCorrelatedStatusEnum];
export const CampaignMandatoryCommentRequirementEnum = {
    AllDecisions: 'ALL_DECISIONS',
    RevokeOnlyDecisions: 'REVOKE_ONLY_DECISIONS',
    NoDecisions: 'NO_DECISIONS'
} as const;

export type CampaignMandatoryCommentRequirementEnum = typeof CampaignMandatoryCommentRequirementEnum[keyof typeof CampaignMandatoryCommentRequirementEnum];

/**
 * 
 * @export
 * @interface CampaignAlert
 */
export interface CampaignAlert {
    /**
     * Denotes the level of the message
     * @type {string}
     * @memberof CampaignAlert
     */
    'level'?: CampaignAlertLevelEnum;
    /**
     * 
     * @type {Array<ErrorMessageDto>}
     * @memberof CampaignAlert
     */
    'localizations'?: Array<ErrorMessageDto>;
}

export const CampaignAlertLevelEnum = {
    Error: 'ERROR',
    Warn: 'WARN',
    Info: 'INFO'
} as const;

export type CampaignAlertLevelEnum = typeof CampaignAlertLevelEnum[keyof typeof CampaignAlertLevelEnum];

/**
 * Determines which items will be included in this campaign. The default campaign filter is used if this field is left blank.
 * @export
 * @interface CampaignAllOfFilter
 */
export interface CampaignAllOfFilter {
    /**
     * The ID of whatever type of filter is being used.
     * @type {string}
     * @memberof CampaignAllOfFilter
     */
    'id'?: string;
    /**
     * Type of the filter
     * @type {string}
     * @memberof CampaignAllOfFilter
     */
    'type'?: CampaignAllOfFilterTypeEnum;
    /**
     * Name of the filter
     * @type {string}
     * @memberof CampaignAllOfFilter
     */
    'name'?: string;
}

export const CampaignAllOfFilterTypeEnum = {
    CampaignFilter: 'CAMPAIGN_FILTER',
    Rule: 'RULE'
} as const;

export type CampaignAllOfFilterTypeEnum = typeof CampaignAllOfFilterTypeEnum[keyof typeof CampaignAllOfFilterTypeEnum];

/**
 * Optional configuration options for role composition campaigns.
 * @export
 * @interface CampaignAllOfRoleCompositionCampaignInfo
 */
export interface CampaignAllOfRoleCompositionCampaignInfo {
    /**
     * 
     * @type {CampaignAllOfSearchCampaignInfoReviewer}
     * @memberof CampaignAllOfRoleCompositionCampaignInfo
     */
    'reviewer'?: CampaignAllOfSearchCampaignInfoReviewer;
    /**
     * Optional list of roles to include in this campaign. Only one of `roleIds` and `query` may be set; if neither are set, all roles are included.
     * @type {Array<string>}
     * @memberof CampaignAllOfRoleCompositionCampaignInfo
     */
    'roleIds'?: Array<string>;
    /**
     * 
     * @type {CampaignAllOfRoleCompositionCampaignInfoRemediatorRef}
     * @memberof CampaignAllOfRoleCompositionCampaignInfo
     */
    'remediatorRef': CampaignAllOfRoleCompositionCampaignInfoRemediatorRef;
    /**
     * Optional search query to scope this campaign to a set of roles. Only one of `roleIds` and `query` may be set; if neither are set, all roles are included.
     * @type {string}
     * @memberof CampaignAllOfRoleCompositionCampaignInfo
     */
    'query'?: string;
    /**
     * Describes this role composition campaign. Intended for storing the query used, and possibly the number of roles selected/available.
     * @type {string}
     * @memberof CampaignAllOfRoleCompositionCampaignInfo
     */
    'description'?: string;
}
/**
 * This determines who remediation tasks will be assigned to. Remediation tasks are created for each revoke decision on items in the campaign. The only legal remediator type is \'IDENTITY\', and the chosen identity must be a Role Admin or Org Admin.
 * @export
 * @interface CampaignAllOfRoleCompositionCampaignInfoRemediatorRef
 */
export interface CampaignAllOfRoleCompositionCampaignInfoRemediatorRef {
    /**
     * Legal Remediator Type
     * @type {string}
     * @memberof CampaignAllOfRoleCompositionCampaignInfoRemediatorRef
     */
    'type': CampaignAllOfRoleCompositionCampaignInfoRemediatorRefTypeEnum;
    /**
     * The ID of the remediator.
     * @type {string}
     * @memberof CampaignAllOfRoleCompositionCampaignInfoRemediatorRef
     */
    'id': string;
    /**
     * The name of the remediator.
     * @type {string}
     * @memberof CampaignAllOfRoleCompositionCampaignInfoRemediatorRef
     */
    'name'?: string;
}

export const CampaignAllOfRoleCompositionCampaignInfoRemediatorRefTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type CampaignAllOfRoleCompositionCampaignInfoRemediatorRefTypeEnum = typeof CampaignAllOfRoleCompositionCampaignInfoRemediatorRefTypeEnum[keyof typeof CampaignAllOfRoleCompositionCampaignInfoRemediatorRefTypeEnum];

/**
 * Must be set only if the campaign type is SEARCH.
 * @export
 * @interface CampaignAllOfSearchCampaignInfo
 */
export interface CampaignAllOfSearchCampaignInfo {
    /**
     * The type of search campaign represented.
     * @type {string}
     * @memberof CampaignAllOfSearchCampaignInfo
     */
    'type': CampaignAllOfSearchCampaignInfoTypeEnum;
    /**
     * Describes this search campaign. Intended for storing the query used, and possibly the number of identities selected/available.
     * @type {string}
     * @memberof CampaignAllOfSearchCampaignInfo
     */
    'description'?: string;
    /**
     * 
     * @type {CampaignAllOfSearchCampaignInfoReviewer}
     * @memberof CampaignAllOfSearchCampaignInfo
     */
    'reviewer'?: CampaignAllOfSearchCampaignInfoReviewer;
    /**
     * The scope for the campaign. The campaign will cover identities returned by the query and identities that have access items returned by the query. One of `query` or `identityIds` must be set.
     * @type {string}
     * @memberof CampaignAllOfSearchCampaignInfo
     */
    'query'?: string;
    /**
     * A direct list of identities to include in this campaign. One of `identityIds` or `query` must be set.
     * @type {Array<string>}
     * @memberof CampaignAllOfSearchCampaignInfo
     */
    'identityIds'?: Array<string>;
    /**
     * Further reduces the scope of the campaign by excluding identities (from `query` or `identityIds`) that do not have this access.
     * @type {Array<AccessConstraint>}
     * @memberof CampaignAllOfSearchCampaignInfo
     */
    'accessConstraints'?: Array<AccessConstraint>;
}

export const CampaignAllOfSearchCampaignInfoTypeEnum = {
    Identity: 'IDENTITY',
    Access: 'ACCESS'
} as const;

export type CampaignAllOfSearchCampaignInfoTypeEnum = typeof CampaignAllOfSearchCampaignInfoTypeEnum[keyof typeof CampaignAllOfSearchCampaignInfoTypeEnum];

/**
 * If specified, this identity or governance group will be the reviewer for all certifications in this campaign. The allowed DTO types are IDENTITY and GOVERNANCE_GROUP.
 * @export
 * @interface CampaignAllOfSearchCampaignInfoReviewer
 */
export interface CampaignAllOfSearchCampaignInfoReviewer {
    /**
     * The reviewer\'s DTO type.
     * @type {string}
     * @memberof CampaignAllOfSearchCampaignInfoReviewer
     */
    'type'?: CampaignAllOfSearchCampaignInfoReviewerTypeEnum;
    /**
     * The reviewer\'s ID.
     * @type {string}
     * @memberof CampaignAllOfSearchCampaignInfoReviewer
     */
    'id'?: string;
    /**
     * The reviewer\'s name.
     * @type {string}
     * @memberof CampaignAllOfSearchCampaignInfoReviewer
     */
    'name'?: string;
}

export const CampaignAllOfSearchCampaignInfoReviewerTypeEnum = {
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY'
} as const;

export type CampaignAllOfSearchCampaignInfoReviewerTypeEnum = typeof CampaignAllOfSearchCampaignInfoReviewerTypeEnum[keyof typeof CampaignAllOfSearchCampaignInfoReviewerTypeEnum];

/**
 * Must be set only if the campaign type is SOURCE_OWNER.
 * @export
 * @interface CampaignAllOfSourceOwnerCampaignInfo
 */
export interface CampaignAllOfSourceOwnerCampaignInfo {
    /**
     * The list of sources to be included in the campaign.
     * @type {Array<string>}
     * @memberof CampaignAllOfSourceOwnerCampaignInfo
     */
    'sourceIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CampaignAllOfSourcesWithOrphanEntitlements
 */
export interface CampaignAllOfSourcesWithOrphanEntitlements {
    /**
     * Id of the source
     * @type {string}
     * @memberof CampaignAllOfSourcesWithOrphanEntitlements
     */
    'id'?: string;
    /**
     * Type
     * @type {string}
     * @memberof CampaignAllOfSourcesWithOrphanEntitlements
     */
    'type'?: CampaignAllOfSourcesWithOrphanEntitlementsTypeEnum;
    /**
     * Name of the source
     * @type {string}
     * @memberof CampaignAllOfSourcesWithOrphanEntitlements
     */
    'name'?: string;
}

export const CampaignAllOfSourcesWithOrphanEntitlementsTypeEnum = {
    Source: 'SOURCE'
} as const;

export type CampaignAllOfSourcesWithOrphanEntitlementsTypeEnum = typeof CampaignAllOfSourcesWithOrphanEntitlementsTypeEnum[keyof typeof CampaignAllOfSourcesWithOrphanEntitlementsTypeEnum];

/**
 * 
 * @export
 * @interface CampaignCompleteOptions
 */
export interface CampaignCompleteOptions {
    /**
     * Determines whether to auto-approve(APPROVE) or auto-revoke(REVOKE) upon campaign completion.
     * @type {string}
     * @memberof CampaignCompleteOptions
     */
    'autoCompleteAction'?: CampaignCompleteOptionsAutoCompleteActionEnum;
}

export const CampaignCompleteOptionsAutoCompleteActionEnum = {
    Approve: 'APPROVE',
    Revoke: 'REVOKE'
} as const;

export type CampaignCompleteOptionsAutoCompleteActionEnum = typeof CampaignCompleteOptionsAutoCompleteActionEnum[keyof typeof CampaignCompleteOptionsAutoCompleteActionEnum];

/**
 * Campaign Filter Details
 * @export
 * @interface CampaignFilterDetails
 */
export interface CampaignFilterDetails {
    /**
     * Id of the campaign filter
     * @type {string}
     * @memberof CampaignFilterDetails
     */
    'id'?: string;
    /**
     * This is campaign filter\'s name.
     * @type {string}
     * @memberof CampaignFilterDetails
     */
    'name': string;
    /**
     * This is campaign filter\'s description.
     * @type {string}
     * @memberof CampaignFilterDetails
     */
    'description': string;
    /**
     * The owner of this filter. This field is automatically populated at creation time with the current user.
     * @type {string}
     * @memberof CampaignFilterDetails
     */
    'owner': string;
    /**
     * The mode/type of Filter, where it is of INCLUSION or EXCLUSION type. INCLUSION type will include the data in generated campaign  as per specified in criteria, whereas EXCLUSION type will exclude the the data in generated campaign as per specified in criteria.
     * @type {object}
     * @memberof CampaignFilterDetails
     */
    'mode': CampaignFilterDetailsModeEnum;
    /**
     * List of criteria.
     * @type {Array<CampaignFilterDetailsCriteriaListInner>}
     * @memberof CampaignFilterDetails
     */
    'criteriaList'?: Array<CampaignFilterDetailsCriteriaListInner>;
}

export const CampaignFilterDetailsModeEnum = {
    Inclusion: 'INCLUSION',
    Exclusion: 'EXCLUSION'
} as const;

export type CampaignFilterDetailsModeEnum = typeof CampaignFilterDetailsModeEnum[keyof typeof CampaignFilterDetailsModeEnum];

/**
 * 
 * @export
 * @interface CampaignFilterDetailsCriteriaListInner
 */
export interface CampaignFilterDetailsCriteriaListInner {
    /**
     * 
     * @type {CriteriaType}
     * @memberof CampaignFilterDetailsCriteriaListInner
     */
    'type': CriteriaType;
    /**
     * 
     * @type {Operation}
     * @memberof CampaignFilterDetailsCriteriaListInner
     */
    'operation': Operation;
    /**
     * The specified key from the Type of criteria.
     * @type {string}
     * @memberof CampaignFilterDetailsCriteriaListInner
     */
    'property': string;
    /**
     * The value for the specified key from the Type of Criteria
     * @type {string}
     * @memberof CampaignFilterDetailsCriteriaListInner
     */
    'value': string;
}


/**
 * 
 * @export
 * @interface CampaignReference
 */
export interface CampaignReference {
    /**
     * The unique ID of the campaign.
     * @type {string}
     * @memberof CampaignReference
     */
    'id': string;
    /**
     * The name of the campaign.
     * @type {string}
     * @memberof CampaignReference
     */
    'name': string;
    /**
     * The type of object that is being referenced.
     * @type {string}
     * @memberof CampaignReference
     */
    'type': CampaignReferenceTypeEnum;
    /**
     * The type of the campaign.
     * @type {string}
     * @memberof CampaignReference
     */
    'campaignType': CampaignReferenceCampaignTypeEnum;
    /**
     * The description of the campaign set by the admin who created it.
     * @type {string}
     * @memberof CampaignReference
     */
    'description': string | null;
    /**
     * The correlatedStatus of the campaign. Only SOURCE_OWNER campaigns can be Uncorrelated. An Uncorrelated certification campaign only includes Uncorrelated identities (An identity is uncorrelated if it has no accounts on an authoritative source).
     * @type {object}
     * @memberof CampaignReference
     */
    'correlatedStatus': CampaignReferenceCorrelatedStatusEnum;
    /**
     * Determines whether comments are required for decisions during certification reviews. You can require comments for all decisions, revoke-only decisions, or no decisions. By default, comments are not required for decisions.
     * @type {string}
     * @memberof CampaignReference
     */
    'mandatoryCommentRequirement': CampaignReferenceMandatoryCommentRequirementEnum;
}

export const CampaignReferenceTypeEnum = {
    Campaign: 'CAMPAIGN'
} as const;

export type CampaignReferenceTypeEnum = typeof CampaignReferenceTypeEnum[keyof typeof CampaignReferenceTypeEnum];
export const CampaignReferenceCampaignTypeEnum = {
    Manager: 'MANAGER',
    SourceOwner: 'SOURCE_OWNER',
    Search: 'SEARCH'
} as const;

export type CampaignReferenceCampaignTypeEnum = typeof CampaignReferenceCampaignTypeEnum[keyof typeof CampaignReferenceCampaignTypeEnum];
export const CampaignReferenceCorrelatedStatusEnum = {
    Correlated: 'CORRELATED',
    Uncorrelated: 'UNCORRELATED'
} as const;

export type CampaignReferenceCorrelatedStatusEnum = typeof CampaignReferenceCorrelatedStatusEnum[keyof typeof CampaignReferenceCorrelatedStatusEnum];
export const CampaignReferenceMandatoryCommentRequirementEnum = {
    AllDecisions: 'ALL_DECISIONS',
    RevokeOnlyDecisions: 'REVOKE_ONLY_DECISIONS',
    NoDecisions: 'NO_DECISIONS'
} as const;

export type CampaignReferenceMandatoryCommentRequirementEnum = typeof CampaignReferenceMandatoryCommentRequirementEnum[keyof typeof CampaignReferenceMandatoryCommentRequirementEnum];

/**
 * 
 * @export
 * @interface CampaignReport
 */
export interface CampaignReport {
    /**
     * SOD policy violation report result DTO type.
     * @type {string}
     * @memberof CampaignReport
     */
    'type'?: CampaignReportTypeEnum;
    /**
     * SOD policy violation report result ID.
     * @type {string}
     * @memberof CampaignReport
     */
    'id'?: string;
    /**
     * Human-readable name of the SOD policy violation report result.
     * @type {string}
     * @memberof CampaignReport
     */
    'name'?: string;
    /**
     * Status of a SOD policy violation report.
     * @type {string}
     * @memberof CampaignReport
     */
    'status'?: CampaignReportStatusEnum;
    /**
     * 
     * @type {ReportType}
     * @memberof CampaignReport
     */
    'reportType': ReportType;
    /**
     * The most recent date and time this report was run
     * @type {string}
     * @memberof CampaignReport
     */
    'lastRunAt'?: string;
}

export const CampaignReportTypeEnum = {
    ReportResult: 'REPORT_RESULT'
} as const;

export type CampaignReportTypeEnum = typeof CampaignReportTypeEnum[keyof typeof CampaignReportTypeEnum];
export const CampaignReportStatusEnum = {
    Success: 'SUCCESS',
    Warning: 'WARNING',
    Error: 'ERROR',
    Terminated: 'TERMINATED',
    TempError: 'TEMP_ERROR',
    Pending: 'PENDING'
} as const;

export type CampaignReportStatusEnum = typeof CampaignReportStatusEnum[keyof typeof CampaignReportStatusEnum];

/**
 * 
 * @export
 * @interface CampaignReportsConfig
 */
export interface CampaignReportsConfig {
    /**
     * list of identity attribute columns
     * @type {Array<string>}
     * @memberof CampaignReportsConfig
     */
    'identityAttributeColumns'?: Array<string>;
}
/**
 * Campaign Template
 * @export
 * @interface CampaignTemplate
 */
export interface CampaignTemplate {
    /**
     * Id of the campaign template
     * @type {string}
     * @memberof CampaignTemplate
     */
    'id'?: string;
    /**
     * This template\'s name. Has no bearing on generated campaigns\' names.
     * @type {string}
     * @memberof CampaignTemplate
     */
    'name': string;
    /**
     * This template\'s description. Has no bearing on generated campaigns\' descriptions.
     * @type {string}
     * @memberof CampaignTemplate
     */
    'description': string;
    /**
     * Creation date of Campaign Template
     * @type {string}
     * @memberof CampaignTemplate
     */
    'created': string;
    /**
     * Modification date of Campaign Template
     * @type {string}
     * @memberof CampaignTemplate
     */
    'modified': string;
    /**
     * Indicates if this campaign template has been scheduled.
     * @type {boolean}
     * @memberof CampaignTemplate
     */
    'scheduled'?: boolean;
    /**
     * 
     * @type {CampaignTemplateOwnerRef}
     * @memberof CampaignTemplate
     */
    'ownerRef'?: CampaignTemplateOwnerRef;
    /**
     * The time period during which the campaign should be completed, formatted as an ISO-8601 Duration. When this template generates a campaign, the campaign\'s deadline will be the current date plus this duration. For example, if generation occurred on 2020-01-01 and this field was \"P2W\" (two weeks), the resulting campaign\'s deadline would be 2020-01-15 (the current date plus 14 days).
     * @type {string}
     * @memberof CampaignTemplate
     */
    'deadlineDuration'?: string;
    /**
     * This will hold campaign related information like name, description etc.
     * @type {Campaign}
     * @memberof CampaignTemplate
     */
    'campaign': Campaign;
}
/**
 * The owner of this template, and the owner of campaigns generated from this template via a schedule. This field is automatically populated at creation time with the current user.
 * @export
 * @interface CampaignTemplateOwnerRef
 */
export interface CampaignTemplateOwnerRef {
    /**
     * Id of the owner
     * @type {string}
     * @memberof CampaignTemplateOwnerRef
     */
    'id'?: string;
    /**
     * Type of the owner
     * @type {string}
     * @memberof CampaignTemplateOwnerRef
     */
    'type'?: CampaignTemplateOwnerRefTypeEnum;
    /**
     * Name of the owner
     * @type {string}
     * @memberof CampaignTemplateOwnerRef
     */
    'name'?: string;
    /**
     * Email of the owner
     * @type {string}
     * @memberof CampaignTemplateOwnerRef
     */
    'email'?: string;
}

export const CampaignTemplateOwnerRefTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type CampaignTemplateOwnerRefTypeEnum = typeof CampaignTemplateOwnerRefTypeEnum[keyof typeof CampaignTemplateOwnerRefTypeEnum];

/**
 * 
 * @export
 * @interface CampaignsDeleteRequest
 */
export interface CampaignsDeleteRequest {
    /**
     * The ids of the campaigns to delete
     * @type {Array<string>}
     * @memberof CampaignsDeleteRequest
     */
    'ids'?: Array<string>;
}
/**
 * Request body payload for cancel access request endpoint.
 * @export
 * @interface CancelAccessRequest
 */
export interface CancelAccessRequest {
    /**
     * This refers to the identityRequestId. To successfully cancel an access request, you must provide the identityRequestId.
     * @type {string}
     * @memberof CancelAccessRequest
     */
    'accountActivityId': string;
    /**
     * Reason for cancelling the pending access request.
     * @type {string}
     * @memberof CancelAccessRequest
     */
    'comment': string;
}
/**
 * Provides additional details for a request that has been cancelled.
 * @export
 * @interface CancelledRequestDetails
 */
export interface CancelledRequestDetails {
    /**
     * Comment made by the owner when cancelling the associated request.
     * @type {string}
     * @memberof CancelledRequestDetails
     */
    'comment'?: string;
    /**
     * 
     * @type {OwnerDto}
     * @memberof CancelledRequestDetails
     */
    'owner'?: OwnerDto;
    /**
     * Date comment was added by the owner when cancelling the associated request.
     * @type {string}
     * @memberof CancelledRequestDetails
     */
    'modified'?: string;
}
/**
 * 
 * @export
 * @interface Certification
 */
export interface Certification {
    /**
     * id of the certification
     * @type {string}
     * @memberof Certification
     */
    'id'?: string;
    /**
     * name of the certification
     * @type {string}
     * @memberof Certification
     */
    'name'?: string;
    /**
     * 
     * @type {CampaignReference}
     * @memberof Certification
     */
    'campaign'?: CampaignReference;
    /**
     * Have all decisions been made?
     * @type {boolean}
     * @memberof Certification
     */
    'completed'?: boolean;
    /**
     * The number of identities for whom all decisions have been made and are complete.
     * @type {number}
     * @memberof Certification
     */
    'identitiesCompleted'?: number;
    /**
     * The total number of identities in the Certification, both complete and incomplete.
     * @type {number}
     * @memberof Certification
     */
    'identitiesTotal'?: number;
    /**
     * created date
     * @type {string}
     * @memberof Certification
     */
    'created'?: string;
    /**
     * modified date
     * @type {string}
     * @memberof Certification
     */
    'modified'?: string;
    /**
     * The number of approve/revoke/acknowledge decisions that have been made.
     * @type {number}
     * @memberof Certification
     */
    'decisionsMade'?: number;
    /**
     * The total number of approve/revoke/acknowledge decisions.
     * @type {number}
     * @memberof Certification
     */
    'decisionsTotal'?: number;
    /**
     * The due date of the certification.
     * @type {string}
     * @memberof Certification
     */
    'due'?: string;
    /**
     * The date the reviewer signed off on the Certification.
     * @type {string}
     * @memberof Certification
     */
    'signed'?: string | null;
    /**
     * 
     * @type {Reviewer}
     * @memberof Certification
     */
    'reviewer'?: Reviewer;
    /**
     * 
     * @type {Reassignment}
     * @memberof Certification
     */
    'reassignment'?: Reassignment | null;
    /**
     * Identifies if the certification has an error
     * @type {boolean}
     * @memberof Certification
     */
    'hasErrors'?: boolean;
    /**
     * Description of the certification error
     * @type {string}
     * @memberof Certification
     */
    'errorMessage'?: string | null;
    /**
     * 
     * @type {CertificationPhase}
     * @memberof Certification
     */
    'phase'?: CertificationPhase;
}


/**
 * The decision to approve or revoke the review item
 * @export
 * @enum {string}
 */

export const CertificationDecision = {
    Approve: 'APPROVE',
    Revoke: 'REVOKE'
} as const;

export type CertificationDecision = typeof CertificationDecision[keyof typeof CertificationDecision];


/**
 * 
 * @export
 * @interface CertificationIdentitySummary
 */
export interface CertificationIdentitySummary {
    /**
     * The ID of the identity summary
     * @type {string}
     * @memberof CertificationIdentitySummary
     */
    'id'?: string;
    /**
     * Name of the linked identity
     * @type {string}
     * @memberof CertificationIdentitySummary
     */
    'name'?: string;
    /**
     * The ID of the identity being certified
     * @type {string}
     * @memberof CertificationIdentitySummary
     */
    'identityId'?: string;
    /**
     * Indicates whether the review items for the linked identity\'s certification have been completed
     * @type {boolean}
     * @memberof CertificationIdentitySummary
     */
    'completed'?: boolean;
}
/**
 * The current phase of the campaign. * `STAGED`: The campaign is waiting to be activated. * `ACTIVE`: The campaign is active. * `SIGNED`: The reviewer has signed off on the campaign, and it is considered complete. 
 * @export
 * @enum {string}
 */

export const CertificationPhase = {
    Staged: 'STAGED',
    Active: 'ACTIVE',
    Signed: 'SIGNED'
} as const;

export type CertificationPhase = typeof CertificationPhase[keyof typeof CertificationPhase];


/**
 * 
 * @export
 * @interface CertificationReference
 */
export interface CertificationReference {
    /**
     * The id of the certification.
     * @type {string}
     * @memberof CertificationReference
     */
    'id'?: string;
    /**
     * The name of the certification.
     * @type {string}
     * @memberof CertificationReference
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CertificationReference
     */
    'type'?: CertificationReferenceTypeEnum;
    /**
     * 
     * @type {Reviewer}
     * @memberof CertificationReference
     */
    'reviewer'?: Reviewer;
}

export const CertificationReferenceTypeEnum = {
    Certification: 'CERTIFICATION'
} as const;

export type CertificationReferenceTypeEnum = typeof CertificationReferenceTypeEnum[keyof typeof CertificationReferenceTypeEnum];

/**
 * 
 * @export
 * @interface CertificationTask
 */
export interface CertificationTask {
    /**
     * The ID of the certification task.
     * @type {string}
     * @memberof CertificationTask
     */
    'id'?: string;
    /**
     * The type of the certification task. More values may be added in the future.
     * @type {string}
     * @memberof CertificationTask
     */
    'type'?: CertificationTaskTypeEnum;
    /**
     * The type of item that is being operated on by this task whose ID is stored in the targetId field.
     * @type {string}
     * @memberof CertificationTask
     */
    'targetType'?: CertificationTaskTargetTypeEnum;
    /**
     * The ID of the item being operated on by this task.
     * @type {string}
     * @memberof CertificationTask
     */
    'targetId'?: string;
    /**
     * The status of the task.
     * @type {string}
     * @memberof CertificationTask
     */
    'status'?: CertificationTaskStatusEnum;
    /**
     * 
     * @type {Array<ErrorMessageDto>}
     * @memberof CertificationTask
     */
    'errors'?: Array<ErrorMessageDto>;
    /**
     * Reassignment trails that lead to self certification identity
     * @type {Array<ReassignmentTrailDTO>}
     * @memberof CertificationTask
     */
    'reassignmentTrailDTOs'?: Array<ReassignmentTrailDTO>;
    /**
     * The date and time on which this task was created.
     * @type {string}
     * @memberof CertificationTask
     */
    'created'?: string;
}

export const CertificationTaskTypeEnum = {
    Reassign: 'REASSIGN',
    AdminReassign: 'ADMIN_REASSIGN',
    CompleteCertification: 'COMPLETE_CERTIFICATION',
    FinishCertification: 'FINISH_CERTIFICATION',
    CompleteCampaign: 'COMPLETE_CAMPAIGN',
    ActivateCampaign: 'ACTIVATE_CAMPAIGN',
    CampaignCreate: 'CAMPAIGN_CREATE',
    CampaignDelete: 'CAMPAIGN_DELETE'
} as const;

export type CertificationTaskTypeEnum = typeof CertificationTaskTypeEnum[keyof typeof CertificationTaskTypeEnum];
export const CertificationTaskTargetTypeEnum = {
    Certification: 'CERTIFICATION',
    Campaign: 'CAMPAIGN'
} as const;

export type CertificationTaskTargetTypeEnum = typeof CertificationTaskTargetTypeEnum[keyof typeof CertificationTaskTargetTypeEnum];
export const CertificationTaskStatusEnum = {
    Queued: 'QUEUED',
    InProgress: 'IN_PROGRESS',
    Success: 'SUCCESS',
    Error: 'ERROR'
} as const;

export type CertificationTaskStatusEnum = typeof CertificationTaskStatusEnum[keyof typeof CertificationTaskStatusEnum];

/**
 * Type of an API Client indicating public or confidentials use
 * @export
 * @enum {string}
 */

export const ClientType = {
    Confidential: 'CONFIDENTIAL',
    Public: 'PUBLIC'
} as const;

export type ClientType = typeof ClientType[keyof typeof ClientType];


/**
 * 
 * @export
 * @interface Column
 */
export interface Column {
    /**
     * The name of the field. 
     * @type {string}
     * @memberof Column
     */
    'field': string;
    /**
     * The value of the header. 
     * @type {string}
     * @memberof Column
     */
    'header'?: string;
}
/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * Id of the identity making the comment
     * @type {string}
     * @memberof Comment
     */
    'commenterId'?: string;
    /**
     * Human-readable display name of the identity making the comment
     * @type {string}
     * @memberof Comment
     */
    'commenterName'?: string;
    /**
     * Content of the comment
     * @type {string}
     * @memberof Comment
     */
    'body'?: string;
    /**
     * Date and time comment was made
     * @type {string}
     * @memberof Comment
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface CommentDto
 */
export interface CommentDto {
    /**
     * Comment content.
     * @type {string}
     * @memberof CommentDto
     */
    'comment'?: string | null;
    /**
     * 
     * @type {CommentDtoAuthor}
     * @memberof CommentDto
     */
    'author'?: CommentDtoAuthor;
    /**
     * Date and time comment was created.
     * @type {string}
     * @memberof CommentDto
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface CommentDtoAuthor
 */
export interface CommentDtoAuthor {
    /**
     * DTO type of the commenting identity.
     * @type {string}
     * @memberof CommentDtoAuthor
     */
    'type'?: CommentDtoAuthorTypeEnum;
    /**
     * ID of the commenting identity.
     * @type {string}
     * @memberof CommentDtoAuthor
     */
    'id'?: string;
    /**
     * Display name of the commenting identity.
     * @type {string}
     * @memberof CommentDtoAuthor
     */
    'name'?: string;
}

export const CommentDtoAuthorTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type CommentDtoAuthorTypeEnum = typeof CommentDtoAuthorTypeEnum[keyof typeof CommentDtoAuthorTypeEnum];

/**
 * 
 * @export
 * @interface CompletedApproval
 */
export interface CompletedApproval {
    /**
     * The approval id.
     * @type {string}
     * @memberof CompletedApproval
     */
    'id'?: string;
    /**
     * The name of the approval.
     * @type {string}
     * @memberof CompletedApproval
     */
    'name'?: string;
    /**
     * When the approval was created.
     * @type {string}
     * @memberof CompletedApproval
     */
    'created'?: string;
    /**
     * When the approval was modified last time.
     * @type {string}
     * @memberof CompletedApproval
     */
    'modified'?: string;
    /**
     * When the access-request was created.
     * @type {string}
     * @memberof CompletedApproval
     */
    'requestCreated'?: string;
    /**
     * 
     * @type {AccessRequestType}
     * @memberof CompletedApproval
     */
    'requestType'?: AccessRequestType;
    /**
     * 
     * @type {AccessItemRequester}
     * @memberof CompletedApproval
     */
    'requester'?: AccessItemRequester;
    /**
     * 
     * @type {AccessItemRequestedFor}
     * @memberof CompletedApproval
     */
    'requestedFor'?: AccessItemRequestedFor;
    /**
     * 
     * @type {AccessItemReviewedBy}
     * @memberof CompletedApproval
     */
    'reviewedBy'?: AccessItemReviewedBy;
    /**
     * 
     * @type {OwnerDto}
     * @memberof CompletedApproval
     */
    'owner'?: OwnerDto;
    /**
     * 
     * @type {RequestableObjectReference}
     * @memberof CompletedApproval
     */
    'requestedObject'?: RequestableObjectReference;
    /**
     * 
     * @type {CommentDto}
     * @memberof CompletedApproval
     */
    'requesterComment'?: CommentDto;
    /**
     * 
     * @type {CompletedApprovalReviewerComment}
     * @memberof CompletedApproval
     */
    'reviewerComment'?: CompletedApprovalReviewerComment | null;
    /**
     * The history of the previous reviewers comments.
     * @type {Array<CommentDto>}
     * @memberof CompletedApproval
     */
    'previousReviewersComments'?: Array<CommentDto>;
    /**
     * The history of approval forward action.
     * @type {Array<ApprovalForwardHistory>}
     * @memberof CompletedApproval
     */
    'forwardHistory'?: Array<ApprovalForwardHistory>;
    /**
     * When true the rejector has to provide comments when rejecting
     * @type {boolean}
     * @memberof CompletedApproval
     */
    'commentRequiredWhenRejected'?: boolean;
    /**
     * 
     * @type {CompletedApprovalState}
     * @memberof CompletedApproval
     */
    'state'?: CompletedApprovalState;
    /**
     * The date the role or access profile is no longer assigned to the specified identity.
     * @type {string}
     * @memberof CompletedApproval
     */
    'removeDate'?: string | null;
    /**
     * If true, then the request was to change the remove date or sunset date.
     * @type {boolean}
     * @memberof CompletedApproval
     */
    'removeDateUpdateRequested'?: boolean;
    /**
     * The remove date or sunset date that was assigned at the time of the request.
     * @type {string}
     * @memberof CompletedApproval
     */
    'currentRemoveDate'?: string | null;
    /**
     * 
     * @type {SodViolationContextCheckCompleted}
     * @memberof CompletedApproval
     */
    'sodViolationContext'?: SodViolationContextCheckCompleted;
}


/**
 * The approval\'s reviewer\'s comment.
 * @export
 * @interface CompletedApprovalReviewerComment
 */
export interface CompletedApprovalReviewerComment {
    /**
     * Comment content.
     * @type {string}
     * @memberof CompletedApprovalReviewerComment
     */
    'comment'?: string | null;
    /**
     * 
     * @type {CommentDtoAuthor}
     * @memberof CompletedApprovalReviewerComment
     */
    'author'?: CommentDtoAuthor;
    /**
     * Date and time comment was created.
     * @type {string}
     * @memberof CompletedApprovalReviewerComment
     */
    'created'?: string;
}
/**
 * Enum represents completed approval object\'s state.
 * @export
 * @enum {string}
 */

export const CompletedApprovalState = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED'
} as const;

export type CompletedApprovalState = typeof CompletedApprovalState[keyof typeof CompletedApprovalState];


/**
 * The status after completion.
 * @export
 * @enum {string}
 */

export const CompletionStatus = {
    Success: 'SUCCESS',
    Failure: 'FAILURE',
    Incomplete: 'INCOMPLETE',
    Pending: 'PENDING'
} as const;

export type CompletionStatus = typeof CompletionStatus[keyof typeof CompletionStatus];


/**
 * 
 * @export
 * @interface Concatenation
 */
export interface Concatenation {
    /**
     * An array of items to join together
     * @type {Array<object>}
     * @memberof Concatenation
     */
    'values': Array<object>;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Concatenation
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Concatenation
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Conditional
 */
export interface Conditional {
    /**
     * A comparison statement that follows the structure of `ValueA eq ValueB` where `ValueA` and `ValueB` are static strings or outputs of other transforms.   The `eq` operator is the only valid comparison
     * @type {string}
     * @memberof Conditional
     */
    'expression': string;
    /**
     * The output of the transform if the expression evalutes to true
     * @type {string}
     * @memberof Conditional
     */
    'positiveCondition': string;
    /**
     * The output of the transform if the expression evalutes to false
     * @type {string}
     * @memberof Conditional
     */
    'negativeCondition': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Conditional
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Conditional
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ConflictingAccessCriteria
 */
export interface ConflictingAccessCriteria {
    /**
     * 
     * @type {AccessCriteria}
     * @memberof ConflictingAccessCriteria
     */
    'leftCriteria'?: AccessCriteria;
    /**
     * 
     * @type {AccessCriteria}
     * @memberof ConflictingAccessCriteria
     */
    'rightCriteria'?: AccessCriteria;
}
/**
 * 
 * @export
 * @interface CreateOAuthClientRequest
 */
export interface CreateOAuthClientRequest {
    /**
     * The name of the business the API Client should belong to
     * @type {string}
     * @memberof CreateOAuthClientRequest
     */
    'businessName'?: string | null;
    /**
     * The homepage URL associated with the owner of the API Client
     * @type {string}
     * @memberof CreateOAuthClientRequest
     */
    'homepageUrl'?: string | null;
    /**
     * A human-readable name for the API Client
     * @type {string}
     * @memberof CreateOAuthClientRequest
     */
    'name': string | null;
    /**
     * A description of the API Client
     * @type {string}
     * @memberof CreateOAuthClientRequest
     */
    'description': string | null;
    /**
     * The number of seconds an access token generated for this API Client is valid for
     * @type {number}
     * @memberof CreateOAuthClientRequest
     */
    'accessTokenValiditySeconds': number;
    /**
     * The number of seconds a refresh token generated for this API Client is valid for
     * @type {number}
     * @memberof CreateOAuthClientRequest
     */
    'refreshTokenValiditySeconds'?: number;
    /**
     * A list of the approved redirect URIs. Provide one or more URIs when assigning the AUTHORIZATION_CODE grant type to a new OAuth Client.
     * @type {Array<string>}
     * @memberof CreateOAuthClientRequest
     */
    'redirectUris'?: Array<string> | null;
    /**
     * A list of OAuth 2.0 grant types this API Client can be used with
     * @type {Array<GrantType>}
     * @memberof CreateOAuthClientRequest
     */
    'grantTypes': Array<GrantType> | null;
    /**
     * 
     * @type {AccessType}
     * @memberof CreateOAuthClientRequest
     */
    'accessType': AccessType;
    /**
     * 
     * @type {ClientType}
     * @memberof CreateOAuthClientRequest
     */
    'type'?: ClientType;
    /**
     * An indicator of whether the API Client can be used for requests internal within the product.
     * @type {boolean}
     * @memberof CreateOAuthClientRequest
     */
    'internal'?: boolean;
    /**
     * An indicator of whether the API Client is enabled for use
     * @type {boolean}
     * @memberof CreateOAuthClientRequest
     */
    'enabled': boolean;
    /**
     * An indicator of whether the API Client supports strong authentication
     * @type {boolean}
     * @memberof CreateOAuthClientRequest
     */
    'strongAuthSupported'?: boolean;
    /**
     * An indicator of whether the API Client supports the serialization of SAML claims when used with the authorization_code flow
     * @type {boolean}
     * @memberof CreateOAuthClientRequest
     */
    'claimsSupported'?: boolean;
    /**
     * Scopes of the API Client. If no scope is specified, the client will be created with the default scope \"sp:scopes:all\". This means the API Client will have all the rights of the owner who created it.
     * @type {Array<string>}
     * @memberof CreateOAuthClientRequest
     */
    'scope'?: Array<string> | null;
}


/**
 * 
 * @export
 * @interface CreateOAuthClientResponse
 */
export interface CreateOAuthClientResponse {
    /**
     * ID of the OAuth client
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'id': string;
    /**
     * Secret of the OAuth client (This field is only returned on the intial create call.)
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'secret': string;
    /**
     * The name of the business the API Client should belong to
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'businessName': string;
    /**
     * The homepage URL associated with the owner of the API Client
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'homepageUrl': string;
    /**
     * A human-readable name for the API Client
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'name': string;
    /**
     * A description of the API Client
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'description': string;
    /**
     * The number of seconds an access token generated for this API Client is valid for
     * @type {number}
     * @memberof CreateOAuthClientResponse
     */
    'accessTokenValiditySeconds': number;
    /**
     * The number of seconds a refresh token generated for this API Client is valid for
     * @type {number}
     * @memberof CreateOAuthClientResponse
     */
    'refreshTokenValiditySeconds': number;
    /**
     * A list of the approved redirect URIs used with the authorization_code flow
     * @type {Array<string>}
     * @memberof CreateOAuthClientResponse
     */
    'redirectUris': Array<string>;
    /**
     * A list of OAuth 2.0 grant types this API Client can be used with
     * @type {Array<GrantType>}
     * @memberof CreateOAuthClientResponse
     */
    'grantTypes': Array<GrantType>;
    /**
     * 
     * @type {AccessType}
     * @memberof CreateOAuthClientResponse
     */
    'accessType': AccessType;
    /**
     * 
     * @type {ClientType}
     * @memberof CreateOAuthClientResponse
     */
    'type': ClientType;
    /**
     * An indicator of whether the API Client can be used for requests internal to IDN
     * @type {boolean}
     * @memberof CreateOAuthClientResponse
     */
    'internal': boolean;
    /**
     * An indicator of whether the API Client is enabled for use
     * @type {boolean}
     * @memberof CreateOAuthClientResponse
     */
    'enabled': boolean;
    /**
     * An indicator of whether the API Client supports strong authentication
     * @type {boolean}
     * @memberof CreateOAuthClientResponse
     */
    'strongAuthSupported': boolean;
    /**
     * An indicator of whether the API Client supports the serialization of SAML claims when used with the authorization_code flow
     * @type {boolean}
     * @memberof CreateOAuthClientResponse
     */
    'claimsSupported': boolean;
    /**
     * The date and time, down to the millisecond, when the API Client was created
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'created': string;
    /**
     * The date and time, down to the millisecond, when the API Client was last updated
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'modified': string;
    /**
     * Scopes of the API Client.
     * @type {Array<string>}
     * @memberof CreateOAuthClientResponse
     */
    'scope': Array<string> | null;
}


/**
 * Object for specifying the name of a personal access token to create
 * @export
 * @interface CreatePersonalAccessTokenRequest
 */
export interface CreatePersonalAccessTokenRequest {
    /**
     * The name of the personal access token (PAT) to be created. Cannot be the same as another PAT owned by the user for whom this PAT is being created.
     * @type {string}
     * @memberof CreatePersonalAccessTokenRequest
     */
    'name': string;
    /**
     * Scopes of the personal  access token. If no scope is specified, the token will be created with the default scope \"sp:scopes:all\". This means the personal access token will have all the rights of the owner who created it.
     * @type {Array<string>}
     * @memberof CreatePersonalAccessTokenRequest
     */
    'scope'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface CreatePersonalAccessTokenResponse
 */
export interface CreatePersonalAccessTokenResponse {
    /**
     * The ID of the personal access token (to be used as the username for Basic Auth).
     * @type {string}
     * @memberof CreatePersonalAccessTokenResponse
     */
    'id': string;
    /**
     * The secret of the personal access token (to be used as the password for Basic Auth).
     * @type {string}
     * @memberof CreatePersonalAccessTokenResponse
     */
    'secret': string;
    /**
     * Scopes of the personal  access token.
     * @type {Array<string>}
     * @memberof CreatePersonalAccessTokenResponse
     */
    'scope': Array<string> | null;
    /**
     * The name of the personal access token. Cannot be the same as other personal access tokens owned by a user.
     * @type {string}
     * @memberof CreatePersonalAccessTokenResponse
     */
    'name': string;
    /**
     * 
     * @type {PatOwner}
     * @memberof CreatePersonalAccessTokenResponse
     */
    'owner': PatOwner;
    /**
     * The date and time, down to the millisecond, when this personal access token was created.
     * @type {string}
     * @memberof CreatePersonalAccessTokenResponse
     */
    'created': string;
}
/**
 * 
 * @export
 * @interface CreateSavedSearchRequest
 */
export interface CreateSavedSearchRequest {
    /**
     * The name of the saved search. 
     * @type {string}
     * @memberof CreateSavedSearchRequest
     */
    'name'?: string;
    /**
     * The description of the saved search. 
     * @type {string}
     * @memberof CreateSavedSearchRequest
     */
    'description'?: string | null;
    /**
     * Indicates if the saved search is public. 
     * @type {boolean}
     * @memberof CreateSavedSearchRequest
     */
    'public'?: boolean;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof CreateSavedSearchRequest
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof CreateSavedSearchRequest
     */
    'modified'?: string | null;
    /**
     * The names of the Elasticsearch indices in which to search. 
     * @type {Array<Index>}
     * @memberof CreateSavedSearchRequest
     */
    'indices': Array<Index>;
    /**
     * The columns to be returned (specifies the order in which they will be presented) for each document type.  The currently supported document types are: _accessprofile_, _accountactivity_, _account_, _aggregation_, _entitlement_, _event_, _identity_, and _role_. 
     * @type {{ [key: string]: Array<Column>; }}
     * @memberof CreateSavedSearchRequest
     */
    'columns'?: { [key: string]: Array<Column>; };
    /**
     * The search query using Elasticsearch [Query String Query](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/query-dsl-query-string-query.html#query-string) syntax from the Query DSL. 
     * @type {string}
     * @memberof CreateSavedSearchRequest
     */
    'query': string;
    /**
     * The fields to be searched against in a multi-field query. 
     * @type {Array<string>}
     * @memberof CreateSavedSearchRequest
     */
    'fields'?: Array<string> | null;
    /**
     * The fields to be used to sort the search results. 
     * @type {Array<string>}
     * @memberof CreateSavedSearchRequest
     */
    'sort'?: Array<string>;
    /**
     * 
     * @type {SavedSearchDetailFilters}
     * @memberof CreateSavedSearchRequest
     */
    'filters'?: SavedSearchDetailFilters | null;
}
/**
 * 
 * @export
 * @interface CreateScheduledSearchRequest
 */
export interface CreateScheduledSearchRequest {
    /**
     * The name of the scheduled search. 
     * @type {string}
     * @memberof CreateScheduledSearchRequest
     */
    'name'?: string | null;
    /**
     * The description of the scheduled search. 
     * @type {string}
     * @memberof CreateScheduledSearchRequest
     */
    'description'?: string | null;
    /**
     * The ID of the saved search that will be executed.
     * @type {string}
     * @memberof CreateScheduledSearchRequest
     */
    'savedSearchId': string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof CreateScheduledSearchRequest
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof CreateScheduledSearchRequest
     */
    'modified'?: string | null;
    /**
     * 
     * @type {Schedule1}
     * @memberof CreateScheduledSearchRequest
     */
    'schedule': Schedule1;
    /**
     * A list of identities that should receive the scheduled search report via email.
     * @type {Array<SearchScheduleRecipientsInner>}
     * @memberof CreateScheduledSearchRequest
     */
    'recipients': Array<SearchScheduleRecipientsInner>;
    /**
     * Indicates if the scheduled search is enabled. 
     * @type {boolean}
     * @memberof CreateScheduledSearchRequest
     */
    'enabled'?: boolean;
    /**
     * Indicates if email generation should not be suppressed if search returns no results. 
     * @type {boolean}
     * @memberof CreateScheduledSearchRequest
     */
    'emailEmptyResults'?: boolean;
    /**
     * Indicates if the generated email should include the query and search results preview (which could include PII). 
     * @type {boolean}
     * @memberof CreateScheduledSearchRequest
     */
    'displayQueryDetails'?: boolean;
}
/**
 * Type of the criteria in the filter.
 * @export
 * @enum {string}
 */

export const CriteriaType = {
    Composite: 'COMPOSITE',
    Role: 'ROLE',
    Identity: 'IDENTITY',
    IdentityAttribute: 'IDENTITY_ATTRIBUTE',
    Entitlement: 'ENTITLEMENT',
    InvalidCertifiableEntity: 'INVALID_CERTIFIABLE_ENTITY',
    AccessProfile: 'ACCESS_PROFILE',
    Source: 'SOURCE',
    Account: 'ACCOUNT',
    InvalidCertifiableBundle: 'INVALID_CERTIFIABLE_BUNDLE',
    AggregatedEntitlement: 'AGGREGATED_ENTITLEMENT'
} as const;

export type CriteriaType = typeof CriteriaType[keyof typeof CriteriaType];


/**
 * DAS data for the entitlement
 * @export
 * @interface DataAccess
 */
export interface DataAccess {
    /**
     * List of classification policies that apply to resources the entitlement \\ groups has access to
     * @type {Array<DataAccessPoliciesInner>}
     * @memberof DataAccess
     */
    'policies'?: Array<DataAccessPoliciesInner>;
    /**
     * List of classification categories that apply to resources the entitlement \\ groups has access to
     * @type {Array<DataAccessCategoriesInner>}
     * @memberof DataAccess
     */
    'categories'?: Array<DataAccessCategoriesInner>;
    /**
     * 
     * @type {DataAccessImpactScore}
     * @memberof DataAccess
     */
    'impactScore'?: DataAccessImpactScore;
}
/**
 * 
 * @export
 * @interface DataAccessCategoriesInner
 */
export interface DataAccessCategoriesInner {
    /**
     * Value of the category
     * @type {string}
     * @memberof DataAccessCategoriesInner
     */
    'value'?: string;
    /**
     * Number of matched for each category
     * @type {number}
     * @memberof DataAccessCategoriesInner
     */
    'matchCount'?: number;
}
/**
 * 
 * @export
 * @interface DataAccessImpactScore
 */
export interface DataAccessImpactScore {
    /**
     * Impact Score for this data
     * @type {string}
     * @memberof DataAccessImpactScore
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface DataAccessPoliciesInner
 */
export interface DataAccessPoliciesInner {
    /**
     * Value of the policy
     * @type {string}
     * @memberof DataAccessPoliciesInner
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface DateCompare
 */
export interface DateCompare {
    /**
     * 
     * @type {DateCompareFirstDate}
     * @memberof DateCompare
     */
    'firstDate': DateCompareFirstDate;
    /**
     * 
     * @type {DateCompareSecondDate}
     * @memberof DateCompare
     */
    'secondDate': DateCompareSecondDate;
    /**
     * This is the comparison to perform. | Operation | Description | | --------- | ------- | | LT        | Strictly less than: firstDate < secondDate | | LTE       | Less than or equal to: firstDate <= secondDate | | GT        | Strictly greater than: firstDate > secondDate | | GTE       | Greater than or equal to: firstDate >= secondDate | 
     * @type {string}
     * @memberof DateCompare
     */
    'operator': DateCompareOperatorEnum;
    /**
     * The output of the transform if the expression evalutes to true
     * @type {string}
     * @memberof DateCompare
     */
    'positiveCondition': string;
    /**
     * The output of the transform if the expression evalutes to false
     * @type {string}
     * @memberof DateCompare
     */
    'negativeCondition': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof DateCompare
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof DateCompare
     */
    'input'?: { [key: string]: any; };
}

export const DateCompareOperatorEnum = {
    Lt: 'LT',
    Lte: 'LTE',
    Gt: 'GT',
    Gte: 'GTE'
} as const;

export type DateCompareOperatorEnum = typeof DateCompareOperatorEnum[keyof typeof DateCompareOperatorEnum];

/**
 * @type DateCompareFirstDate
 * This is the first date to consider (The date that would be on the left hand side of the comparison operation).
 * @export
 */
export type DateCompareFirstDate = AccountAttribute | DateFormat;

/**
 * @type DateCompareSecondDate
 * This is the second date to consider (The date that would be on the right hand side of the comparison operation).
 * @export
 */
export type DateCompareSecondDate = AccountAttribute | DateFormat;

/**
 * 
 * @export
 * @interface DateFormat
 */
export interface DateFormat {
    /**
     * 
     * @type {DateFormatInputFormat}
     * @memberof DateFormat
     */
    'inputFormat'?: DateFormatInputFormat;
    /**
     * 
     * @type {DateFormatOutputFormat}
     * @memberof DateFormat
     */
    'outputFormat'?: DateFormatOutputFormat;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof DateFormat
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof DateFormat
     */
    'input'?: { [key: string]: any; };
}
/**
 * @type DateFormatInputFormat
 * A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data is coming in as.  *If no inputFormat is provided, the transform assumes that it is in ISO8601 format*
 * @export
 */
export type DateFormatInputFormat = NamedConstructs | string;

/**
 * @type DateFormatOutputFormat
 * A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data should be formatted into.  *If no inputFormat is provided, the transform assumes that it is in ISO8601 format*
 * @export
 */
export type DateFormatOutputFormat = NamedConstructs | string;

/**
 * 
 * @export
 * @interface DateMath
 */
export interface DateMath {
    /**
     * A string value of the date and time components to operation on, along with the math operations to execute. 
     * @type {string}
     * @memberof DateMath
     */
    'expression': string;
    /**
     * A boolean value to indicate whether the transform should round up or down when a rounding `/` operation is defined in the expression.    If not provided, the transform will default to `false`   `true` indicates the transform should round up (i.e., truncate the fractional date/time component indicated and then add one unit of that component)   `false` indicates the transform should round down (i.e., truncate the fractional date/time component indicated) 
     * @type {boolean}
     * @memberof DateMath
     */
    'roundUp'?: boolean;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof DateMath
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof DateMath
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface DecomposeDiacriticalMarks
 */
export interface DecomposeDiacriticalMarks {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof DecomposeDiacriticalMarks
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof DecomposeDiacriticalMarks
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface DeleteNonEmployeeRecordsInBulkRequest
 */
export interface DeleteNonEmployeeRecordsInBulkRequest {
    /**
     * List of non-employee ids.
     * @type {Array<string>}
     * @memberof DeleteNonEmployeeRecordsInBulkRequest
     */
    'ids': Array<string>;
}
/**
 * 
 * @export
 * @interface DeleteSource202Response
 */
export interface DeleteSource202Response {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof DeleteSource202Response
     */
    'type'?: DeleteSource202ResponseTypeEnum;
    /**
     * ID of the task result
     * @type {string}
     * @memberof DeleteSource202Response
     */
    'id'?: string;
    /**
     * Human-readable display name of the task result (should be null/empty)
     * @type {string}
     * @memberof DeleteSource202Response
     */
    'name'?: string;
}

export const DeleteSource202ResponseTypeEnum = {
    TaskResult: 'TASK_RESULT'
} as const;

export type DeleteSource202ResponseTypeEnum = typeof DeleteSource202ResponseTypeEnum[keyof typeof DeleteSource202ResponseTypeEnum];

/**
 * 
 * @export
 * @interface DisplayReference
 */
export interface DisplayReference {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof DisplayReference
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof DisplayReference
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisplayReference
     */
    'displayName'?: string;
}
/**
 * Enum representing the currently supported document types.  Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const DocumentType = {
    Accessprofile: 'accessprofile',
    Accountactivity: 'accountactivity',
    Account: 'account',
    Aggregation: 'aggregation',
    Entitlement: 'entitlement',
    Event: 'event',
    Identity: 'identity',
    Role: 'role'
} as const;

export type DocumentType = typeof DocumentType[keyof typeof DocumentType];


/**
 * An enumeration of the types of DTOs supported within the IdentityNow infrastructure.
 * @export
 * @enum {string}
 */

export const DtoType = {
    AccountCorrelationConfig: 'ACCOUNT_CORRELATION_CONFIG',
    AccessProfile: 'ACCESS_PROFILE',
    AccessRequestApproval: 'ACCESS_REQUEST_APPROVAL',
    Account: 'ACCOUNT',
    Application: 'APPLICATION',
    Campaign: 'CAMPAIGN',
    CampaignFilter: 'CAMPAIGN_FILTER',
    Certification: 'CERTIFICATION',
    Cluster: 'CLUSTER',
    ConnectorSchema: 'CONNECTOR_SCHEMA',
    Entitlement: 'ENTITLEMENT',
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY',
    IdentityProfile: 'IDENTITY_PROFILE',
    IdentityRequest: 'IDENTITY_REQUEST',
    LifecycleState: 'LIFECYCLE_STATE',
    PasswordPolicy: 'PASSWORD_POLICY',
    Role: 'ROLE',
    Rule: 'RULE',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE',
    Tag: 'TAG',
    TagCategory: 'TAG_CATEGORY',
    TaskResult: 'TASK_RESULT',
    ReportResult: 'REPORT_RESULT',
    SodViolation: 'SOD_VIOLATION',
    AccountActivity: 'ACCOUNT_ACTIVITY',
    Workgroup: 'WORKGROUP'
} as const;

export type DtoType = typeof DtoType[keyof typeof DtoType];


/**
 * 
 * @export
 * @interface E164phone
 */
export interface E164phone {
    /**
     * This is an optional attribute that can be used to define the region of the phone number to format into.   If defaultRegion is not provided, it will take US as the default country.   The format of the country code should be in [ISO 3166-1 alpha-2 format](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) 
     * @type {string}
     * @memberof E164phone
     */
    'defaultRegion'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof E164phone
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof E164phone
     */
    'input'?: { [key: string]: any; };
}
/**
 * This is used for representing email configuration for a lifecycle state
 * @export
 * @interface EmailNotificationOption
 */
export interface EmailNotificationOption {
    /**
     * If true, then the manager is notified of the lifecycle state change.
     * @type {boolean}
     * @memberof EmailNotificationOption
     */
    'notifyManagers'?: boolean;
    /**
     * If true, then all the admins are notified of the lifecycle state change.
     * @type {boolean}
     * @memberof EmailNotificationOption
     */
    'notifyAllAdmins'?: boolean;
    /**
     * If true, then the users specified in \"emailAddressList\" below are notified of lifecycle state change.
     * @type {boolean}
     * @memberof EmailNotificationOption
     */
    'notifySpecificUsers'?: boolean;
    /**
     * List of user email addresses. If \"notifySpecificUsers\" option is true, then these users are notified of lifecycle state change.
     * @type {Array<string>}
     * @memberof EmailNotificationOption
     */
    'emailAddressList'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Entitlement
 */
export interface Entitlement {
    /**
     * The entitlement id
     * @type {string}
     * @memberof Entitlement
     */
    'id'?: string;
    /**
     * The entitlement name
     * @type {string}
     * @memberof Entitlement
     */
    'name'?: string;
    /**
     * The entitlement attribute name
     * @type {string}
     * @memberof Entitlement
     */
    'attribute'?: string;
    /**
     * The value of the entitlement
     * @type {string}
     * @memberof Entitlement
     */
    'value'?: string;
    /**
     * The object type of the entitlement from the source schema
     * @type {string}
     * @memberof Entitlement
     */
    'sourceSchemaObjectType'?: string;
    /**
     * The description of the entitlement
     * @type {string}
     * @memberof Entitlement
     */
    'description'?: string;
    /**
     * True if the entitlement is privileged
     * @type {boolean}
     * @memberof Entitlement
     */
    'privileged'?: boolean;
    /**
     * True if the entitlement is cloud governed
     * @type {boolean}
     * @memberof Entitlement
     */
    'cloudGoverned'?: boolean;
    /**
     * Time when the entitlement was created
     * @type {string}
     * @memberof Entitlement
     */
    'created'?: string;
    /**
     * Time when the entitlement was last modified
     * @type {string}
     * @memberof Entitlement
     */
    'modified'?: string;
    /**
     * 
     * @type {EntitlementSource}
     * @memberof Entitlement
     */
    'source'?: EntitlementSource;
    /**
     * A map of free-form key-value pairs from the source system
     * @type {{ [key: string]: any; }}
     * @memberof Entitlement
     */
    'attributes'?: { [key: string]: any; };
    /**
     * List of IDs of segments, if any, to which this Entitlement is assigned.
     * @type {Array<string>}
     * @memberof Entitlement
     */
    'segments'?: Array<string> | null;
    /**
     * 
     * @type {Array<PermissionDto>}
     * @memberof Entitlement
     */
    'directPermissions'?: Array<PermissionDto>;
}
/**
 * Entitlement
 * @export
 * @interface EntitlementDocument
 */
export interface EntitlementDocument {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof EntitlementDocument
     */
    'id': string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof EntitlementDocument
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof EntitlementDocument
     */
    '_type': DocumentType;
    /**
     * A description of the entitlement
     * @type {string}
     * @memberof EntitlementDocument
     */
    'description'?: string;
    /**
     * The name of the entitlement attribute
     * @type {string}
     * @memberof EntitlementDocument
     */
    'attribute'?: string;
    /**
     * The value of the entitlement
     * @type {string}
     * @memberof EntitlementDocument
     */
    'value'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof EntitlementDocument
     */
    'modified'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof EntitlementDocument
     */
    'synced'?: string | null;
    /**
     * The display name of the entitlement
     * @type {string}
     * @memberof EntitlementDocument
     */
    'displayName'?: string;
    /**
     * 
     * @type {Reference1}
     * @memberof EntitlementDocument
     */
    'source'?: Reference1;
    /**
     * 
     * @type {boolean}
     * @memberof EntitlementDocument
     */
    'privileged'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof EntitlementDocument
     */
    'identityCount'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof EntitlementDocument
     */
    'tags'?: Array<string>;
}


/**
 * 
 * @export
 * @interface EntitlementDto
 */
export interface EntitlementDto {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof EntitlementDto
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof EntitlementDto
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof EntitlementDto
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof EntitlementDto
     */
    'modified'?: string;
    /**
     * Name of the entitlement attribute
     * @type {string}
     * @memberof EntitlementDto
     */
    'attribute'?: string;
    /**
     * Raw value of the entitlement
     * @type {string}
     * @memberof EntitlementDto
     */
    'value'?: string;
    /**
     * Entitlment description
     * @type {string}
     * @memberof EntitlementDto
     */
    'description'?: string;
    /**
     * Entitlement attributes
     * @type {{ [key: string]: any; }}
     * @memberof EntitlementDto
     */
    'attributes'?: { [key: string]: any; };
    /**
     * Schema objectType on the given application that maps to an Account Group
     * @type {string}
     * @memberof EntitlementDto
     */
    'sourceSchemaObjectType'?: string;
    /**
     * Determines if this Entitlement is privileged.
     * @type {boolean}
     * @memberof EntitlementDto
     */
    'privileged'?: boolean;
    /**
     * Determines if this Entitlement is goverened in the cloud.
     * @type {boolean}
     * @memberof EntitlementDto
     */
    'cloudGoverned'?: boolean;
    /**
     * 
     * @type {EntitlementSource}
     * @memberof EntitlementDto
     */
    'source'?: EntitlementSource;
}
/**
 * Entitlement including a specific set of access.
 * @export
 * @interface EntitlementRef
 */
export interface EntitlementRef {
    /**
     * Entitlement\'s DTO type.
     * @type {string}
     * @memberof EntitlementRef
     */
    'type'?: EntitlementRefTypeEnum;
    /**
     * Entitlement\'s ID.
     * @type {string}
     * @memberof EntitlementRef
     */
    'id'?: string;
    /**
     * Entitlement\'s display name.
     * @type {string}
     * @memberof EntitlementRef
     */
    'name'?: string;
}

export const EntitlementRefTypeEnum = {
    Entitlement: 'ENTITLEMENT'
} as const;

export type EntitlementRefTypeEnum = typeof EntitlementRefTypeEnum[keyof typeof EntitlementRefTypeEnum];

/**
 * 
 * @export
 * @interface EntitlementRequestConfig
 */
export interface EntitlementRequestConfig {
    /**
     * Flag for allowing entitlement request.
     * @type {boolean}
     * @memberof EntitlementRequestConfig
     */
    'allowEntitlementRequest'?: boolean;
    /**
     * Flag for requiring comments while submitting an entitlement request.
     * @type {boolean}
     * @memberof EntitlementRequestConfig
     */
    'requestCommentsRequired'?: boolean;
    /**
     * Flag for requiring comments while rejecting an entitlement request.
     * @type {boolean}
     * @memberof EntitlementRequestConfig
     */
    'deniedCommentsRequired'?: boolean;
    /**
     * Approval schemes for granting entitlement request. This can be empty if no approval is needed. Multiple schemes must be comma-separated. The valid schemes are \"entitlementOwner\", \"sourceOwner\", \"manager\" and \"workgroup:{id}\". Multiple workgroups (governance groups) can be used. 
     * @type {string}
     * @memberof EntitlementRequestConfig
     */
    'grantRequestApprovalSchemes'?: string;
}
/**
 * 
 * @export
 * @interface EntitlementSource
 */
export interface EntitlementSource {
    /**
     * The source ID
     * @type {string}
     * @memberof EntitlementSource
     */
    'id'?: string;
    /**
     * The source type, will always be \"SOURCE\"
     * @type {string}
     * @memberof EntitlementSource
     */
    'type'?: string;
    /**
     * The source name
     * @type {string}
     * @memberof EntitlementSource
     */
    'name'?: string;
}
/**
 * EntitlementReference
 * @export
 * @interface EntitlementSummary
 */
export interface EntitlementSummary {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof EntitlementSummary
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof EntitlementSummary
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntitlementSummary
     */
    'displayName'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof EntitlementSummary
     */
    'type'?: DtoType;
    /**
     * 
     * @type {string}
     * @memberof EntitlementSummary
     */
    'description'?: string | null;
    /**
     * 
     * @type {Reference1}
     * @memberof EntitlementSummary
     */
    'source'?: Reference1;
    /**
     * 
     * @type {boolean}
     * @memberof EntitlementSummary
     */
    'privileged'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EntitlementSummary
     */
    'attribute'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntitlementSummary
     */
    'value'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EntitlementSummary
     */
    'standalone'?: boolean;
}


/**
 * 
 * @export
 * @interface ErrorMessageDto
 */
export interface ErrorMessageDto {
    /**
     * The locale for the message text, a BCP 47 language tag.
     * @type {string}
     * @memberof ErrorMessageDto
     */
    'locale'?: string;
    /**
     * 
     * @type {LocaleOrigin}
     * @memberof ErrorMessageDto
     */
    'localeOrigin'?: LocaleOrigin;
    /**
     * Actual text of the error message in the indicated locale.
     * @type {string}
     * @memberof ErrorMessageDto
     */
    'text'?: string;
}


/**
 * 
 * @export
 * @interface ErrorResponseDto
 */
export interface ErrorResponseDto {
    /**
     * Fine-grained error code providing more detail of the error.
     * @type {string}
     * @memberof ErrorResponseDto
     */
    'detailCode'?: string;
    /**
     * Unique tracking id for the error.
     * @type {string}
     * @memberof ErrorResponseDto
     */
    'trackingId'?: string;
    /**
     * Generic localized reason for error
     * @type {Array<ErrorMessageDto>}
     * @memberof ErrorResponseDto
     */
    'messages'?: Array<ErrorMessageDto>;
    /**
     * Plain-text descriptive reasons to provide additional detail to the text provided in the messages field
     * @type {Array<ErrorMessageDto>}
     * @memberof ErrorResponseDto
     */
    'causes'?: Array<ErrorMessageDto>;
}
/**
 * Event
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof Event
     */
    '_type': DocumentType;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof Event
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof Event
     */
    'synced'?: string | null;
    /**
     * The action that was performed
     * @type {string}
     * @memberof Event
     */
    'action'?: string;
    /**
     * The type of event
     * @type {string}
     * @memberof Event
     */
    'type'?: string;
    /**
     * 
     * @type {NameType}
     * @memberof Event
     */
    'actor'?: NameType;
    /**
     * 
     * @type {NameType}
     * @memberof Event
     */
    'target'?: NameType;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'stack'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'trackingNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'ipAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'details'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Event
     */
    'attributes'?: { [key: string]: any; };
    /**
     * 
     * @type {Array<string>}
     * @memberof Event
     */
    'objects'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'operation'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'technicalName'?: string;
}


/**
 * Event
 * @export
 * @interface EventDocument
 */
export interface EventDocument {
    /**
     * 
     * @type {string}
     * @memberof EventDocument
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventDocument
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof EventDocument
     */
    '_type': DocumentType;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof EventDocument
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof EventDocument
     */
    'synced'?: string | null;
    /**
     * The action that was performed
     * @type {string}
     * @memberof EventDocument
     */
    'action'?: string;
    /**
     * The type of event
     * @type {string}
     * @memberof EventDocument
     */
    'type'?: string;
    /**
     * 
     * @type {NameType}
     * @memberof EventDocument
     */
    'actor'?: NameType;
    /**
     * 
     * @type {NameType}
     * @memberof EventDocument
     */
    'target'?: NameType;
    /**
     * 
     * @type {string}
     * @memberof EventDocument
     */
    'stack'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventDocument
     */
    'trackingNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventDocument
     */
    'ipAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventDocument
     */
    'details'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof EventDocument
     */
    'attributes'?: { [key: string]: any; };
    /**
     * 
     * @type {Array<string>}
     * @memberof EventDocument
     */
    'objects'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EventDocument
     */
    'operation'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventDocument
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventDocument
     */
    'technicalName'?: string;
}


/**
 * 
 * @export
 * @interface ExceptionAccessCriteria
 */
export interface ExceptionAccessCriteria {
    /**
     * 
     * @type {ExceptionCriteria}
     * @memberof ExceptionAccessCriteria
     */
    'leftCriteria'?: ExceptionCriteria;
    /**
     * 
     * @type {ExceptionCriteria}
     * @memberof ExceptionAccessCriteria
     */
    'rightCriteria'?: ExceptionCriteria;
}
/**
 * 
 * @export
 * @interface ExceptionCriteria
 */
export interface ExceptionCriteria {
    /**
     * List of exception criteria. There is a min of 1 and max of 50 items in the list.
     * @type {Array<ExceptionCriteriaCriteriaListInner>}
     * @memberof ExceptionCriteria
     */
    'criteriaList'?: Array<ExceptionCriteriaCriteriaListInner>;
}
/**
 * Access reference with addition of boolean existing flag to indicate whether the access was extant
 * @export
 * @interface ExceptionCriteriaAccess
 */
export interface ExceptionCriteriaAccess {
    /**
     * 
     * @type {DtoType}
     * @memberof ExceptionCriteriaAccess
     */
    'type'?: DtoType;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof ExceptionCriteriaAccess
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof ExceptionCriteriaAccess
     */
    'name'?: string;
    /**
     * Whether the subject identity already had that access or not
     * @type {boolean}
     * @memberof ExceptionCriteriaAccess
     */
    'existing'?: boolean;
}


/**
 * The types of objects supported for SOD violations
 * @export
 * @interface ExceptionCriteriaCriteriaListInner
 */
export interface ExceptionCriteriaCriteriaListInner {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof ExceptionCriteriaCriteriaListInner
     */
    'type'?: ExceptionCriteriaCriteriaListInnerTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof ExceptionCriteriaCriteriaListInner
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof ExceptionCriteriaCriteriaListInner
     */
    'name'?: string;
    /**
     * Whether the subject identity already had that access or not
     * @type {boolean}
     * @memberof ExceptionCriteriaCriteriaListInner
     */
    'existing'?: boolean;
}

export const ExceptionCriteriaCriteriaListInnerTypeEnum = {
    Entitlement: 'ENTITLEMENT'
} as const;

export type ExceptionCriteriaCriteriaListInnerTypeEnum = typeof ExceptionCriteriaCriteriaListInnerTypeEnum[keyof typeof ExceptionCriteriaCriteriaListInnerTypeEnum];

/**
 * The current state of execution.
 * @export
 * @enum {string}
 */

export const ExecutionStatus = {
    Executing: 'EXECUTING',
    Verifying: 'VERIFYING',
    Terminated: 'TERMINATED',
    Completed: 'COMPLETED'
} as const;

export type ExecutionStatus = typeof ExecutionStatus[keyof typeof ExecutionStatus];


/**
 * 
 * @export
 * @interface ExpansionItem
 */
export interface ExpansionItem {
    /**
     * The ID of the account
     * @type {string}
     * @memberof ExpansionItem
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExpansionItem
     */
    'cause'?: string;
    /**
     * The name of the item
     * @type {string}
     * @memberof ExpansionItem
     */
    'name'?: string;
    /**
     * 
     * @type {Array<AttributeRequest>}
     * @memberof ExpansionItem
     */
    'attributeRequests'?: Array<AttributeRequest>;
    /**
     * 
     * @type {AccountSource}
     * @memberof ExpansionItem
     */
    'source'?: AccountSource;
}
/**
 * 
 * @export
 * @interface Expression
 */
export interface Expression {
    /**
     * Operator for the expression
     * @type {string}
     * @memberof Expression
     */
    'operator'?: ExpressionOperatorEnum;
    /**
     * Name for the attribute
     * @type {string}
     * @memberof Expression
     */
    'attribute'?: string;
    /**
     * 
     * @type {Value}
     * @memberof Expression
     */
    'value'?: Value;
    /**
     * List of expressions
     * @type {Array<Value>}
     * @memberof Expression
     */
    'children'?: Array<Value> | null;
}

export const ExpressionOperatorEnum = {
    And: 'AND',
    Equals: 'EQUALS'
} as const;

export type ExpressionOperatorEnum = typeof ExpressionOperatorEnum[keyof typeof ExpressionOperatorEnum];

/**
 * 
 * @export
 * @interface FieldDetailsDto
 */
export interface FieldDetailsDto {
    /**
     * The name of the attribute.
     * @type {string}
     * @memberof FieldDetailsDto
     */
    'name'?: string;
    /**
     * The transform to apply to the field
     * @type {object}
     * @memberof FieldDetailsDto
     */
    'transform'?: object;
    /**
     * Attributes required for the transform
     * @type {object}
     * @memberof FieldDetailsDto
     */
    'attributes'?: object;
    /**
     * Flag indicating whether or not the attribute is required.
     * @type {boolean}
     * @memberof FieldDetailsDto
     */
    'isRequired'?: boolean;
    /**
     * The type of the attribute.
     * @type {string}
     * @memberof FieldDetailsDto
     */
    'type'?: string;
    /**
     * Flag indicating whether or not the attribute is multi-valued.
     * @type {boolean}
     * @memberof FieldDetailsDto
     */
    'isMultiValued'?: boolean;
}
/**
 * 
 * @export
 * @interface Filter
 */
export interface Filter {
    /**
     * 
     * @type {FilterType}
     * @memberof Filter
     */
    'type'?: FilterType;
    /**
     * 
     * @type {Range}
     * @memberof Filter
     */
    'range'?: Range;
    /**
     * The terms to be filtered.
     * @type {Array<string>}
     * @memberof Filter
     */
    'terms'?: Array<string>;
    /**
     * Indicates if the filter excludes results.
     * @type {boolean}
     * @memberof Filter
     */
    'exclude'?: boolean;
}


/**
 * An additional filter to constrain the results of the search query.
 * @export
 * @interface FilterAggregation
 */
export interface FilterAggregation {
    /**
     * The name of the filter aggregate to be included in the result.
     * @type {string}
     * @memberof FilterAggregation
     */
    'name': string;
    /**
     * 
     * @type {SearchFilterType}
     * @memberof FilterAggregation
     */
    'type'?: SearchFilterType;
    /**
     * The search field to apply the filter to.  Prefix the field name with \'@\' to reference a nested object. 
     * @type {string}
     * @memberof FilterAggregation
     */
    'field': string;
    /**
     * The value to filter on.
     * @type {string}
     * @memberof FilterAggregation
     */
    'value': string;
}


/**
 * Enum representing the currently supported filter types. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const FilterType = {
    Exists: 'EXISTS',
    Range: 'RANGE',
    Terms: 'TERMS'
} as const;

export type FilterType = typeof FilterType[keyof typeof FilterType];


/**
 * 
 * @export
 * @interface FirstValid
 */
export interface FirstValid {
    /**
     * An array of attributes to evaluate for existence.
     * @type {Array<object>}
     * @memberof FirstValid
     */
    'values': Array<object>;
    /**
     * a true or false value representing to move on to the next option if an error (like an Null Pointer Exception) were to occur.
     * @type {boolean}
     * @memberof FirstValid
     */
    'ignoreErrors'?: boolean;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof FirstValid
     */
    'requiresPeriodicRefresh'?: boolean;
}
/**
 * 
 * @export
 * @interface FormDetails
 */
export interface FormDetails {
    /**
     * ID of the form
     * @type {string}
     * @memberof FormDetails
     */
    'id'?: string;
    /**
     * Name of the form
     * @type {string}
     * @memberof FormDetails
     */
    'name'?: string;
    /**
     * The form title
     * @type {string}
     * @memberof FormDetails
     */
    'title'?: string;
    /**
     * The form subtitle.
     * @type {string}
     * @memberof FormDetails
     */
    'subtitle'?: string;
    /**
     * The name of the user that should be shown this form
     * @type {string}
     * @memberof FormDetails
     */
    'targetUser'?: string;
    /**
     * 
     * @type {SectionDetails}
     * @memberof FormDetails
     */
    'sections'?: SectionDetails;
}
/**
 * 
 * @export
 * @interface FormItemDetails
 */
export interface FormItemDetails {
    /**
     * Name of the FormItem
     * @type {string}
     * @memberof FormItemDetails
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ForwardApprovalDto
 */
export interface ForwardApprovalDto {
    /**
     * The Id of the new owner
     * @type {string}
     * @memberof ForwardApprovalDto
     */
    'newOwnerId': string;
    /**
     * The comment provided by the forwarder
     * @type {string}
     * @memberof ForwardApprovalDto
     */
    'comment': string;
}
/**
 * 
 * @export
 * @interface GenerateRandomString
 */
export interface GenerateRandomString {
    /**
     * This must always be set to \"Cloud Services Deployment Utility\"
     * @type {string}
     * @memberof GenerateRandomString
     */
    'name': string;
    /**
     * The operation to perform `generateRandomString`
     * @type {string}
     * @memberof GenerateRandomString
     */
    'operation': string;
    /**
     * This must be either \"true\" or \"false\" to indicate whether the generator logic should include numbers
     * @type {boolean}
     * @memberof GenerateRandomString
     */
    'includeNumbers': boolean;
    /**
     * This must be either \"true\" or \"false\" to indicate whether the generator logic should include special characters
     * @type {boolean}
     * @memberof GenerateRandomString
     */
    'includeSpecialChars': boolean;
    /**
     * This specifies how long the randomly generated string needs to be   >NOTE Due to identity attribute data constraints, the maximum allowable value is 450 characters 
     * @type {string}
     * @memberof GenerateRandomString
     */
    'length': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof GenerateRandomString
     */
    'requiresPeriodicRefresh'?: boolean;
}
/**
 * 
 * @export
 * @interface GenericRule
 */
export interface GenericRule {
    /**
     * This is the name of the Generic rule that needs to be invoked by the transform
     * @type {string}
     * @memberof GenericRule
     */
    'name': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof GenericRule
     */
    'requiresPeriodicRefresh'?: boolean;
}
/**
 * @type GetActiveCampaigns200ResponseInner
 * @export
 */
export type GetActiveCampaigns200ResponseInner = Campaign | SlimCampaign;

/**
 * 
 * @export
 * @interface GetOAuthClientResponse
 */
export interface GetOAuthClientResponse {
    /**
     * ID of the OAuth client
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'id': string;
    /**
     * The name of the business the API Client should belong to
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'businessName': string | null;
    /**
     * The homepage URL associated with the owner of the API Client
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'homepageUrl': string | null;
    /**
     * A human-readable name for the API Client
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'name': string;
    /**
     * A description of the API Client
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'description': string | null;
    /**
     * The number of seconds an access token generated for this API Client is valid for
     * @type {number}
     * @memberof GetOAuthClientResponse
     */
    'accessTokenValiditySeconds': number;
    /**
     * The number of seconds a refresh token generated for this API Client is valid for
     * @type {number}
     * @memberof GetOAuthClientResponse
     */
    'refreshTokenValiditySeconds': number;
    /**
     * A list of the approved redirect URIs used with the authorization_code flow
     * @type {Array<string>}
     * @memberof GetOAuthClientResponse
     */
    'redirectUris': Array<string> | null;
    /**
     * A list of OAuth 2.0 grant types this API Client can be used with
     * @type {Array<GrantType>}
     * @memberof GetOAuthClientResponse
     */
    'grantTypes': Array<GrantType>;
    /**
     * 
     * @type {AccessType}
     * @memberof GetOAuthClientResponse
     */
    'accessType': AccessType;
    /**
     * 
     * @type {ClientType}
     * @memberof GetOAuthClientResponse
     */
    'type': ClientType;
    /**
     * An indicator of whether the API Client can be used for requests internal to IDN
     * @type {boolean}
     * @memberof GetOAuthClientResponse
     */
    'internal': boolean;
    /**
     * An indicator of whether the API Client is enabled for use
     * @type {boolean}
     * @memberof GetOAuthClientResponse
     */
    'enabled': boolean;
    /**
     * An indicator of whether the API Client supports strong authentication
     * @type {boolean}
     * @memberof GetOAuthClientResponse
     */
    'strongAuthSupported': boolean;
    /**
     * An indicator of whether the API Client supports the serialization of SAML claims when used with the authorization_code flow
     * @type {boolean}
     * @memberof GetOAuthClientResponse
     */
    'claimsSupported': boolean;
    /**
     * The date and time, down to the millisecond, when the API Client was created
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'created': string;
    /**
     * The date and time, down to the millisecond, when the API Client was last updated
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'modified': string;
    /**
     * The date and time, down to the millisecond, when this API Client was last used to generate an access token. This timestamp does not get updated on every API Client usage, but only once a day. This property can be useful for identifying which API Clients are no longer actively used and can be removed.
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'lastUsed'?: string | null;
    /**
     * Scopes of the API Client.
     * @type {Array<string>}
     * @memberof GetOAuthClientResponse
     */
    'scope': Array<string> | null;
}


/**
 * 
 * @export
 * @interface GetPersonalAccessTokenResponse
 */
export interface GetPersonalAccessTokenResponse {
    /**
     * The ID of the personal access token (to be used as the username for Basic Auth).
     * @type {string}
     * @memberof GetPersonalAccessTokenResponse
     */
    'id': string;
    /**
     * The name of the personal access token. Cannot be the same as other personal access tokens owned by a user.
     * @type {string}
     * @memberof GetPersonalAccessTokenResponse
     */
    'name': string;
    /**
     * Scopes of the personal  access token.
     * @type {Array<string>}
     * @memberof GetPersonalAccessTokenResponse
     */
    'scope': Array<string> | null;
    /**
     * 
     * @type {PatOwner}
     * @memberof GetPersonalAccessTokenResponse
     */
    'owner': PatOwner;
    /**
     * The date and time, down to the millisecond, when this personal access token was created.
     * @type {string}
     * @memberof GetPersonalAccessTokenResponse
     */
    'created': string;
    /**
     * The date and time, down to the millisecond, when this personal access token was last used to generate an access token. This timestamp does not get updated on every PAT usage, but only once a day. This property can be useful for identifying which PATs are no longer actively used and can be removed.
     * @type {string}
     * @memberof GetPersonalAccessTokenResponse
     */
    'lastUsed'?: string | null;
}
/**
 * 
 * @export
 * @interface GetReferenceIdentityAttribute
 */
export interface GetReferenceIdentityAttribute {
    /**
     * This must always be set to \"Cloud Services Deployment Utility\"
     * @type {string}
     * @memberof GetReferenceIdentityAttribute
     */
    'name': string;
    /**
     * The operation to perform `getReferenceIdentityAttribute`
     * @type {string}
     * @memberof GetReferenceIdentityAttribute
     */
    'operation': string;
    /**
     * This is the SailPoint User Name (uid) value of the identity whose attribute is desired  As a convenience feature, you can use the `manager` keyword to dynamically look up the user\'s manager and then get that manager\'s identity attribute. 
     * @type {string}
     * @memberof GetReferenceIdentityAttribute
     */
    'uid': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof GetReferenceIdentityAttribute
     */
    'requiresPeriodicRefresh'?: boolean;
}
/**
 * OAuth2 Grant Type
 * @export
 * @enum {string}
 */

export const GrantType = {
    ClientCredentials: 'CLIENT_CREDENTIALS',
    AuthorizationCode: 'AUTHORIZATION_CODE',
    RefreshToken: 'REFRESH_TOKEN'
} as const;

export type GrantType = typeof GrantType[keyof typeof GrantType];


/**
 * 
 * @export
 * @interface ISO3166
 */
export interface ISO3166 {
    /**
     * An optional value to denote which ISO 3166 format to return. Valid values are:   `alpha2` - Two-character country code (e.g., \"US\"); this is the default value if no format is supplied   `alpha3` - Three-character country code (e.g., \"USA\")   `numeric` - The numeric country code (e.g., \"840\") 
     * @type {string}
     * @memberof ISO3166
     */
    'format'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof ISO3166
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof ISO3166
     */
    'input'?: { [key: string]: any; };
}
/**
 * Arguments for Identities details report (IDENTITIES_DETAILS)
 * @export
 * @interface IdentitiesDetailsReportArguments
 */
export interface IdentitiesDetailsReportArguments {
    /**
     * Boolean FLAG to specify if only correlated identities should be used in report processing
     * @type {boolean}
     * @memberof IdentitiesDetailsReportArguments
     */
    'correlatedOnly': boolean;
    /**
     * Use it to set default s3 bucket where generated report will be saved.  In case this argument is false and \'s3Bucket\' argument is null or absent there will be default s3Bucket assigned to the report.
     * @type {boolean}
     * @memberof IdentitiesDetailsReportArguments
     */
    'defaultS3Bucket': boolean;
    /**
     * If you want to be specific you could use this argument with defaultS3Bucket = false.
     * @type {string}
     * @memberof IdentitiesDetailsReportArguments
     */
    's3Bucket'?: string;
}
/**
 * Arguments for Identities report (IDENTITIES)
 * @export
 * @interface IdentitiesReportArguments
 */
export interface IdentitiesReportArguments {
    /**
     * Boolean FLAG to specify if only correlated identities should be used in report processing
     * @type {boolean}
     * @memberof IdentitiesReportArguments
     */
    'correlatedOnly'?: boolean;
    /**
     * Use it to set default s3 bucket where generated report will be saved.  In case this argument is false and \'s3Bucket\' argument is null or absent there will be default s3Bucket assigned to the report.
     * @type {boolean}
     * @memberof IdentitiesReportArguments
     */
    'defaultS3Bucket': boolean;
    /**
     * If you want to be specific you could use this argument with defaultS3Bucket = false.
     * @type {string}
     * @memberof IdentitiesReportArguments
     */
    's3Bucket'?: string;
}
/**
 * @type IdentityAccess
 * @export
 */
export type IdentityAccess = { type: 'ACCESS_PROFILE' } & AccessProfileSummary | { type: 'ENTITLEMENT' } & AccessProfileEntitlement | { type: 'ROLE' } & AccessProfileRole;

/**
 * 
 * @export
 * @interface IdentityAttribute
 */
export interface IdentityAttribute {
    /**
     * The system (camel-cased) name of the identity attribute to bring in
     * @type {string}
     * @memberof IdentityAttribute
     */
    'name': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof IdentityAttribute
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof IdentityAttribute
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface IdentityAttribute1
 */
export interface IdentityAttribute1 {
    /**
     * The attribute key
     * @type {string}
     * @memberof IdentityAttribute1
     */
    'key'?: string;
    /**
     * Human-readable display name of the attribute
     * @type {string}
     * @memberof IdentityAttribute1
     */
    'name'?: string;
    /**
     * The attribute value
     * @type {string}
     * @memberof IdentityAttribute1
     */
    'value'?: string;
}
/**
 * Defines all the identity attribute mapping configurations. This defines how to generate or collect data for each identity attributes in identity refresh process.
 * @export
 * @interface IdentityAttributeConfig
 */
export interface IdentityAttributeConfig {
    /**
     * The backend will only promote values if the profile/mapping is enabled.
     * @type {boolean}
     * @memberof IdentityAttributeConfig
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<IdentityAttributeTransform>}
     * @memberof IdentityAttributeConfig
     */
    'attributeTransforms'?: Array<IdentityAttributeTransform>;
}
/**
 * Defines a transformation definition for an identity attribute.
 * @export
 * @interface IdentityAttributeTransform
 */
export interface IdentityAttributeTransform {
    /**
     * Name of the identity attribute.
     * @type {string}
     * @memberof IdentityAttributeTransform
     */
    'identityAttributeName'?: string;
    /**
     * 
     * @type {TransformDefinition}
     * @memberof IdentityAttributeTransform
     */
    'transformDefinition'?: TransformDefinition;
}
/**
 * 
 * @export
 * @interface IdentityCertDecisionSummary
 */
export interface IdentityCertDecisionSummary {
    /**
     * Number of entitlement decisions that have been made
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'entitlementDecisionsMade'?: number;
    /**
     * Number of access profile decisions that have been made
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accessProfileDecisionsMade'?: number;
    /**
     * Number of role decisions that have been made
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'roleDecisionsMade'?: number;
    /**
     * Number of account decisions that have been made
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accountDecisionsMade'?: number;
    /**
     * The total number of entitlement decisions on the certification, both complete and incomplete
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'entitlementDecisionsTotal'?: number;
    /**
     * The total number of access profile decisions on the certification, both complete and incomplete
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accessProfileDecisionsTotal'?: number;
    /**
     * The total number of role decisions on the certification, both complete and incomplete
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'roleDecisionsTotal'?: number;
    /**
     * The total number of account decisions on the certification, both complete and incomplete
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accountDecisionsTotal'?: number;
    /**
     * The number of entitlement decisions that have been made which were approved
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'entitlementsApproved'?: number;
    /**
     * The number of entitlement decisions that have been made which were revoked
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'entitlementsRevoked'?: number;
    /**
     * The number of access profile decisions that have been made which were approved
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accessProfilesApproved'?: number;
    /**
     * The number of access profile decisions that have been made which were revoked
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accessProfilesRevoked'?: number;
    /**
     * The number of role decisions that have been made which were approved
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'rolesApproved'?: number;
    /**
     * The number of role decisions that have been made which were revoked
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'rolesRevoked'?: number;
    /**
     * The number of account decisions that have been made which were approved
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accountsApproved'?: number;
    /**
     * The number of account decisions that have been made which were revoked
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accountsRevoked'?: number;
}
/**
 * 
 * @export
 * @interface IdentityCertificationDto
 */
export interface IdentityCertificationDto {
    /**
     * id of the certification
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'id'?: string;
    /**
     * name of the certification
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'name'?: string;
    /**
     * 
     * @type {CampaignReference}
     * @memberof IdentityCertificationDto
     */
    'campaign'?: CampaignReference;
    /**
     * Have all decisions been made?
     * @type {boolean}
     * @memberof IdentityCertificationDto
     */
    'completed'?: boolean;
    /**
     * The number of identities for whom all decisions have been made and are complete.
     * @type {number}
     * @memberof IdentityCertificationDto
     */
    'identitiesCompleted'?: number;
    /**
     * The total number of identities in the Certification, both complete and incomplete.
     * @type {number}
     * @memberof IdentityCertificationDto
     */
    'identitiesTotal'?: number;
    /**
     * created date
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'created'?: string;
    /**
     * modified date
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'modified'?: string;
    /**
     * The number of approve/revoke/acknowledge decisions that have been made.
     * @type {number}
     * @memberof IdentityCertificationDto
     */
    'decisionsMade'?: number;
    /**
     * The total number of approve/revoke/acknowledge decisions.
     * @type {number}
     * @memberof IdentityCertificationDto
     */
    'decisionsTotal'?: number;
    /**
     * The due date of the certification.
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'due'?: string;
    /**
     * The date the reviewer signed off on the Certification.
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'signed'?: string | null;
    /**
     * 
     * @type {Reviewer}
     * @memberof IdentityCertificationDto
     */
    'reviewer'?: Reviewer;
    /**
     * 
     * @type {Reassignment}
     * @memberof IdentityCertificationDto
     */
    'reassignment'?: Reassignment | null;
    /**
     * Identifies if the certification has an error
     * @type {boolean}
     * @memberof IdentityCertificationDto
     */
    'hasErrors'?: boolean;
    /**
     * Description of the certification error
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'errorMessage'?: string | null;
    /**
     * 
     * @type {CertificationPhase}
     * @memberof IdentityCertificationDto
     */
    'phase'?: CertificationPhase;
}


/**
 * Identity
 * @export
 * @interface IdentityDocument
 */
export interface IdentityDocument {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof IdentityDocument
     */
    'id': string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof IdentityDocument
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof IdentityDocument
     */
    '_type': DocumentType;
    /**
     * The display name of the identity
     * @type {string}
     * @memberof IdentityDocument
     */
    'displayName'?: string;
    /**
     * The first name of the identity
     * @type {string}
     * @memberof IdentityDocument
     */
    'firstName'?: string;
    /**
     * The last name of the identity
     * @type {string}
     * @memberof IdentityDocument
     */
    'lastName'?: string;
    /**
     * The identity\'s primary email address
     * @type {string}
     * @memberof IdentityDocument
     */
    'email'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof IdentityDocument
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof IdentityDocument
     */
    'modified'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof IdentityDocument
     */
    'synced'?: string | null;
    /**
     * The phone number of the identity
     * @type {string}
     * @memberof IdentityDocument
     */
    'phone'?: string;
    /**
     * Indicates if the identity is inactive
     * @type {boolean}
     * @memberof IdentityDocument
     */
    'inactive'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IdentityDocument
     */
    'protected'?: boolean;
    /**
     * The identity\'s status in SailPoint
     * @type {string}
     * @memberof IdentityDocument
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityDocument
     */
    'employeeNumber'?: string;
    /**
     * 
     * @type {DisplayReference}
     * @memberof IdentityDocument
     */
    'manager'?: DisplayReference;
    /**
     * Indicates if this identity is a manager of other identities
     * @type {boolean}
     * @memberof IdentityDocument
     */
    'isManager'?: boolean;
    /**
     * 
     * @type {Reference1}
     * @memberof IdentityDocument
     */
    'identityProfile'?: Reference1;
    /**
     * 
     * @type {Reference1}
     * @memberof IdentityDocument
     */
    'source'?: Reference1;
    /**
     * a map or dictionary of key/value pairs
     * @type {{ [key: string]: any; }}
     * @memberof IdentityDocument
     */
    'attributes'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof IdentityDocument
     */
    'processingState'?: string | null;
    /**
     * 
     * @type {ProcessingDetails}
     * @memberof IdentityDocument
     */
    'processingDetails'?: ProcessingDetails;
    /**
     * List of accounts associated with the identity
     * @type {Array<BaseAccount>}
     * @memberof IdentityDocument
     */
    'accounts'?: Array<BaseAccount>;
    /**
     * Number of accounts associated with the identity
     * @type {number}
     * @memberof IdentityDocument
     */
    'accountCount'?: number;
    /**
     * The list of applications the identity has access to
     * @type {Array<App>}
     * @memberof IdentityDocument
     */
    'apps'?: Array<App>;
    /**
     * The number of applications the identity has access to
     * @type {number}
     * @memberof IdentityDocument
     */
    'appCount'?: number;
    /**
     * The list of access items assigned to the identity
     * @type {Array<IdentityAccess>}
     * @memberof IdentityDocument
     */
    'access'?: Array<IdentityAccess>;
    /**
     * The number of access items assigned to the identity
     * @type {number}
     * @memberof IdentityDocument
     */
    'accessCount'?: number;
    /**
     * The number of access profiles assigned to the identity
     * @type {number}
     * @memberof IdentityDocument
     */
    'accessProfileCount'?: number;
    /**
     * The number of entitlements assigned to the identity
     * @type {number}
     * @memberof IdentityDocument
     */
    'entitlementCount'?: number;
    /**
     * The number of roles assigned to the identity
     * @type {number}
     * @memberof IdentityDocument
     */
    'roleCount'?: number;
    /**
     * 
     * @type {Owns}
     * @memberof IdentityDocument
     */
    'owns'?: Owns;
    /**
     * 
     * @type {Array<string>}
     * @memberof IdentityDocument
     */
    'tags'?: Array<string>;
}


/**
 * 
 * @export
 * @interface IdentityExceptionReportReference
 */
export interface IdentityExceptionReportReference {
    /**
     * The id of the task result.
     * @type {string}
     * @memberof IdentityExceptionReportReference
     */
    'taskResultId'?: string;
    /**
     * The name of the report.
     * @type {string}
     * @memberof IdentityExceptionReportReference
     */
    'reportName'?: string;
}
/**
 * 
 * @export
 * @interface IdentityProfile
 */
export interface IdentityProfile {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof IdentityProfile
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof IdentityProfile
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof IdentityProfile
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof IdentityProfile
     */
    'modified'?: string;
    /**
     * The description of the Identity Profile.
     * @type {string}
     * @memberof IdentityProfile
     */
    'description'?: string | null;
    /**
     * 
     * @type {IdentityProfileAllOfOwner}
     * @memberof IdentityProfile
     */
    'owner'?: IdentityProfileAllOfOwner | null;
    /**
     * The priority for an Identity Profile.
     * @type {number}
     * @memberof IdentityProfile
     */
    'priority'?: number;
    /**
     * 
     * @type {IdentityProfileAllOfAuthoritativeSource}
     * @memberof IdentityProfile
     */
    'authoritativeSource': IdentityProfileAllOfAuthoritativeSource;
    /**
     * True if a identity refresh is needed. Typically triggered when a change on the source has been made.
     * @type {boolean}
     * @memberof IdentityProfile
     */
    'identityRefreshRequired'?: boolean;
    /**
     * The number of identities that belong to the Identity Profile.
     * @type {number}
     * @memberof IdentityProfile
     */
    'identityCount'?: number;
    /**
     * 
     * @type {IdentityAttributeConfig}
     * @memberof IdentityProfile
     */
    'identityAttributeConfig'?: IdentityAttributeConfig;
    /**
     * 
     * @type {IdentityExceptionReportReference}
     * @memberof IdentityProfile
     */
    'identityExceptionReportReference'?: IdentityExceptionReportReference | null;
    /**
     * Indicates the value of requiresPeriodicRefresh attribute for the Identity Profile.
     * @type {boolean}
     * @memberof IdentityProfile
     */
    'hasTimeBasedAttr'?: boolean;
}
/**
 * 
 * @export
 * @interface IdentityProfileAllOfAuthoritativeSource
 */
export interface IdentityProfileAllOfAuthoritativeSource {
    /**
     * Type of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfileAllOfAuthoritativeSource
     */
    'type'?: IdentityProfileAllOfAuthoritativeSourceTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfileAllOfAuthoritativeSource
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfileAllOfAuthoritativeSource
     */
    'name'?: string;
}

export const IdentityProfileAllOfAuthoritativeSourceTypeEnum = {
    Source: 'SOURCE'
} as const;

export type IdentityProfileAllOfAuthoritativeSourceTypeEnum = typeof IdentityProfileAllOfAuthoritativeSourceTypeEnum[keyof typeof IdentityProfileAllOfAuthoritativeSourceTypeEnum];

/**
 * The owner of the Identity Profile.
 * @export
 * @interface IdentityProfileAllOfOwner
 */
export interface IdentityProfileAllOfOwner {
    /**
     * Type of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfileAllOfOwner
     */
    'type'?: IdentityProfileAllOfOwnerTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfileAllOfOwner
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfileAllOfOwner
     */
    'name'?: string;
}

export const IdentityProfileAllOfOwnerTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type IdentityProfileAllOfOwnerTypeEnum = typeof IdentityProfileAllOfOwnerTypeEnum[keyof typeof IdentityProfileAllOfOwnerTypeEnum];

/**
 * Identity profile exported object.
 * @export
 * @interface IdentityProfileExportedObject
 */
export interface IdentityProfileExportedObject {
    /**
     * Version or object from the target service.
     * @type {number}
     * @memberof IdentityProfileExportedObject
     */
    'version'?: number;
    /**
     * 
     * @type {IdentityProfileExportedObjectSelf}
     * @memberof IdentityProfileExportedObject
     */
    'self'?: IdentityProfileExportedObjectSelf;
    /**
     * 
     * @type {IdentityProfile}
     * @memberof IdentityProfileExportedObject
     */
    'object'?: IdentityProfile;
}
/**
 * Self block for exported object.
 * @export
 * @interface IdentityProfileExportedObjectSelf
 */
export interface IdentityProfileExportedObjectSelf {
    /**
     * Exported object\'s DTO type.
     * @type {string}
     * @memberof IdentityProfileExportedObjectSelf
     */
    'type'?: IdentityProfileExportedObjectSelfTypeEnum;
    /**
     * Exported object\'s ID.
     * @type {string}
     * @memberof IdentityProfileExportedObjectSelf
     */
    'id'?: string;
    /**
     * Exported object\'s display name.
     * @type {string}
     * @memberof IdentityProfileExportedObjectSelf
     */
    'name'?: string;
}

export const IdentityProfileExportedObjectSelfTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    AccessRequestConfig: 'ACCESS_REQUEST_CONFIG',
    AttrSyncSourceConfig: 'ATTR_SYNC_SOURCE_CONFIG',
    AuthOrg: 'AUTH_ORG',
    CampaignFilter: 'CAMPAIGN_FILTER',
    FormDefinition: 'FORM_DEFINITION',
    GovernanceGroup: 'GOVERNANCE_GROUP',
    IdentityObjectConfig: 'IDENTITY_OBJECT_CONFIG',
    IdentityProfile: 'IDENTITY_PROFILE',
    LifecycleState: 'LIFECYCLE_STATE',
    NotificationTemplate: 'NOTIFICATION_TEMPLATE',
    PasswordPolicy: 'PASSWORD_POLICY',
    PasswordSyncGroup: 'PASSWORD_SYNC_GROUP',
    PublicIdentitiesConfig: 'PUBLIC_IDENTITIES_CONFIG',
    Role: 'ROLE',
    Rule: 'RULE',
    Segment: 'SEGMENT',
    ServiceDeskIntegration: 'SERVICE_DESK_INTEGRATION',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE',
    Tag: 'TAG',
    Transform: 'TRANSFORM',
    TriggerSubscription: 'TRIGGER_SUBSCRIPTION',
    Workflow: 'WORKFLOW'
} as const;

export type IdentityProfileExportedObjectSelfTypeEnum = typeof IdentityProfileExportedObjectSelfTypeEnum[keyof typeof IdentityProfileExportedObjectSelfTypeEnum];

/**
 * Arguments for Identity Profile Identity Error report (IDENTITY_PROFILE_IDENTITY_ERROR)
 * @export
 * @interface IdentityProfileIdentityErrorReportArguments
 */
export interface IdentityProfileIdentityErrorReportArguments {
    /**
     * Source Id to be checked on errors of identity profiles aggregation
     * @type {string}
     * @memberof IdentityProfileIdentityErrorReportArguments
     */
    'authoritativeSource': string;
    /**
     * Use it to set default s3 bucket where generated report will be saved.  In case this argument is false and \'s3Bucket\' argument is null or absent there will be default s3Bucket assigned to the report.
     * @type {boolean}
     * @memberof IdentityProfileIdentityErrorReportArguments
     */
    'defaultS3Bucket': boolean;
    /**
     * If you want to be specific you could use this argument with defaultS3Bucket = false.
     * @type {string}
     * @memberof IdentityProfileIdentityErrorReportArguments
     */
    's3Bucket'?: string;
}
/**
 * The manager for the identity.
 * @export
 * @interface IdentityReference
 */
export interface IdentityReference {
    /**
     * 
     * @type {DtoType}
     * @memberof IdentityReference
     */
    'type'?: DtoType;
    /**
     * Identity id
     * @type {string}
     * @memberof IdentityReference
     */
    'id'?: string;
    /**
     * Human-readable display name of identity.
     * @type {string}
     * @memberof IdentityReference
     */
    'name'?: string;
}


/**
 * 
 * @export
 * @interface IdentityReferenceWithNameAndEmail
 */
export interface IdentityReferenceWithNameAndEmail {
    /**
     * The type can only be IDENTITY. This is read-only
     * @type {string}
     * @memberof IdentityReferenceWithNameAndEmail
     */
    'type'?: string;
    /**
     * Identity id.
     * @type {string}
     * @memberof IdentityReferenceWithNameAndEmail
     */
    'id'?: string;
    /**
     * Human-readable display name of identity. This is read-only
     * @type {string}
     * @memberof IdentityReferenceWithNameAndEmail
     */
    'name'?: string;
    /**
     * Email address of identity. This is read-only
     * @type {string}
     * @memberof IdentityReferenceWithNameAndEmail
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface IdentitySummary
 */
export interface IdentitySummary {
    /**
     * ID of this identity summary
     * @type {string}
     * @memberof IdentitySummary
     */
    'id'?: string;
    /**
     * Human-readable display name of identity
     * @type {string}
     * @memberof IdentitySummary
     */
    'name'?: string;
    /**
     * ID of the identity that this summary represents
     * @type {string}
     * @memberof IdentitySummary
     */
    'identityId'?: string;
    /**
     * Indicates if all access items for this summary have been decided on
     * @type {boolean}
     * @memberof IdentitySummary
     */
    'completed'?: boolean;
}
/**
 * An identity with a set of access to be added
 * @export
 * @interface IdentityWithNewAccess
 */
export interface IdentityWithNewAccess {
    /**
     * Identity id to be checked.
     * @type {string}
     * @memberof IdentityWithNewAccess
     */
    'identityId': string;
    /**
     * The list of entitlements to consider for possible violations in a preventive check.
     * @type {Array<IdentityWithNewAccessAccessRefsInner>}
     * @memberof IdentityWithNewAccess
     */
    'accessRefs': Array<IdentityWithNewAccessAccessRefsInner>;
}
/**
 * An identity with a set of access to be added
 * @export
 * @interface IdentityWithNewAccess1
 */
export interface IdentityWithNewAccess1 {
    /**
     * Set of identity IDs to be checked.
     * @type {string}
     * @memberof IdentityWithNewAccess1
     */
    'identityId': string;
    /**
     * The bundle of access profiles to be added to the identities specified. All references must be ENTITLEMENT type.
     * @type {Array<EntitlementRef>}
     * @memberof IdentityWithNewAccess1
     */
    'accessRefs': Array<EntitlementRef>;
    /**
     * Arbitrary key-value pairs. They will never be processed by the IdentityNow system but will be returned on completion of the violation check.
     * @type {{ [key: string]: string; }}
     * @memberof IdentityWithNewAccess1
     */
    'clientMetadata'?: { [key: string]: string; };
}
/**
 * Entitlement including a specific set of access.
 * @export
 * @interface IdentityWithNewAccessAccessRefsInner
 */
export interface IdentityWithNewAccessAccessRefsInner {
    /**
     * Entitlement\'s DTO type.
     * @type {string}
     * @memberof IdentityWithNewAccessAccessRefsInner
     */
    'type'?: IdentityWithNewAccessAccessRefsInnerTypeEnum;
    /**
     * Entitlement\'s ID.
     * @type {string}
     * @memberof IdentityWithNewAccessAccessRefsInner
     */
    'id'?: string;
    /**
     * Entitlement\'s display name.
     * @type {string}
     * @memberof IdentityWithNewAccessAccessRefsInner
     */
    'name'?: string;
}

export const IdentityWithNewAccessAccessRefsInnerTypeEnum = {
    Entitlement: 'ENTITLEMENT'
} as const;

export type IdentityWithNewAccessAccessRefsInnerTypeEnum = typeof IdentityWithNewAccessAccessRefsInnerTypeEnum[keyof typeof IdentityWithNewAccessAccessRefsInnerTypeEnum];

/**
 * 
 * @export
 * @interface ImportNonEmployeeRecordsInBulkRequest
 */
export interface ImportNonEmployeeRecordsInBulkRequest {
    /**
     * 
     * @type {File}
     * @memberof ImportNonEmployeeRecordsInBulkRequest
     */
    'data': File;
}
/**
 * Object created or updated by import.
 * @export
 * @interface ImportObject
 */
export interface ImportObject {
    /**
     * DTO type of object created or updated by import.
     * @type {string}
     * @memberof ImportObject
     */
    'type'?: ImportObjectTypeEnum;
    /**
     * ID of object created or updated by import.
     * @type {string}
     * @memberof ImportObject
     */
    'id'?: string;
    /**
     * Display name of object created or updated by import.
     * @type {string}
     * @memberof ImportObject
     */
    'name'?: string;
}

export const ImportObjectTypeEnum = {
    IdentityObjectConfig: 'IDENTITY_OBJECT_CONFIG',
    IdentityProfile: 'IDENTITY_PROFILE',
    Rule: 'RULE',
    Source: 'SOURCE',
    Transform: 'TRANSFORM',
    TriggerSubscription: 'TRIGGER_SUBSCRIPTION'
} as const;

export type ImportObjectTypeEnum = typeof ImportObjectTypeEnum[keyof typeof ImportObjectTypeEnum];

/**
 * Enum representing the currently supported indices. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const Index = {
    Accessprofiles: 'accessprofiles',
    Accountactivities: 'accountactivities',
    Entitlements: 'entitlements',
    Events: 'events',
    Identities: 'identities',
    Roles: 'roles',
    Star: '*'
} as const;

export type Index = typeof Index[keyof typeof Index];


/**
 * 
 * @export
 * @interface IndexOf
 */
export interface IndexOf {
    /**
     * A substring to search for, searches the entire calling string, and returns the index of the first occurrence of the specified substring.
     * @type {string}
     * @memberof IndexOf
     */
    'substring': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof IndexOf
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof IndexOf
     */
    'input'?: { [key: string]: any; };
}
/**
 * Inner Hit query object that will cause the specified nested type to be returned as the result matching the supplied query.
 * @export
 * @interface InnerHit
 */
export interface InnerHit {
    /**
     * The search query using the Elasticsearch [Query String Query](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/query-dsl-query-string-query.html#query-string) syntax from the Query DSL extended by SailPoint to support Nested queries.
     * @type {string}
     * @memberof InnerHit
     */
    'query': string;
    /**
     * The nested type to use in the inner hits query.  The nested type [Nested Type](https://www.elastic.co/guide/en/elasticsearch/reference/current/nested.html) refers to a document \"nested\" within another document. For example, an identity can have nested documents for access, accounts, and apps.
     * @type {string}
     * @memberof InnerHit
     */
    'type': string;
}
/**
 * A JSONPatch document as defined by [RFC 6902 - JSON Patch](https://tools.ietf.org/html/rfc6902)
 * @export
 * @interface JsonPatch
 */
export interface JsonPatch {
    /**
     * Operations to be applied
     * @type {Array<JsonPatchOperation>}
     * @memberof JsonPatch
     */
    'operations'?: Array<JsonPatchOperation>;
}
/**
 * A JSONPatch Operation as defined by [RFC 6902 - JSON Patch](https://tools.ietf.org/html/rfc6902)
 * @export
 * @interface JsonPatchOperation
 */
export interface JsonPatchOperation {
    /**
     * The operation to be performed
     * @type {string}
     * @memberof JsonPatchOperation
     */
    'op': JsonPatchOperationOpEnum;
    /**
     * A string JSON Pointer representing the target path to an element to be affected by the operation
     * @type {string}
     * @memberof JsonPatchOperation
     */
    'path': string;
    /**
     * 
     * @type {JsonPatchOperationValue}
     * @memberof JsonPatchOperation
     */
    'value'?: JsonPatchOperationValue;
}

export const JsonPatchOperationOpEnum = {
    Add: 'add',
    Remove: 'remove',
    Replace: 'replace',
    Move: 'move',
    Copy: 'copy',
    Test: 'test'
} as const;

export type JsonPatchOperationOpEnum = typeof JsonPatchOperationOpEnum[keyof typeof JsonPatchOperationOpEnum];

/**
 * @type JsonPatchOperationValue
 * The value to be used for the operation, required for \"add\" and \"replace\" operations
 * @export
 */
export type JsonPatchOperationValue = Array<ArrayInner> | number | object | string;

/**
 * 
 * @export
 * @interface LeftPad
 */
export interface LeftPad {
    /**
     * An integer value for the desired length of the final output string
     * @type {string}
     * @memberof LeftPad
     */
    'length': string;
    /**
     * A string value representing the character that the incoming data should be padded with to get to the desired length   If not provided, the transform will default to a single space (\" \") character for padding 
     * @type {string}
     * @memberof LeftPad
     */
    'padding'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof LeftPad
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof LeftPad
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface LifecycleState
 */
export interface LifecycleState {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof LifecycleState
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof LifecycleState
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof LifecycleState
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof LifecycleState
     */
    'modified'?: string;
    /**
     * Whether the lifecycle state is enabled or disabled.
     * @type {boolean}
     * @memberof LifecycleState
     */
    'enabled'?: boolean;
    /**
     * The technical name for lifecycle state. This is for internal use.
     * @type {string}
     * @memberof LifecycleState
     */
    'technicalName': string;
    /**
     * Lifecycle state description.
     * @type {string}
     * @memberof LifecycleState
     */
    'description'?: string;
    /**
     * Number of identities that have the lifecycle state.
     * @type {number}
     * @memberof LifecycleState
     */
    'identityCount'?: number;
    /**
     * 
     * @type {EmailNotificationOption}
     * @memberof LifecycleState
     */
    'emailNotificationOption'?: EmailNotificationOption;
    /**
     * 
     * @type {Array<AccountAction>}
     * @memberof LifecycleState
     */
    'accountActions'?: Array<AccountAction>;
    /**
     * List of unique access-profile IDs that are associated with the lifecycle state.
     * @type {Set<string>}
     * @memberof LifecycleState
     */
    'accessProfileIds'?: Set<string>;
}
/**
 * Deleted lifecycle state.
 * @export
 * @interface LifecyclestateDeleted
 */
export interface LifecyclestateDeleted {
    /**
     * Deleted lifecycle state\'s DTO type.
     * @type {string}
     * @memberof LifecyclestateDeleted
     */
    'type'?: LifecyclestateDeletedTypeEnum;
    /**
     * Deleted lifecycle state ID.
     * @type {string}
     * @memberof LifecyclestateDeleted
     */
    'id'?: string;
    /**
     * Deleted lifecycle state\'s display name.
     * @type {string}
     * @memberof LifecyclestateDeleted
     */
    'name'?: string;
}

export const LifecyclestateDeletedTypeEnum = {
    LifecycleState: 'LIFECYCLE_STATE'
} as const;

export type LifecyclestateDeletedTypeEnum = typeof LifecyclestateDeletedTypeEnum[keyof typeof LifecyclestateDeletedTypeEnum];

/**
 * 
 * @export
 * @interface ListAccessProfiles401Response
 */
export interface ListAccessProfiles401Response {
    /**
     * A message describing the error
     * @type {object}
     * @memberof ListAccessProfiles401Response
     */
    'error'?: object;
}
/**
 * 
 * @export
 * @interface ListAccessProfiles429Response
 */
export interface ListAccessProfiles429Response {
    /**
     * A message describing the error
     * @type {object}
     * @memberof ListAccessProfiles429Response
     */
    'message'?: object;
}
/**
 * An indicator of how the locale was selected. *DEFAULT* means the locale is the system default. *REQUEST* means the locale was selected from the request context (i.e., best match based on the *Accept-Language* header). Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const LocaleOrigin = {
    Default: 'DEFAULT',
    Request: 'REQUEST'
} as const;

export type LocaleOrigin = typeof LocaleOrigin[keyof typeof LocaleOrigin];


/**
 * 
 * @export
 * @interface Lookup
 */
export interface Lookup {
    /**
     * This is a JSON object of key-value pairs. The key is the string that will attempt to be matched to the input, and the value is the output string that should be returned if the key is matched   >**Note** the use of the optional default key value here; if none of the three countries in the above example match the input string, the transform will return \"Unknown Region\" for the attribute that is mapped to this transform. 
     * @type {{ [key: string]: any; }}
     * @memberof Lookup
     */
    'table': { [key: string]: any; };
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Lookup
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Lookup
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Lower
 */
export interface Lower {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Lower
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Lower
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ManagerCorrelationMapping
 */
export interface ManagerCorrelationMapping {
    /**
     * Name of the attribute to use for manager correlation. The value found on the account attribute will be used to lookup the manager\'s identity.
     * @type {string}
     * @memberof ManagerCorrelationMapping
     */
    'accountAttribute'?: string;
    /**
     * Name of the identity attribute to search when trying to find a manager using the value from the accountAttribute.
     * @type {string}
     * @memberof ManagerCorrelationMapping
     */
    'identityAttribute'?: string;
}
/**
 * 
 * @export
 * @interface ManualWorkItemDetails
 */
export interface ManualWorkItemDetails {
    /**
     * True if the request for this item was forwarded from one owner to another.
     * @type {boolean}
     * @memberof ManualWorkItemDetails
     */
    'forwarded'?: boolean;
    /**
     * 
     * @type {ManualWorkItemDetailsOriginalOwner}
     * @memberof ManualWorkItemDetails
     */
    'originalOwner'?: ManualWorkItemDetailsOriginalOwner;
    /**
     * 
     * @type {ManualWorkItemDetailsCurrentOwner}
     * @memberof ManualWorkItemDetails
     */
    'currentOwner'?: ManualWorkItemDetailsCurrentOwner;
    /**
     * Time at which item was modified.
     * @type {string}
     * @memberof ManualWorkItemDetails
     */
    'modified'?: string;
    /**
     * 
     * @type {ManualWorkItemState}
     * @memberof ManualWorkItemDetails
     */
    'status'?: ManualWorkItemState;
    /**
     * The history of approval forward action.
     * @type {Array<ApprovalForwardHistory>}
     * @memberof ManualWorkItemDetails
     */
    'forwardHistory'?: Array<ApprovalForwardHistory>;
}


/**
 * Identity of current work item owner.
 * @export
 * @interface ManualWorkItemDetailsCurrentOwner
 */
export interface ManualWorkItemDetailsCurrentOwner {
    /**
     * DTO type of current work item owner\'s identity.
     * @type {string}
     * @memberof ManualWorkItemDetailsCurrentOwner
     */
    'type'?: ManualWorkItemDetailsCurrentOwnerTypeEnum;
    /**
     * ID of current work item owner\'s identity.
     * @type {string}
     * @memberof ManualWorkItemDetailsCurrentOwner
     */
    'id'?: string;
    /**
     * Display name of current work item owner.
     * @type {string}
     * @memberof ManualWorkItemDetailsCurrentOwner
     */
    'name'?: string;
}

export const ManualWorkItemDetailsCurrentOwnerTypeEnum = {
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY'
} as const;

export type ManualWorkItemDetailsCurrentOwnerTypeEnum = typeof ManualWorkItemDetailsCurrentOwnerTypeEnum[keyof typeof ManualWorkItemDetailsCurrentOwnerTypeEnum];

/**
 * Identity of original work item owner, if the work item has been forwarded.
 * @export
 * @interface ManualWorkItemDetailsOriginalOwner
 */
export interface ManualWorkItemDetailsOriginalOwner {
    /**
     * DTO type of original work item owner\'s identity.
     * @type {string}
     * @memberof ManualWorkItemDetailsOriginalOwner
     */
    'type'?: ManualWorkItemDetailsOriginalOwnerTypeEnum;
    /**
     * ID of original work item owner\'s identity.
     * @type {string}
     * @memberof ManualWorkItemDetailsOriginalOwner
     */
    'id'?: string;
    /**
     * Display name of original work item owner.
     * @type {string}
     * @memberof ManualWorkItemDetailsOriginalOwner
     */
    'name'?: string;
}

export const ManualWorkItemDetailsOriginalOwnerTypeEnum = {
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY'
} as const;

export type ManualWorkItemDetailsOriginalOwnerTypeEnum = typeof ManualWorkItemDetailsOriginalOwnerTypeEnum[keyof typeof ManualWorkItemDetailsOriginalOwnerTypeEnum];

/**
 * Indicates the state of the request processing for this item: * PENDING: The request for this item is awaiting processing. * APPROVED: The request for this item has been approved. * REJECTED: The request for this item was rejected. * EXPIRED: The request for this item expired with no action taken. * CANCELLED: The request for this item was cancelled with no user action. * ARCHIVED: The request for this item has been archived after completion.
 * @export
 * @enum {string}
 */

export const ManualWorkItemState = {
    Pending: 'PENDING',
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    Expired: 'EXPIRED',
    Cancelled: 'CANCELLED',
    Archived: 'ARCHIVED'
} as const;

export type ManualWorkItemState = typeof ManualWorkItemState[keyof typeof ManualWorkItemState];


/**
 * The calculation done on the results of the query
 * @export
 * @interface MetricAggregation
 */
export interface MetricAggregation {
    /**
     * The name of the metric aggregate to be included in the result. If the metric aggregation is omitted, the resulting aggregation will be a count of the documents in the search results.
     * @type {string}
     * @memberof MetricAggregation
     */
    'name': string;
    /**
     * 
     * @type {MetricType}
     * @memberof MetricAggregation
     */
    'type'?: MetricType;
    /**
     * The field the calculation is performed on.  Prefix the field name with \'@\' to reference a nested object. 
     * @type {string}
     * @memberof MetricAggregation
     */
    'field': string;
}


/**
 * Enum representing the currently supported metric aggregation types. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const MetricType = {
    Count: 'COUNT',
    UniqueCount: 'UNIQUE_COUNT',
    Avg: 'AVG',
    Sum: 'SUM',
    Median: 'MEDIAN',
    Min: 'MIN',
    Max: 'MAX'
} as const;

export type MetricType = typeof MetricType[keyof typeof MetricType];


/**
 * 
 * @export
 * @interface MultiPolicyRequest
 */
export interface MultiPolicyRequest {
    /**
     * Multi-policy report will be run for this list of ids
     * @type {Array<string>}
     * @memberof MultiPolicyRequest
     */
    'filteredPolicyList'?: Array<string>;
}
/**
 * 
 * @export
 * @interface NameNormalizer
 */
export interface NameNormalizer {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof NameNormalizer
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof NameNormalizer
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface NameType
 */
export interface NameType {
    /**
     * the actor or target name
     * @type {string}
     * @memberof NameType
     */
    'name'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof NameType
     */
    'type'?: DtoType;
}


/**
 * | Construct       | Date Time Pattern | Description | | ---------       | ----------------- | ----------- | | ISO8601         | `yyyy-MM-dd\'T\'HH:mm:ss.SSSX` | The ISO8601 standard. |           | LDAP            | `yyyyMMddHHmmss.Z`           | The LDAP standard.    | | PEOPLE_SOFT     | `MM/dd/yyyy`                 | The date format People Soft uses. | | EPOCH_TIME_JAVA | # ms from midnight, January 1st, 1970 | The incoming date value as elapsed time in milliseconds from midnight, January 1st, 1970. | | EPOCH_TIME_WIN32| # intervals of 100ns from midnight, January 1st, 1601 | The incoming date value as elapsed time in 100-nanosecond intervals from midnight, January 1st, 1601. | 
 * @export
 * @enum {string}
 */

export const NamedConstructs = {
    Iso8601: 'ISO8601',
    Ldap: 'LDAP',
    PeopleSoft: 'PEOPLE_SOFT',
    EpochTimeJava: 'EPOCH_TIME_JAVA',
    EpochTimeWin32: 'EPOCH_TIME_WIN32'
} as const;

export type NamedConstructs = typeof NamedConstructs[keyof typeof NamedConstructs];


/**
 * The nested aggregation object.
 * @export
 * @interface NestedAggregation
 */
export interface NestedAggregation {
    /**
     * The name of the nested aggregate to be included in the result.
     * @type {string}
     * @memberof NestedAggregation
     */
    'name': string;
    /**
     * The type of the nested object.
     * @type {string}
     * @memberof NestedAggregation
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface NetworkConfiguration
 */
export interface NetworkConfiguration {
    /**
     * The collection of ip ranges.
     * @type {Array<string>}
     * @memberof NetworkConfiguration
     */
    'range'?: Array<string>;
    /**
     * The collection of country codes.
     * @type {Array<string>}
     * @memberof NetworkConfiguration
     */
    'geolocation'?: Array<string>;
    /**
     * Denotes whether the provided lists are whitelisted or blacklisted for geo location.
     * @type {boolean}
     * @memberof NetworkConfiguration
     */
    'whitelisted'?: boolean;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalDecision
 */
export interface NonEmployeeApprovalDecision {
    /**
     * Comment on the approval item.
     * @type {string}
     * @memberof NonEmployeeApprovalDecision
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalItem
 */
export interface NonEmployeeApprovalItem {
    /**
     * Non-Employee approval item id
     * @type {string}
     * @memberof NonEmployeeApprovalItem
     */
    'id'?: string;
    /**
     * 
     * @type {NonEmployeeIdentityReferenceWithId}
     * @memberof NonEmployeeApprovalItem
     */
    'approver'?: NonEmployeeIdentityReferenceWithId;
    /**
     * Requested identity account name
     * @type {string}
     * @memberof NonEmployeeApprovalItem
     */
    'accountName'?: string;
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof NonEmployeeApprovalItem
     */
    'approvalStatus'?: ApprovalStatus;
    /**
     * Approval order
     * @type {number}
     * @memberof NonEmployeeApprovalItem
     */
    'approvalOrder'?: number;
    /**
     * comment of approver
     * @type {string}
     * @memberof NonEmployeeApprovalItem
     */
    'comment'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeApprovalItem
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeApprovalItem
     */
    'created'?: string;
    /**
     * 
     * @type {NonEmployeeRequestLite}
     * @memberof NonEmployeeApprovalItem
     */
    'nonEmployeeRequest'?: NonEmployeeRequestLite;
}


/**
 * 
 * @export
 * @interface NonEmployeeApprovalItemBase
 */
export interface NonEmployeeApprovalItemBase {
    /**
     * Non-Employee approval item id
     * @type {string}
     * @memberof NonEmployeeApprovalItemBase
     */
    'id'?: string;
    /**
     * 
     * @type {NonEmployeeIdentityReferenceWithId}
     * @memberof NonEmployeeApprovalItemBase
     */
    'approver'?: NonEmployeeIdentityReferenceWithId;
    /**
     * Requested identity account name
     * @type {string}
     * @memberof NonEmployeeApprovalItemBase
     */
    'accountName'?: string;
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof NonEmployeeApprovalItemBase
     */
    'approvalStatus'?: ApprovalStatus;
    /**
     * Approval order
     * @type {number}
     * @memberof NonEmployeeApprovalItemBase
     */
    'approvalOrder'?: number;
    /**
     * comment of approver
     * @type {string}
     * @memberof NonEmployeeApprovalItemBase
     */
    'comment'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeApprovalItemBase
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeApprovalItemBase
     */
    'created'?: string;
}


/**
 * 
 * @export
 * @interface NonEmployeeApprovalItemDetail
 */
export interface NonEmployeeApprovalItemDetail {
    /**
     * Non-Employee approval item id
     * @type {string}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'id'?: string;
    /**
     * 
     * @type {NonEmployeeIdentityReferenceWithId}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'approver'?: NonEmployeeIdentityReferenceWithId;
    /**
     * Requested identity account name
     * @type {string}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'accountName'?: string;
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'approvalStatus'?: ApprovalStatus;
    /**
     * Approval order
     * @type {number}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'approvalOrder'?: number;
    /**
     * comment of approver
     * @type {string}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'comment'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'created'?: string;
    /**
     * 
     * @type {NonEmployeeRequestWithoutApprovalItem}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'nonEmployeeRequest'?: NonEmployeeRequestWithoutApprovalItem;
}


/**
 * 
 * @export
 * @interface NonEmployeeApprovalSummary
 */
export interface NonEmployeeApprovalSummary {
    /**
     * The number of approved non-employee approval requests.
     * @type {number}
     * @memberof NonEmployeeApprovalSummary
     */
    'approved'?: number;
    /**
     * The number of pending non-employee approval requests.
     * @type {number}
     * @memberof NonEmployeeApprovalSummary
     */
    'pending'?: number;
    /**
     * The number of rejected non-employee approval requests.
     * @type {number}
     * @memberof NonEmployeeApprovalSummary
     */
    'rejected'?: number;
}
/**
 * 
 * @export
 * @interface NonEmployeeBulkUploadJob
 */
export interface NonEmployeeBulkUploadJob {
    /**
     * The bulk upload job\'s ID. (UUID)
     * @type {string}
     * @memberof NonEmployeeBulkUploadJob
     */
    'id'?: string;
    /**
     * The ID of the source to bulk-upload non-employees to. (UUID)
     * @type {string}
     * @memberof NonEmployeeBulkUploadJob
     */
    'sourceId'?: string;
    /**
     * The date-time the job was submitted.
     * @type {string}
     * @memberof NonEmployeeBulkUploadJob
     */
    'created'?: string;
    /**
     * The date-time that the job was last updated.
     * @type {string}
     * @memberof NonEmployeeBulkUploadJob
     */
    'modified'?: string;
    /**
     * Returns the following values indicating the progress or result of the bulk upload job. \"PENDING\" means the job is queued and waiting to be processed. \"IN_PROGRESS\" means the job is currently being processed. \"COMPLETED\" means the job has been completed without any errors. \"ERROR\" means the job failed to process with errors. 
     * @type {string}
     * @memberof NonEmployeeBulkUploadJob
     */
    'status'?: NonEmployeeBulkUploadJobStatusEnum;
}

export const NonEmployeeBulkUploadJobStatusEnum = {
    Pending: 'PENDING',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Error: 'ERROR'
} as const;

export type NonEmployeeBulkUploadJobStatusEnum = typeof NonEmployeeBulkUploadJobStatusEnum[keyof typeof NonEmployeeBulkUploadJobStatusEnum];

/**
 * 
 * @export
 * @interface NonEmployeeBulkUploadStatus
 */
export interface NonEmployeeBulkUploadStatus {
    /**
     * Returns the following values indicating the progress or result of the bulk upload job. \"PENDING\" means the job is queued and waiting to be processed. \"IN_PROGRESS\" means the job is currently being processed. \"COMPLETED\" means the job has been completed without any errors. \"ERROR\" means the job failed to process with errors. null means job has been submitted to the source. 
     * @type {string}
     * @memberof NonEmployeeBulkUploadStatus
     */
    'status'?: NonEmployeeBulkUploadStatusStatusEnum;
}

export const NonEmployeeBulkUploadStatusStatusEnum = {
    Pending: 'PENDING',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Error: 'ERROR'
} as const;

export type NonEmployeeBulkUploadStatusStatusEnum = typeof NonEmployeeBulkUploadStatusStatusEnum[keyof typeof NonEmployeeBulkUploadStatusStatusEnum];

/**
 * Identifies if the identity is a normal identity or a governance group
 * @export
 * @enum {string}
 */

export const NonEmployeeIdentityDtoType = {
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY'
} as const;

export type NonEmployeeIdentityDtoType = typeof NonEmployeeIdentityDtoType[keyof typeof NonEmployeeIdentityDtoType];


/**
 * 
 * @export
 * @interface NonEmployeeIdentityReferenceWithId
 */
export interface NonEmployeeIdentityReferenceWithId {
    /**
     * 
     * @type {NonEmployeeIdentityDtoType}
     * @memberof NonEmployeeIdentityReferenceWithId
     */
    'type'?: NonEmployeeIdentityDtoType;
    /**
     * Identity id
     * @type {string}
     * @memberof NonEmployeeIdentityReferenceWithId
     */
    'id'?: string;
}


/**
 * 
 * @export
 * @interface NonEmployeeIdnUserRequest
 */
export interface NonEmployeeIdnUserRequest {
    /**
     * Identity id.
     * @type {string}
     * @memberof NonEmployeeIdnUserRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRecord
 */
export interface NonEmployeeRecord {
    /**
     * Non-Employee record id.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'id'?: string;
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'accountName'?: string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'firstName'?: string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'lastName'?: string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'email'?: string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'phone'?: string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'manager'?: string;
    /**
     * Non-Employee\'s source id.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'sourceId'?: string;
    /**
     * Attribute blob/bag for a non-employee.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRecord
     */
    'data'?: { [key: string]: string; };
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'startDate'?: string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'endDate'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRejectApprovalDecision
 */
export interface NonEmployeeRejectApprovalDecision {
    /**
     * Comment on the approval item.
     * @type {string}
     * @memberof NonEmployeeRejectApprovalDecision
     */
    'comment': string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequest
 */
export interface NonEmployeeRequest {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'description'?: string;
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'accountName'?: string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'firstName'?: string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'lastName'?: string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'email'?: string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'phone'?: string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'manager'?: string;
    /**
     * 
     * @type {NonEmployeeSourceLite}
     * @memberof NonEmployeeRequest
     */
    'nonEmployeeSource'?: NonEmployeeSourceLite;
    /**
     * Attribute blob/bag for a non-employee.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRequest
     */
    'data'?: { [key: string]: string; };
    /**
     * List of approval item for the request
     * @type {Array<NonEmployeeApprovalItemBase>}
     * @memberof NonEmployeeRequest
     */
    'approvalItems'?: Array<NonEmployeeApprovalItemBase>;
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof NonEmployeeRequest
     */
    'approvalStatus'?: ApprovalStatus;
    /**
     * comment of requester
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'comment'?: string;
    /**
     * When the request was completely approved.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'completionDate'?: string;
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'startDate'?: string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'endDate'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'created'?: string;
}


/**
 * 
 * @export
 * @interface NonEmployeeRequestBody
 */
export interface NonEmployeeRequestBody {
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'accountName': string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'firstName': string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'lastName': string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'email': string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'phone': string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'manager': string;
    /**
     * Non-Employee\'s source id.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'sourceId': string;
    /**
     * Attribute blob/bag for a non-employee, 10 attributes is the maximum size supported.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRequestBody
     */
    'data'?: { [key: string]: string; };
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'startDate': string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'endDate': string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequestLite
 */
export interface NonEmployeeRequestLite {
    /**
     * Non-Employee request id.
     * @type {string}
     * @memberof NonEmployeeRequestLite
     */
    'id'?: string;
    /**
     * 
     * @type {NonEmployeeIdentityReferenceWithId}
     * @memberof NonEmployeeRequestLite
     */
    'requester'?: NonEmployeeIdentityReferenceWithId;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequestSummary
 */
export interface NonEmployeeRequestSummary {
    /**
     * The number of approved non-employee requests on all sources that *requested-for* user manages.
     * @type {number}
     * @memberof NonEmployeeRequestSummary
     */
    'approved'?: number;
    /**
     * The number of rejected non-employee requests on all sources that *requested-for* user manages.
     * @type {number}
     * @memberof NonEmployeeRequestSummary
     */
    'rejected'?: number;
    /**
     * The number of pending non-employee requests on all sources that *requested-for* user manages.
     * @type {number}
     * @memberof NonEmployeeRequestSummary
     */
    'pending'?: number;
    /**
     * The number of non-employee records on all sources that *requested-for* user manages.
     * @type {number}
     * @memberof NonEmployeeRequestSummary
     */
    'nonEmployeeCount'?: number;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequestWithoutApprovalItem
 */
export interface NonEmployeeRequestWithoutApprovalItem {
    /**
     * Non-Employee request id.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'id'?: string;
    /**
     * 
     * @type {NonEmployeeIdentityReferenceWithId}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'requester'?: NonEmployeeIdentityReferenceWithId;
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'accountName'?: string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'firstName'?: string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'lastName'?: string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'email'?: string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'phone'?: string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'manager'?: string;
    /**
     * 
     * @type {NonEmployeeSourceLiteWithSchemaAttributes}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'nonEmployeeSource'?: NonEmployeeSourceLiteWithSchemaAttributes;
    /**
     * Attribute blob/bag for a non-employee.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'data'?: { [key: string]: string; };
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'approvalStatus'?: ApprovalStatus;
    /**
     * comment of requester
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'comment'?: string;
    /**
     * When the request was completely approved.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'completionDate'?: string;
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'startDate'?: string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'endDate'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'created'?: string;
}


/**
 * 
 * @export
 * @interface NonEmployeeSchemaAttribute
 */
export interface NonEmployeeSchemaAttribute {
    /**
     * Schema Attribute Id
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'id'?: string;
    /**
     * True if this schema attribute is mandatory on all non-employees sources.
     * @type {boolean}
     * @memberof NonEmployeeSchemaAttribute
     */
    'system'?: boolean;
    /**
     * When the schema attribute was last modified.
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'modified'?: string;
    /**
     * When the schema attribute was created.
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'created'?: string;
    /**
     * 
     * @type {NonEmployeeSchemaAttributeType}
     * @memberof NonEmployeeSchemaAttribute
     */
    'type': NonEmployeeSchemaAttributeType;
    /**
     * Label displayed on the UI for this schema attribute.
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'label': string;
    /**
     * The technical name of the attribute. Must be unique per source.
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'technicalName': string;
    /**
     * help text displayed by UI.
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'helpText'?: string;
    /**
     * Hint text that fills UI box.
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'placeholder'?: string;
    /**
     * If true, the schema attribute is required for all non-employees in the source
     * @type {boolean}
     * @memberof NonEmployeeSchemaAttribute
     */
    'required'?: boolean;
}


/**
 * 
 * @export
 * @interface NonEmployeeSchemaAttributeBody
 */
export interface NonEmployeeSchemaAttributeBody {
    /**
     * Type of the attribute. Only type \'TEXT\' is supported for custom attributes.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBody
     */
    'type': string;
    /**
     * Label displayed on the UI for this schema attribute.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBody
     */
    'label': string;
    /**
     * The technical name of the attribute. Must be unique per source.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBody
     */
    'technicalName': string;
    /**
     * help text displayed by UI.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBody
     */
    'helpText'?: string;
    /**
     * Hint text that fills UI box.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBody
     */
    'placeholder'?: string;
    /**
     * If true, the schema attribute is required for all non-employees in the source
     * @type {boolean}
     * @memberof NonEmployeeSchemaAttributeBody
     */
    'required'?: boolean;
}
/**
 * Enum representing the type of data a schema attribute accepts.
 * @export
 * @enum {string}
 */

export const NonEmployeeSchemaAttributeType = {
    Text: 'TEXT',
    Date: 'DATE',
    Identity: 'IDENTITY'
} as const;

export type NonEmployeeSchemaAttributeType = typeof NonEmployeeSchemaAttributeType[keyof typeof NonEmployeeSchemaAttributeType];


/**
 * 
 * @export
 * @interface NonEmployeeSource
 */
export interface NonEmployeeSource {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeSource
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSource
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSource
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSource
     */
    'description'?: string;
    /**
     * List of approvers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSource
     */
    'approvers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * List of account managers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSource
     */
    'accountManagers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeSource
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeSource
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceLite
 */
export interface NonEmployeeSourceLite {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeSourceLite
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLite
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLite
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLite
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceLiteWithSchemaAttributes
 */
export interface NonEmployeeSourceLiteWithSchemaAttributes {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributes
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributes
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributes
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributes
     */
    'description'?: string;
    /**
     * List of schema attributes associated with this non-employee source.
     * @type {Array<NonEmployeeSchemaAttribute>}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributes
     */
    'schemaAttributes'?: Array<NonEmployeeSchemaAttribute>;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceRequestBody
 */
export interface NonEmployeeSourceRequestBody {
    /**
     * Name of non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceRequestBody
     */
    'name': string;
    /**
     * Description of non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceRequestBody
     */
    'description': string;
    /**
     * 
     * @type {NonEmployeeIdnUserRequest}
     * @memberof NonEmployeeSourceRequestBody
     */
    'owner': NonEmployeeIdnUserRequest;
    /**
     * The ID for the management workgroup that contains source sub-admins
     * @type {string}
     * @memberof NonEmployeeSourceRequestBody
     */
    'managementWorkgroup'?: string;
    /**
     * List of approvers.
     * @type {Array<NonEmployeeIdnUserRequest>}
     * @memberof NonEmployeeSourceRequestBody
     */
    'approvers'?: Array<NonEmployeeIdnUserRequest>;
    /**
     * List of account managers.
     * @type {Array<NonEmployeeIdnUserRequest>}
     * @memberof NonEmployeeSourceRequestBody
     */
    'accountManagers'?: Array<NonEmployeeIdnUserRequest>;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceWithCloudExternalId
 */
export interface NonEmployeeSourceWithCloudExternalId {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'description'?: string;
    /**
     * List of approvers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'approvers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * List of account managers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'accountManagers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'created'?: string;
    /**
     * Legacy ID used for sources from the V1 API. This attribute will be removed from a future version of the API and will not be considered a breaking change. No clients should rely on this ID always being present.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'cloudExternalId'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceWithNECount
 */
export interface NonEmployeeSourceWithNECount {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECount
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECount
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECount
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECount
     */
    'description'?: string;
    /**
     * List of approvers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSourceWithNECount
     */
    'approvers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * List of account managers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSourceWithNECount
     */
    'accountManagers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECount
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECount
     */
    'created'?: string;
    /**
     * Number of non-employee records associated with this source.
     * @type {number}
     * @memberof NonEmployeeSourceWithNECount
     */
    'nonEmployeeCount'?: number;
}
/**
 * Response model for import of a single object.
 * @export
 * @interface ObjectImportResult
 */
export interface ObjectImportResult {
    /**
     * Informational messages returned from the target service on import.
     * @type {Array<SpConfigMessage>}
     * @memberof ObjectImportResult
     */
    'infos': Array<SpConfigMessage>;
    /**
     * Warning messages returned from the target service on import.
     * @type {Array<SpConfigMessage>}
     * @memberof ObjectImportResult
     */
    'warnings': Array<SpConfigMessage>;
    /**
     * Error messages returned from the target service on import.
     * @type {Array<SpConfigMessage>}
     * @memberof ObjectImportResult
     */
    'errors': Array<SpConfigMessage>;
    /**
     * References to objects that were created or updated by the import.
     * @type {Array<ImportObject>}
     * @memberof ObjectImportResult
     */
    'importedObjects': Array<ImportObject>;
}
/**
 * Operation on a specific criteria
 * @export
 * @enum {string}
 */

export const Operation = {
    Equals: 'EQUALS',
    NotEquals: 'NOT_EQUALS',
    Contains: 'CONTAINS',
    StartsWith: 'STARTS_WITH',
    EndsWith: 'ENDS_WITH',
    And: 'AND',
    Or: 'OR'
} as const;

export type Operation = typeof Operation[keyof typeof Operation];


/**
 * 
 * @export
 * @interface OriginalRequest
 */
export interface OriginalRequest {
    /**
     * the account id
     * @type {string}
     * @memberof OriginalRequest
     */
    'accountId'?: string;
    /**
     * 
     * @type {Array<AttributeRequest>}
     * @memberof OriginalRequest
     */
    'attributeRequests'?: Array<AttributeRequest>;
    /**
     * the operation that was used
     * @type {string}
     * @memberof OriginalRequest
     */
    'op'?: string;
    /**
     * 
     * @type {AccountSource}
     * @memberof OriginalRequest
     */
    'source'?: AccountSource;
}
/**
 * Arguments for Orphan Identities report (ORPHAN_IDENTITIES) and Uncorrelated Accounts report (UNCORRELATED_ACCOUNTS)
 * @export
 * @interface OrphanUncorrelatedReportArguments
 */
export interface OrphanUncorrelatedReportArguments {
    /**
     * Output report file formats. This are formats for calling get endpoint as a query parameter \'fileFormat\'.  In case report won\'t have this argument there will be [\'CSV\', \'PDF\'] as default.
     * @type {Array<string>}
     * @memberof OrphanUncorrelatedReportArguments
     */
    'selectedFormats'?: Array<OrphanUncorrelatedReportArgumentsSelectedFormatsEnum>;
    /**
     * Use it to set default s3 bucket where generated report will be saved.  In case this argument is false and \'s3Bucket\' argument is null or absent there will be default s3Bucket assigned to the report.
     * @type {boolean}
     * @memberof OrphanUncorrelatedReportArguments
     */
    'defaultS3Bucket': boolean;
    /**
     * If you want to be specific you could use this argument with defaultS3Bucket = false.
     * @type {string}
     * @memberof OrphanUncorrelatedReportArguments
     */
    's3Bucket'?: string;
}

export const OrphanUncorrelatedReportArgumentsSelectedFormatsEnum = {
    Csv: 'CSV',
    Pdf: 'PDF'
} as const;

export type OrphanUncorrelatedReportArgumentsSelectedFormatsEnum = typeof OrphanUncorrelatedReportArgumentsSelectedFormatsEnum[keyof typeof OrphanUncorrelatedReportArgumentsSelectedFormatsEnum];

/**
 * 
 * @export
 * @interface Owner
 */
export interface Owner {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof Owner
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof Owner
     */
    'name'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof Owner
     */
    'type'?: DtoType;
    /**
     * The email of the identity
     * @type {string}
     * @memberof Owner
     */
    'email'?: string;
}


/**
 * Owner\'s identity.
 * @export
 * @interface OwnerDto
 */
export interface OwnerDto {
    /**
     * Owner\'s DTO type.
     * @type {string}
     * @memberof OwnerDto
     */
    'type'?: OwnerDtoTypeEnum;
    /**
     * Owner\'s identity ID.
     * @type {string}
     * @memberof OwnerDto
     */
    'id'?: string;
    /**
     * Owner\'s display name.
     * @type {string}
     * @memberof OwnerDto
     */
    'name'?: string;
}

export const OwnerDtoTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type OwnerDtoTypeEnum = typeof OwnerDtoTypeEnum[keyof typeof OwnerDtoTypeEnum];

/**
 * The owner of this object.
 * @export
 * @interface OwnerReference
 */
export interface OwnerReference {
    /**
     * Owner type. This field must be either left null or set to \'IDENTITY\' on input, otherwise a 400 Bad Request error will result.
     * @type {string}
     * @memberof OwnerReference
     */
    'type'?: OwnerReferenceTypeEnum;
    /**
     * Identity id
     * @type {string}
     * @memberof OwnerReference
     */
    'id'?: string;
    /**
     * Human-readable display name of the owner. It may be left null or omitted in a POST or PATCH. If set, it must match the current value of the owner\'s display name, otherwise a 400 Bad Request error will result.
     * @type {string}
     * @memberof OwnerReference
     */
    'name'?: string;
}

export const OwnerReferenceTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type OwnerReferenceTypeEnum = typeof OwnerReferenceTypeEnum[keyof typeof OwnerReferenceTypeEnum];

/**
 * The owner of this object.
 * @export
 * @interface OwnerReferenceSegments
 */
export interface OwnerReferenceSegments {
    /**
     * Owner type. This field must be either left null or set to \'IDENTITY\' on input, otherwise a 400 Bad Request error will result.
     * @type {string}
     * @memberof OwnerReferenceSegments
     */
    'type'?: OwnerReferenceSegmentsTypeEnum;
    /**
     * Identity id
     * @type {string}
     * @memberof OwnerReferenceSegments
     */
    'id'?: string;
    /**
     * Human-readable display name of the owner. It may be left null or omitted in a POST or PATCH. If set, it must match the current value of the owner\'s display name, otherwise a 400 Bad Request error will result.
     * @type {string}
     * @memberof OwnerReferenceSegments
     */
    'name'?: string;
}

export const OwnerReferenceSegmentsTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type OwnerReferenceSegmentsTypeEnum = typeof OwnerReferenceSegmentsTypeEnum[keyof typeof OwnerReferenceSegmentsTypeEnum];

/**
 * 
 * @export
 * @interface Owns
 */
export interface Owns {
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof Owns
     */
    'sources'?: Array<Reference1>;
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof Owns
     */
    'entitlements'?: Array<Reference1>;
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof Owns
     */
    'accessProfiles'?: Array<Reference1>;
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof Owns
     */
    'roles'?: Array<Reference1>;
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof Owns
     */
    'apps'?: Array<Reference1>;
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof Owns
     */
    'governanceGroups'?: Array<Reference1>;
    /**
     * 
     * @type {boolean}
     * @memberof Owns
     */
    'fallbackApprover'?: boolean;
}
/**
 * 
 * @export
 * @interface PasswordChangeRequest
 */
export interface PasswordChangeRequest {
    /**
     * The identity ID that requested the password change
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'identityId'?: string;
    /**
     * The RSA encrypted password
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'encryptedPassword'?: string;
    /**
     * The encryption key ID
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'publicKeyId'?: string;
    /**
     * Account ID of the account This is specified per account schema in the source configuration. It is used to distinguish accounts. More info can be found here https://community.sailpoint.com/t5/IdentityNow-Connectors/How-do-I-designate-an-account-attribute-as-the-Account-ID-for-a/ta-p/80350
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'accountId'?: string;
    /**
     * The ID of the source for which identity is requesting the password change
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'sourceId'?: string;
}
/**
 * 
 * @export
 * @interface PasswordChangeResponse
 */
export interface PasswordChangeResponse {
    /**
     * The password change request ID
     * @type {string}
     * @memberof PasswordChangeResponse
     */
    'requestId'?: string | null;
    /**
     * Password change state
     * @type {string}
     * @memberof PasswordChangeResponse
     */
    'state'?: PasswordChangeResponseStateEnum;
}

export const PasswordChangeResponseStateEnum = {
    InProgress: 'IN_PROGRESS',
    Finished: 'FINISHED',
    Failed: 'FAILED'
} as const;

export type PasswordChangeResponseStateEnum = typeof PasswordChangeResponseStateEnum[keyof typeof PasswordChangeResponseStateEnum];

/**
 * 
 * @export
 * @interface PasswordInfo
 */
export interface PasswordInfo {
    /**
     * Identity ID
     * @type {string}
     * @memberof PasswordInfo
     */
    'identityId'?: string;
    /**
     * source ID
     * @type {string}
     * @memberof PasswordInfo
     */
    'sourceId'?: string;
    /**
     * public key ID
     * @type {string}
     * @memberof PasswordInfo
     */
    'publicKeyId'?: string;
    /**
     * User\'s public key with Base64 encoding
     * @type {string}
     * @memberof PasswordInfo
     */
    'publicKey'?: string;
    /**
     * Account info related to queried identity and source
     * @type {Array<PasswordInfoAccount>}
     * @memberof PasswordInfo
     */
    'accounts'?: Array<PasswordInfoAccount>;
    /**
     * Password constraints
     * @type {Array<string>}
     * @memberof PasswordInfo
     */
    'policies'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PasswordInfoAccount
 */
export interface PasswordInfoAccount {
    /**
     * Account ID of the account. This is specified per account schema in the source configuration. It is used to distinguish accounts. More info can be found here https://community.sailpoint.com/t5/IdentityNow-Connectors/How-do-I-designate-an-account-attribute-as-the-Account-ID-for-a/ta-p/80350
     * @type {string}
     * @memberof PasswordInfoAccount
     */
    'accountId'?: string;
    /**
     * Display name of the account. This is specified per account schema in the source configuration. It is used to display name of the account. More info can be found here https://community.sailpoint.com/t5/IdentityNow-Connectors/How-do-I-designate-an-account-attribute-as-the-Account-Name-for/ta-p/74008
     * @type {string}
     * @memberof PasswordInfoAccount
     */
    'accountName'?: string;
}
/**
 * 
 * @export
 * @interface PasswordInfoQueryDTO
 */
export interface PasswordInfoQueryDTO {
    /**
     * The login name of the user
     * @type {string}
     * @memberof PasswordInfoQueryDTO
     */
    'userName'?: string;
    /**
     * The display name of the source
     * @type {string}
     * @memberof PasswordInfoQueryDTO
     */
    'sourceName'?: string;
}
/**
 * 
 * @export
 * @interface PasswordOrgConfig
 */
export interface PasswordOrgConfig {
    /**
     * Indicator whether custom password instructions feature is enabled. The default value is false.
     * @type {boolean}
     * @memberof PasswordOrgConfig
     */
    'customInstructionsEnabled'?: boolean;
    /**
     * Indicator whether \"digit token\" feature is enabled. The default value is false.
     * @type {boolean}
     * @memberof PasswordOrgConfig
     */
    'digitTokenEnabled'?: boolean;
    /**
     * The duration of \"digit token\" in minutes. The default value is 5.
     * @type {number}
     * @memberof PasswordOrgConfig
     */
    'digitTokenDurationMinutes'?: number;
    /**
     * The length of \"digit token\". The default value is 6.
     * @type {number}
     * @memberof PasswordOrgConfig
     */
    'digitTokenLength'?: number;
}
/**
 * 
 * @export
 * @interface PasswordStatus
 */
export interface PasswordStatus {
    /**
     * The password change request ID
     * @type {string}
     * @memberof PasswordStatus
     */
    'requestId'?: string | null;
    /**
     * Password change state
     * @type {string}
     * @memberof PasswordStatus
     */
    'state'?: PasswordStatusStateEnum;
    /**
     * The errors during the password change request
     * @type {Array<string>}
     * @memberof PasswordStatus
     */
    'errors'?: Array<string>;
    /**
     * List of source IDs in the password change request
     * @type {Array<string>}
     * @memberof PasswordStatus
     */
    'sourceIds'?: Array<string>;
}

export const PasswordStatusStateEnum = {
    InProgress: 'IN_PROGRESS',
    Finished: 'FINISHED',
    Failed: 'FAILED'
} as const;

export type PasswordStatusStateEnum = typeof PasswordStatusStateEnum[keyof typeof PasswordStatusStateEnum];

/**
 * 
 * @export
 * @interface PasswordSyncGroup
 */
export interface PasswordSyncGroup {
    /**
     * ID of the sync group
     * @type {string}
     * @memberof PasswordSyncGroup
     */
    'id'?: string;
    /**
     * Name of the sync group
     * @type {string}
     * @memberof PasswordSyncGroup
     */
    'name'?: string;
    /**
     * ID of the password policy
     * @type {string}
     * @memberof PasswordSyncGroup
     */
    'passwordPolicyId'?: string;
    /**
     * List of password managed sources IDs
     * @type {Array<string>}
     * @memberof PasswordSyncGroup
     */
    'sourceIds'?: Array<string>;
}
/**
 * Personal access token owner\'s identity.
 * @export
 * @interface PatOwner
 */
export interface PatOwner {
    /**
     * Personal access token owner\'s DTO type.
     * @type {string}
     * @memberof PatOwner
     */
    'type'?: PatOwnerTypeEnum;
    /**
     * Personal access token owner\'s identity ID.
     * @type {string}
     * @memberof PatOwner
     */
    'id'?: string;
    /**
     * Personal access token owner\'s human-readable display name.
     * @type {string}
     * @memberof PatOwner
     */
    'name'?: string;
}

export const PatOwnerTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type PatOwnerTypeEnum = typeof PatOwnerTypeEnum[keyof typeof PatOwnerTypeEnum];

/**
 * 
 * @export
 * @interface PendingApproval
 */
export interface PendingApproval {
    /**
     * The approval id.
     * @type {string}
     * @memberof PendingApproval
     */
    'id'?: string;
    /**
     * The name of the approval.
     * @type {string}
     * @memberof PendingApproval
     */
    'name'?: string;
    /**
     * When the approval was created.
     * @type {string}
     * @memberof PendingApproval
     */
    'created'?: string;
    /**
     * When the approval was modified last time.
     * @type {string}
     * @memberof PendingApproval
     */
    'modified'?: string;
    /**
     * When the access-request was created.
     * @type {string}
     * @memberof PendingApproval
     */
    'requestCreated'?: string;
    /**
     * 
     * @type {AccessRequestType}
     * @memberof PendingApproval
     */
    'requestType'?: AccessRequestType;
    /**
     * 
     * @type {AccessItemRequester}
     * @memberof PendingApproval
     */
    'requester'?: AccessItemRequester;
    /**
     * 
     * @type {AccessItemRequestedFor}
     * @memberof PendingApproval
     */
    'requestedFor'?: AccessItemRequestedFor;
    /**
     * 
     * @type {PendingApprovalOwner}
     * @memberof PendingApproval
     */
    'owner'?: PendingApprovalOwner;
    /**
     * 
     * @type {RequestableObjectReference}
     * @memberof PendingApproval
     */
    'requestedObject'?: RequestableObjectReference;
    /**
     * 
     * @type {CommentDto}
     * @memberof PendingApproval
     */
    'requesterComment'?: CommentDto;
    /**
     * The history of the previous reviewers comments.
     * @type {Array<CommentDto>}
     * @memberof PendingApproval
     */
    'previousReviewersComments'?: Array<CommentDto>;
    /**
     * The history of approval forward action.
     * @type {Array<ApprovalForwardHistory>}
     * @memberof PendingApproval
     */
    'forwardHistory'?: Array<ApprovalForwardHistory>;
    /**
     * When true the rejector has to provide comments when rejecting
     * @type {boolean}
     * @memberof PendingApproval
     */
    'commentRequiredWhenRejected'?: boolean;
    /**
     * 
     * @type {PendingApprovalAction}
     * @memberof PendingApproval
     */
    'actionInProcess'?: PendingApprovalAction;
    /**
     * The date the role or access profile is no longer assigned to the specified identity.
     * @type {string}
     * @memberof PendingApproval
     */
    'removeDate'?: string;
    /**
     * If true, then the request is to change the remove date or sunset date.
     * @type {boolean}
     * @memberof PendingApproval
     */
    'removeDateUpdateRequested'?: boolean;
    /**
     * The remove date or sunset date that was assigned at the time of the request.
     * @type {string}
     * @memberof PendingApproval
     */
    'currentRemoveDate'?: string;
    /**
     * 
     * @type {SodViolationContextCheckCompleted}
     * @memberof PendingApproval
     */
    'sodViolationContext'?: SodViolationContextCheckCompleted;
}


/**
 * Enum represents action that is being processed on an approval.
 * @export
 * @enum {string}
 */

export const PendingApprovalAction = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    Forwarded: 'FORWARDED'
} as const;

export type PendingApprovalAction = typeof PendingApprovalAction[keyof typeof PendingApprovalAction];


/**
 * Access item owner\'s identity.
 * @export
 * @interface PendingApprovalOwner
 */
export interface PendingApprovalOwner {
    /**
     * Access item owner\'s DTO type.
     * @type {string}
     * @memberof PendingApprovalOwner
     */
    'type'?: PendingApprovalOwnerTypeEnum;
    /**
     * Access item owner\'s identity ID.
     * @type {string}
     * @memberof PendingApprovalOwner
     */
    'id'?: string;
    /**
     * Access item owner\'s human-readable display name.
     * @type {string}
     * @memberof PendingApprovalOwner
     */
    'name'?: string;
}

export const PendingApprovalOwnerTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type PendingApprovalOwnerTypeEnum = typeof PendingApprovalOwnerTypeEnum[keyof typeof PendingApprovalOwnerTypeEnum];

/**
 * Simplified DTO for the Permission objects stored in SailPoint\'s database. The data is aggregated from customer systems and is free-form, so its appearance can vary largely between different clients/customers.
 * @export
 * @interface PermissionDto
 */
export interface PermissionDto {
    /**
     * All the rights (e.g. actions) that this permission allows on the target
     * @type {Array<string>}
     * @memberof PermissionDto
     */
    'rights'?: Array<string>;
    /**
     * The target the permission would grants rights on.
     * @type {string}
     * @memberof PermissionDto
     */
    'target'?: string;
}
/**
 * Provides additional details about the pre-approval trigger for this request.
 * @export
 * @interface PreApprovalTriggerDetails
 */
export interface PreApprovalTriggerDetails {
    /**
     * Comment left for the pre-approval decision
     * @type {string}
     * @memberof PreApprovalTriggerDetails
     */
    'comment'?: string;
    /**
     * The reviewer of the pre-approval decision
     * @type {string}
     * @memberof PreApprovalTriggerDetails
     */
    'reviewer'?: string;
    /**
     * The decision of the pre-approval trigger
     * @type {string}
     * @memberof PreApprovalTriggerDetails
     */
    'decision'?: PreApprovalTriggerDetailsDecisionEnum;
}

export const PreApprovalTriggerDetailsDecisionEnum = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED'
} as const;

export type PreApprovalTriggerDetailsDecisionEnum = typeof PreApprovalTriggerDetailsDecisionEnum[keyof typeof PreApprovalTriggerDetailsDecisionEnum];

/**
 * 
 * @export
 * @interface ProcessingDetails
 */
export interface ProcessingDetails {
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof ProcessingDetails
     */
    'date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProcessingDetails
     */
    'stage'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProcessingDetails
     */
    'retryCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProcessingDetails
     */
    'stackTrace'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessingDetails
     */
    'message'?: string;
}
/**
 * Specification of a Service Desk integration provisioning configuration.
 * @export
 * @interface ProvisioningConfig
 */
export interface ProvisioningConfig {
    /**
     * Specifies whether this configuration is used to manage provisioning requests for all sources from the org.  If true, no managedResourceRefs are allowed.
     * @type {boolean}
     * @memberof ProvisioningConfig
     */
    'universalManager'?: boolean;
    /**
     * References to sources for the Service Desk integration template.  May only be specified if universalManager is false.
     * @type {Array<ServiceDeskSource>}
     * @memberof ProvisioningConfig
     */
    'managedResourceRefs'?: Array<ServiceDeskSource>;
    /**
     * 
     * @type {ProvisioningConfigPlanInitializerScript}
     * @memberof ProvisioningConfig
     */
    'planInitializerScript'?: ProvisioningConfigPlanInitializerScript;
    /**
     * Name of an attribute that when true disables the saving of ProvisioningRequest objects whenever plans are sent through this integration.
     * @type {boolean}
     * @memberof ProvisioningConfig
     */
    'noProvisioningRequests'?: boolean;
    /**
     * When saving pending requests is enabled, this defines the number of hours the request is allowed to live before it is considered expired and no longer affects plan compilation.
     * @type {number}
     * @memberof ProvisioningConfig
     */
    'provisioningRequestExpiration'?: number;
}
/**
 * This is a reference to a plan initializer script.
 * @export
 * @interface ProvisioningConfigPlanInitializerScript
 */
export interface ProvisioningConfigPlanInitializerScript {
    /**
     * This is a Rule that allows provisioning instruction changes.
     * @type {string}
     * @memberof ProvisioningConfigPlanInitializerScript
     */
    'source'?: string;
}
/**
 * Defines matching criteria for an Account to be provisioned with a specific Access Profile
 * @export
 * @interface ProvisioningCriteriaLevel1
 */
export interface ProvisioningCriteriaLevel1 {
    /**
     * 
     * @type {ProvisioningCriteriaOperation}
     * @memberof ProvisioningCriteriaLevel1
     */
    'operation'?: ProvisioningCriteriaOperation;
    /**
     * Name of the Account attribute to be tested. If **operation** is one of EQUALS, NOT_EQUALS, CONTAINS, or HAS, this field is required. Otherwise, specifying it is an error.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel1
     */
    'attribute'?: string | null;
    /**
     * String value to test the Account attribute w/r/t the specified operation. If the operation is one of EQUALS, NOT_EQUALS, or CONTAINS, this field is required. Otherwise, specifying it is an error. If the Attribute is not String-typed, it will be converted to the appropriate type.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel1
     */
    'value'?: string | null;
    /**
     * Array of child criteria. Required if the operation is AND or OR, otherwise it must be left null. A maximum of three levels of criteria are supported, including leaf nodes.
     * @type {Array<ProvisioningCriteriaLevel2>}
     * @memberof ProvisioningCriteriaLevel1
     */
    'children'?: Array<ProvisioningCriteriaLevel2> | null;
}


/**
 * Defines matching criteria for an Account to be provisioned with a specific Access Profile
 * @export
 * @interface ProvisioningCriteriaLevel2
 */
export interface ProvisioningCriteriaLevel2 {
    /**
     * 
     * @type {ProvisioningCriteriaOperation}
     * @memberof ProvisioningCriteriaLevel2
     */
    'operation'?: ProvisioningCriteriaOperation;
    /**
     * Name of the Account attribute to be tested. If **operation** is one of EQUALS, NOT_EQUALS, CONTAINS, or HAS, this field is required. Otherwise, specifying it is an error.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel2
     */
    'attribute'?: string | null;
    /**
     * String value to test the Account attribute w/r/t the specified operation. If the operation is one of EQUALS, NOT_EQUALS, or CONTAINS, this field is required. Otherwise, specifying it is an error. If the Attribute is not String-typed, it will be converted to the appropriate type.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel2
     */
    'value'?: string | null;
    /**
     * Array of child criteria. Required if the operation is AND or OR, otherwise it must be left null. A maximum of three levels of criteria are supported, including leaf nodes.
     * @type {Array<ProvisioningCriteriaLevel3>}
     * @memberof ProvisioningCriteriaLevel2
     */
    'children'?: Array<ProvisioningCriteriaLevel3> | null;
}


/**
 * Defines matching criteria for an Account to be provisioned with a specific Access Profile
 * @export
 * @interface ProvisioningCriteriaLevel3
 */
export interface ProvisioningCriteriaLevel3 {
    /**
     * 
     * @type {ProvisioningCriteriaOperation}
     * @memberof ProvisioningCriteriaLevel3
     */
    'operation'?: ProvisioningCriteriaOperation;
    /**
     * Name of the Account attribute to be tested. If **operation** is one of EQUALS, NOT_EQUALS, CONTAINS, or HAS, this field is required. Otherwise, specifying it is an error.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel3
     */
    'attribute'?: string | null;
    /**
     * String value to test the Account attribute w/r/t the specified operation. If the operation is one of EQUALS, NOT_EQUALS, or CONTAINS, this field is required. Otherwise, specifying it is an error. If the Attribute is not String-typed, it will be converted to the appropriate type.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel3
     */
    'value'?: string;
}


/**
 * Supported operations on ProvisioningCriteria
 * @export
 * @enum {string}
 */

export const ProvisioningCriteriaOperation = {
    Equals: 'EQUALS',
    NotEquals: 'NOT_EQUALS',
    Contains: 'CONTAINS',
    Has: 'HAS',
    And: 'AND',
    Or: 'OR'
} as const;

export type ProvisioningCriteriaOperation = typeof ProvisioningCriteriaOperation[keyof typeof ProvisioningCriteriaOperation];


/**
 * Provides additional details about provisioning for this request.
 * @export
 * @interface ProvisioningDetails
 */
export interface ProvisioningDetails {
    /**
     * Ordered CSV of sub phase references to objects that contain more information about provisioning. For example, this can contain \"manualWorkItemDetails\" which indicate that there is further information in that object for this phase.
     * @type {string}
     * @memberof ProvisioningDetails
     */
    'orderedSubPhaseReferences'?: string;
}
/**
 * 
 * @export
 * @interface ProvisioningPolicy
 */
export interface ProvisioningPolicy {
    /**
     * the provisioning policy name
     * @type {string}
     * @memberof ProvisioningPolicy
     */
    'name': string;
    /**
     * the description of the provisioning policy
     * @type {string}
     * @memberof ProvisioningPolicy
     */
    'description'?: string;
    /**
     * 
     * @type {UsageType}
     * @memberof ProvisioningPolicy
     */
    'usageType'?: UsageType;
    /**
     * 
     * @type {Array<FieldDetailsDto>}
     * @memberof ProvisioningPolicy
     */
    'fields'?: Array<FieldDetailsDto>;
}


/**
 * 
 * @export
 * @interface ProvisioningPolicyDto
 */
export interface ProvisioningPolicyDto {
    /**
     * the provisioning policy name
     * @type {string}
     * @memberof ProvisioningPolicyDto
     */
    'name': string;
    /**
     * the description of the provisioning policy
     * @type {string}
     * @memberof ProvisioningPolicyDto
     */
    'description'?: string;
    /**
     * 
     * @type {UsageType}
     * @memberof ProvisioningPolicyDto
     */
    'usageType'?: UsageType;
    /**
     * 
     * @type {Array<FieldDetailsDto>}
     * @memberof ProvisioningPolicyDto
     */
    'fields'?: Array<FieldDetailsDto>;
}


/**
 * Provisioning state of an account activity item
 * @export
 * @enum {string}
 */

export const ProvisioningState = {
    Pending: 'PENDING',
    Finished: 'FINISHED',
    Unverifiable: 'UNVERIFIABLE',
    Commited: 'COMMITED',
    Failed: 'FAILED',
    Retry: 'RETRY'
} as const;

export type ProvisioningState = typeof ProvisioningState[keyof typeof ProvisioningState];


/**
 * Details about a public identity
 * @export
 * @interface PublicIdentity
 */
export interface PublicIdentity {
    /**
     * Identity id
     * @type {string}
     * @memberof PublicIdentity
     */
    'id'?: string;
    /**
     * Human-readable display name of identity.
     * @type {string}
     * @memberof PublicIdentity
     */
    'name'?: string;
    /**
     * Alternate unique identifier for the identity.
     * @type {string}
     * @memberof PublicIdentity
     */
    'alias'?: string;
    /**
     * Email address of identity.
     * @type {string}
     * @memberof PublicIdentity
     */
    'email'?: string | null;
    /**
     * The lifecycle status for the identity
     * @type {string}
     * @memberof PublicIdentity
     */
    'status'?: string | null;
    /**
     * 
     * @type {IdentityReference}
     * @memberof PublicIdentity
     */
    'manager'?: IdentityReference | null;
    /**
     * The public identity attributes of the identity
     * @type {Array<IdentityAttribute1>}
     * @memberof PublicIdentity
     */
    'attributes'?: Array<IdentityAttribute1>;
}
/**
 * Used to map an attribute key for an Identity to its display name.
 * @export
 * @interface PublicIdentityAttributeConfig
 */
export interface PublicIdentityAttributeConfig {
    /**
     * The attribute key
     * @type {string}
     * @memberof PublicIdentityAttributeConfig
     */
    'key'?: string;
    /**
     * The attribute display name
     * @type {string}
     * @memberof PublicIdentityAttributeConfig
     */
    'name'?: string;
}
/**
 * Details of up to 5 Identity attributes that will be publicly accessible for all Identities to anyone in the org.
 * @export
 * @interface PublicIdentityConfig
 */
export interface PublicIdentityConfig {
    /**
     * Up to 5 identity attributes that will be available to everyone in the org for all users in the org.
     * @type {Array<PublicIdentityAttributeConfig>}
     * @memberof PublicIdentityConfig
     */
    'attributes'?: Array<PublicIdentityAttributeConfig>;
    /**
     * When this configuration was last modified.
     * @type {string}
     * @memberof PublicIdentityConfig
     */
    'modified'?: string | null;
    /**
     * 
     * @type {IdentityReference}
     * @memberof PublicIdentityConfig
     */
    'modifiedBy'?: IdentityReference | null;
}
/**
 * Query parameters used to construct an Elasticsearch query object.
 * @export
 * @interface Query
 */
export interface Query {
    /**
     * The query using the Elasticsearch [Query String Query](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/query-dsl-query-string-query.html#query-string) syntax from the Query DSL extended by SailPoint to support Nested queries.
     * @type {string}
     * @memberof Query
     */
    'query'?: string;
    /**
     * The fields the query will be applied to.  Fields provide you with a simple way to add additional fields to search, without making the query too complicated.  For example, you can use the fields to specify that you want your query of \"a*\" to be applied to \"name\", \"firstName\", and the \"source.name\".  The response will include all results matching the \"a*\" query found in those three fields.  A field\'s availability depends on the indices being searched.  For example, if you are searching \"identities\", you can apply your search to the \"firstName\" field, but you couldn\'t use \"firstName\" with a search on \"access profiles\".  Refer to the response schema for the respective lists of available fields. 
     * @type {Array<string>}
     * @memberof Query
     */
    'fields'?: Array<string>;
    /**
     * The time zone to be applied to any range query related to dates.
     * @type {string}
     * @memberof Query
     */
    'timeZone'?: string;
    /**
     * 
     * @type {InnerHit}
     * @memberof Query
     */
    'innerHit'?: InnerHit;
}
/**
 * Allows the query results to be filtered by specifying a list of fields to include and/or exclude from the result documents.
 * @export
 * @interface QueryResultFilter
 */
export interface QueryResultFilter {
    /**
     * The list of field names to include in the result documents.
     * @type {Array<string>}
     * @memberof QueryResultFilter
     */
    'includes'?: Array<string>;
    /**
     * The list of field names to exclude from the result documents.
     * @type {Array<string>}
     * @memberof QueryResultFilter
     */
    'excludes'?: Array<string>;
}
/**
 * The type of query to use.  By default, the `SAILPOINT` query type is used, which requires the `query` object to be defined in the request body. To use the `queryDsl` or `typeAheadQuery` objects in the request, you must set the type to `DSL` or `TYPEAHEAD` accordingly. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const QueryType = {
    Dsl: 'DSL',
    Sailpoint: 'SAILPOINT',
    Text: 'TEXT',
    Typeahead: 'TYPEAHEAD'
} as const;

export type QueryType = typeof QueryType[keyof typeof QueryType];


/**
 * Configuration of maximum number days and interval for checking Service Desk integration queue status
 * @export
 * @interface QueuedCheckConfigDetails
 */
export interface QueuedCheckConfigDetails {
    /**
     * interval in minutes between status checks
     * @type {string}
     * @memberof QueuedCheckConfigDetails
     */
    'provisioningStatusCheckIntervalMinutes': string;
    /**
     * maximum number of days to check
     * @type {string}
     * @memberof QueuedCheckConfigDetails
     */
    'provisioningMaxStatusCheckDays': string;
}
/**
 * 
 * @export
 * @interface RandomAlphaNumeric
 */
export interface RandomAlphaNumeric {
    /**
     * This is an integer value specifying the size/number of characters the random string must contain   * This value must be a positive number and cannot be blank   * If no length is provided, the transform will default to a value of `32`   * Due to identity attribute data constraints, the maximum allowable value is `450` characters 
     * @type {string}
     * @memberof RandomAlphaNumeric
     */
    'length'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof RandomAlphaNumeric
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof RandomAlphaNumeric
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface RandomNumeric
 */
export interface RandomNumeric {
    /**
     * This is an integer value specifying the size/number of characters the random string must contain   * This value must be a positive number and cannot be blank   * If no length is provided, the transform will default to a value of `32`   * Due to identity attribute data constraints, the maximum allowable value is `450` characters 
     * @type {string}
     * @memberof RandomNumeric
     */
    'length'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof RandomNumeric
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof RandomNumeric
     */
    'input'?: { [key: string]: any; };
}
/**
 * The range of values to be filtered.
 * @export
 * @interface Range
 */
export interface Range {
    /**
     * 
     * @type {Bound}
     * @memberof Range
     */
    'lower'?: Bound;
    /**
     * 
     * @type {Bound}
     * @memberof Range
     */
    'upper'?: Bound;
}
/**
 * 
 * @export
 * @interface ReassignReference
 */
export interface ReassignReference {
    /**
     * The ID of item or identity being reassigned.
     * @type {string}
     * @memberof ReassignReference
     */
    'id': string;
    /**
     * The type of item or identity being reassigned.
     * @type {string}
     * @memberof ReassignReference
     */
    'type': ReassignReferenceTypeEnum;
}

export const ReassignReferenceTypeEnum = {
    TargetSummary: 'TARGET_SUMMARY',
    Item: 'ITEM',
    IdentitySummary: 'IDENTITY_SUMMARY'
} as const;

export type ReassignReferenceTypeEnum = typeof ReassignReferenceTypeEnum[keyof typeof ReassignReferenceTypeEnum];

/**
 * 
 * @export
 * @interface Reassignment
 */
export interface Reassignment {
    /**
     * 
     * @type {CertificationReference}
     * @memberof Reassignment
     */
    'from'?: CertificationReference;
    /**
     * The comment entered when the Certification was reassigned
     * @type {string}
     * @memberof Reassignment
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface ReassignmentReference
 */
export interface ReassignmentReference {
    /**
     * The ID of item or identity being reassigned.
     * @type {string}
     * @memberof ReassignmentReference
     */
    'id': string;
    /**
     * The type of item or identity being reassigned.
     * @type {string}
     * @memberof ReassignmentReference
     */
    'type': ReassignmentReferenceTypeEnum;
}

export const ReassignmentReferenceTypeEnum = {
    TargetSummary: 'TARGET_SUMMARY',
    Item: 'ITEM',
    IdentitySummary: 'IDENTITY_SUMMARY'
} as const;

export type ReassignmentReferenceTypeEnum = typeof ReassignmentReferenceTypeEnum[keyof typeof ReassignmentReferenceTypeEnum];

/**
 * 
 * @export
 * @interface ReassignmentTrailDTO
 */
export interface ReassignmentTrailDTO {
    /**
     * The ID of previous owner identity.
     * @type {string}
     * @memberof ReassignmentTrailDTO
     */
    'previousOwner'?: string;
    /**
     * The ID of new owner identity.
     * @type {string}
     * @memberof ReassignmentTrailDTO
     */
    'newOwner'?: string;
    /**
     * The type of reassignment.
     * @type {string}
     * @memberof ReassignmentTrailDTO
     */
    'reassignmentType'?: string;
}
/**
 * The approval reassignment type.  * MANUAL_REASSIGNMENT: An approval with this reassignment type has been specifically reassigned by the approval task\'s owner, from their queue to someone else\'s.  * AUTOMATIC_REASSIGNMENT: An approval with this reassignment type has been automatically reassigned from another approver\'s queue, according to that approver\'s reassignment configuration. The approver\'s reassignment configuration may be set up to automatically reassign approval tasks for a defined (or possibly open-ended) period of time. * AUTO_ESCALATION: An approval with this reassignment type has been automatically reassigned from another approver\'s queue, according to the request\'s escalation configuration. For more information about escalation configuration, refer to [Setting Global Reminders and Escalation Policies](https://documentation.sailpoint.com/saas/help/requests/config_emails.html). * SELF_REVIEW_DELEGATION: An approval with this reassignment type has been automatically reassigned by the system to prevent self-review. This helps prevent situations like a requester being tasked with approving their own request. For more information about preventing self-review, refer to [Self-review Prevention](https://documentation.sailpoint.com/saas/help/users/work_reassignment.html#self-review-prevention) and [Preventing Self-approval](https://documentation.sailpoint.com/saas/help/requests/config_ap_roles.html#preventing-self-approval).
 * @export
 * @enum {string}
 */

export const ReassignmentType = {
    ManualReassignment: 'MANUAL_REASSIGNMENT',
    AutomaticReassignment: 'AUTOMATIC_REASSIGNMENT',
    AutoEscalation: 'AUTO_ESCALATION',
    SelfReviewDelegation: 'SELF_REVIEW_DELEGATION'
} as const;

export type ReassignmentType = typeof ReassignmentType[keyof typeof ReassignmentType];


/**
 * 
 * @export
 * @interface Reference
 */
export interface Reference {
    /**
     * This ID specifies the name of the pre-existing transform which you want to use within your current transform
     * @type {string}
     * @memberof Reference
     */
    'id': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Reference
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Reference
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Reference1
 */
export interface Reference1 {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof Reference1
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof Reference1
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface RemediationItemDetails
 */
export interface RemediationItemDetails {
    /**
     * The ID of the certification
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'id'?: string;
    /**
     * The ID of the certification target
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'targetId'?: string;
    /**
     * The name of the certification target
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'targetName'?: string;
    /**
     * The display name of the certification target
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'targetDisplayName'?: string;
    /**
     * The name of the application/source
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'applicationName'?: string;
    /**
     * The name of the attribute being certified
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'attributeName'?: string;
    /**
     * The operation of the certification on the attribute
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'attributeOperation'?: string;
    /**
     * The value of the attribute being certified
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'attributeValue'?: string;
    /**
     * The native identity of the target
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'nativeIdentity'?: string;
}
/**
 * 
 * @export
 * @interface RemediationItems
 */
export interface RemediationItems {
    /**
     * The ID of the certification
     * @type {string}
     * @memberof RemediationItems
     */
    'id'?: string;
    /**
     * The ID of the certification target
     * @type {string}
     * @memberof RemediationItems
     */
    'targetId'?: string;
    /**
     * The name of the certification target
     * @type {string}
     * @memberof RemediationItems
     */
    'targetName'?: string;
    /**
     * The display name of the certification target
     * @type {string}
     * @memberof RemediationItems
     */
    'targetDisplayName'?: string;
    /**
     * The name of the application/source
     * @type {string}
     * @memberof RemediationItems
     */
    'applicationName'?: string;
    /**
     * The name of the attribute being certified
     * @type {string}
     * @memberof RemediationItems
     */
    'attributeName'?: string;
    /**
     * The operation of the certification on the attribute
     * @type {string}
     * @memberof RemediationItems
     */
    'attributeOperation'?: string;
    /**
     * The value of the attribute being certified
     * @type {string}
     * @memberof RemediationItems
     */
    'attributeValue'?: string;
    /**
     * The native identity of the target
     * @type {string}
     * @memberof RemediationItems
     */
    'nativeIdentity'?: string;
}
/**
 * 
 * @export
 * @interface Replace
 */
export interface Replace {
    /**
     * This can be a string or a regex pattern in which you want to replace.
     * @type {string}
     * @memberof Replace
     */
    'regex': string;
    /**
     * This is the replacement string that should be substituded wherever the string or pattern is found.
     * @type {string}
     * @memberof Replace
     */
    'replacement': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Replace
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Replace
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ReplaceAll
 */
export interface ReplaceAll {
    /**
     * An attribute of key-value pairs. Each pair identifies the pattern to search for as its key, and the replacement string as its value.
     * @type {{ [key: string]: any; }}
     * @memberof ReplaceAll
     */
    'table': { [key: string]: any; };
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof ReplaceAll
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof ReplaceAll
     */
    'input'?: { [key: string]: any; };
}
/**
 * Details about report to be processed.
 * @export
 * @interface ReportDetails
 */
export interface ReportDetails {
    /**
     * Use this property to define what report should be processed in the RDE service.
     * @type {string}
     * @memberof ReportDetails
     */
    'reportType'?: ReportDetailsReportTypeEnum;
    /**
     * 
     * @type {ReportDetailsArguments}
     * @memberof ReportDetails
     */
    'arguments'?: ReportDetailsArguments;
}

export const ReportDetailsReportTypeEnum = {
    Accounts: 'ACCOUNTS',
    IdentitiesDetails: 'IDENTITIES_DETAILS',
    Identities: 'IDENTITIES',
    IdentityProfileIdentityError: 'IDENTITY_PROFILE_IDENTITY_ERROR',
    OrphanIdentities: 'ORPHAN_IDENTITIES',
    SearchExport: 'SEARCH_EXPORT',
    UncorrelatedAccounts: 'UNCORRELATED_ACCOUNTS'
} as const;

export type ReportDetailsReportTypeEnum = typeof ReportDetailsReportTypeEnum[keyof typeof ReportDetailsReportTypeEnum];

/**
 * @type ReportDetailsArguments
 * The string-object map(dictionary) with the arguments needed for report processing.
 * @export
 */
export type ReportDetailsArguments = AccountsExportReportArguments | IdentitiesDetailsReportArguments | IdentitiesReportArguments | IdentityProfileIdentityErrorReportArguments | OrphanUncorrelatedReportArguments | SearchExportReportArguments;

/**
 * 
 * @export
 * @interface ReportResultReference
 */
export interface ReportResultReference {
    /**
     * SOD policy violation report result DTO type.
     * @type {string}
     * @memberof ReportResultReference
     */
    'type'?: ReportResultReferenceTypeEnum;
    /**
     * SOD policy violation report result ID.
     * @type {string}
     * @memberof ReportResultReference
     */
    'id'?: string;
    /**
     * Human-readable name of the SOD policy violation report result.
     * @type {string}
     * @memberof ReportResultReference
     */
    'name'?: string;
    /**
     * Status of a SOD policy violation report.
     * @type {string}
     * @memberof ReportResultReference
     */
    'status'?: ReportResultReferenceStatusEnum;
}

export const ReportResultReferenceTypeEnum = {
    ReportResult: 'REPORT_RESULT'
} as const;

export type ReportResultReferenceTypeEnum = typeof ReportResultReferenceTypeEnum[keyof typeof ReportResultReferenceTypeEnum];
export const ReportResultReferenceStatusEnum = {
    Success: 'SUCCESS',
    Warning: 'WARNING',
    Error: 'ERROR',
    Terminated: 'TERMINATED',
    TempError: 'TEMP_ERROR',
    Pending: 'PENDING'
} as const;

export type ReportResultReferenceStatusEnum = typeof ReportResultReferenceStatusEnum[keyof typeof ReportResultReferenceStatusEnum];

/**
 * Details about report result or current state.
 * @export
 * @interface ReportResults
 */
export interface ReportResults {
    /**
     * Use this property to define what report should be processed in the RDE service.
     * @type {string}
     * @memberof ReportResults
     */
    'reportType'?: ReportResultsReportTypeEnum;
    /**
     * Name of the task definition which is started to process requesting report. Usually the same as report name
     * @type {string}
     * @memberof ReportResults
     */
    'taskDefName'?: string;
    /**
     * Unique task definition identifier.
     * @type {string}
     * @memberof ReportResults
     */
    'id'?: string;
    /**
     * Report processing start date
     * @type {string}
     * @memberof ReportResults
     */
    'created'?: string;
    /**
     * Report current state or result status.
     * @type {string}
     * @memberof ReportResults
     */
    'status'?: ReportResultsStatusEnum;
    /**
     * Report processing time in ms.
     * @type {number}
     * @memberof ReportResults
     */
    'duration'?: number;
    /**
     * Report size in rows.
     * @type {number}
     * @memberof ReportResults
     */
    'rows'?: number;
    /**
     * Output report file formats. This are formats for calling get endpoint as a query parameter \'fileFormat\'.  In case report won\'t have this argument there will be [\'CSV\', \'PDF\'] as default.
     * @type {Array<string>}
     * @memberof ReportResults
     */
    'availableFormats'?: Array<ReportResultsAvailableFormatsEnum>;
}

export const ReportResultsReportTypeEnum = {
    Accounts: 'ACCOUNTS',
    IdentitiesDetails: 'IDENTITIES_DETAILS',
    Identities: 'IDENTITIES',
    IdentityProfileIdentityError: 'IDENTITY_PROFILE_IDENTITY_ERROR',
    OrphanIdentities: 'ORPHAN_IDENTITIES',
    SearchExport: 'SEARCH_EXPORT',
    UncorrelatedAccounts: 'UNCORRELATED_ACCOUNTS'
} as const;

export type ReportResultsReportTypeEnum = typeof ReportResultsReportTypeEnum[keyof typeof ReportResultsReportTypeEnum];
export const ReportResultsStatusEnum = {
    Success: 'SUCCESS',
    Failure: 'FAILURE',
    Warning: 'WARNING',
    Terminated: 'TERMINATED'
} as const;

export type ReportResultsStatusEnum = typeof ReportResultsStatusEnum[keyof typeof ReportResultsStatusEnum];
export const ReportResultsAvailableFormatsEnum = {
    Csv: 'CSV',
    Pdf: 'PDF'
} as const;

export type ReportResultsAvailableFormatsEnum = typeof ReportResultsAvailableFormatsEnum[keyof typeof ReportResultsAvailableFormatsEnum];

/**
 * type of a Report
 * @export
 * @enum {string}
 */

export const ReportType = {
    CampaignCompositionReport: 'CAMPAIGN_COMPOSITION_REPORT',
    CampaignRemediationStatusReport: 'CAMPAIGN_REMEDIATION_STATUS_REPORT',
    CampaignStatusReport: 'CAMPAIGN_STATUS_REPORT',
    CertificationSignoffReport: 'CERTIFICATION_SIGNOFF_REPORT'
} as const;

export type ReportType = typeof ReportType[keyof typeof ReportType];


/**
 * 
 * @export
 * @interface RequestOnBehalfOfConfig
 */
export interface RequestOnBehalfOfConfig {
    /**
     * If anyone can request access for anyone.
     * @type {boolean}
     * @memberof RequestOnBehalfOfConfig
     */
    'allowRequestOnBehalfOfAnyoneByAnyone'?: boolean;
    /**
     * If a manager can request access for his/her direct reports.
     * @type {boolean}
     * @memberof RequestOnBehalfOfConfig
     */
    'allowRequestOnBehalfOfEmployeeByManager'?: boolean;
}
/**
 * 
 * @export
 * @interface Requestability
 */
export interface Requestability {
    /**
     * Whether the requester of the containing object must provide comments justifying the request
     * @type {boolean}
     * @memberof Requestability
     */
    'commentsRequired'?: boolean;
    /**
     * Whether an approver must provide comments when denying the request
     * @type {boolean}
     * @memberof Requestability
     */
    'denialCommentsRequired'?: boolean;
    /**
     * List describing the steps in approving the request
     * @type {Array<AccessProfileApprovalScheme>}
     * @memberof Requestability
     */
    'approvalSchemes'?: Array<AccessProfileApprovalScheme>;
}
/**
 * 
 * @export
 * @interface RequestabilityForRole
 */
export interface RequestabilityForRole {
    /**
     * Whether the requester of the containing object must provide comments justifying the request
     * @type {boolean}
     * @memberof RequestabilityForRole
     */
    'commentsRequired'?: boolean | null;
    /**
     * Whether an approver must provide comments when denying the request
     * @type {boolean}
     * @memberof RequestabilityForRole
     */
    'denialCommentsRequired'?: boolean | null;
    /**
     * List describing the steps in approving the request
     * @type {Array<ApprovalSchemeForRole>}
     * @memberof RequestabilityForRole
     */
    'approvalSchemes'?: Array<ApprovalSchemeForRole>;
}
/**
 * 
 * @export
 * @interface RequestableObject
 */
export interface RequestableObject {
    /**
     * Id of the requestable object itself
     * @type {string}
     * @memberof RequestableObject
     */
    'id'?: string;
    /**
     * Human-readable display name of the requestable object
     * @type {string}
     * @memberof RequestableObject
     */
    'name'?: string;
    /**
     * The time when the requestable object was created
     * @type {string}
     * @memberof RequestableObject
     */
    'created'?: string;
    /**
     * The time when the requestable object was last modified
     * @type {string}
     * @memberof RequestableObject
     */
    'modified'?: string | null;
    /**
     * Description of the requestable object.
     * @type {string}
     * @memberof RequestableObject
     */
    'description'?: string;
    /**
     * 
     * @type {RequestableObjectType}
     * @memberof RequestableObject
     */
    'type'?: RequestableObjectType;
    /**
     * 
     * @type {RequestableObjectRequestStatus}
     * @memberof RequestableObject
     */
    'requestStatus'?: RequestableObjectRequestStatus;
    /**
     * If *requestStatus* is *PENDING*, indicates the id of the associated account activity.
     * @type {string}
     * @memberof RequestableObject
     */
    'identityRequestId'?: string | null;
    /**
     * 
     * @type {IdentityReferenceWithNameAndEmail}
     * @memberof RequestableObject
     */
    'ownerRef'?: IdentityReferenceWithNameAndEmail | null;
    /**
     * Whether the requester must provide comments when requesting the object.
     * @type {boolean}
     * @memberof RequestableObject
     */
    'requestCommentsRequired'?: boolean;
}


/**
 * 
 * @export
 * @interface RequestableObjectReference
 */
export interface RequestableObjectReference {
    /**
     * Id of the object.
     * @type {string}
     * @memberof RequestableObjectReference
     */
    'id'?: string;
    /**
     * Name of the object.
     * @type {string}
     * @memberof RequestableObjectReference
     */
    'name'?: string;
    /**
     * Description of the object.
     * @type {string}
     * @memberof RequestableObjectReference
     */
    'description'?: string;
    /**
     * Type of the object.
     * @type {string}
     * @memberof RequestableObjectReference
     */
    'type'?: RequestableObjectReferenceTypeEnum;
}

export const RequestableObjectReferenceTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE',
    Entitlement: 'ENTITLEMENT'
} as const;

export type RequestableObjectReferenceTypeEnum = typeof RequestableObjectReferenceTypeEnum[keyof typeof RequestableObjectReferenceTypeEnum];

/**
 * Status indicating the ability of an access request for the object to be made by or on behalf of the identity specified by *identity-id*. *AVAILABLE* indicates the object is available to request. *PENDING* indicates the object is unavailable because the identity has a pending request in flight. *ASSIGNED* indicates the object is unavailable because the identity already has the indicated role or access profile. If *identity-id* is not specified (allowed only for admin users), then status will be *AVAILABLE* for all results.
 * @export
 * @enum {string}
 */

export const RequestableObjectRequestStatus = {
    Available: 'AVAILABLE',
    Pending: 'PENDING',
    Assigned: 'ASSIGNED'
} as const;

export type RequestableObjectRequestStatus = typeof RequestableObjectRequestStatus[keyof typeof RequestableObjectRequestStatus];


/**
 * The currently supported requestable object types. 
 * @export
 * @enum {string}
 */

export const RequestableObjectType = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE'
} as const;

export type RequestableObjectType = typeof RequestableObjectType[keyof typeof RequestableObjectType];


/**
 * 
 * @export
 * @interface RequestedItemStatus
 */
export interface RequestedItemStatus {
    /**
     * Human-readable display name of the item being requested.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'name'?: string;
    /**
     * Type of requested object.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'type'?: RequestedItemStatusTypeEnum;
    /**
     * 
     * @type {CancelledRequestDetails}
     * @memberof RequestedItemStatus
     */
    'cancelledRequestDetails'?: CancelledRequestDetails;
    /**
     * List of list of localized error messages, if any, encountered during the approval/provisioning process.
     * @type {Array<Array<ErrorMessageDto>>}
     * @memberof RequestedItemStatus
     */
    'errorMessages'?: Array<Array<ErrorMessageDto>> | null;
    /**
     * 
     * @type {RequestedItemStatusRequestState}
     * @memberof RequestedItemStatus
     */
    'state'?: RequestedItemStatusRequestState;
    /**
     * Approval details for each item.
     * @type {Array<ApprovalStatusDto>}
     * @memberof RequestedItemStatus
     */
    'approvalDetails'?: Array<ApprovalStatusDto>;
    /**
     * Manual work items created for provisioning the item.
     * @type {Array<ManualWorkItemDetails>}
     * @memberof RequestedItemStatus
     */
    'manualWorkItemDetails'?: Array<ManualWorkItemDetails> | null;
    /**
     * Id of associated account activity item.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'accountActivityItemId'?: string;
    /**
     * 
     * @type {AccessRequestType}
     * @memberof RequestedItemStatus
     */
    'requestType'?: AccessRequestType;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'created'?: string;
    /**
     * 
     * @type {AccessItemRequester}
     * @memberof RequestedItemStatus
     */
    'requester'?: AccessItemRequester;
    /**
     * 
     * @type {AccessItemRequestedFor}
     * @memberof RequestedItemStatus
     */
    'requestedFor'?: AccessItemRequestedFor;
    /**
     * 
     * @type {CommentDto}
     * @memberof RequestedItemStatus
     */
    'requesterComment'?: CommentDto;
    /**
     * 
     * @type {SodViolationContextCheckCompleted}
     * @memberof RequestedItemStatus
     */
    'sodViolationContext'?: SodViolationContextCheckCompleted;
    /**
     * 
     * @type {ProvisioningDetails}
     * @memberof RequestedItemStatus
     */
    'provisioningDetails'?: ProvisioningDetails;
    /**
     * 
     * @type {PreApprovalTriggerDetails}
     * @memberof RequestedItemStatus
     */
    'preApprovalTriggerDetails'?: PreApprovalTriggerDetails;
    /**
     * A list of Phases that the Access Request has gone through in order, to help determine the status of the request.
     * @type {Array<AccessRequestPhases>}
     * @memberof RequestedItemStatus
     */
    'accessRequestPhases'?: Array<AccessRequestPhases>;
    /**
     * Description associated to the requested object.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'description'?: string;
    /**
     * When the role access is scheduled for removal.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'removeDate'?: string | null;
    /**
     * True if the request can be canceled.
     * @type {boolean}
     * @memberof RequestedItemStatus
     */
    'cancelable'?: boolean;
    /**
     * This is the account activity id.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'accessRequestId'?: string;
    /**
     * Arbitrary key-value pairs, if any were included in the corresponding access request
     * @type {{ [key: string]: string; }}
     * @memberof RequestedItemStatus
     */
    'clientMetadata'?: { [key: string]: string; } | null;
}

export const RequestedItemStatusTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE',
    Entitlement: 'ENTITLEMENT'
} as const;

export type RequestedItemStatusTypeEnum = typeof RequestedItemStatusTypeEnum[keyof typeof RequestedItemStatusTypeEnum];

/**
 * Indicates the state of an access request: * EXECUTING: The request is executing, which indicates the system is doing some processing. * REQUEST_COMPLETED: Indicates the request  has been completed. * CANCELLED: The request was cancelled with no user input. * TERMINATED: The request has been terminated before it was able to complete. * PROVISIONING_VERIFICATION_PENDING: The request has finished any approval steps and provisioning is waiting to be verified. * REJECTED: The request was rejected. * PROVISIONING_FAILED: The request has failed to complete. * NOT_ALL_ITEMS_PROVISIONED: One or more of the requested items failed to complete, but there were one or more  successes. * ERROR: An error occurred during request processing.
 * @export
 * @enum {string}
 */

export const RequestedItemStatusRequestState = {
    Executing: 'EXECUTING',
    RequestCompleted: 'REQUEST_COMPLETED',
    Cancelled: 'CANCELLED',
    Terminated: 'TERMINATED',
    ProvisioningVerificationPending: 'PROVISIONING_VERIFICATION_PENDING',
    Rejected: 'REJECTED',
    ProvisioningFailed: 'PROVISIONING_FAILED',
    NotAllItemsProvisioned: 'NOT_ALL_ITEMS_PROVISIONED',
    Error: 'ERROR'
} as const;

export type RequestedItemStatusRequestState = typeof RequestedItemStatusRequestState[keyof typeof RequestedItemStatusRequestState];


/**
 * 
 * @export
 * @interface ReviewDecision
 */
export interface ReviewDecision {
    /**
     * The id of the review decision
     * @type {string}
     * @memberof ReviewDecision
     */
    'id': string;
    /**
     * 
     * @type {CertificationDecision}
     * @memberof ReviewDecision
     */
    'decision': CertificationDecision;
    /**
     * The date at which a user\'s access should be taken away. Should only be set for `REVOKE` decisions.
     * @type {string}
     * @memberof ReviewDecision
     */
    'proposedEndDate'?: string;
    /**
     * Indicates whether decision should be marked as part of a larger bulk decision
     * @type {boolean}
     * @memberof ReviewDecision
     */
    'bulk': boolean;
    /**
     * 
     * @type {ReviewRecommendation}
     * @memberof ReviewDecision
     */
    'recommendation'?: ReviewRecommendation;
    /**
     * Comments recorded when the decision was made
     * @type {string}
     * @memberof ReviewDecision
     */
    'comments'?: string;
}


/**
 * 
 * @export
 * @interface ReviewReassign
 */
export interface ReviewReassign {
    /**
     * 
     * @type {Array<ReassignReference>}
     * @memberof ReviewReassign
     */
    'reassign': Array<ReassignReference>;
    /**
     * The ID of the identity to which the certification is reassigned
     * @type {string}
     * @memberof ReviewReassign
     */
    'reassignTo': string;
    /**
     * The reason comment for why the reassign was made
     * @type {string}
     * @memberof ReviewReassign
     */
    'reason': string;
}
/**
 * 
 * @export
 * @interface ReviewRecommendation
 */
export interface ReviewRecommendation {
    /**
     * The recommendation from IAI at the time of the decision. This field will be null if no recommendation was made.
     * @type {string}
     * @memberof ReviewRecommendation
     */
    'recommendation'?: string | null;
    /**
     * A list of reasons for the recommendation.
     * @type {Array<string>}
     * @memberof ReviewRecommendation
     */
    'reasons'?: Array<string>;
    /**
     * The time at which the recommendation was recorded.
     * @type {string}
     * @memberof ReviewRecommendation
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface ReviewableAccessProfile
 */
export interface ReviewableAccessProfile {
    /**
     * The id of the Access Profile
     * @type {string}
     * @memberof ReviewableAccessProfile
     */
    'id'?: string;
    /**
     * Name of the Access Profile
     * @type {string}
     * @memberof ReviewableAccessProfile
     */
    'name'?: string;
    /**
     * Information about the Access Profile
     * @type {string}
     * @memberof ReviewableAccessProfile
     */
    'description'?: string;
    /**
     * Indicates if the entitlement is a privileged entitlement
     * @type {boolean}
     * @memberof ReviewableAccessProfile
     */
    'privileged'?: boolean;
    /**
     * True if the entitlement is cloud governed
     * @type {boolean}
     * @memberof ReviewableAccessProfile
     */
    'cloudGoverned'?: boolean;
    /**
     * The date at which a user\'s access expires
     * @type {string}
     * @memberof ReviewableAccessProfile
     */
    'endDate'?: string | null;
    /**
     * 
     * @type {IdentityReferenceWithNameAndEmail}
     * @memberof ReviewableAccessProfile
     */
    'owner'?: IdentityReferenceWithNameAndEmail | null;
    /**
     * A list of entitlements associated with this Access Profile
     * @type {Array<ReviewableEntitlement>}
     * @memberof ReviewableAccessProfile
     */
    'entitlements'?: Array<ReviewableEntitlement>;
    /**
     * Date the Access Profile was created.
     * @type {string}
     * @memberof ReviewableAccessProfile
     */
    'created'?: string;
    /**
     * Date the Access Profile was last modified.
     * @type {string}
     * @memberof ReviewableAccessProfile
     */
    'modified'?: string;
}
/**
 * 
 * @export
 * @interface ReviewableEntitlement
 */
export interface ReviewableEntitlement {
    /**
     * The id for the entitlement
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'id'?: string;
    /**
     * The name of the entitlement
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'name'?: string;
    /**
     * Information about the entitlement
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'description'?: string | null;
    /**
     * Indicates if the entitlement is a privileged entitlement
     * @type {boolean}
     * @memberof ReviewableEntitlement
     */
    'privileged'?: boolean;
    /**
     * 
     * @type {IdentityReferenceWithNameAndEmail}
     * @memberof ReviewableEntitlement
     */
    'owner'?: IdentityReferenceWithNameAndEmail | null;
    /**
     * The name of the attribute on the source
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'attributeName'?: string;
    /**
     * The value of the attribute on the source
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'attributeValue'?: string;
    /**
     * The schema object type on the source used to represent the entitlement and its attributes
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'sourceSchemaObjectType'?: string;
    /**
     * The name of the source for which this entitlement belongs
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'sourceName'?: string;
    /**
     * The type of the source for which the entitlement belongs
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'sourceType'?: string;
    /**
     * The ID of the source for which the entitlement belongs
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'sourceId'?: string;
    /**
     * Indicates if the entitlement has permissions
     * @type {boolean}
     * @memberof ReviewableEntitlement
     */
    'hasPermissions'?: boolean;
    /**
     * Indicates if the entitlement is a representation of an account permission
     * @type {boolean}
     * @memberof ReviewableEntitlement
     */
    'isPermission'?: boolean;
    /**
     * Indicates whether the entitlement can be revoked
     * @type {boolean}
     * @memberof ReviewableEntitlement
     */
    'revocable'?: boolean;
    /**
     * True if the entitlement is cloud governed
     * @type {boolean}
     * @memberof ReviewableEntitlement
     */
    'cloudGoverned'?: boolean;
    /**
     * True if the entitlement has DAS data
     * @type {boolean}
     * @memberof ReviewableEntitlement
     */
    'containsDataAccess'?: boolean;
    /**
     * 
     * @type {DataAccess}
     * @memberof ReviewableEntitlement
     */
    'dataAccess'?: DataAccess | null;
    /**
     * 
     * @type {ReviewableEntitlementAccount}
     * @memberof ReviewableEntitlement
     */
    'account'?: ReviewableEntitlementAccount | null;
}
/**
 * Information about the status of the entitlement
 * @export
 * @interface ReviewableEntitlementAccount
 */
export interface ReviewableEntitlementAccount {
    /**
     * The native identity for this account
     * @type {string}
     * @memberof ReviewableEntitlementAccount
     */
    'nativeIdentity'?: string;
    /**
     * Indicates whether this account is currently disabled
     * @type {boolean}
     * @memberof ReviewableEntitlementAccount
     */
    'disabled'?: boolean;
    /**
     * Indicates whether this account is currently locked
     * @type {boolean}
     * @memberof ReviewableEntitlementAccount
     */
    'locked'?: boolean;
    /**
     * 
     * @type {DtoType}
     * @memberof ReviewableEntitlementAccount
     */
    'type'?: DtoType;
    /**
     * The id associated with the account
     * @type {string}
     * @memberof ReviewableEntitlementAccount
     */
    'id'?: string | null;
    /**
     * The account name
     * @type {string}
     * @memberof ReviewableEntitlementAccount
     */
    'name'?: string | null;
    /**
     * When the account was created
     * @type {string}
     * @memberof ReviewableEntitlementAccount
     */
    'created'?: string | null;
    /**
     * When the account was last modified
     * @type {string}
     * @memberof ReviewableEntitlementAccount
     */
    'modified'?: string | null;
}


/**
 * 
 * @export
 * @interface ReviewableRole
 */
export interface ReviewableRole {
    /**
     * The id for the Role
     * @type {string}
     * @memberof ReviewableRole
     */
    'id'?: string;
    /**
     * The name of the Role
     * @type {string}
     * @memberof ReviewableRole
     */
    'name'?: string;
    /**
     * Information about the Role
     * @type {string}
     * @memberof ReviewableRole
     */
    'description'?: string;
    /**
     * Indicates if the entitlement is a privileged entitlement
     * @type {boolean}
     * @memberof ReviewableRole
     */
    'privileged'?: boolean;
    /**
     * 
     * @type {IdentityReferenceWithNameAndEmail}
     * @memberof ReviewableRole
     */
    'owner'?: IdentityReferenceWithNameAndEmail | null;
    /**
     * Indicates whether the Role can be revoked or requested
     * @type {boolean}
     * @memberof ReviewableRole
     */
    'revocable'?: boolean;
    /**
     * The date when a user\'s access expires.
     * @type {string}
     * @memberof ReviewableRole
     */
    'endDate'?: string;
    /**
     * The list of Access Profiles associated with this Role
     * @type {Array<ReviewableAccessProfile>}
     * @memberof ReviewableRole
     */
    'accessProfiles'?: Array<ReviewableAccessProfile>;
}
/**
 * 
 * @export
 * @interface Reviewer
 */
export interface Reviewer {
    /**
     * The id of the reviewer.
     * @type {string}
     * @memberof Reviewer
     */
    'id'?: string;
    /**
     * The name of the reviewer.
     * @type {string}
     * @memberof Reviewer
     */
    'name'?: string;
    /**
     * The email of the reviewing identity.
     * @type {string}
     * @memberof Reviewer
     */
    'email'?: string;
    /**
     * The type of the reviewing identity.
     * @type {string}
     * @memberof Reviewer
     */
    'type'?: ReviewerTypeEnum;
    /**
     * The created date of the reviewing identity.
     * @type {string}
     * @memberof Reviewer
     */
    'created'?: string | null;
    /**
     * The modified date of the reviewing identity.
     * @type {string}
     * @memberof Reviewer
     */
    'modified'?: string | null;
}

export const ReviewerTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type ReviewerTypeEnum = typeof ReviewerTypeEnum[keyof typeof ReviewerTypeEnum];

/**
 * 
 * @export
 * @interface Revocability
 */
export interface Revocability {
    /**
     * Whether the requester of the containing object must provide comments justifying the request
     * @type {boolean}
     * @memberof Revocability
     */
    'commentsRequired'?: boolean | null;
    /**
     * Whether an approver must provide comments when denying the request
     * @type {boolean}
     * @memberof Revocability
     */
    'denialCommentsRequired'?: boolean | null;
    /**
     * List describing the steps in approving the revocation request
     * @type {Array<AccessProfileApprovalScheme>}
     * @memberof Revocability
     */
    'approvalSchemes'?: Array<AccessProfileApprovalScheme>;
}
/**
 * 
 * @export
 * @interface RightPad
 */
export interface RightPad {
    /**
     * An integer value for the desired length of the final output string
     * @type {string}
     * @memberof RightPad
     */
    'length': string;
    /**
     * A string value representing the character that the incoming data should be padded with to get to the desired length   If not provided, the transform will default to a single space (\" \") character for padding 
     * @type {string}
     * @memberof RightPad
     */
    'padding'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof RightPad
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof RightPad
     */
    'input'?: { [key: string]: any; };
}
/**
 * A Role
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * The id of the Role. This field must be left null when creating an Role, otherwise a 400 Bad Request error will result.
     * @type {string}
     * @memberof Role
     */
    'id'?: string;
    /**
     * The human-readable display name of the Role
     * @type {string}
     * @memberof Role
     */
    'name': string;
    /**
     * Date the Role was created
     * @type {string}
     * @memberof Role
     */
    'created'?: string;
    /**
     * Date the Role was last modified.
     * @type {string}
     * @memberof Role
     */
    'modified'?: string;
    /**
     * A human-readable description of the Role
     * @type {string}
     * @memberof Role
     */
    'description'?: string | null;
    /**
     * 
     * @type {OwnerReference}
     * @memberof Role
     */
    'owner': OwnerReference;
    /**
     * 
     * @type {Array<AccessProfileRef>}
     * @memberof Role
     */
    'accessProfiles'?: Array<AccessProfileRef> | null;
    /**
     * 
     * @type {RoleMembershipSelector}
     * @memberof Role
     */
    'membership'?: RoleMembershipSelector | null;
    /**
     * This field is not directly modifiable and is generally expected to be *null*. In very rare instances, some Roles may have been created using membership selection criteria that are no longer fully supported. While these Roles will still work, they should be migrated to STANDARD or IDENTITY_LIST selection criteria. This field exists for informational purposes as an aid to such migration.
     * @type {{ [key: string]: any; }}
     * @memberof Role
     */
    'legacyMembershipInfo'?: { [key: string]: any; } | null;
    /**
     * Whether the Role is enabled or not.
     * @type {boolean}
     * @memberof Role
     */
    'enabled'?: boolean;
    /**
     * Whether the Role can be the target of access requests.
     * @type {boolean}
     * @memberof Role
     */
    'requestable'?: boolean;
    /**
     * 
     * @type {RequestabilityForRole}
     * @memberof Role
     */
    'accessRequestConfig'?: RequestabilityForRole;
    /**
     * 
     * @type {Revocability}
     * @memberof Role
     */
    'revocationRequestConfig'?: Revocability;
    /**
     * List of IDs of segments, if any, to which this Role is assigned.
     * @type {Array<string>}
     * @memberof Role
     */
    'segments'?: Array<string> | null;
}
/**
 * Type which indicates how a particular Identity obtained a particular Role
 * @export
 * @enum {string}
 */

export const RoleAssignmentSourceType = {
    AccessRequest: 'ACCESS_REQUEST',
    RoleMembership: 'ROLE_MEMBERSHIP'
} as const;

export type RoleAssignmentSourceType = typeof RoleAssignmentSourceType[keyof typeof RoleAssignmentSourceType];


/**
 * 
 * @export
 * @interface RoleBulkDeleteRequest
 */
export interface RoleBulkDeleteRequest {
    /**
     * List of IDs of Roles to be deleted.
     * @type {Array<string>}
     * @memberof RoleBulkDeleteRequest
     */
    'roleIds': Array<string>;
}
/**
 * Refers to a specific Identity attribute, Account attibute, or Entitlement used in Role membership criteria
 * @export
 * @interface RoleCriteriaKey
 */
export interface RoleCriteriaKey {
    /**
     * 
     * @type {RoleCriteriaKeyType}
     * @memberof RoleCriteriaKey
     */
    'type': RoleCriteriaKeyType;
    /**
     * The name of the attribute or entitlement to which the associated criteria applies.
     * @type {string}
     * @memberof RoleCriteriaKey
     */
    'property': string;
    /**
     * ID of the Source from which an account attribute or entitlement is drawn. Required if type is ACCOUNT or ENTITLEMENT
     * @type {string}
     * @memberof RoleCriteriaKey
     */
    'sourceId'?: string | null;
}


/**
 * Indicates whether the associated criteria represents an expression on identity attributes, account attributes, or entitlements, respectively.
 * @export
 * @enum {string}
 */

export const RoleCriteriaKeyType = {
    Identity: 'IDENTITY',
    Account: 'ACCOUNT',
    Entitlement: 'ENTITLEMENT'
} as const;

export type RoleCriteriaKeyType = typeof RoleCriteriaKeyType[keyof typeof RoleCriteriaKeyType];


/**
 * Defines STANDARD type Role membership
 * @export
 * @interface RoleCriteriaLevel1
 */
export interface RoleCriteriaLevel1 {
    /**
     * 
     * @type {RoleCriteriaOperation}
     * @memberof RoleCriteriaLevel1
     */
    'operation'?: RoleCriteriaOperation;
    /**
     * 
     * @type {RoleCriteriaKey}
     * @memberof RoleCriteriaLevel1
     */
    'key'?: RoleCriteriaKey | null;
    /**
     * String value to test the Identity attribute, Account attribute, or Entitlement specified in the key w/r/t the specified operation. If this criteria is a leaf node, that is, if the operation is one of EQUALS, NOT_EQUALS, CONTAINS, STARTS_WITH, or ENDS_WITH, this field is required. Otherwise, specifying it is an error.
     * @type {string}
     * @memberof RoleCriteriaLevel1
     */
    'stringValue'?: string | null;
    /**
     * Array of child criteria. Required if the operation is AND or OR, otherwise it must be left null. A maximum of three levels of criteria are supported, including leaf nodes. Additionally, AND nodes can only be children or OR nodes and vice-versa.
     * @type {Array<RoleCriteriaLevel2>}
     * @memberof RoleCriteriaLevel1
     */
    'children'?: Array<RoleCriteriaLevel2> | null;
}


/**
 * Defines STANDARD type Role membership
 * @export
 * @interface RoleCriteriaLevel2
 */
export interface RoleCriteriaLevel2 {
    /**
     * 
     * @type {RoleCriteriaOperation}
     * @memberof RoleCriteriaLevel2
     */
    'operation'?: RoleCriteriaOperation;
    /**
     * 
     * @type {RoleCriteriaKey}
     * @memberof RoleCriteriaLevel2
     */
    'key'?: RoleCriteriaKey | null;
    /**
     * String value to test the Identity attribute, Account attribute, or Entitlement specified in the key w/r/t the specified operation. If this criteria is a leaf node, that is, if the operation is one of EQUALS, NOT_EQUALS, CONTAINS, STARTS_WITH, or ENDS_WITH, this field is required. Otherwise, specifying it is an error.
     * @type {string}
     * @memberof RoleCriteriaLevel2
     */
    'stringValue'?: string | null;
    /**
     * Array of child criteria. Required if the operation is AND or OR, otherwise it must be left null. A maximum of three levels of criteria are supported, including leaf nodes. Additionally, AND nodes can only be children or OR nodes and vice-versa.
     * @type {Array<RoleCriteriaLevel3>}
     * @memberof RoleCriteriaLevel2
     */
    'children'?: Array<RoleCriteriaLevel3> | null;
}


/**
 * Defines STANDARD type Role membership
 * @export
 * @interface RoleCriteriaLevel3
 */
export interface RoleCriteriaLevel3 {
    /**
     * 
     * @type {RoleCriteriaOperation}
     * @memberof RoleCriteriaLevel3
     */
    'operation'?: RoleCriteriaOperation;
    /**
     * 
     * @type {RoleCriteriaKey}
     * @memberof RoleCriteriaLevel3
     */
    'key'?: RoleCriteriaKey | null;
    /**
     * String value to test the Identity attribute, Account attribute, or Entitlement specified in the key w/r/t the specified operation. If this criteria is a leaf node, that is, if the operation is one of EQUALS, NOT_EQUALS, CONTAINS, STARTS_WITH, or ENDS_WITH, this field is required. Otherwise, specifying it is an error.
     * @type {string}
     * @memberof RoleCriteriaLevel3
     */
    'stringValue'?: string;
}


/**
 * An operation
 * @export
 * @enum {string}
 */

export const RoleCriteriaOperation = {
    Equals: 'EQUALS',
    NotEquals: 'NOT_EQUALS',
    Contains: 'CONTAINS',
    StartsWith: 'STARTS_WITH',
    EndsWith: 'ENDS_WITH',
    And: 'AND',
    Or: 'OR'
} as const;

export type RoleCriteriaOperation = typeof RoleCriteriaOperation[keyof typeof RoleCriteriaOperation];


/**
 * Role
 * @export
 * @interface RoleDocument
 */
export interface RoleDocument {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof RoleDocument
     */
    'id': string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof RoleDocument
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof RoleDocument
     */
    '_type': DocumentType;
    /**
     * The description of the access item
     * @type {string}
     * @memberof RoleDocument
     */
    'description'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof RoleDocument
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof RoleDocument
     */
    'modified'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof RoleDocument
     */
    'synced'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof RoleDocument
     */
    'enabled'?: boolean;
    /**
     * Indicates if the access can be requested
     * @type {boolean}
     * @memberof RoleDocument
     */
    'requestable'?: boolean;
    /**
     * Indicates if comments are required when requesting access
     * @type {boolean}
     * @memberof RoleDocument
     */
    'requestCommentsRequired'?: boolean;
    /**
     * 
     * @type {Owner}
     * @memberof RoleDocument
     */
    'owner'?: Owner;
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof RoleDocument
     */
    'accessProfiles'?: Array<Reference1>;
    /**
     * 
     * @type {number}
     * @memberof RoleDocument
     */
    'accessProfileCount'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof RoleDocument
     */
    'tags'?: Array<string>;
}


/**
 * A subset of the fields of an Identity which is a member of a Role.
 * @export
 * @interface RoleIdentity
 */
export interface RoleIdentity {
    /**
     * The ID of the Identity
     * @type {string}
     * @memberof RoleIdentity
     */
    'id'?: string;
    /**
     * The alias / username of the Identity
     * @type {string}
     * @memberof RoleIdentity
     */
    'aliasName'?: string;
    /**
     * The human-readable display name of the Identity
     * @type {string}
     * @memberof RoleIdentity
     */
    'name'?: string;
    /**
     * Email address of the Identity
     * @type {string}
     * @memberof RoleIdentity
     */
    'email'?: string;
    /**
     * 
     * @type {RoleAssignmentSourceType}
     * @memberof RoleIdentity
     */
    'roleAssignmentSource'?: RoleAssignmentSourceType;
}


/**
 * A reference to an Identity in an IDENTITY_LIST role membership criteria.
 * @export
 * @interface RoleMembershipIdentity
 */
export interface RoleMembershipIdentity {
    /**
     * 
     * @type {DtoType}
     * @memberof RoleMembershipIdentity
     */
    'type'?: DtoType;
    /**
     * Identity id
     * @type {string}
     * @memberof RoleMembershipIdentity
     */
    'id'?: string;
    /**
     * Human-readable display name of the Identity.
     * @type {string}
     * @memberof RoleMembershipIdentity
     */
    'name'?: string | null;
    /**
     * User name of the Identity
     * @type {string}
     * @memberof RoleMembershipIdentity
     */
    'aliasName'?: string | null;
}


/**
 * When present, specifies that the Role is to be granted to Identities which either satisfy specific criteria or which are members of a given list of Identities.
 * @export
 * @interface RoleMembershipSelector
 */
export interface RoleMembershipSelector {
    /**
     * 
     * @type {RoleMembershipSelectorType}
     * @memberof RoleMembershipSelector
     */
    'type'?: RoleMembershipSelectorType;
    /**
     * 
     * @type {RoleCriteriaLevel1}
     * @memberof RoleMembershipSelector
     */
    'criteria'?: RoleCriteriaLevel1 | null;
    /**
     * Defines role membership as being exclusive to the specified Identities, when type is IDENTITY_LIST.
     * @type {Array<RoleMembershipIdentity>}
     * @memberof RoleMembershipSelector
     */
    'identities'?: Array<RoleMembershipIdentity> | null;
}


/**
 * This enum characterizes the type of a Role\'s membership selector. Only the following two are fully supported:  STANDARD: Indicates that Role membership is defined in terms of a criteria expression  IDENTITY_LIST: Indicates that Role membership is conferred on the specific identities listed
 * @export
 * @enum {string}
 */

export const RoleMembershipSelectorType = {
    Standard: 'STANDARD',
    IdentityList: 'IDENTITY_LIST'
} as const;

export type RoleMembershipSelectorType = typeof RoleMembershipSelectorType[keyof typeof RoleMembershipSelectorType];


/**
 * Role
 * @export
 * @interface RoleSummary
 */
export interface RoleSummary {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof RoleSummary
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof RoleSummary
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RoleSummary
     */
    'displayName'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof RoleSummary
     */
    'type'?: DtoType;
    /**
     * 
     * @type {string}
     * @memberof RoleSummary
     */
    'description'?: string | null;
    /**
     * 
     * @type {DisplayReference}
     * @memberof RoleSummary
     */
    'owner'?: DisplayReference;
    /**
     * 
     * @type {boolean}
     * @memberof RoleSummary
     */
    'disabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RoleSummary
     */
    'revocable'?: boolean;
}


/**
 * @type Rule
 * @export
 */
export type Rule = GenerateRandomString | GenericRule | GetReferenceIdentityAttribute;

/**
 * 
 * @export
 * @interface SavedSearch
 */
export interface SavedSearch {
    /**
     * The name of the saved search. 
     * @type {string}
     * @memberof SavedSearch
     */
    'name'?: string;
    /**
     * The description of the saved search. 
     * @type {string}
     * @memberof SavedSearch
     */
    'description'?: string | null;
    /**
     * Indicates if the saved search is public. 
     * @type {boolean}
     * @memberof SavedSearch
     */
    'public'?: boolean;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof SavedSearch
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof SavedSearch
     */
    'modified'?: string | null;
    /**
     * The names of the Elasticsearch indices in which to search. 
     * @type {Array<Index>}
     * @memberof SavedSearch
     */
    'indices': Array<Index>;
    /**
     * The columns to be returned (specifies the order in which they will be presented) for each document type.  The currently supported document types are: _accessprofile_, _accountactivity_, _account_, _aggregation_, _entitlement_, _event_, _identity_, and _role_. 
     * @type {{ [key: string]: Array<Column>; }}
     * @memberof SavedSearch
     */
    'columns'?: { [key: string]: Array<Column>; };
    /**
     * The search query using Elasticsearch [Query String Query](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/query-dsl-query-string-query.html#query-string) syntax from the Query DSL. 
     * @type {string}
     * @memberof SavedSearch
     */
    'query': string;
    /**
     * The fields to be searched against in a multi-field query. 
     * @type {Array<string>}
     * @memberof SavedSearch
     */
    'fields'?: Array<string> | null;
    /**
     * The fields to be used to sort the search results. 
     * @type {Array<string>}
     * @memberof SavedSearch
     */
    'sort'?: Array<string>;
    /**
     * 
     * @type {SavedSearchDetailFilters}
     * @memberof SavedSearch
     */
    'filters'?: SavedSearchDetailFilters | null;
    /**
     * The saved search ID. 
     * @type {string}
     * @memberof SavedSearch
     */
    'id'?: string;
    /**
     * 
     * @type {TypedReference}
     * @memberof SavedSearch
     */
    'owner'?: TypedReference;
}
/**
 * 
 * @export
 * @interface SavedSearchDetail
 */
export interface SavedSearchDetail {
    /**
     * Indicates if the saved search is public. 
     * @type {boolean}
     * @memberof SavedSearchDetail
     */
    'public'?: boolean;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof SavedSearchDetail
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof SavedSearchDetail
     */
    'modified'?: string | null;
    /**
     * The names of the Elasticsearch indices in which to search. 
     * @type {Array<Index>}
     * @memberof SavedSearchDetail
     */
    'indices': Array<Index>;
    /**
     * The columns to be returned (specifies the order in which they will be presented) for each document type.  The currently supported document types are: _accessprofile_, _accountactivity_, _account_, _aggregation_, _entitlement_, _event_, _identity_, and _role_. 
     * @type {{ [key: string]: Array<Column>; }}
     * @memberof SavedSearchDetail
     */
    'columns'?: { [key: string]: Array<Column>; };
    /**
     * The search query using Elasticsearch [Query String Query](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/query-dsl-query-string-query.html#query-string) syntax from the Query DSL. 
     * @type {string}
     * @memberof SavedSearchDetail
     */
    'query': string;
    /**
     * The fields to be searched against in a multi-field query. 
     * @type {Array<string>}
     * @memberof SavedSearchDetail
     */
    'fields'?: Array<string> | null;
    /**
     * The fields to be used to sort the search results. 
     * @type {Array<string>}
     * @memberof SavedSearchDetail
     */
    'sort'?: Array<string>;
    /**
     * 
     * @type {SavedSearchDetailFilters}
     * @memberof SavedSearchDetail
     */
    'filters'?: SavedSearchDetailFilters | null;
}
/**
 * 
 * @export
 * @interface SavedSearchDetailFilters
 */
export interface SavedSearchDetailFilters {
    /**
     * 
     * @type {FilterType}
     * @memberof SavedSearchDetailFilters
     */
    'type'?: FilterType;
    /**
     * 
     * @type {Range}
     * @memberof SavedSearchDetailFilters
     */
    'range'?: Range;
    /**
     * The terms to be filtered.
     * @type {Array<string>}
     * @memberof SavedSearchDetailFilters
     */
    'terms'?: Array<string>;
    /**
     * Indicates if the filter excludes results.
     * @type {boolean}
     * @memberof SavedSearchDetailFilters
     */
    'exclude'?: boolean;
}


/**
 * 
 * @export
 * @interface SavedSearchName
 */
export interface SavedSearchName {
    /**
     * The name of the saved search. 
     * @type {string}
     * @memberof SavedSearchName
     */
    'name'?: string;
    /**
     * The description of the saved search. 
     * @type {string}
     * @memberof SavedSearchName
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface Schedule
 */
export interface Schedule {
    /**
     * Determines the overall schedule cadence. In general, all time period fields smaller than the chosen type can be configured. For example, a DAILY schedule can have \'hours\' set, but not \'days\'; a WEEKLY schedule can have both \'hours\' and \'days\' set.
     * @type {string}
     * @memberof Schedule
     */
    'type': ScheduleTypeEnum;
    /**
     * 
     * @type {ScheduleMonths}
     * @memberof Schedule
     */
    'months'?: ScheduleMonths;
    /**
     * 
     * @type {ScheduleDays}
     * @memberof Schedule
     */
    'days'?: ScheduleDays;
    /**
     * 
     * @type {ScheduleHours}
     * @memberof Schedule
     */
    'hours': ScheduleHours;
    /**
     * Specifies the time after which this schedule will no longer occur.
     * @type {string}
     * @memberof Schedule
     */
    'expiration'?: string;
    /**
     * The time zone to use when running the schedule. For instance, if the schedule is scheduled to run at 1AM, and this field is set to \"CST\", the schedule will run at 1AM CST.
     * @type {string}
     * @memberof Schedule
     */
    'timeZoneId'?: string;
}

export const ScheduleTypeEnum = {
    Weekly: 'WEEKLY',
    Monthly: 'MONTHLY',
    Annually: 'ANNUALLY',
    Calendar: 'CALENDAR'
} as const;

export type ScheduleTypeEnum = typeof ScheduleTypeEnum[keyof typeof ScheduleTypeEnum];

/**
 * The schedule information.
 * @export
 * @interface Schedule1
 */
export interface Schedule1 {
    /**
     * 
     * @type {ScheduleType}
     * @memberof Schedule1
     */
    'type': ScheduleType;
    /**
     * 
     * @type {Schedule1Days}
     * @memberof Schedule1
     */
    'days'?: Schedule1Days;
    /**
     * 
     * @type {Schedule1Hours}
     * @memberof Schedule1
     */
    'hours': Schedule1Hours;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof Schedule1
     */
    'expiration'?: string | null;
    /**
     * The GMT formatted timezone the schedule will run in (ex. GMT-06:00).  If no timezone is specified, the org\'s default timezone is used.
     * @type {string}
     * @memberof Schedule1
     */
    'timeZoneId'?: string | null;
}


/**
 * 
 * @export
 * @interface Schedule1Days
 */
export interface Schedule1Days {
    /**
     * 
     * @type {SelectorType}
     * @memberof Schedule1Days
     */
    'type': SelectorType;
    /**
     * The selected values. 
     * @type {Array<string>}
     * @memberof Schedule1Days
     */
    'values': Array<string>;
    /**
     * The selected interval for RANGE selectors. 
     * @type {number}
     * @memberof Schedule1Days
     */
    'interval'?: number | null;
}


/**
 * 
 * @export
 * @interface Schedule1Hours
 */
export interface Schedule1Hours {
    /**
     * 
     * @type {SelectorType}
     * @memberof Schedule1Hours
     */
    'type': SelectorType;
    /**
     * The selected values. 
     * @type {Array<string>}
     * @memberof Schedule1Hours
     */
    'values': Array<string>;
    /**
     * The selected interval for RANGE selectors. 
     * @type {number}
     * @memberof Schedule1Hours
     */
    'interval'?: number | null;
}


/**
 * Specifies which day(s) a schedule is active for. This is required for all schedule types. The \"values\" field holds different data depending on the type of schedule: * WEEKLY: days of the week (1-7) * MONTHLY: days of the month (1-31, L, L-1...) * ANNUALLY: if the \"months\" field is also set: days of the month (1-31, L, L-1...); otherwise: ISO-8601 dates without year (\"--12-31\") * CALENDAR: ISO-8601 dates (\"2020-12-31\")  Note that CALENDAR only supports the LIST type, and ANNUALLY does not support the RANGE type when provided with ISO-8601 dates without year.  Examples:  On Sundays: * type LIST * values \"1\"  The second to last day of the month: * type LIST * values \"L-1\"  From the 20th to the last day of the month: * type RANGE * values \"20\", \"L\"  Every March 2nd: * type LIST * values \"--03-02\"  On March 2nd, 2021: * type: LIST * values \"2021-03-02\" 
 * @export
 * @interface ScheduleDays
 */
export interface ScheduleDays {
    /**
     * Enum type to specify days value
     * @type {string}
     * @memberof ScheduleDays
     */
    'type': ScheduleDaysTypeEnum;
    /**
     * Values of the days based on the enum type mentioned above
     * @type {Array<string>}
     * @memberof ScheduleDays
     */
    'values': Array<string>;
    /**
     * Interval between the cert generations
     * @type {number}
     * @memberof ScheduleDays
     */
    'interval'?: number;
}

export const ScheduleDaysTypeEnum = {
    List: 'LIST',
    Range: 'RANGE'
} as const;

export type ScheduleDaysTypeEnum = typeof ScheduleDaysTypeEnum[keyof typeof ScheduleDaysTypeEnum];

/**
 * Specifies which hour(s) a schedule is active for. Examples:  Every three hours starting from 8AM, inclusive: * type LIST * values \"8\" * interval 3  During business hours: * type RANGE * values \"9\", \"5\"  At 5AM, noon, and 5PM: * type LIST * values \"5\", \"12\", \"17\" 
 * @export
 * @interface ScheduleHours
 */
export interface ScheduleHours {
    /**
     * Enum type to specify hours value
     * @type {string}
     * @memberof ScheduleHours
     */
    'type': ScheduleHoursTypeEnum;
    /**
     * Values of the days based on the enum type mentioned above
     * @type {Array<string>}
     * @memberof ScheduleHours
     */
    'values': Array<string>;
    /**
     * Interval between the cert generations
     * @type {number}
     * @memberof ScheduleHours
     */
    'interval'?: number;
}

export const ScheduleHoursTypeEnum = {
    List: 'LIST',
    Range: 'RANGE'
} as const;

export type ScheduleHoursTypeEnum = typeof ScheduleHoursTypeEnum[keyof typeof ScheduleHoursTypeEnum];

/**
 * Specifies which months of a schedule are active. Only valid for ANNUALLY schedule types. Examples:  On February and March: * type LIST * values \"2\", \"3\"  Every 3 months, starting in January (quarterly): * type LIST * values \"1\" * interval 3  Every two months between July and December: * type RANGE * values \"7\", \"12\" * interval 2 
 * @export
 * @interface ScheduleMonths
 */
export interface ScheduleMonths {
    /**
     * Enum type to specify months value
     * @type {string}
     * @memberof ScheduleMonths
     */
    'type': ScheduleMonthsTypeEnum;
    /**
     * Values of the months based on the enum type mentioned above
     * @type {Array<string>}
     * @memberof ScheduleMonths
     */
    'values': Array<string>;
    /**
     * Interval between the cert generations
     * @type {number}
     * @memberof ScheduleMonths
     */
    'interval'?: number;
}

export const ScheduleMonthsTypeEnum = {
    List: 'LIST',
    Range: 'RANGE'
} as const;

export type ScheduleMonthsTypeEnum = typeof ScheduleMonthsTypeEnum[keyof typeof ScheduleMonthsTypeEnum];

/**
 * Enum representing the currently supported schedule types.  Additional values may be added in the future without notice. 
 * @export
 * @enum {string}
 */

export const ScheduleType = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Monthly: 'MONTHLY',
    Calendar: 'CALENDAR'
} as const;

export type ScheduleType = typeof ScheduleType[keyof typeof ScheduleType];


/**
 * 
 * @export
 * @interface ScheduledSearch
 */
export interface ScheduledSearch {
    /**
     * The name of the scheduled search. 
     * @type {string}
     * @memberof ScheduledSearch
     */
    'name'?: string | null;
    /**
     * The description of the scheduled search. 
     * @type {string}
     * @memberof ScheduledSearch
     */
    'description'?: string | null;
    /**
     * The ID of the saved search that will be executed.
     * @type {string}
     * @memberof ScheduledSearch
     */
    'savedSearchId': string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof ScheduledSearch
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof ScheduledSearch
     */
    'modified'?: string | null;
    /**
     * 
     * @type {Schedule1}
     * @memberof ScheduledSearch
     */
    'schedule': Schedule1;
    /**
     * A list of identities that should receive the scheduled search report via email.
     * @type {Array<SearchScheduleRecipientsInner>}
     * @memberof ScheduledSearch
     */
    'recipients': Array<SearchScheduleRecipientsInner>;
    /**
     * Indicates if the scheduled search is enabled. 
     * @type {boolean}
     * @memberof ScheduledSearch
     */
    'enabled'?: boolean;
    /**
     * Indicates if email generation should not be suppressed if search returns no results. 
     * @type {boolean}
     * @memberof ScheduledSearch
     */
    'emailEmptyResults'?: boolean;
    /**
     * Indicates if the generated email should include the query and search results preview (which could include PII). 
     * @type {boolean}
     * @memberof ScheduledSearch
     */
    'displayQueryDetails'?: boolean;
    /**
     * The scheduled search ID.
     * @type {string}
     * @memberof ScheduledSearch
     */
    'id': string;
    /**
     * 
     * @type {ScheduledSearchAllOfOwner}
     * @memberof ScheduledSearch
     */
    'owner': ScheduledSearchAllOfOwner;
    /**
     * The ID of the scheduled search owner.  Please use the `id` in the `owner` object instead. 
     * @type {string}
     * @memberof ScheduledSearch
     * @deprecated
     */
    'ownerId': string;
}
/**
 * The owner of the scheduled search
 * @export
 * @interface ScheduledSearchAllOfOwner
 */
export interface ScheduledSearchAllOfOwner {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof ScheduledSearchAllOfOwner
     */
    'type': ScheduledSearchAllOfOwnerTypeEnum;
    /**
     * The ID of the referenced object
     * @type {string}
     * @memberof ScheduledSearchAllOfOwner
     */
    'id': string;
}

export const ScheduledSearchAllOfOwnerTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type ScheduledSearchAllOfOwnerTypeEnum = typeof ScheduledSearchAllOfOwnerTypeEnum[keyof typeof ScheduledSearchAllOfOwnerTypeEnum];

/**
 * 
 * @export
 * @interface ScheduledSearchName
 */
export interface ScheduledSearchName {
    /**
     * The name of the scheduled search. 
     * @type {string}
     * @memberof ScheduledSearchName
     */
    'name'?: string | null;
    /**
     * The description of the scheduled search. 
     * @type {string}
     * @memberof ScheduledSearchName
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface Schema
 */
export interface Schema {
    /**
     * The id of the Schema.
     * @type {string}
     * @memberof Schema
     */
    'id'?: string;
    /**
     * The name of the Schema.
     * @type {string}
     * @memberof Schema
     */
    'name'?: string;
    /**
     * The name of the object type on the native system that the schema represents.
     * @type {string}
     * @memberof Schema
     */
    'nativeObjectType'?: string;
    /**
     * The name of the attribute used to calculate the unique identifier for an object in the schema.
     * @type {string}
     * @memberof Schema
     */
    'identityAttribute'?: string;
    /**
     * The name of the attribute used to calculate the display value for an object in the schema.
     * @type {string}
     * @memberof Schema
     */
    'displayAttribute'?: string;
    /**
     * The name of the attribute whose values represent other objects in a hierarchy. Only relevant to group schemas.
     * @type {string}
     * @memberof Schema
     */
    'hierarchyAttribute'?: string;
    /**
     * Flag indicating whether or not the include permissions with the object data when aggregating the schema.
     * @type {boolean}
     * @memberof Schema
     */
    'includePermissions'?: boolean;
    /**
     * The features that the schema supports.
     * @type {Array<SourceFeature>}
     * @memberof Schema
     */
    'features'?: Array<SourceFeature>;
    /**
     * Holds any extra configuration data that the schema may require.
     * @type {object}
     * @memberof Schema
     */
    'configuration'?: object;
    /**
     * The attribute definitions which form the schema.
     * @type {Array<AttributeDefinition>}
     * @memberof Schema
     */
    'attributes'?: Array<AttributeDefinition>;
    /**
     * The date the Schema was created.
     * @type {string}
     * @memberof Schema
     */
    'created'?: string;
    /**
     * The date the Schema was last modified.
     * @type {string}
     * @memberof Schema
     */
    'modified'?: string;
}
/**
 * 
 * @export
 * @interface Search
 */
export interface Search {
    /**
     * The names of the Elasticsearch indices in which to search. If none are provided, then all indices will be searched.
     * @type {Array<Index>}
     * @memberof Search
     */
    'indices'?: Array<Index>;
    /**
     * 
     * @type {QueryType}
     * @memberof Search
     */
    'queryType'?: QueryType;
    /**
     * 
     * @type {string}
     * @memberof Search
     */
    'queryVersion'?: string;
    /**
     * 
     * @type {Query}
     * @memberof Search
     */
    'query'?: Query;
    /**
     * The search query using the Elasticsearch [Query DSL](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl.html) syntax.
     * @type {object}
     * @memberof Search
     */
    'queryDsl'?: object;
    /**
     * 
     * @type {TextQuery}
     * @memberof Search
     */
    'textQuery'?: TextQuery;
    /**
     * 
     * @type {TypeAheadQuery}
     * @memberof Search
     */
    'typeAheadQuery'?: TypeAheadQuery;
    /**
     * Indicates whether nested objects from returned search results should be included.
     * @type {boolean}
     * @memberof Search
     */
    'includeNested'?: boolean;
    /**
     * 
     * @type {QueryResultFilter}
     * @memberof Search
     */
    'queryResultFilter'?: QueryResultFilter;
    /**
     * 
     * @type {AggregationType}
     * @memberof Search
     */
    'aggregationType'?: AggregationType;
    /**
     * 
     * @type {string}
     * @memberof Search
     */
    'aggregationsVersion'?: string;
    /**
     * The aggregation search query using Elasticsearch [Aggregations](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/search-aggregations.html) syntax.
     * @type {object}
     * @memberof Search
     */
    'aggregationsDsl'?: object;
    /**
     * 
     * @type {SearchAggregationSpecification}
     * @memberof Search
     */
    'aggregations'?: SearchAggregationSpecification;
    /**
     * The fields to be used to sort the search results. Use + or - to specify the sort direction.
     * @type {Array<string>}
     * @memberof Search
     */
    'sort'?: Array<string>;
    /**
     * Used to begin the search window at the values specified. This parameter consists of the last values of the sorted fields in the current record set. This is used to expand the Elasticsearch limit of 10K records by shifting the 10K window to begin at this value. It is recommended that you always include the ID of the object in addition to any other fields on this parameter in order to ensure you don\'t get duplicate results while paging. For example, when searching for identities, if you are sorting by displayName you will also want to include ID, for example [\"displayName\", \"id\"].  If the last identity ID in the search result is 2c91808375d8e80a0175e1f88a575221 and the last displayName is \"John Doe\", then using that displayName and ID will start a new search after this identity. The searchAfter value will look like [\"John Doe\",\"2c91808375d8e80a0175e1f88a575221\"]
     * @type {Array<string>}
     * @memberof Search
     */
    'searchAfter'?: Array<string>;
    /**
     * The filters to be applied for each filtered field name.
     * @type {{ [key: string]: Filter; }}
     * @memberof Search
     */
    'filters'?: { [key: string]: Filter; };
}


/**
 * 
 * @export
 * @interface SearchAggregationSpecification
 */
export interface SearchAggregationSpecification {
    /**
     * 
     * @type {NestedAggregation}
     * @memberof SearchAggregationSpecification
     */
    'nested'?: NestedAggregation;
    /**
     * 
     * @type {MetricAggregation}
     * @memberof SearchAggregationSpecification
     */
    'metric'?: MetricAggregation;
    /**
     * 
     * @type {FilterAggregation}
     * @memberof SearchAggregationSpecification
     */
    'filter'?: FilterAggregation;
    /**
     * 
     * @type {BucketAggregation}
     * @memberof SearchAggregationSpecification
     */
    'bucket'?: BucketAggregation;
    /**
     * 
     * @type {SubSearchAggregationSpecification}
     * @memberof SearchAggregationSpecification
     */
    'subAggregation'?: SubSearchAggregationSpecification;
}
/**
 * 
 * @export
 * @interface SearchArguments
 */
export interface SearchArguments {
    /**
     * The ID of the scheduled search that triggered the saved search execution. 
     * @type {string}
     * @memberof SearchArguments
     */
    'scheduleId'?: string;
    /**
     * 
     * @type {TypedReference}
     * @memberof SearchArguments
     */
    'owner'?: TypedReference;
    /**
     * The email recipients of the scheduled search being tested. 
     * @type {Array<TypedReference>}
     * @memberof SearchArguments
     */
    'recipients'?: Array<TypedReference>;
}
/**
 * @type SearchDocument
 * @export
 */
export type SearchDocument = { _type: 'accessprofile' } & AccessProfileDocument | { _type: 'accountactivity' } & AccountActivityDocument | { _type: 'entitlement' } & EntitlementDocument | { _type: 'event' } & EventDocument | { _type: 'identity' } & IdentityDocument | { _type: 'role' } & RoleDocument;

/**
 * Arguments for Search Export report (SEARCH_EXPORT)
 * @export
 * @interface SearchExportReportArguments
 */
export interface SearchExportReportArguments {
    /**
     * The names of the Elasticsearch indices in which to search. If none are provided, then all indices will be searched.
     * @type {Array<Index>}
     * @memberof SearchExportReportArguments
     */
    'indices'?: Array<Index>;
    /**
     * The filters to be applied for each filtered field name.
     * @type {{ [key: string]: Filter; }}
     * @memberof SearchExportReportArguments
     */
    'filters'?: { [key: string]: Filter; };
    /**
     * 
     * @type {Query}
     * @memberof SearchExportReportArguments
     */
    'query': Query;
    /**
     * Indicates whether nested objects from returned search results should be included.
     * @type {boolean}
     * @memberof SearchExportReportArguments
     */
    'includeNested'?: boolean;
    /**
     * The fields to be used to sort the search results. Use + or - to specify the sort direction.
     * @type {Array<string>}
     * @memberof SearchExportReportArguments
     */
    'sort'?: Array<string>;
    /**
     * Use it to set default s3 bucket where generated report will be saved.  In case this argument is false and \'s3Bucket\' argument is null or absent there will be default s3Bucket assigned to the report.
     * @type {boolean}
     * @memberof SearchExportReportArguments
     */
    'defaultS3Bucket': boolean;
    /**
     * If you want to be specific you could use this argument with defaultS3Bucket = false.
     * @type {string}
     * @memberof SearchExportReportArguments
     */
    's3Bucket'?: string;
}
/**
 * Enum representing the currently supported filter aggregation types. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const SearchFilterType = {
    Term: 'TERM'
} as const;

export type SearchFilterType = typeof SearchFilterType[keyof typeof SearchFilterType];


/**
 * 
 * @export
 * @interface SearchIdentityReference
 */
export interface SearchIdentityReference {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof SearchIdentityReference
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof SearchIdentityReference
     */
    'name'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof SearchIdentityReference
     */
    'type'?: DtoType;
}


/**
 * 
 * @export
 * @interface SearchSchedule
 */
export interface SearchSchedule {
    /**
     * The ID of the saved search that will be executed.
     * @type {string}
     * @memberof SearchSchedule
     */
    'savedSearchId': string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof SearchSchedule
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof SearchSchedule
     */
    'modified'?: string | null;
    /**
     * 
     * @type {Schedule1}
     * @memberof SearchSchedule
     */
    'schedule': Schedule1;
    /**
     * A list of identities that should receive the scheduled search report via email.
     * @type {Array<SearchScheduleRecipientsInner>}
     * @memberof SearchSchedule
     */
    'recipients': Array<SearchScheduleRecipientsInner>;
    /**
     * Indicates if the scheduled search is enabled. 
     * @type {boolean}
     * @memberof SearchSchedule
     */
    'enabled'?: boolean;
    /**
     * Indicates if email generation should not be suppressed if search returns no results. 
     * @type {boolean}
     * @memberof SearchSchedule
     */
    'emailEmptyResults'?: boolean;
    /**
     * Indicates if the generated email should include the query and search results preview (which could include PII). 
     * @type {boolean}
     * @memberof SearchSchedule
     */
    'displayQueryDetails'?: boolean;
}
/**
 * 
 * @export
 * @interface SearchScheduleRecipientsInner
 */
export interface SearchScheduleRecipientsInner {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SearchScheduleRecipientsInner
     */
    'type': SearchScheduleRecipientsInnerTypeEnum;
    /**
     * The ID of the referenced object
     * @type {string}
     * @memberof SearchScheduleRecipientsInner
     */
    'id': string;
}

export const SearchScheduleRecipientsInnerTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type SearchScheduleRecipientsInnerTypeEnum = typeof SearchScheduleRecipientsInnerTypeEnum[keyof typeof SearchScheduleRecipientsInnerTypeEnum];

/**
 * 
 * @export
 * @interface SectionDetails
 */
export interface SectionDetails {
    /**
     * Name of the FormItem
     * @type {string}
     * @memberof SectionDetails
     */
    'name'?: string;
    /**
     * Label of the section
     * @type {string}
     * @memberof SectionDetails
     */
    'label'?: string;
    /**
     * List of FormItems. FormItems can be SectionDetails and/or FieldDetails
     * @type {Array<object>}
     * @memberof SectionDetails
     */
    'formItems'?: Array<object>;
}
/**
 * 
 * @export
 * @interface Segment
 */
export interface Segment {
    /**
     * The segment\'s ID.
     * @type {string}
     * @memberof Segment
     */
    'id'?: string;
    /**
     * The segment\'s business name.
     * @type {string}
     * @memberof Segment
     */
    'name'?: string;
    /**
     * The time when the segment is created.
     * @type {string}
     * @memberof Segment
     */
    'created'?: string;
    /**
     * The time when the segment is modified.
     * @type {string}
     * @memberof Segment
     */
    'modified'?: string;
    /**
     * The segment\'s optional description.
     * @type {string}
     * @memberof Segment
     */
    'description'?: string;
    /**
     * 
     * @type {OwnerReferenceSegments}
     * @memberof Segment
     */
    'owner'?: OwnerReferenceSegments | null;
    /**
     * 
     * @type {VisibilityCriteria}
     * @memberof Segment
     */
    'visibilityCriteria'?: VisibilityCriteria;
    /**
     * This boolean indicates whether the segment is currently active. Inactive segments have no effect.
     * @type {boolean}
     * @memberof Segment
     */
    'active'?: boolean;
}
/**
 * 
 * @export
 * @interface Selector
 */
export interface Selector {
    /**
     * 
     * @type {SelectorType}
     * @memberof Selector
     */
    'type': SelectorType;
    /**
     * The selected values. 
     * @type {Array<string>}
     * @memberof Selector
     */
    'values': Array<string>;
    /**
     * The selected interval for RANGE selectors. 
     * @type {number}
     * @memberof Selector
     */
    'interval'?: number | null;
}


/**
 * Enum representing the currently supported selector types.  LIST - the *values* array contains one or more distinct values.  RANGE - the *values* array contains two values: the start and end of the range, inclusive.  Additional values may be added in the future without notice. 
 * @export
 * @enum {string}
 */

export const SelectorType = {
    List: 'LIST',
    Range: 'RANGE'
} as const;

export type SelectorType = typeof SelectorType[keyof typeof SelectorType];


/**
 * 
 * @export
 * @interface ServiceDeskIntegrationDto
 */
export interface ServiceDeskIntegrationDto {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     */
    'modified'?: string;
    /**
     * Description of the Service Desk integration
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     */
    'description': string;
    /**
     * Service Desk integration types  - ServiceNowSDIM - ServiceNow 
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     */
    'type': string;
    /**
     * 
     * @type {ServiceDeskIntegrationDtoAllOfOwnerRef}
     * @memberof ServiceDeskIntegrationDto
     */
    'ownerRef'?: ServiceDeskIntegrationDtoAllOfOwnerRef;
    /**
     * 
     * @type {SourceClusterDto}
     * @memberof ServiceDeskIntegrationDto
     */
    'clusterRef'?: SourceClusterDto;
    /**
     * ID of the cluster for the Service Desk integration (replaced by clusterRef, retained for backward compatibility).
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     * @deprecated
     */
    'cluster'?: string;
    /**
     * Source IDs for the Service Desk integration (replaced by provisioningConfig.managedSResourceRefs, but retained here for backward compatibility).
     * @type {Array<string>}
     * @memberof ServiceDeskIntegrationDto
     * @deprecated
     */
    'managedSources'?: Array<string>;
    /**
     * 
     * @type {ProvisioningConfig}
     * @memberof ServiceDeskIntegrationDto
     */
    'provisioningConfig'?: ProvisioningConfig;
    /**
     * Attributes of the Service Desk integration.  Validation constraints enforced by the implementation.
     * @type {{ [key: string]: any; }}
     * @memberof ServiceDeskIntegrationDto
     */
    'attributes': { [key: string]: any; };
    /**
     * 
     * @type {BeforeProvisioningRuleDto}
     * @memberof ServiceDeskIntegrationDto
     */
    'beforeProvisioningRule'?: BeforeProvisioningRuleDto;
}
/**
 * Source for Service Desk integration template.
 * @export
 * @interface ServiceDeskIntegrationDtoAllOfOwnerRef
 */
export interface ServiceDeskIntegrationDtoAllOfOwnerRef {
    /**
     * DTO type of source for service desk integration template.
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoAllOfOwnerRef
     */
    'type'?: ServiceDeskIntegrationDtoAllOfOwnerRefTypeEnum;
    /**
     * ID of source for service desk integration template.
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoAllOfOwnerRef
     */
    'id'?: string;
    /**
     * Human-readable name of source for service desk integration template.
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoAllOfOwnerRef
     */
    'name'?: string;
}

export const ServiceDeskIntegrationDtoAllOfOwnerRefTypeEnum = {
    Source: 'SOURCE'
} as const;

export type ServiceDeskIntegrationDtoAllOfOwnerRefTypeEnum = typeof ServiceDeskIntegrationDtoAllOfOwnerRefTypeEnum[keyof typeof ServiceDeskIntegrationDtoAllOfOwnerRefTypeEnum];

/**
 * 
 * @export
 * @interface ServiceDeskIntegrationTemplateDto
 */
export interface ServiceDeskIntegrationTemplateDto {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'modified'?: string;
    /**
     * The \'type\' property specifies the type of the Service Desk integration template.
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'type': string;
    /**
     * The \'attributes\' property value is a map of attributes available for integrations using this Service Desk integration template.
     * @type {{ [key: string]: any; }}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'attributes': { [key: string]: any; };
    /**
     * 
     * @type {ProvisioningConfig}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'provisioningConfig': ProvisioningConfig;
}
/**
 * This represents a Service Desk Integration template type.
 * @export
 * @interface ServiceDeskIntegrationTemplateType
 */
export interface ServiceDeskIntegrationTemplateType {
    /**
     * This is the name of the type.
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateType
     */
    'name'?: string;
    /**
     * This is the type value for the type.
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateType
     */
    'type': string;
    /**
     * This is the scriptName attribute value for the type.
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateType
     */
    'scriptName': string;
}
/**
 * Source for Service Desk integration template.
 * @export
 * @interface ServiceDeskSource
 */
export interface ServiceDeskSource {
    /**
     * DTO type of source for service desk integration template.
     * @type {string}
     * @memberof ServiceDeskSource
     */
    'type'?: ServiceDeskSourceTypeEnum;
    /**
     * ID of source for service desk integration template.
     * @type {string}
     * @memberof ServiceDeskSource
     */
    'id'?: string;
    /**
     * Human-readable name of source for service desk integration template.
     * @type {string}
     * @memberof ServiceDeskSource
     */
    'name'?: string;
}

export const ServiceDeskSourceTypeEnum = {
    Source: 'SOURCE'
} as const;

export type ServiceDeskSourceTypeEnum = typeof ServiceDeskSourceTypeEnum[keyof typeof ServiceDeskSourceTypeEnum];

/**
 * 
 * @export
 * @interface SetLifecycleState200Response
 */
export interface SetLifecycleState200Response {
    /**
     * The ID of the IdentityRequest object that was generated when the workflow launches
     * @type {string}
     * @memberof SetLifecycleState200Response
     */
    'accountActivityId'?: string;
}
/**
 * 
 * @export
 * @interface SetLifecycleStateRequest
 */
export interface SetLifecycleStateRequest {
    /**
     * The ID of the lifecycle state to set
     * @type {string}
     * @memberof SetLifecycleStateRequest
     */
    'lifecycleStateId'?: string;
}
/**
 * 
 * @export
 * @interface SlimCampaign
 */
export interface SlimCampaign {
    /**
     * Id of the campaign
     * @type {string}
     * @memberof SlimCampaign
     */
    'id'?: string;
    /**
     * The campaign name. If this object is part of a template, special formatting applies; see the `/campaign-templates/{id}/generate` endpoint documentation for details.
     * @type {string}
     * @memberof SlimCampaign
     */
    'name': string;
    /**
     * The campaign description. If this object is part of a template, special formatting applies; see the `/campaign-templates/{id}/generate` endpoint documentation for details.
     * @type {string}
     * @memberof SlimCampaign
     */
    'description': string;
    /**
     * The campaign\'s completion deadline.  This date must be in the future in order to activate the campaign.  If you try to activate a campaign with a deadline of today or in the past, you will receive a 400 error response.
     * @type {string}
     * @memberof SlimCampaign
     */
    'deadline'?: string;
    /**
     * The type of campaign. Could be extended in the future.
     * @type {string}
     * @memberof SlimCampaign
     */
    'type': SlimCampaignTypeEnum;
    /**
     * Enables email notification for this campaign
     * @type {boolean}
     * @memberof SlimCampaign
     */
    'emailNotificationEnabled'?: boolean;
    /**
     * Allows auto revoke for this campaign
     * @type {boolean}
     * @memberof SlimCampaign
     */
    'autoRevokeAllowed'?: boolean;
    /**
     * Enables IAI for this campaign. Accepts true even if the IAI product feature is off. If IAI is turned off then campaigns generated from this template will indicate false. The real value will then be returned if IAI is ever enabled for the org in the future.
     * @type {boolean}
     * @memberof SlimCampaign
     */
    'recommendationsEnabled'?: boolean;
    /**
     * The campaign\'s current status.
     * @type {string}
     * @memberof SlimCampaign
     */
    'status'?: SlimCampaignStatusEnum;
    /**
     * The correlatedStatus of the campaign. Only SOURCE_OWNER campaigns can be Uncorrelated. An Uncorrelated certification campaign only includes Uncorrelated identities (An identity is uncorrelated if it has no accounts on an authoritative source).
     * @type {string}
     * @memberof SlimCampaign
     */
    'correlatedStatus'?: SlimCampaignCorrelatedStatusEnum;
    /**
     * Created time of the campaign
     * @type {string}
     * @memberof SlimCampaign
     */
    'created'?: string;
    /**
     * The total number of certifications in this campaign.
     * @type {number}
     * @memberof SlimCampaign
     */
    'totalCertifications'?: number;
    /**
     * The number of completed certifications in this campaign.
     * @type {number}
     * @memberof SlimCampaign
     */
    'completedCertifications'?: number;
    /**
     * A list of errors and warnings that have accumulated.
     * @type {Array<CampaignAlert>}
     * @memberof SlimCampaign
     */
    'alerts'?: Array<CampaignAlert>;
}

export const SlimCampaignTypeEnum = {
    Manager: 'MANAGER',
    SourceOwner: 'SOURCE_OWNER',
    Search: 'SEARCH',
    RoleComposition: 'ROLE_COMPOSITION'
} as const;

export type SlimCampaignTypeEnum = typeof SlimCampaignTypeEnum[keyof typeof SlimCampaignTypeEnum];
export const SlimCampaignStatusEnum = {
    Pending: 'PENDING',
    Staged: 'STAGED',
    Canceling: 'CANCELING',
    Activating: 'ACTIVATING',
    Active: 'ACTIVE',
    Completing: 'COMPLETING',
    Completed: 'COMPLETED',
    Error: 'ERROR',
    Archived: 'ARCHIVED'
} as const;

export type SlimCampaignStatusEnum = typeof SlimCampaignStatusEnum[keyof typeof SlimCampaignStatusEnum];
export const SlimCampaignCorrelatedStatusEnum = {
    Correlated: 'CORRELATED',
    Uncorrelated: 'UNCORRELATED'
} as const;

export type SlimCampaignCorrelatedStatusEnum = typeof SlimCampaignCorrelatedStatusEnum[keyof typeof SlimCampaignCorrelatedStatusEnum];

/**
 * Details of the Entitlement criteria
 * @export
 * @interface SodExemptCriteria
 */
export interface SodExemptCriteria {
    /**
     * If the entitlement already belonged to the user or not.
     * @type {boolean}
     * @memberof SodExemptCriteria
     */
    'existing'?: boolean;
    /**
     * 
     * @type {DtoType}
     * @memberof SodExemptCriteria
     */
    'type'?: DtoType;
    /**
     * Entitlement ID
     * @type {string}
     * @memberof SodExemptCriteria
     */
    'id'?: string;
    /**
     * Entitlement name
     * @type {string}
     * @memberof SodExemptCriteria
     */
    'name'?: string;
}


/**
 * 
 * @export
 * @interface SodPolicy
 */
export interface SodPolicy {
    /**
     * Policy id
     * @type {string}
     * @memberof SodPolicy
     */
    'id'?: string;
    /**
     * Policy Business Name
     * @type {string}
     * @memberof SodPolicy
     */
    'name'?: string;
    /**
     * The time when this SOD policy is created.
     * @type {string}
     * @memberof SodPolicy
     */
    'created'?: string;
    /**
     * The time when this SOD policy is modified.
     * @type {string}
     * @memberof SodPolicy
     */
    'modified'?: string;
    /**
     * Optional description of the SOD policy
     * @type {string}
     * @memberof SodPolicy
     */
    'description'?: string | null;
    /**
     * 
     * @type {OwnerDto}
     * @memberof SodPolicy
     */
    'ownerRef'?: OwnerDto;
    /**
     * Optional External Policy Reference
     * @type {string}
     * @memberof SodPolicy
     */
    'externalPolicyReference'?: string | null;
    /**
     * Search query of the SOD policy
     * @type {string}
     * @memberof SodPolicy
     */
    'policyQuery'?: string;
    /**
     * Optional compensating controls(Mitigating Controls)
     * @type {string}
     * @memberof SodPolicy
     */
    'compensatingControls'?: string | null;
    /**
     * Optional correction advice
     * @type {string}
     * @memberof SodPolicy
     */
    'correctionAdvice'?: string | null;
    /**
     * whether the policy is enforced or not
     * @type {string}
     * @memberof SodPolicy
     */
    'state'?: SodPolicyStateEnum;
    /**
     * tags for this policy object
     * @type {Array<string>}
     * @memberof SodPolicy
     */
    'tags'?: Array<string>;
    /**
     * Policy\'s creator ID
     * @type {string}
     * @memberof SodPolicy
     */
    'creatorId'?: string;
    /**
     * Policy\'s modifier ID
     * @type {string}
     * @memberof SodPolicy
     */
    'modifierId'?: string | null;
    /**
     * 
     * @type {ViolationOwnerAssignmentConfig}
     * @memberof SodPolicy
     */
    'violationOwnerAssignmentConfig'?: ViolationOwnerAssignmentConfig;
    /**
     * defines whether a policy has been scheduled or not
     * @type {boolean}
     * @memberof SodPolicy
     */
    'scheduled'?: boolean;
    /**
     * whether a policy is query based or conflicting access based
     * @type {string}
     * @memberof SodPolicy
     */
    'type'?: SodPolicyTypeEnum;
    /**
     * 
     * @type {SodPolicyConflictingAccessCriteria}
     * @memberof SodPolicy
     */
    'conflictingAccessCriteria'?: SodPolicyConflictingAccessCriteria;
}

export const SodPolicyStateEnum = {
    Enforced: 'ENFORCED',
    NotEnforced: 'NOT_ENFORCED'
} as const;

export type SodPolicyStateEnum = typeof SodPolicyStateEnum[keyof typeof SodPolicyStateEnum];
export const SodPolicyTypeEnum = {
    General: 'GENERAL',
    ConflictingAccessBased: 'CONFLICTING_ACCESS_BASED'
} as const;

export type SodPolicyTypeEnum = typeof SodPolicyTypeEnum[keyof typeof SodPolicyTypeEnum];

/**
 * 
 * @export
 * @interface SodPolicyConflictingAccessCriteria
 */
export interface SodPolicyConflictingAccessCriteria {
    /**
     * 
     * @type {AccessCriteria}
     * @memberof SodPolicyConflictingAccessCriteria
     */
    'leftCriteria'?: AccessCriteria;
    /**
     * 
     * @type {AccessCriteria}
     * @memberof SodPolicyConflictingAccessCriteria
     */
    'rightCriteria'?: AccessCriteria;
}
/**
 * SOD policy.
 * @export
 * @interface SodPolicyDto
 */
export interface SodPolicyDto {
    /**
     * SOD policy DTO type.
     * @type {string}
     * @memberof SodPolicyDto
     */
    'type'?: SodPolicyDtoTypeEnum;
    /**
     * SOD policy ID.
     * @type {string}
     * @memberof SodPolicyDto
     */
    'id'?: string;
    /**
     * SOD policy display name.
     * @type {string}
     * @memberof SodPolicyDto
     */
    'name'?: string;
}

export const SodPolicyDtoTypeEnum = {
    SodPolicy: 'SOD_POLICY'
} as const;

export type SodPolicyDtoTypeEnum = typeof SodPolicyDtoTypeEnum[keyof typeof SodPolicyDtoTypeEnum];

/**
 * 
 * @export
 * @interface SodPolicySchedule
 */
export interface SodPolicySchedule {
    /**
     * SOD Policy schedule name
     * @type {string}
     * @memberof SodPolicySchedule
     */
    'name'?: string;
    /**
     * The time when this SOD policy schedule is created.
     * @type {string}
     * @memberof SodPolicySchedule
     */
    'created'?: string;
    /**
     * The time when this SOD policy schedule is modified.
     * @type {string}
     * @memberof SodPolicySchedule
     */
    'modified'?: string;
    /**
     * SOD Policy schedule description
     * @type {string}
     * @memberof SodPolicySchedule
     */
    'description'?: string;
    /**
     * 
     * @type {Schedule1}
     * @memberof SodPolicySchedule
     */
    'schedule'?: Schedule1;
    /**
     * 
     * @type {Array<SodRecipient>}
     * @memberof SodPolicySchedule
     */
    'recipients'?: Array<SodRecipient>;
    /**
     * Indicates if empty results need to be emailed
     * @type {boolean}
     * @memberof SodPolicySchedule
     */
    'emailEmptyResults'?: boolean;
    /**
     * Policy\'s creator ID
     * @type {string}
     * @memberof SodPolicySchedule
     */
    'creatorId'?: string;
    /**
     * Policy\'s modifier ID
     * @type {string}
     * @memberof SodPolicySchedule
     */
    'modifierId'?: string;
}
/**
 * SOD policy recipient.
 * @export
 * @interface SodRecipient
 */
export interface SodRecipient {
    /**
     * SOD policy recipient DTO type.
     * @type {string}
     * @memberof SodRecipient
     */
    'type'?: SodRecipientTypeEnum;
    /**
     * SOD policy recipient\'s identity ID.
     * @type {string}
     * @memberof SodRecipient
     */
    'id'?: string;
    /**
     * SOD policy recipient\'s display name.
     * @type {string}
     * @memberof SodRecipient
     */
    'name'?: string;
}

export const SodRecipientTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type SodRecipientTypeEnum = typeof SodRecipientTypeEnum[keyof typeof SodRecipientTypeEnum];

/**
 * SOD policy violation report result.
 * @export
 * @interface SodReportResultDto
 */
export interface SodReportResultDto {
    /**
     * SOD policy violation report result DTO type.
     * @type {string}
     * @memberof SodReportResultDto
     */
    'type'?: SodReportResultDtoTypeEnum;
    /**
     * SOD policy violation report result ID.
     * @type {string}
     * @memberof SodReportResultDto
     */
    'id'?: string;
    /**
     * Human-readable name of the SOD policy violation report result.
     * @type {string}
     * @memberof SodReportResultDto
     */
    'name'?: string;
}

export const SodReportResultDtoTypeEnum = {
    ReportResult: 'REPORT_RESULT'
} as const;

export type SodReportResultDtoTypeEnum = typeof SodReportResultDtoTypeEnum[keyof typeof SodReportResultDtoTypeEnum];

/**
 * An object referencing an SOD violation check
 * @export
 * @interface SodViolationCheck
 */
export interface SodViolationCheck {
    /**
     * The id of the original request
     * @type {string}
     * @memberof SodViolationCheck
     */
    'requestId': string;
    /**
     * The date-time when this request was created.
     * @type {string}
     * @memberof SodViolationCheck
     */
    'created'?: string;
}
/**
 * The inner object representing the completed SOD Violation check
 * @export
 * @interface SodViolationCheckResult
 */
export interface SodViolationCheckResult {
    /**
     * 
     * @type {ErrorMessageDto}
     * @memberof SodViolationCheckResult
     */
    'message'?: ErrorMessageDto;
    /**
     * Arbitrary key-value pairs. They will never be processed by the IdentityNow system but will be returned on completion of the violation check.
     * @type {{ [key: string]: string; }}
     * @memberof SodViolationCheckResult
     */
    'clientMetadata'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<SodViolationContext>}
     * @memberof SodViolationCheckResult
     */
    'violationContexts'?: Array<SodViolationContext>;
    /**
     * A list of the SOD policies that were violated.
     * @type {Array<SodPolicyDto>}
     * @memberof SodViolationCheckResult
     */
    'violatedPolicies'?: Array<SodPolicyDto>;
}
/**
 * The contextual information of the violated criteria
 * @export
 * @interface SodViolationContext
 */
export interface SodViolationContext {
    /**
     * 
     * @type {SodPolicyDto}
     * @memberof SodViolationContext
     */
    'policy'?: SodPolicyDto;
    /**
     * 
     * @type {SodViolationContextConflictingAccessCriteria}
     * @memberof SodViolationContext
     */
    'conflictingAccessCriteria'?: SodViolationContextConflictingAccessCriteria;
}
/**
 * An object referencing a completed SOD violation check
 * @export
 * @interface SodViolationContextCheckCompleted
 */
export interface SodViolationContextCheckCompleted {
    /**
     * The status of SOD violation check
     * @type {string}
     * @memberof SodViolationContextCheckCompleted
     */
    'state'?: SodViolationContextCheckCompletedStateEnum;
    /**
     * The id of the Violation check event
     * @type {string}
     * @memberof SodViolationContextCheckCompleted
     */
    'uuid'?: string;
    /**
     * 
     * @type {SodViolationCheckResult}
     * @memberof SodViolationContextCheckCompleted
     */
    'violationCheckResult'?: SodViolationCheckResult;
}

export const SodViolationContextCheckCompletedStateEnum = {
    Success: 'SUCCESS',
    Error: 'ERROR'
} as const;

export type SodViolationContextCheckCompletedStateEnum = typeof SodViolationContextCheckCompletedStateEnum[keyof typeof SodViolationContextCheckCompletedStateEnum];

/**
 * The object which contains the left and right hand side of the entitlements that got violated according to the policy.
 * @export
 * @interface SodViolationContextConflictingAccessCriteria
 */
export interface SodViolationContextConflictingAccessCriteria {
    /**
     * 
     * @type {SodViolationContextConflictingAccessCriteriaLeftCriteria}
     * @memberof SodViolationContextConflictingAccessCriteria
     */
    'leftCriteria'?: SodViolationContextConflictingAccessCriteriaLeftCriteria;
    /**
     * 
     * @type {SodViolationContextConflictingAccessCriteriaLeftCriteria}
     * @memberof SodViolationContextConflictingAccessCriteria
     */
    'rightCriteria'?: SodViolationContextConflictingAccessCriteriaLeftCriteria;
}
/**
 * 
 * @export
 * @interface SodViolationContextConflictingAccessCriteriaLeftCriteria
 */
export interface SodViolationContextConflictingAccessCriteriaLeftCriteria {
    /**
     * 
     * @type {Array<SodExemptCriteria>}
     * @memberof SodViolationContextConflictingAccessCriteriaLeftCriteria
     */
    'criteriaList'?: Array<SodExemptCriteria>;
}
/**
 * 
 * @export
 * @interface Source
 */
export interface Source {
    /**
     * the id of the Source
     * @type {string}
     * @memberof Source
     */
    'id'?: string;
    /**
     * Human-readable name of the source
     * @type {string}
     * @memberof Source
     */
    'name': string;
    /**
     * Human-readable description of the source
     * @type {string}
     * @memberof Source
     */
    'description'?: string;
    /**
     * 
     * @type {SourceOwner}
     * @memberof Source
     */
    'owner': SourceOwner;
    /**
     * 
     * @type {SourceCluster}
     * @memberof Source
     */
    'cluster'?: SourceCluster;
    /**
     * 
     * @type {SourceAccountCorrelationConfig}
     * @memberof Source
     */
    'accountCorrelationConfig'?: SourceAccountCorrelationConfig;
    /**
     * 
     * @type {SourceAccountCorrelationRule}
     * @memberof Source
     */
    'accountCorrelationRule'?: SourceAccountCorrelationRule;
    /**
     * 
     * @type {ManagerCorrelationMapping}
     * @memberof Source
     */
    'managerCorrelationMapping'?: ManagerCorrelationMapping;
    /**
     * 
     * @type {SourceManagerCorrelationRule}
     * @memberof Source
     */
    'managerCorrelationRule'?: SourceManagerCorrelationRule;
    /**
     * 
     * @type {SourceBeforeProvisioningRule}
     * @memberof Source
     */
    'beforeProvisioningRule'?: SourceBeforeProvisioningRule;
    /**
     * List of references to Schema objects
     * @type {Array<SourceSchemasInner>}
     * @memberof Source
     */
    'schemas'?: Array<SourceSchemasInner>;
    /**
     * List of references to the associated PasswordPolicy objects.
     * @type {Array<SourcePasswordPoliciesInner>}
     * @memberof Source
     */
    'passwordPolicies'?: Array<SourcePasswordPoliciesInner>;
    /**
     * Optional features that can be supported by a source.
     * @type {Array<SourceFeature>}
     * @memberof Source
     */
    'features'?: Array<SourceFeature>;
    /**
     * Specifies the type of system being managed e.g. Active Directory, Workday, etc.. If you are creating a Delimited File source, you must set the `provisionasCsv` query parameter to `true`. 
     * @type {string}
     * @memberof Source
     */
    'type'?: string;
    /**
     * Connector script name.
     * @type {string}
     * @memberof Source
     */
    'connector': string;
    /**
     * The fully qualified name of the Java class that implements the connector interface.
     * @type {string}
     * @memberof Source
     */
    'connectorClass'?: string;
    /**
     * Connector specific configuration; will differ from type to type.
     * @type {object}
     * @memberof Source
     */
    'connectorAttributes'?: object;
    /**
     * Number from 0 to 100 that specifies when to skip the delete phase.
     * @type {number}
     * @memberof Source
     */
    'deleteThreshold'?: number;
    /**
     * When true indicates the source is referenced by an IdentityProfile.
     * @type {boolean}
     * @memberof Source
     */
    'authoritative'?: boolean;
    /**
     * 
     * @type {SourceManagementWorkgroup}
     * @memberof Source
     */
    'managementWorkgroup'?: SourceManagementWorkgroup;
    /**
     * When true indicates a healthy source
     * @type {boolean}
     * @memberof Source
     */
    'healthy'?: boolean;
    /**
     * A status identifier, giving specific information on why a source is healthy or not
     * @type {string}
     * @memberof Source
     */
    'status'?: string;
    /**
     * Timestamp showing when a source health check was last performed
     * @type {string}
     * @memberof Source
     */
    'since'?: string;
    /**
     * The id of connector
     * @type {string}
     * @memberof Source
     */
    'connectorId'?: string;
    /**
     * The name of the connector that was chosen on source creation
     * @type {string}
     * @memberof Source
     */
    'connectorName'?: string;
    /**
     * The type of connection (direct or file)
     * @type {string}
     * @memberof Source
     */
    'connectionType'?: string;
    /**
     * The connector implementation id
     * @type {string}
     * @memberof Source
     */
    'connectorImplementationId'?: string;
}
/**
 * Reference to an Account Correlation Config object
 * @export
 * @interface SourceAccountCorrelationConfig
 */
export interface SourceAccountCorrelationConfig {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceAccountCorrelationConfig
     */
    'type'?: SourceAccountCorrelationConfigTypeEnum;
    /**
     * ID of the account correlation config
     * @type {string}
     * @memberof SourceAccountCorrelationConfig
     */
    'id'?: string;
    /**
     * Human-readable display name of the account correlation config
     * @type {string}
     * @memberof SourceAccountCorrelationConfig
     */
    'name'?: string;
}

export const SourceAccountCorrelationConfigTypeEnum = {
    AccountCorrelationConfig: 'ACCOUNT_CORRELATION_CONFIG'
} as const;

export type SourceAccountCorrelationConfigTypeEnum = typeof SourceAccountCorrelationConfigTypeEnum[keyof typeof SourceAccountCorrelationConfigTypeEnum];

/**
 * Reference to a Rule that can do COMPLEX correlation, should only be used when accountCorrelationConfig can\'t be used.
 * @export
 * @interface SourceAccountCorrelationRule
 */
export interface SourceAccountCorrelationRule {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceAccountCorrelationRule
     */
    'type'?: SourceAccountCorrelationRuleTypeEnum;
    /**
     * ID of the rule
     * @type {string}
     * @memberof SourceAccountCorrelationRule
     */
    'id'?: string;
    /**
     * Human-readable display name of the rule
     * @type {string}
     * @memberof SourceAccountCorrelationRule
     */
    'name'?: string;
}

export const SourceAccountCorrelationRuleTypeEnum = {
    Rule: 'RULE'
} as const;

export type SourceAccountCorrelationRuleTypeEnum = typeof SourceAccountCorrelationRuleTypeEnum[keyof typeof SourceAccountCorrelationRuleTypeEnum];

/**
 * Rule that runs on the CCG and allows for customization of provisioning plans before the connector is called.
 * @export
 * @interface SourceBeforeProvisioningRule
 */
export interface SourceBeforeProvisioningRule {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceBeforeProvisioningRule
     */
    'type'?: SourceBeforeProvisioningRuleTypeEnum;
    /**
     * ID of the rule
     * @type {string}
     * @memberof SourceBeforeProvisioningRule
     */
    'id'?: string;
    /**
     * Human-readable display name of the rule
     * @type {string}
     * @memberof SourceBeforeProvisioningRule
     */
    'name'?: string;
}

export const SourceBeforeProvisioningRuleTypeEnum = {
    Rule: 'RULE'
} as const;

export type SourceBeforeProvisioningRuleTypeEnum = typeof SourceBeforeProvisioningRuleTypeEnum[keyof typeof SourceBeforeProvisioningRuleTypeEnum];

/**
 * Reference to the associated Cluster
 * @export
 * @interface SourceCluster
 */
export interface SourceCluster {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceCluster
     */
    'type': SourceClusterTypeEnum;
    /**
     * ID of the cluster
     * @type {string}
     * @memberof SourceCluster
     */
    'id': string;
    /**
     * Human-readable display name of the cluster
     * @type {string}
     * @memberof SourceCluster
     */
    'name': string;
}

export const SourceClusterTypeEnum = {
    Cluster: 'CLUSTER'
} as const;

export type SourceClusterTypeEnum = typeof SourceClusterTypeEnum[keyof typeof SourceClusterTypeEnum];

/**
 * Source cluster.
 * @export
 * @interface SourceClusterDto
 */
export interface SourceClusterDto {
    /**
     * Source cluster DTO type.
     * @type {string}
     * @memberof SourceClusterDto
     */
    'type'?: SourceClusterDtoTypeEnum;
    /**
     * Source cluster ID.
     * @type {string}
     * @memberof SourceClusterDto
     */
    'id'?: string;
    /**
     * Source cluster display name.
     * @type {string}
     * @memberof SourceClusterDto
     */
    'name'?: string;
}

export const SourceClusterDtoTypeEnum = {
    Cluster: 'CLUSTER'
} as const;

export type SourceClusterDtoTypeEnum = typeof SourceClusterDtoTypeEnum[keyof typeof SourceClusterDtoTypeEnum];

/**
 * Optional features that can be supported by an source. * AUTHENTICATE: The source supports pass-through authentication. * COMPOSITE: The source supports composite source creation. * DIRECT_PERMISSIONS: The source supports returning DirectPermissions. * DISCOVER_SCHEMA: The source supports discovering schemas for users and groups. * ENABLE The source supports reading if an account is enabled or disabled. * MANAGER_LOOKUP: The source supports looking up managers as they are encountered in a feed. This is the opposite of NO_RANDOM_ACCESS. * NO_RANDOM_ACCESS: The source does not support random access and the getObject() methods should not be called and expected to perform. * PROXY: The source can serve as a proxy for another source. When an source has a proxy, all connector calls made with that source are redirected through the connector for the proxy source. * SEARCH * TEMPLATE * UNLOCK: The source supports reading if an account is locked or unlocked. * UNSTRUCTURED_TARGETS: The source supports returning unstructured Targets. * SHAREPOINT_TARGET: The source supports returning unstructured Target data for SharePoint. It will be typically used by AD, LDAP sources. * PROVISIONING: The source can both read and write accounts. Having this feature implies that the provision() method is implemented. It also means that direct and target permissions can also be provisioned if they can be returned by aggregation. * GROUP_PROVISIONING: The source can both read and write groups. Having this feature implies that the provision() method is implemented. * SYNC_PROVISIONING: The source can provision accounts synchronously. * PASSWORD: The source can provision password changes. Since sources can never read passwords, this is should only be used in conjunction with the PROVISIONING feature. * CURRENT_PASSWORD: Some source types support verification of the current password * ACCOUNT_ONLY_REQUEST: The source supports requesting accounts without entitlements. * ADDITIONAL_ACCOUNT_REQUEST: The source supports requesting additional accounts. * NO_AGGREGATION: A source that does not support aggregation. * GROUPS_HAVE_MEMBERS: The source models group memberships with a member attribute on the group object rather than a groups attribute on the account object. This effects the implementation of delta account aggregation. * NO_PERMISSIONS_PROVISIONING: Indicates that the connector cannot provision direct or target permissions for accounts. When DIRECT_PERMISSIONS and PROVISIONING features are present, it is assumed that the connector can also provision direct permissions. This feature disables that assumption and causes permission request to be converted to work items for accounts. * NO_GROUP_PERMISSIONS_PROVISIONING: Indicates that the connector cannot provision direct or target permissions for groups. When DIRECT_PERMISSIONS and PROVISIONING features are present, it is assumed that the connector can also provision direct permissions. This feature disables that assumption and causes permission request to be converted to work items for groups. * NO_UNSTRUCTURED_TARGETS_PROVISIONING: This string will be replaced by NO_GROUP_PERMISSIONS_PROVISIONING and NO_PERMISSIONS_PROVISIONING. * NO_DIRECT_PERMISSIONS_PROVISIONING: This string will be replaced by NO_GROUP_PERMISSIONS_PROVISIONING and NO_PERMISSIONS_PROVISIONING.
 * @export
 * @enum {string}
 */

export const SourceFeature = {
    Authenticate: 'AUTHENTICATE',
    Composite: 'COMPOSITE',
    DirectPermissions: 'DIRECT_PERMISSIONS',
    DiscoverSchema: 'DISCOVER_SCHEMA',
    Enable: 'ENABLE',
    ManagerLookup: 'MANAGER_LOOKUP',
    NoRandomAccess: 'NO_RANDOM_ACCESS',
    Proxy: 'PROXY',
    Search: 'SEARCH',
    Template: 'TEMPLATE',
    Unlock: 'UNLOCK',
    UnstructuredTargets: 'UNSTRUCTURED_TARGETS',
    SharepointTarget: 'SHAREPOINT_TARGET',
    Provisioning: 'PROVISIONING',
    GroupProvisioning: 'GROUP_PROVISIONING',
    SyncProvisioning: 'SYNC_PROVISIONING',
    Password: 'PASSWORD',
    CurrentPassword: 'CURRENT_PASSWORD',
    AccountOnlyRequest: 'ACCOUNT_ONLY_REQUEST',
    AdditionalAccountRequest: 'ADDITIONAL_ACCOUNT_REQUEST',
    NoAggregation: 'NO_AGGREGATION',
    GroupsHaveMembers: 'GROUPS_HAVE_MEMBERS',
    NoPermissionsProvisioning: 'NO_PERMISSIONS_PROVISIONING',
    NoGroupPermissionsProvisioning: 'NO_GROUP_PERMISSIONS_PROVISIONING',
    NoUnstructuredTargetsProvisioning: 'NO_UNSTRUCTURED_TARGETS_PROVISIONING',
    NoDirectPermissionsProvisioning: 'NO_DIRECT_PERMISSIONS_PROVISIONING',
    PreferUuid: 'PREFER_UUID'
} as const;

export type SourceFeature = typeof SourceFeature[keyof typeof SourceFeature];


/**
 * Dto for source health data
 * @export
 * @interface SourceHealthDto
 */
export interface SourceHealthDto {
    /**
     * the id of the Source
     * @type {string}
     * @memberof SourceHealthDto
     */
    'id'?: string;
    /**
     * Specifies the type of system being managed e.g. Active Directory, Workday, etc.. If you are creating a Delimited File source, you must set the `provisionasCsv` query parameter to `true`. 
     * @type {string}
     * @memberof SourceHealthDto
     */
    'type'?: string;
    /**
     * the name of the source
     * @type {string}
     * @memberof SourceHealthDto
     */
    'name'?: string;
    /**
     * source\'s org
     * @type {string}
     * @memberof SourceHealthDto
     */
    'org'?: string;
    /**
     * Is the source authoritative
     * @type {boolean}
     * @memberof SourceHealthDto
     */
    'isAuthoritative'?: boolean;
    /**
     * Is the source in a cluster
     * @type {boolean}
     * @memberof SourceHealthDto
     */
    'isCluster'?: boolean;
    /**
     * source\'s hostname
     * @type {string}
     * @memberof SourceHealthDto
     */
    'hostname'?: string;
    /**
     * source\'s pod
     * @type {string}
     * @memberof SourceHealthDto
     */
    'pod'?: string;
    /**
     * The version of the iqService
     * @type {string}
     * @memberof SourceHealthDto
     */
    'iqServiceVersion'?: string;
    /**
     * connection test result
     * @type {string}
     * @memberof SourceHealthDto
     */
    'status'?: SourceHealthDtoStatusEnum;
}

export const SourceHealthDtoStatusEnum = {
    ErrorCluster: 'SOURCE_STATE_ERROR_CLUSTER',
    ErrorSource: 'SOURCE_STATE_ERROR_SOURCE',
    ErrorVa: 'SOURCE_STATE_ERROR_VA',
    FailureCluster: 'SOURCE_STATE_FAILURE_CLUSTER',
    FailureSource: 'SOURCE_STATE_FAILURE_SOURCE',
    Healthy: 'SOURCE_STATE_HEALTHY',
    UncheckedCluster: 'SOURCE_STATE_UNCHECKED_CLUSTER',
    UncheckedClusterNoSources: 'SOURCE_STATE_UNCHECKED_CLUSTER_NO_SOURCES',
    UncheckedSource: 'SOURCE_STATE_UNCHECKED_SOURCE',
    UncheckedSourceNoAccounts: 'SOURCE_STATE_UNCHECKED_SOURCE_NO_ACCOUNTS'
} as const;

export type SourceHealthDtoStatusEnum = typeof SourceHealthDtoStatusEnum[keyof typeof SourceHealthDtoStatusEnum];

/**
 * Reference to Management Workgroup for this Source
 * @export
 * @interface SourceManagementWorkgroup
 */
export interface SourceManagementWorkgroup {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceManagementWorkgroup
     */
    'type'?: SourceManagementWorkgroupTypeEnum;
    /**
     * ID of the management workgroup
     * @type {string}
     * @memberof SourceManagementWorkgroup
     */
    'id'?: string;
    /**
     * Human-readable display name of the management workgroup
     * @type {string}
     * @memberof SourceManagementWorkgroup
     */
    'name'?: string;
}

export const SourceManagementWorkgroupTypeEnum = {
    GovernanceGroup: 'GOVERNANCE_GROUP'
} as const;

export type SourceManagementWorkgroupTypeEnum = typeof SourceManagementWorkgroupTypeEnum[keyof typeof SourceManagementWorkgroupTypeEnum];

/**
 * Reference to the ManagerCorrelationRule, only used when a simple filter isn\'t sufficient.
 * @export
 * @interface SourceManagerCorrelationRule
 */
export interface SourceManagerCorrelationRule {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceManagerCorrelationRule
     */
    'type'?: SourceManagerCorrelationRuleTypeEnum;
    /**
     * ID of the rule
     * @type {string}
     * @memberof SourceManagerCorrelationRule
     */
    'id'?: string;
    /**
     * Human-readable display name of the rule
     * @type {string}
     * @memberof SourceManagerCorrelationRule
     */
    'name'?: string;
}

export const SourceManagerCorrelationRuleTypeEnum = {
    Rule: 'RULE'
} as const;

export type SourceManagerCorrelationRuleTypeEnum = typeof SourceManagerCorrelationRuleTypeEnum[keyof typeof SourceManagerCorrelationRuleTypeEnum];

/**
 * Reference to an owning Identity Object
 * @export
 * @interface SourceOwner
 */
export interface SourceOwner {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceOwner
     */
    'type'?: SourceOwnerTypeEnum;
    /**
     * ID of the identity
     * @type {string}
     * @memberof SourceOwner
     */
    'id'?: string;
    /**
     * Human-readable display name of the identity
     * @type {string}
     * @memberof SourceOwner
     */
    'name'?: string;
}

export const SourceOwnerTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type SourceOwnerTypeEnum = typeof SourceOwnerTypeEnum[keyof typeof SourceOwnerTypeEnum];

/**
 * 
 * @export
 * @interface SourcePasswordPoliciesInner
 */
export interface SourcePasswordPoliciesInner {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourcePasswordPoliciesInner
     */
    'type'?: SourcePasswordPoliciesInnerTypeEnum;
    /**
     * ID of the policy
     * @type {string}
     * @memberof SourcePasswordPoliciesInner
     */
    'id'?: string;
    /**
     * Human-readable display name of the policy
     * @type {string}
     * @memberof SourcePasswordPoliciesInner
     */
    'name'?: string;
}

export const SourcePasswordPoliciesInnerTypeEnum = {
    PasswordPolicy: 'PASSWORD_POLICY'
} as const;

export type SourcePasswordPoliciesInnerTypeEnum = typeof SourcePasswordPoliciesInnerTypeEnum[keyof typeof SourcePasswordPoliciesInnerTypeEnum];

/**
 * 
 * @export
 * @interface SourceSchemasInner
 */
export interface SourceSchemasInner {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceSchemasInner
     */
    'type'?: SourceSchemasInnerTypeEnum;
    /**
     * ID of the schema
     * @type {string}
     * @memberof SourceSchemasInner
     */
    'id'?: string;
    /**
     * Human-readable display name of the schema
     * @type {string}
     * @memberof SourceSchemasInner
     */
    'name'?: string;
}

export const SourceSchemasInnerTypeEnum = {
    ConnectorSchema: 'CONNECTOR_SCHEMA'
} as const;

export type SourceSchemasInnerTypeEnum = typeof SourceSchemasInnerTypeEnum[keyof typeof SourceSchemasInnerTypeEnum];

/**
 * 
 * @export
 * @interface SourceUsage
 */
export interface SourceUsage {
    /**
     * The first day of the month for which activity is aggregated.
     * @type {string}
     * @memberof SourceUsage
     */
    'date'?: string;
    /**
     * The average number of days that accounts were active within this source, for the month.
     * @type {number}
     * @memberof SourceUsage
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface SourceUsageStatus
 */
export interface SourceUsageStatus {
    /**
     * Source Usage Status. Acceptable values are:   - COMPLETE       - This status means that an activity data source has been setup and usage insights are available for the source.   - INCOMPLETE       - This status means that an activity data source has not been setup and usage insights are not available for the source.
     * @type {string}
     * @memberof SourceUsageStatus
     */
    'status'?: SourceUsageStatusStatusEnum;
}

export const SourceUsageStatusStatusEnum = {
    Complete: 'COMPLETE',
    Incomplete: 'INCOMPLETE'
} as const;

export type SourceUsageStatusStatusEnum = typeof SourceUsageStatusStatusEnum[keyof typeof SourceUsageStatusStatusEnum];

/**
 * Message model for Config Import/Export.
 * @export
 * @interface SpConfigMessage
 */
export interface SpConfigMessage {
    /**
     * Message key.
     * @type {string}
     * @memberof SpConfigMessage
     */
    'key': string;
    /**
     * Message text.
     * @type {string}
     * @memberof SpConfigMessage
     */
    'text': string;
    /**
     * Message details if any, in key:value pairs.
     * @type {{ [key: string]: any; }}
     * @memberof SpConfigMessage
     */
    'details': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Split
 */
export interface Split {
    /**
     * This can be either a single character or a regex expression, and is used by the transform to identify the break point between two substrings in the incoming data
     * @type {string}
     * @memberof Split
     */
    'delimiter': string;
    /**
     * An integer value for the desired array element after the incoming data has been split into a list; the array is a 0-based object, so the first array element would be index 0, the second element would be index 1, etc.
     * @type {string}
     * @memberof Split
     */
    'index': string;
    /**
     * A boolean (true/false) value which indicates whether an exception should be thrown and returned as an output when an index is out of bounds with the resultant array (i.e., the provided index value is larger than the size of the array)   `true` - The transform should return \"IndexOutOfBoundsException\"   `false` - The transform should return null   If not provided, the transform will default to false and return a null 
     * @type {boolean}
     * @memberof Split
     */
    'throws'?: boolean;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Split
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Split
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Static
 */
export interface Static {
    /**
     * This must evaluate to a JSON string, either through a fixed value or through conditional logic using the Apache Velocity Template Language.
     * @type {string}
     * @memberof Static
     */
    'values': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Static
     */
    'requiresPeriodicRefresh'?: boolean;
}
/**
 * 
 * @export
 * @interface SubSearchAggregationSpecification
 */
export interface SubSearchAggregationSpecification {
    /**
     * 
     * @type {NestedAggregation}
     * @memberof SubSearchAggregationSpecification
     */
    'nested'?: NestedAggregation;
    /**
     * 
     * @type {MetricAggregation}
     * @memberof SubSearchAggregationSpecification
     */
    'metric'?: MetricAggregation;
    /**
     * 
     * @type {FilterAggregation}
     * @memberof SubSearchAggregationSpecification
     */
    'filter'?: FilterAggregation;
    /**
     * 
     * @type {BucketAggregation}
     * @memberof SubSearchAggregationSpecification
     */
    'bucket'?: BucketAggregation;
    /**
     * 
     * @type {Aggregations}
     * @memberof SubSearchAggregationSpecification
     */
    'subAggregation'?: Aggregations;
}
/**
 * 
 * @export
 * @interface Substring
 */
export interface Substring {
    /**
     * The index of the first character to include in the returned substring.   If `begin` is set to -1, the transform will begin at character 0 of the input data 
     * @type {number}
     * @memberof Substring
     */
    'begin': number;
    /**
     * This integer value is the number of characters to add to the begin attribute when returning a substring.   This attribute is only used if begin is not -1. 
     * @type {number}
     * @memberof Substring
     */
    'beginOffset'?: number;
    /**
     * The index of the first character to exclude from the returned substring.  If end is -1 or not provided at all, the substring transform will return everything up to the end of the input string. 
     * @type {number}
     * @memberof Substring
     */
    'end'?: number;
    /**
     * This integer value is the number of characters to add to the end attribute when returning a substring.   This attribute is only used if end is provided and is not -1. 
     * @type {number}
     * @memberof Substring
     */
    'endOffset'?: number;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Substring
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Substring
     */
    'input'?: { [key: string]: any; };
}
/**
 * Tagged object.
 * @export
 * @interface TaggedObject
 */
export interface TaggedObject {
    /**
     * 
     * @type {TaggedObjectDto}
     * @memberof TaggedObject
     */
    'objectRef'?: TaggedObjectDto;
    /**
     * Labels to be applied to an Object
     * @type {Array<string>}
     * @memberof TaggedObject
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TaggedObjectDto
 */
export interface TaggedObjectDto {
    /**
     * DTO type
     * @type {string}
     * @memberof TaggedObjectDto
     */
    'type'?: TaggedObjectDtoTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof TaggedObjectDto
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof TaggedObjectDto
     */
    'name'?: string | null;
}

export const TaggedObjectDtoTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    Application: 'APPLICATION',
    Campaign: 'CAMPAIGN',
    Entitlement: 'ENTITLEMENT',
    Identity: 'IDENTITY',
    Role: 'ROLE',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE'
} as const;

export type TaggedObjectDtoTypeEnum = typeof TaggedObjectDtoTypeEnum[keyof typeof TaggedObjectDtoTypeEnum];

/**
 * Details about job or task type, state and lifecycle.
 * @export
 * @interface TaskResultDetails
 */
export interface TaskResultDetails {
    /**
     * Type of the job or task underlying in the report processing. It could be a quartz task, QPOC or MENTOS jobs or a refresh/sync task.
     * @type {string}
     * @memberof TaskResultDetails
     */
    'type'?: TaskResultDetailsTypeEnum;
    /**
     * Unique task definition identifier.
     * @type {string}
     * @memberof TaskResultDetails
     */
    'id'?: string;
    /**
     * Use this property to define what report should be processed in the RDE service.
     * @type {object}
     * @memberof TaskResultDetails
     */
    'reportType'?: TaskResultDetailsReportTypeEnum;
    /**
     * Description of the report purpose and/or contents.
     * @type {string}
     * @memberof TaskResultDetails
     */
    'description'?: string;
    /**
     * Name of the parent task/report if exists.
     * @type {string}
     * @memberof TaskResultDetails
     */
    'parentName'?: string | null;
    /**
     * Name of the report processing initiator.
     * @type {string}
     * @memberof TaskResultDetails
     */
    'launcher'?: string;
    /**
     * Report creation date
     * @type {string}
     * @memberof TaskResultDetails
     */
    'created'?: string;
    /**
     * Report start date
     * @type {string}
     * @memberof TaskResultDetails
     */
    'launched'?: string | null;
    /**
     * Report completion date
     * @type {string}
     * @memberof TaskResultDetails
     */
    'completed'?: string | null;
    /**
     * Report completion status.
     * @type {string}
     * @memberof TaskResultDetails
     */
    'completionStatus'?: TaskResultDetailsCompletionStatusEnum;
    /**
     * List of the messages dedicated to the report.  From task definition perspective here usually should be warnings or errors.
     * @type {Array<TaskResultDetailsMessagesInner>}
     * @memberof TaskResultDetails
     */
    'messages'?: Array<TaskResultDetailsMessagesInner>;
    /**
     * Task definition results, if necessary.
     * @type {Array<TaskResultDetailsReturnsInner>}
     * @memberof TaskResultDetails
     */
    'returns'?: Array<TaskResultDetailsReturnsInner>;
    /**
     * Extra attributes map(dictionary) needed for the report.
     * @type {{ [key: string]: object; }}
     * @memberof TaskResultDetails
     */
    'attributes'?: { [key: string]: object; };
    /**
     * Current report state.
     * @type {string}
     * @memberof TaskResultDetails
     */
    'progress'?: string | null;
}

export const TaskResultDetailsTypeEnum = {
    Quartz: 'QUARTZ',
    Qpoc: 'QPOC',
    Mentos: 'MENTOS',
    QueuedTask: 'QUEUED_TASK'
} as const;

export type TaskResultDetailsTypeEnum = typeof TaskResultDetailsTypeEnum[keyof typeof TaskResultDetailsTypeEnum];
export const TaskResultDetailsReportTypeEnum = {
    Accounts: 'ACCOUNTS',
    IdentitiesDetails: 'IDENTITIES_DETAILS',
    Identities: 'IDENTITIES',
    IdentityProfileIdentityError: 'IDENTITY_PROFILE_IDENTITY_ERROR',
    OrphanIdentities: 'ORPHAN_IDENTITIES',
    SearchExport: 'SEARCH_EXPORT',
    UncorrelatedAccounts: 'UNCORRELATED_ACCOUNTS'
} as const;

export type TaskResultDetailsReportTypeEnum = typeof TaskResultDetailsReportTypeEnum[keyof typeof TaskResultDetailsReportTypeEnum];
export const TaskResultDetailsCompletionStatusEnum = {
    Success: 'SUCCESS',
    Warning: 'WARNING',
    Error: 'ERROR',
    Terminated: 'TERMINATED',
    TempError: 'TEMP_ERROR'
} as const;

export type TaskResultDetailsCompletionStatusEnum = typeof TaskResultDetailsCompletionStatusEnum[keyof typeof TaskResultDetailsCompletionStatusEnum];

/**
 * 
 * @export
 * @interface TaskResultDetailsMessagesInner
 */
export interface TaskResultDetailsMessagesInner {
    /**
     * Type of the message.
     * @type {string}
     * @memberof TaskResultDetailsMessagesInner
     */
    'type'?: TaskResultDetailsMessagesInnerTypeEnum;
    /**
     * Flag whether message is an error.
     * @type {boolean}
     * @memberof TaskResultDetailsMessagesInner
     */
    'error'?: boolean;
    /**
     * Flag whether message is a warning.
     * @type {boolean}
     * @memberof TaskResultDetailsMessagesInner
     */
    'warning'?: boolean;
    /**
     * Message string identifier.
     * @type {string}
     * @memberof TaskResultDetailsMessagesInner
     */
    'key'?: string;
    /**
     * Message context with the locale based language.
     * @type {string}
     * @memberof TaskResultDetailsMessagesInner
     */
    'localizedText'?: string;
}

export const TaskResultDetailsMessagesInnerTypeEnum = {
    Info: 'INFO',
    Warn: 'WARN',
    Error: 'ERROR'
} as const;

export type TaskResultDetailsMessagesInnerTypeEnum = typeof TaskResultDetailsMessagesInnerTypeEnum[keyof typeof TaskResultDetailsMessagesInnerTypeEnum];

/**
 * 
 * @export
 * @interface TaskResultDetailsReturnsInner
 */
export interface TaskResultDetailsReturnsInner {
    /**
     * Attribute description.
     * @type {string}
     * @memberof TaskResultDetailsReturnsInner
     */
    'displayLabel'?: string;
    /**
     * System or database attribute name.
     * @type {string}
     * @memberof TaskResultDetailsReturnsInner
     */
    'attributeName'?: string;
}
/**
 * Task result.
 * @export
 * @interface TaskResultDto
 */
export interface TaskResultDto {
    /**
     * Task result DTO type.
     * @type {string}
     * @memberof TaskResultDto
     */
    'type'?: TaskResultDtoTypeEnum;
    /**
     * Task result ID.
     * @type {string}
     * @memberof TaskResultDto
     */
    'id'?: string;
    /**
     * Task result display name.
     * @type {string}
     * @memberof TaskResultDto
     */
    'name'?: string | null;
}

export const TaskResultDtoTypeEnum = {
    TaskResult: 'TASK_RESULT'
} as const;

export type TaskResultDtoTypeEnum = typeof TaskResultDtoTypeEnum[keyof typeof TaskResultDtoTypeEnum];

/**
 * 
 * @export
 * @interface TaskResultSimplified
 */
export interface TaskResultSimplified {
    /**
     * Task identifier
     * @type {string}
     * @memberof TaskResultSimplified
     */
    'id'?: string;
    /**
     * Task name
     * @type {string}
     * @memberof TaskResultSimplified
     */
    'name'?: string;
    /**
     * Task description
     * @type {string}
     * @memberof TaskResultSimplified
     */
    'description'?: string;
    /**
     * User or process who launched the task
     * @type {string}
     * @memberof TaskResultSimplified
     */
    'launcher'?: string;
    /**
     * Date time of completion
     * @type {string}
     * @memberof TaskResultSimplified
     */
    'completed'?: string;
    /**
     * Date time when the task was launched
     * @type {string}
     * @memberof TaskResultSimplified
     */
    'launched'?: string;
    /**
     * Task result status
     * @type {string}
     * @memberof TaskResultSimplified
     */
    'completionStatus'?: TaskResultSimplifiedCompletionStatusEnum;
}

export const TaskResultSimplifiedCompletionStatusEnum = {
    Success: 'Success',
    Warning: 'Warning',
    Error: 'Error',
    Terminated: 'Terminated',
    TempError: 'TempError'
} as const;

export type TaskResultSimplifiedCompletionStatusEnum = typeof TaskResultSimplifiedCompletionStatusEnum[keyof typeof TaskResultSimplifiedCompletionStatusEnum];

/**
 * Query parameters used to construct an Elasticsearch text query object.
 * @export
 * @interface TextQuery
 */
export interface TextQuery {
    /**
     * Words or characters that specify a particular thing to be searched for.
     * @type {Array<string>}
     * @memberof TextQuery
     */
    'terms': Array<string>;
    /**
     * The fields to be searched.
     * @type {Array<string>}
     * @memberof TextQuery
     */
    'fields': Array<string>;
    /**
     * Indicates that at least one of the terms must be found in the specified fields;  otherwise, all terms must be found.
     * @type {boolean}
     * @memberof TextQuery
     */
    'matchAny'?: boolean;
    /**
     * Indicates that the terms can be located anywhere in the specified fields;  otherwise, the fields must begin with the terms.
     * @type {boolean}
     * @memberof TextQuery
     */
    'contains'?: boolean;
}
/**
 * The representation of an internally- or customer-defined transform.
 * @export
 * @interface Transform
 */
export interface Transform {
    /**
     * Unique name of this transform
     * @type {string}
     * @memberof Transform
     */
    'name': string;
    /**
     * The type of transform operation
     * @type {string}
     * @memberof Transform
     */
    'type': TransformTypeEnum;
    /**
     * 
     * @type {TransformAttributes}
     * @memberof Transform
     */
    'attributes': TransformAttributes | null;
}

export const TransformTypeEnum = {
    AccountAttribute: 'accountAttribute',
    Base64Decode: 'base64Decode',
    Base64Encode: 'base64Encode',
    Concat: 'concat',
    Conditional: 'conditional',
    DateCompare: 'dateCompare',
    DateFormat: 'dateFormat',
    DateMath: 'dateMath',
    DecomposeDiacriticalMarks: 'decomposeDiacriticalMarks',
    E164phone: 'e164phone',
    FirstValid: 'firstValid',
    Rule: 'rule',
    IdentityAttribute: 'identityAttribute',
    IndexOf: 'indexOf',
    Iso3166: 'iso3166',
    LastIndexOf: 'lastIndexOf',
    LeftPad: 'leftPad',
    Lookup: 'lookup',
    Lower: 'lower',
    NormalizeNames: 'normalizeNames',
    RandomAlphaNumeric: 'randomAlphaNumeric',
    RandomNumeric: 'randomNumeric',
    Reference: 'reference',
    ReplaceAll: 'replaceAll',
    Replace: 'replace',
    RightPad: 'rightPad',
    Split: 'split',
    Static: 'static',
    Substring: 'substring',
    Trim: 'trim',
    Upper: 'upper',
    UsernameGenerator: 'usernameGenerator',
    Uuid: 'uuid'
} as const;

export type TransformTypeEnum = typeof TransformTypeEnum[keyof typeof TransformTypeEnum];

/**
 * @type TransformAttributes
 * Meta-data about the transform. Values in this list are specific to the type of transform to be executed.
 * @export
 */
export type TransformAttributes = AccountAttribute | Base64Decode | Base64Encode | Concatenation | Conditional | DateCompare | DateFormat | DateMath | DecomposeDiacriticalMarks | E164phone | FirstValid | ISO3166 | IdentityAttribute | IndexOf | LeftPad | Lookup | Lower | NameNormalizer | RandomAlphaNumeric | RandomNumeric | Reference | Replace | ReplaceAll | RightPad | Rule | Split | Static | Substring | Trim | UUIDGenerator | Upper;

/**
 * 
 * @export
 * @interface TransformDefinition
 */
export interface TransformDefinition {
    /**
     * The type of the transform definition.
     * @type {string}
     * @memberof TransformDefinition
     */
    'type'?: string;
    /**
     * Arbitrary key-value pairs to store any metadata for the object
     * @type {{ [key: string]: TransformDefinitionAttributesValue; }}
     * @memberof TransformDefinition
     */
    'attributes'?: { [key: string]: TransformDefinitionAttributesValue; };
}
/**
 * 
 * @export
 * @interface TransformDefinitionAttributesValue
 */
export interface TransformDefinitionAttributesValue {
}
/**
 * 
 * @export
 * @interface TransformRead
 */
export interface TransformRead {
    /**
     * Unique name of this transform
     * @type {string}
     * @memberof TransformRead
     */
    'name': string;
    /**
     * The type of transform operation
     * @type {string}
     * @memberof TransformRead
     */
    'type': TransformReadTypeEnum;
    /**
     * 
     * @type {TransformAttributes}
     * @memberof TransformRead
     */
    'attributes': TransformAttributes | null;
    /**
     * Unique ID of this transform
     * @type {string}
     * @memberof TransformRead
     */
    'id': string;
    /**
     * Indicates whether this is an internal SailPoint-created transform or a customer-created transform
     * @type {boolean}
     * @memberof TransformRead
     */
    'internal': boolean;
}

export const TransformReadTypeEnum = {
    AccountAttribute: 'accountAttribute',
    Base64Decode: 'base64Decode',
    Base64Encode: 'base64Encode',
    Concat: 'concat',
    Conditional: 'conditional',
    DateCompare: 'dateCompare',
    DateFormat: 'dateFormat',
    DateMath: 'dateMath',
    DecomposeDiacriticalMarks: 'decomposeDiacriticalMarks',
    E164phone: 'e164phone',
    FirstValid: 'firstValid',
    Rule: 'rule',
    IdentityAttribute: 'identityAttribute',
    IndexOf: 'indexOf',
    Iso3166: 'iso3166',
    LastIndexOf: 'lastIndexOf',
    LeftPad: 'leftPad',
    Lookup: 'lookup',
    Lower: 'lower',
    NormalizeNames: 'normalizeNames',
    RandomAlphaNumeric: 'randomAlphaNumeric',
    RandomNumeric: 'randomNumeric',
    Reference: 'reference',
    ReplaceAll: 'replaceAll',
    Replace: 'replace',
    RightPad: 'rightPad',
    Split: 'split',
    Static: 'static',
    Substring: 'substring',
    Trim: 'trim',
    Upper: 'upper',
    UsernameGenerator: 'usernameGenerator',
    Uuid: 'uuid'
} as const;

export type TransformReadTypeEnum = typeof TransformReadTypeEnum[keyof typeof TransformReadTypeEnum];

/**
 * 
 * @export
 * @interface Trim
 */
export interface Trim {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Trim
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Trim
     */
    'input'?: { [key: string]: any; };
}
/**
 * Query parameters used to construct an Elasticsearch type ahead query object.  The typeAheadQuery performs a search for top values beginning with the typed values. For example, typing \"Jo\" results in top hits matching \"Jo.\" Typing \"Job\" results in top hits matching \"Job.\" 
 * @export
 * @interface TypeAheadQuery
 */
export interface TypeAheadQuery {
    /**
     * The type ahead query string used to construct a phrase prefix match query.
     * @type {string}
     * @memberof TypeAheadQuery
     */
    'query': string;
    /**
     * The field on which to perform the type ahead search.
     * @type {string}
     * @memberof TypeAheadQuery
     */
    'field': string;
    /**
     * The nested type.
     * @type {string}
     * @memberof TypeAheadQuery
     */
    'nestedType'?: string;
    /**
     * The number of suffixes the last term will be expanded into. Influences the performance of the query and the number results returned. Valid values: 1 to 1000.
     * @type {number}
     * @memberof TypeAheadQuery
     */
    'maxExpansions'?: number;
    /**
     * The max amount of records the search will return.
     * @type {number}
     * @memberof TypeAheadQuery
     */
    'size'?: number;
    /**
     * The sort order of the returned records.
     * @type {string}
     * @memberof TypeAheadQuery
     */
    'sort'?: string;
    /**
     * The flag that defines the sort type, by count or value.
     * @type {boolean}
     * @memberof TypeAheadQuery
     */
    'sortByValue'?: boolean;
}
/**
 * A typed reference to the object. 
 * @export
 * @interface TypedReference
 */
export interface TypedReference {
    /**
     * 
     * @type {DtoType}
     * @memberof TypedReference
     */
    'type': DtoType;
    /**
     * The id of the object. 
     * @type {string}
     * @memberof TypedReference
     */
    'id': string;
}


/**
 * 
 * @export
 * @interface UUIDGenerator
 */
export interface UUIDGenerator {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof UUIDGenerator
     */
    'requiresPeriodicRefresh'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdatePasswordDictionaryRequest
 */
export interface UpdatePasswordDictionaryRequest {
    /**
     * 
     * @type {File}
     * @memberof UpdatePasswordDictionaryRequest
     */
    'file'?: File;
}
/**
 * 
 * @export
 * @interface Upper
 */
export interface Upper {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Upper
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Upper
     */
    'input'?: { [key: string]: any; };
}
/**
 * The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \'Create Account Profile\', the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \'Update Account Profile\', the provisioning template for the \'Update\' connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \'Enable Account Profile\', the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\'s account is created.  DISABLE - This usage type relates to \'Disable Account Profile\', the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
 * @export
 * @enum {string}
 */

export const UsageType = {
    Create: 'CREATE',
    Update: 'UPDATE',
    Enable: 'ENABLE',
    Disable: 'DISABLE',
    Delete: 'DELETE',
    Assign: 'ASSIGN',
    Unassign: 'UNASSIGN',
    CreateGroup: 'CREATE_GROUP',
    UpdateGroup: 'UPDATE_GROUP',
    DeleteGroup: 'DELETE_GROUP',
    Register: 'REGISTER',
    CreateIdentity: 'CREATE_IDENTITY',
    UpdateIdentity: 'UPDATE_IDENTITY',
    EditGroup: 'EDIT_GROUP',
    Unlock: 'UNLOCK',
    ChangePassword: 'CHANGE_PASSWORD'
} as const;

export type UsageType = typeof UsageType[keyof typeof UsageType];


/**
 * 
 * @export
 * @interface Value
 */
export interface Value {
    /**
     * The type of attribute value
     * @type {string}
     * @memberof Value
     */
    'type'?: string;
    /**
     * The attribute value
     * @type {string}
     * @memberof Value
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface ViolationContext
 */
export interface ViolationContext {
    /**
     * 
     * @type {ViolationContextPolicy}
     * @memberof ViolationContext
     */
    'policy'?: ViolationContextPolicy;
    /**
     * 
     * @type {ExceptionAccessCriteria}
     * @memberof ViolationContext
     */
    'conflictingAccessCriteria'?: ExceptionAccessCriteria;
}
/**
 * The types of objects supported for SOD violations
 * @export
 * @interface ViolationContextPolicy
 */
export interface ViolationContextPolicy {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof ViolationContextPolicy
     */
    'type'?: ViolationContextPolicyTypeEnum;
    /**
     * SOD policy ID.
     * @type {string}
     * @memberof ViolationContextPolicy
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ViolationContextPolicy
     */
    'name'?: string;
}

export const ViolationContextPolicyTypeEnum = {
    Entitlement: 'ENTITLEMENT'
} as const;

export type ViolationContextPolicyTypeEnum = typeof ViolationContextPolicyTypeEnum[keyof typeof ViolationContextPolicyTypeEnum];

/**
 * 
 * @export
 * @interface ViolationOwnerAssignmentConfig
 */
export interface ViolationOwnerAssignmentConfig {
    /**
     * Details about the violations owner. MANAGER - identity\'s manager STATIC - Governance Group or Identity
     * @type {string}
     * @memberof ViolationOwnerAssignmentConfig
     */
    'assignmentRule'?: ViolationOwnerAssignmentConfigAssignmentRuleEnum;
    /**
     * 
     * @type {ViolationOwnerAssignmentConfigOwnerRef}
     * @memberof ViolationOwnerAssignmentConfig
     */
    'ownerRef'?: ViolationOwnerAssignmentConfigOwnerRef;
}

export const ViolationOwnerAssignmentConfigAssignmentRuleEnum = {
    Manager: 'MANAGER',
    Static: 'STATIC',
    Null: 'null'
} as const;

export type ViolationOwnerAssignmentConfigAssignmentRuleEnum = typeof ViolationOwnerAssignmentConfigAssignmentRuleEnum[keyof typeof ViolationOwnerAssignmentConfigAssignmentRuleEnum];

/**
 * 
 * @export
 * @interface ViolationOwnerAssignmentConfigOwnerRef
 */
export interface ViolationOwnerAssignmentConfigOwnerRef {
    /**
     * Owner\'s DTO type.
     * @type {string}
     * @memberof ViolationOwnerAssignmentConfigOwnerRef
     */
    'type'?: ViolationOwnerAssignmentConfigOwnerRefTypeEnum;
    /**
     * Owner\'s identity ID.
     * @type {string}
     * @memberof ViolationOwnerAssignmentConfigOwnerRef
     */
    'id'?: string;
    /**
     * Owner\'s display name.
     * @type {string}
     * @memberof ViolationOwnerAssignmentConfigOwnerRef
     */
    'name'?: string;
}

export const ViolationOwnerAssignmentConfigOwnerRefTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type ViolationOwnerAssignmentConfigOwnerRefTypeEnum = typeof ViolationOwnerAssignmentConfigOwnerRefTypeEnum[keyof typeof ViolationOwnerAssignmentConfigOwnerRefTypeEnum];

/**
 * An object containing a listing of the SOD violation reasons detected by this check.
 * @export
 * @interface ViolationPrediction
 */
export interface ViolationPrediction {
    /**
     * List of Violation Contexts
     * @type {Array<ViolationContext>}
     * @memberof ViolationPrediction
     */
    'violationContexts'?: Array<ViolationContext>;
}
/**
 * 
 * @export
 * @interface VisibilityCriteria
 */
export interface VisibilityCriteria {
    /**
     * 
     * @type {Expression}
     * @memberof VisibilityCriteria
     */
    'expression'?: Expression;
}
/**
 * The state of a work item
 * @export
 * @enum {string}
 */

export const WorkItemState = {
    Finished: 'FINISHED',
    Rejected: 'REJECTED',
    Returned: 'RETURNED',
    Expired: 'EXPIRED',
    Pending: 'PENDING',
    Canceled: 'CANCELED'
} as const;

export type WorkItemState = typeof WorkItemState[keyof typeof WorkItemState];


/**
 * The type of the work item
 * @export
 * @enum {string}
 */

export const WorkItemType = {
    Unknown: 'UNKNOWN',
    Generic: 'GENERIC',
    Certification: 'CERTIFICATION',
    Remediation: 'REMEDIATION',
    Delegation: 'DELEGATION',
    Approval: 'APPROVAL',
    Violationreview: 'VIOLATIONREVIEW',
    Form: 'FORM',
    Policyviolation: 'POLICYVIOLATION',
    Challenge: 'CHALLENGE',
    Impactanalysis: 'IMPACTANALYSIS',
    Signoff: 'SIGNOFF',
    Event: 'EVENT',
    Manualaction: 'MANUALACTION',
    Test: 'TEST'
} as const;

export type WorkItemType = typeof WorkItemType[keyof typeof WorkItemType];


/**
 * 
 * @export
 * @interface WorkItems
 */
export interface WorkItems {
    /**
     * ID of the work item
     * @type {string}
     * @memberof WorkItems
     */
    'id'?: string;
    /**
     * ID of the requester
     * @type {string}
     * @memberof WorkItems
     */
    'requesterId'?: string;
    /**
     * The displayname of the requester
     * @type {string}
     * @memberof WorkItems
     */
    'requesterDisplayName'?: string;
    /**
     * The ID of the owner
     * @type {string}
     * @memberof WorkItems
     */
    'ownerId'?: string;
    /**
     * The name of the owner
     * @type {string}
     * @memberof WorkItems
     */
    'ownerName'?: string;
    /**
     * Time when the work item was created
     * @type {string}
     * @memberof WorkItems
     */
    'created'?: string;
    /**
     * Time when the work item was last updated
     * @type {string}
     * @memberof WorkItems
     */
    'modified'?: string;
    /**
     * The description of the work item
     * @type {string}
     * @memberof WorkItems
     */
    'description'?: string;
    /**
     * 
     * @type {WorkItemState}
     * @memberof WorkItems
     */
    'state'?: WorkItemState;
    /**
     * 
     * @type {WorkItemType}
     * @memberof WorkItems
     */
    'type'?: WorkItemType;
    /**
     * 
     * @type {RemediationItemDetails}
     * @memberof WorkItems
     */
    'remediationItems'?: RemediationItemDetails;
    /**
     * 
     * @type {ApprovalItemDetails}
     * @memberof WorkItems
     */
    'approvalItems'?: ApprovalItemDetails;
    /**
     * The work item name
     * @type {string}
     * @memberof WorkItems
     */
    'name'?: string;
    /**
     * The time at which the work item completed
     * @type {string}
     * @memberof WorkItems
     */
    'completed'?: string;
    /**
     * The number of items in the work item
     * @type {number}
     * @memberof WorkItems
     */
    'numItems'?: number;
    /**
     * 
     * @type {FormDetails}
     * @memberof WorkItems
     */
    'form'?: FormDetails;
    /**
     * An array of errors that ocurred during the work item
     * @type {Array<string>}
     * @memberof WorkItems
     */
    'errors'?: Array<string>;
}


/**
 * 
 * @export
 * @interface WorkItemsCount
 */
export interface WorkItemsCount {
    /**
     * The count of work items
     * @type {number}
     * @memberof WorkItemsCount
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface WorkItemsSummary
 */
export interface WorkItemsSummary {
    /**
     * The count of open work items
     * @type {number}
     * @memberof WorkItemsSummary
     */
    'open'?: number;
    /**
     * The count of completed work items
     * @type {number}
     * @memberof WorkItemsSummary
     */
    'completed'?: number;
    /**
     * The count of total work items
     * @type {number}
     * @memberof WorkItemsSummary
     */
    'total'?: number;
}

/**
 * AccessProfilesApi - axios parameter creator
 * @export
 */
export const AccessProfilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates an Access Profile. A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a token with only ROLE_SUBADMIN or SOURCE_SUBADMIN authority must be associated with the Access Profile\'s Source. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Create an Access Profile
         * @param {AccessProfile} accessProfile 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccessProfile: async (accessProfile: AccessProfile, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessProfile' is not null or undefined
            assertParamExists('createAccessProfile', 'accessProfile', accessProfile)
            const localVarPath = `/access-profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessProfile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API deletes an existing Access Profile.  The Access Profile must not be in use, for example, Access Profile can not be deleted if they belong to an Application, Life Cycle State or a Role. If it is, a 400 error is returned.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a SOURCE_SUBADMIN token must be able to administer the Source associated with the Access Profile.
         * @summary Delete the specified Access Profile
         * @param {string} id ID of the Access Profile to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessProfile: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAccessProfile', 'id', id)
            const localVarPath = `/access-profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API initiates a bulk deletion of one or more Access Profiles.  By default, if any of the indicated Access Profiles are in use, no deletions will be performed and the **inUse** field of the response indicates the usages that must be removed first. If the request field **bestEffortOnly** is **true**, however, usages are reported in the **inUse** response field but all other indicated Access Profiles will be deleted.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to delete Access Profiles which are associated with Sources they are able to administer.
         * @summary Delete Access Profile(s)
         * @param {AccessProfileBulkDeleteRequest} accessProfileBulkDeleteRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessProfilesInBulk: async (accessProfileBulkDeleteRequest: AccessProfileBulkDeleteRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessProfileBulkDeleteRequest' is not null or undefined
            assertParamExists('deleteAccessProfilesInBulk', 'accessProfileBulkDeleteRequest', accessProfileBulkDeleteRequest)
            const localVarPath = `/access-profiles/bulk-delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessProfileBulkDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns an Access Profile by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get an Access Profile
         * @param {string} id ID of the Access Profile
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessProfile: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccessProfile', 'id', id)
            const localVarPath = `/access-profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API lists the Entitlements associated with a given Access Profile  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a token with SOURCE_SUBADMIN authority must have access to the Source associated with the given Access Profile
         * @summary List Access Profile\'s Entitlements
         * @param {string} id ID of the containing Access Profile
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **attribute**: *eq, sw*  **value**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **source.id**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, attribute, value, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessProfileEntitlements: async (id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccessProfileEntitlements', 'id', id)
            const localVarPath = `/access-profiles/{id}/entitlements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of Access Profiles.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary List Access Profiles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN or SOURCE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID.  A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*  **source.id**: *eq, in*  Composite operators supported: *and, or*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters Access Profiles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Whether or not the response list should contain unsegmented Access Profiles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccessProfiles: async (forSubadmin?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSegmentIds?: string, includeUnsegmented?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (forSubadmin !== undefined) {
                localVarQueryParameter['for-subadmin'] = forSubadmin;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (forSegmentIds !== undefined) {
                localVarQueryParameter['for-segment-ids'] = forSegmentIds;
            }

            if (includeUnsegmented !== undefined) {
                localVarQueryParameter['include-unsegmented'] = includeUnsegmented;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates an existing Access Profile. The following fields are patchable:  **name**  **description**  **enabled**  **owner**  **requestable**  **accessRequestConfig**  **revokeRequestConfig**  **segments**  **entitlements**  **provisioningCriteria**  **source** (must be updated with entitlements belonging to new source in the same API call)  If you need to change the `source` of the access profile, you can do so only if you update the `entitlements` in the same API call.  The new entitlements can only come from the target source that you want to change to.  Look for the example \"Replace Source\" in the examples dropdown.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to patch Access Profiles which are associated with Sources they are able to administer. >  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.  > You can only add or replace **entitlements** that exist on the source that the access profile is attached to. You can use the **list entitlements** endpoint with the **filters** query parameter to get a list of available entitlements on the access profile\'s source.  >  Patching the value of the **requestable** field is only supported for customers enabled with the new Request Center. Otherwise, attempting to modify this field results in a 400 error.
         * @summary Patch a specified Access Profile
         * @param {string} id ID of the Access Profile to patch
         * @param {Array<JsonPatchOperation>} jsonPatchOperation 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAccessProfile: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchAccessProfile', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchAccessProfile', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/access-profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessProfilesApi - functional programming interface
 * @export
 */
export const AccessProfilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessProfilesApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates an Access Profile. A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a token with only ROLE_SUBADMIN or SOURCE_SUBADMIN authority must be associated with the Access Profile\'s Source. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Create an Access Profile
         * @param {AccessProfile} accessProfile 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createAccessProfile(accessProfile: AccessProfile, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccessProfile(accessProfile, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccessProfilesApi.createAccessProfile']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API deletes an existing Access Profile.  The Access Profile must not be in use, for example, Access Profile can not be deleted if they belong to an Application, Life Cycle State or a Role. If it is, a 400 error is returned.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a SOURCE_SUBADMIN token must be able to administer the Source associated with the Access Profile.
         * @summary Delete the specified Access Profile
         * @param {string} id ID of the Access Profile to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccessProfile(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccessProfile(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccessProfilesApi.deleteAccessProfile']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API initiates a bulk deletion of one or more Access Profiles.  By default, if any of the indicated Access Profiles are in use, no deletions will be performed and the **inUse** field of the response indicates the usages that must be removed first. If the request field **bestEffortOnly** is **true**, however, usages are reported in the **inUse** response field but all other indicated Access Profiles will be deleted.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to delete Access Profiles which are associated with Sources they are able to administer.
         * @summary Delete Access Profile(s)
         * @param {AccessProfileBulkDeleteRequest} accessProfileBulkDeleteRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccessProfilesInBulk(accessProfileBulkDeleteRequest: AccessProfileBulkDeleteRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessProfileBulkDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccessProfilesInBulk(accessProfileBulkDeleteRequest, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccessProfilesApi.deleteAccessProfilesInBulk']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API returns an Access Profile by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get an Access Profile
         * @param {string} id ID of the Access Profile
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessProfile(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessProfile(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccessProfilesApi.getAccessProfile']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API lists the Entitlements associated with a given Access Profile  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a token with SOURCE_SUBADMIN authority must have access to the Source associated with the given Access Profile
         * @summary List Access Profile\'s Entitlements
         * @param {string} id ID of the containing Access Profile
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **attribute**: *eq, sw*  **value**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **source.id**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, attribute, value, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessProfileEntitlements(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Entitlement>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessProfileEntitlements(id, limit, offset, count, filters, sorters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccessProfilesApi.getAccessProfileEntitlements']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API returns a list of Access Profiles.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary List Access Profiles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN or SOURCE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID.  A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*  **source.id**: *eq, in*  Composite operators supported: *and, or*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters Access Profiles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Whether or not the response list should contain unsegmented Access Profiles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listAccessProfiles(forSubadmin?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSegmentIds?: string, includeUnsegmented?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccessProfile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccessProfiles(forSubadmin, limit, offset, count, filters, sorters, forSegmentIds, includeUnsegmented, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccessProfilesApi.listAccessProfiles']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API updates an existing Access Profile. The following fields are patchable:  **name**  **description**  **enabled**  **owner**  **requestable**  **accessRequestConfig**  **revokeRequestConfig**  **segments**  **entitlements**  **provisioningCriteria**  **source** (must be updated with entitlements belonging to new source in the same API call)  If you need to change the `source` of the access profile, you can do so only if you update the `entitlements` in the same API call.  The new entitlements can only come from the target source that you want to change to.  Look for the example \"Replace Source\" in the examples dropdown.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to patch Access Profiles which are associated with Sources they are able to administer. >  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.  > You can only add or replace **entitlements** that exist on the source that the access profile is attached to. You can use the **list entitlements** endpoint with the **filters** query parameter to get a list of available entitlements on the access profile\'s source.  >  Patching the value of the **requestable** field is only supported for customers enabled with the new Request Center. Otherwise, attempting to modify this field results in a 400 error.
         * @summary Patch a specified Access Profile
         * @param {string} id ID of the Access Profile to patch
         * @param {Array<JsonPatchOperation>} jsonPatchOperation 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchAccessProfile(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAccessProfile(id, jsonPatchOperation, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccessProfilesApi.patchAccessProfile']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AccessProfilesApi - factory interface
 * @export
 */
export const AccessProfilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessProfilesApiFp(configuration)
    return {
        /**
         * This API creates an Access Profile. A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a token with only ROLE_SUBADMIN or SOURCE_SUBADMIN authority must be associated with the Access Profile\'s Source. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Create an Access Profile
         * @param {AccessProfilesApiCreateAccessProfileRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        createAccessProfile(requestParameters: AccessProfilesApiCreateAccessProfileRequest, options?: AxiosRequestConfig): AxiosPromise<AccessProfile> {
            return localVarFp.createAccessProfile(requestParameters.accessProfile, options).then((request) => request(axios, basePath));
        },
        /**
         * This API deletes an existing Access Profile.  The Access Profile must not be in use, for example, Access Profile can not be deleted if they belong to an Application, Life Cycle State or a Role. If it is, a 400 error is returned.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a SOURCE_SUBADMIN token must be able to administer the Source associated with the Access Profile.
         * @summary Delete the specified Access Profile
         * @param {AccessProfilesApiDeleteAccessProfileRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteAccessProfile(requestParameters: AccessProfilesApiDeleteAccessProfileRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAccessProfile(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This API initiates a bulk deletion of one or more Access Profiles.  By default, if any of the indicated Access Profiles are in use, no deletions will be performed and the **inUse** field of the response indicates the usages that must be removed first. If the request field **bestEffortOnly** is **true**, however, usages are reported in the **inUse** response field but all other indicated Access Profiles will be deleted.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to delete Access Profiles which are associated with Sources they are able to administer.
         * @summary Delete Access Profile(s)
         * @param {AccessProfilesApiDeleteAccessProfilesInBulkRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteAccessProfilesInBulk(requestParameters: AccessProfilesApiDeleteAccessProfilesInBulkRequest, options?: AxiosRequestConfig): AxiosPromise<AccessProfileBulkDeleteResponse> {
            return localVarFp.deleteAccessProfilesInBulk(requestParameters.accessProfileBulkDeleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API returns an Access Profile by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get an Access Profile
         * @param {AccessProfilesApiGetAccessProfileRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getAccessProfile(requestParameters: AccessProfilesApiGetAccessProfileRequest, options?: AxiosRequestConfig): AxiosPromise<AccessProfile> {
            return localVarFp.getAccessProfile(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This API lists the Entitlements associated with a given Access Profile  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a token with SOURCE_SUBADMIN authority must have access to the Source associated with the given Access Profile
         * @summary List Access Profile\'s Entitlements
         * @param {AccessProfilesApiGetAccessProfileEntitlementsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getAccessProfileEntitlements(requestParameters: AccessProfilesApiGetAccessProfileEntitlementsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<Entitlement>> {
            return localVarFp.getAccessProfileEntitlements(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, options).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of Access Profiles.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary List Access Profiles
         * @param {AccessProfilesApiListAccessProfilesRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listAccessProfiles(requestParameters: AccessProfilesApiListAccessProfilesRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<AccessProfile>> {
            return localVarFp.listAccessProfiles(requestParameters.forSubadmin, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.forSegmentIds, requestParameters.includeUnsegmented, options).then((request) => request(axios, basePath));
        },
        /**
         * This API updates an existing Access Profile. The following fields are patchable:  **name**  **description**  **enabled**  **owner**  **requestable**  **accessRequestConfig**  **revokeRequestConfig**  **segments**  **entitlements**  **provisioningCriteria**  **source** (must be updated with entitlements belonging to new source in the same API call)  If you need to change the `source` of the access profile, you can do so only if you update the `entitlements` in the same API call.  The new entitlements can only come from the target source that you want to change to.  Look for the example \"Replace Source\" in the examples dropdown.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to patch Access Profiles which are associated with Sources they are able to administer. >  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.  > You can only add or replace **entitlements** that exist on the source that the access profile is attached to. You can use the **list entitlements** endpoint with the **filters** query parameter to get a list of available entitlements on the access profile\'s source.  >  Patching the value of the **requestable** field is only supported for customers enabled with the new Request Center. Otherwise, attempting to modify this field results in a 400 error.
         * @summary Patch a specified Access Profile
         * @param {AccessProfilesApiPatchAccessProfileRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        patchAccessProfile(requestParameters: AccessProfilesApiPatchAccessProfileRequest, options?: AxiosRequestConfig): AxiosPromise<AccessProfile> {
            return localVarFp.patchAccessProfile(requestParameters.id, requestParameters.jsonPatchOperation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAccessProfile operation in AccessProfilesApi.
 * @export
 * @interface AccessProfilesApiCreateAccessProfileRequest
 */
export interface AccessProfilesApiCreateAccessProfileRequest {
    /**
     * 
     * @type {AccessProfile}
     * @memberof AccessProfilesApiCreateAccessProfile
     */
    readonly accessProfile: AccessProfile
}

/**
 * Request parameters for deleteAccessProfile operation in AccessProfilesApi.
 * @export
 * @interface AccessProfilesApiDeleteAccessProfileRequest
 */
export interface AccessProfilesApiDeleteAccessProfileRequest {
    /**
     * ID of the Access Profile to delete
     * @type {string}
     * @memberof AccessProfilesApiDeleteAccessProfile
     */
    readonly id: string
}

/**
 * Request parameters for deleteAccessProfilesInBulk operation in AccessProfilesApi.
 * @export
 * @interface AccessProfilesApiDeleteAccessProfilesInBulkRequest
 */
export interface AccessProfilesApiDeleteAccessProfilesInBulkRequest {
    /**
     * 
     * @type {AccessProfileBulkDeleteRequest}
     * @memberof AccessProfilesApiDeleteAccessProfilesInBulk
     */
    readonly accessProfileBulkDeleteRequest: AccessProfileBulkDeleteRequest
}

/**
 * Request parameters for getAccessProfile operation in AccessProfilesApi.
 * @export
 * @interface AccessProfilesApiGetAccessProfileRequest
 */
export interface AccessProfilesApiGetAccessProfileRequest {
    /**
     * ID of the Access Profile
     * @type {string}
     * @memberof AccessProfilesApiGetAccessProfile
     */
    readonly id: string
}

/**
 * Request parameters for getAccessProfileEntitlements operation in AccessProfilesApi.
 * @export
 * @interface AccessProfilesApiGetAccessProfileEntitlementsRequest
 */
export interface AccessProfilesApiGetAccessProfileEntitlementsRequest {
    /**
     * ID of the containing Access Profile
     * @type {string}
     * @memberof AccessProfilesApiGetAccessProfileEntitlements
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessProfilesApiGetAccessProfileEntitlements
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessProfilesApiGetAccessProfileEntitlements
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccessProfilesApiGetAccessProfileEntitlements
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **attribute**: *eq, sw*  **value**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **source.id**: *eq, in*
     * @type {string}
     * @memberof AccessProfilesApiGetAccessProfileEntitlements
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, attribute, value, created, modified**
     * @type {string}
     * @memberof AccessProfilesApiGetAccessProfileEntitlements
     */
    readonly sorters?: string
}

/**
 * Request parameters for listAccessProfiles operation in AccessProfilesApi.
 * @export
 * @interface AccessProfilesApiListAccessProfilesRequest
 */
export interface AccessProfilesApiListAccessProfilesRequest {
    /**
     * If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN or SOURCE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID.  A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
     * @type {string}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly forSubadmin?: string

    /**
     * Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*  **source.id**: *eq, in*  Composite operators supported: *and, or*
     * @type {string}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
     * @type {string}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly sorters?: string

    /**
     * If present and not empty, additionally filters Access Profiles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
     * @type {string}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly forSegmentIds?: string

    /**
     * Whether or not the response list should contain unsegmented Access Profiles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
     * @type {boolean}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly includeUnsegmented?: boolean
}

/**
 * Request parameters for patchAccessProfile operation in AccessProfilesApi.
 * @export
 * @interface AccessProfilesApiPatchAccessProfileRequest
 */
export interface AccessProfilesApiPatchAccessProfileRequest {
    /**
     * ID of the Access Profile to patch
     * @type {string}
     * @memberof AccessProfilesApiPatchAccessProfile
     */
    readonly id: string

    /**
     * 
     * @type {Array<JsonPatchOperation>}
     * @memberof AccessProfilesApiPatchAccessProfile
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * AccessProfilesApi - object-oriented interface
 * @export
 * @class AccessProfilesApi
 * @extends {BaseAPI}
 */
export class AccessProfilesApi extends BaseAPI {
    /**
     * This API creates an Access Profile. A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a token with only ROLE_SUBADMIN or SOURCE_SUBADMIN authority must be associated with the Access Profile\'s Source. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.
     * @summary Create an Access Profile
     * @param {AccessProfilesApiCreateAccessProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    public createAccessProfile(requestParameters: AccessProfilesApiCreateAccessProfileRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessProfilesApiFp(this.configuration).createAccessProfile(requestParameters.accessProfile, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API deletes an existing Access Profile.  The Access Profile must not be in use, for example, Access Profile can not be deleted if they belong to an Application, Life Cycle State or a Role. If it is, a 400 error is returned.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a SOURCE_SUBADMIN token must be able to administer the Source associated with the Access Profile.
     * @summary Delete the specified Access Profile
     * @param {AccessProfilesApiDeleteAccessProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    public deleteAccessProfile(requestParameters: AccessProfilesApiDeleteAccessProfileRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessProfilesApiFp(this.configuration).deleteAccessProfile(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API initiates a bulk deletion of one or more Access Profiles.  By default, if any of the indicated Access Profiles are in use, no deletions will be performed and the **inUse** field of the response indicates the usages that must be removed first. If the request field **bestEffortOnly** is **true**, however, usages are reported in the **inUse** response field but all other indicated Access Profiles will be deleted.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to delete Access Profiles which are associated with Sources they are able to administer.
     * @summary Delete Access Profile(s)
     * @param {AccessProfilesApiDeleteAccessProfilesInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    public deleteAccessProfilesInBulk(requestParameters: AccessProfilesApiDeleteAccessProfilesInBulkRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessProfilesApiFp(this.configuration).deleteAccessProfilesInBulk(requestParameters.accessProfileBulkDeleteRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns an Access Profile by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Get an Access Profile
     * @param {AccessProfilesApiGetAccessProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    public getAccessProfile(requestParameters: AccessProfilesApiGetAccessProfileRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessProfilesApiFp(this.configuration).getAccessProfile(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API lists the Entitlements associated with a given Access Profile  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a token with SOURCE_SUBADMIN authority must have access to the Source associated with the given Access Profile
     * @summary List Access Profile\'s Entitlements
     * @param {AccessProfilesApiGetAccessProfileEntitlementsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    public getAccessProfileEntitlements(requestParameters: AccessProfilesApiGetAccessProfileEntitlementsRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessProfilesApiFp(this.configuration).getAccessProfileEntitlements(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of Access Profiles.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary List Access Profiles
     * @param {AccessProfilesApiListAccessProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    public listAccessProfiles(requestParameters: AccessProfilesApiListAccessProfilesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccessProfilesApiFp(this.configuration).listAccessProfiles(requestParameters.forSubadmin, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.forSegmentIds, requestParameters.includeUnsegmented, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates an existing Access Profile. The following fields are patchable:  **name**  **description**  **enabled**  **owner**  **requestable**  **accessRequestConfig**  **revokeRequestConfig**  **segments**  **entitlements**  **provisioningCriteria**  **source** (must be updated with entitlements belonging to new source in the same API call)  If you need to change the `source` of the access profile, you can do so only if you update the `entitlements` in the same API call.  The new entitlements can only come from the target source that you want to change to.  Look for the example \"Replace Source\" in the examples dropdown.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to patch Access Profiles which are associated with Sources they are able to administer. >  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.  > You can only add or replace **entitlements** that exist on the source that the access profile is attached to. You can use the **list entitlements** endpoint with the **filters** query parameter to get a list of available entitlements on the access profile\'s source.  >  Patching the value of the **requestable** field is only supported for customers enabled with the new Request Center. Otherwise, attempting to modify this field results in a 400 error.
     * @summary Patch a specified Access Profile
     * @param {AccessProfilesApiPatchAccessProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    public patchAccessProfile(requestParameters: AccessProfilesApiPatchAccessProfileRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessProfilesApiFp(this.configuration).patchAccessProfile(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AccessRequestApprovalsApi - axios parameter creator
 * @export
 */
export const AccessRequestApprovalsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint approves an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Approves an access request approval.
         * @param {string} approvalId The id of the approval.
         * @param {CommentDto} [commentDto] Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveAccessRequest: async (approvalId: string, commentDto?: CommentDto, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'approvalId' is not null or undefined
            assertParamExists('approveAccessRequest', 'approvalId', approvalId)
            const localVarPath = `/access-request-approvals/{approvalId}/approve`
                .replace(`{${"approvalId"}}`, encodeURIComponent(String(approvalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint forwards an access request approval to a new owner. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Forwards an access request approval.
         * @param {string} approvalId The id of the approval.
         * @param {ForwardApprovalDto} forwardApprovalDto Information about the forwarded approval.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        forwardAccessRequest: async (approvalId: string, forwardApprovalDto: ForwardApprovalDto, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'approvalId' is not null or undefined
            assertParamExists('forwardAccessRequest', 'approvalId', approvalId)
            // verify required parameter 'forwardApprovalDto' is not null or undefined
            assertParamExists('forwardAccessRequest', 'forwardApprovalDto', forwardApprovalDto)
            const localVarPath = `/access-request-approvals/{approvalId}/forward`
                .replace(`{${"approvalId"}}`, encodeURIComponent(String(approvalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forwardApprovalDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns the number of pending, approved and rejected access requests approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Get the number of access-requests-approvals
         * @param {string} [ownerId] The id of the owner or approver identity of the approvals. If present, the value returns approval summary for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN user can also fetch all the approvals in the org, when owner-id is not used.    * Non ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {string} [fromDate] From date is the date and time from which the results will be shown. It should be in a valid ISO-8601 format
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestApprovalSummary: async (ownerId?: string, fromDate?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-request-approvals/approval-summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['owner-id'] = ownerId;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = fromDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns list of completed approvals. See *owner-id* query parameter below for authorization info.
         * @summary Completed Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only completed approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **requestedFor.id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **modified**: *gt, lt, ge, le, eq, in, ne, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCompletedApprovals: async (ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-request-approvals/completed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['owner-id'] = ownerId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list of pending approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Pending Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only pending approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le, eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPendingApprovals: async (ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-request-approvals/pending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['owner-id'] = ownerId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint rejects an access request approval. Only the owner of the approval and admin users are allowed to perform this action.
         * @summary Rejects an access request approval.
         * @param {string} approvalId The id of the approval.
         * @param {CommentDto} [commentDto] Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectAccessRequest: async (approvalId: string, commentDto?: CommentDto, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'approvalId' is not null or undefined
            assertParamExists('rejectAccessRequest', 'approvalId', approvalId)
            const localVarPath = `/access-request-approvals/{approvalId}/reject`
                .replace(`{${"approvalId"}}`, encodeURIComponent(String(approvalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessRequestApprovalsApi - functional programming interface
 * @export
 */
export const AccessRequestApprovalsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessRequestApprovalsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint approves an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Approves an access request approval.
         * @param {string} approvalId The id of the approval.
         * @param {CommentDto} [commentDto] Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async approveAccessRequest(approvalId: string, commentDto?: CommentDto, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveAccessRequest(approvalId, commentDto, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccessRequestApprovalsApi.approveAccessRequest']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint forwards an access request approval to a new owner. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Forwards an access request approval.
         * @param {string} approvalId The id of the approval.
         * @param {ForwardApprovalDto} forwardApprovalDto Information about the forwarded approval.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async forwardAccessRequest(approvalId: string, forwardApprovalDto: ForwardApprovalDto, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forwardAccessRequest(approvalId, forwardApprovalDto, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccessRequestApprovalsApi.forwardAccessRequest']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint returns the number of pending, approved and rejected access requests approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Get the number of access-requests-approvals
         * @param {string} [ownerId] The id of the owner or approver identity of the approvals. If present, the value returns approval summary for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN user can also fetch all the approvals in the org, when owner-id is not used.    * Non ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {string} [fromDate] From date is the date and time from which the results will be shown. It should be in a valid ISO-8601 format
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessRequestApprovalSummary(ownerId?: string, fromDate?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApprovalSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessRequestApprovalSummary(ownerId, fromDate, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccessRequestApprovalsApi.getAccessRequestApprovalSummary']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint returns list of completed approvals. See *owner-id* query parameter below for authorization info.
         * @summary Completed Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only completed approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **requestedFor.id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **modified**: *gt, lt, ge, le, eq, in, ne, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listCompletedApprovals(ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CompletedApproval>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCompletedApprovals(ownerId, limit, offset, count, filters, sorters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccessRequestApprovalsApi.listCompletedApprovals']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint returns a list of pending approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Pending Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only pending approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le, eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listPendingApprovals(ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PendingApproval>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPendingApprovals(ownerId, limit, offset, count, filters, sorters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccessRequestApprovalsApi.listPendingApprovals']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint rejects an access request approval. Only the owner of the approval and admin users are allowed to perform this action.
         * @summary Rejects an access request approval.
         * @param {string} approvalId The id of the approval.
         * @param {CommentDto} [commentDto] Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async rejectAccessRequest(approvalId: string, commentDto?: CommentDto, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectAccessRequest(approvalId, commentDto, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccessRequestApprovalsApi.rejectAccessRequest']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AccessRequestApprovalsApi - factory interface
 * @export
 */
export const AccessRequestApprovalsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessRequestApprovalsApiFp(configuration)
    return {
        /**
         * This endpoint approves an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Approves an access request approval.
         * @param {AccessRequestApprovalsApiApproveAccessRequestRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        approveAccessRequest(requestParameters: AccessRequestApprovalsApiApproveAccessRequestRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.approveAccessRequest(requestParameters.approvalId, requestParameters.commentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint forwards an access request approval to a new owner. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Forwards an access request approval.
         * @param {AccessRequestApprovalsApiForwardAccessRequestRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        forwardAccessRequest(requestParameters: AccessRequestApprovalsApiForwardAccessRequestRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.forwardAccessRequest(requestParameters.approvalId, requestParameters.forwardApprovalDto, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns the number of pending, approved and rejected access requests approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Get the number of access-requests-approvals
         * @param {AccessRequestApprovalsApiGetAccessRequestApprovalSummaryRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getAccessRequestApprovalSummary(requestParameters: AccessRequestApprovalsApiGetAccessRequestApprovalSummaryRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ApprovalSummary> {
            return localVarFp.getAccessRequestApprovalSummary(requestParameters.ownerId, requestParameters.fromDate, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns list of completed approvals. See *owner-id* query parameter below for authorization info.
         * @summary Completed Access Request Approvals List
         * @param {AccessRequestApprovalsApiListCompletedApprovalsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listCompletedApprovals(requestParameters: AccessRequestApprovalsApiListCompletedApprovalsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<CompletedApproval>> {
            return localVarFp.listCompletedApprovals(requestParameters.ownerId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of pending approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Pending Access Request Approvals List
         * @param {AccessRequestApprovalsApiListPendingApprovalsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listPendingApprovals(requestParameters: AccessRequestApprovalsApiListPendingApprovalsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<PendingApproval>> {
            return localVarFp.listPendingApprovals(requestParameters.ownerId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint rejects an access request approval. Only the owner of the approval and admin users are allowed to perform this action.
         * @summary Rejects an access request approval.
         * @param {AccessRequestApprovalsApiRejectAccessRequestRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        rejectAccessRequest(requestParameters: AccessRequestApprovalsApiRejectAccessRequestRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.rejectAccessRequest(requestParameters.approvalId, requestParameters.commentDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for approveAccessRequest operation in AccessRequestApprovalsApi.
 * @export
 * @interface AccessRequestApprovalsApiApproveAccessRequestRequest
 */
export interface AccessRequestApprovalsApiApproveAccessRequestRequest {
    /**
     * The id of the approval.
     * @type {string}
     * @memberof AccessRequestApprovalsApiApproveAccessRequest
     */
    readonly approvalId: string

    /**
     * Reviewer\&#39;s comment.
     * @type {CommentDto}
     * @memberof AccessRequestApprovalsApiApproveAccessRequest
     */
    readonly commentDto?: CommentDto
}

/**
 * Request parameters for forwardAccessRequest operation in AccessRequestApprovalsApi.
 * @export
 * @interface AccessRequestApprovalsApiForwardAccessRequestRequest
 */
export interface AccessRequestApprovalsApiForwardAccessRequestRequest {
    /**
     * The id of the approval.
     * @type {string}
     * @memberof AccessRequestApprovalsApiForwardAccessRequest
     */
    readonly approvalId: string

    /**
     * Information about the forwarded approval.
     * @type {ForwardApprovalDto}
     * @memberof AccessRequestApprovalsApiForwardAccessRequest
     */
    readonly forwardApprovalDto: ForwardApprovalDto
}

/**
 * Request parameters for getAccessRequestApprovalSummary operation in AccessRequestApprovalsApi.
 * @export
 * @interface AccessRequestApprovalsApiGetAccessRequestApprovalSummaryRequest
 */
export interface AccessRequestApprovalsApiGetAccessRequestApprovalSummaryRequest {
    /**
     * The id of the owner or approver identity of the approvals. If present, the value returns approval summary for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN user can also fetch all the approvals in the org, when owner-id is not used.    * Non ORG_ADMIN users can only specify *me* or pass their own identity ID value.
     * @type {string}
     * @memberof AccessRequestApprovalsApiGetAccessRequestApprovalSummary
     */
    readonly ownerId?: string

    /**
     * From date is the date and time from which the results will be shown. It should be in a valid ISO-8601 format
     * @type {string}
     * @memberof AccessRequestApprovalsApiGetAccessRequestApprovalSummary
     */
    readonly fromDate?: string
}

/**
 * Request parameters for listCompletedApprovals operation in AccessRequestApprovalsApi.
 * @export
 * @interface AccessRequestApprovalsApiListCompletedApprovalsRequest
 */
export interface AccessRequestApprovalsApiListCompletedApprovalsRequest {
    /**
     * If present, the value returns only completed approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
     * @type {string}
     * @memberof AccessRequestApprovalsApiListCompletedApprovals
     */
    readonly ownerId?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessRequestApprovalsApiListCompletedApprovals
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessRequestApprovalsApiListCompletedApprovals
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccessRequestApprovalsApiListCompletedApprovals
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **requestedFor.id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **modified**: *gt, lt, ge, le, eq, in, ne, sw*
     * @type {string}
     * @memberof AccessRequestApprovalsApiListCompletedApprovals
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
     * @type {string}
     * @memberof AccessRequestApprovalsApiListCompletedApprovals
     */
    readonly sorters?: string
}

/**
 * Request parameters for listPendingApprovals operation in AccessRequestApprovalsApi.
 * @export
 * @interface AccessRequestApprovalsApiListPendingApprovalsRequest
 */
export interface AccessRequestApprovalsApiListPendingApprovalsRequest {
    /**
     * If present, the value returns only pending approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
     * @type {string}
     * @memberof AccessRequestApprovalsApiListPendingApprovals
     */
    readonly ownerId?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessRequestApprovalsApiListPendingApprovals
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessRequestApprovalsApiListPendingApprovals
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccessRequestApprovalsApiListPendingApprovals
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le, eq, in*
     * @type {string}
     * @memberof AccessRequestApprovalsApiListPendingApprovals
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
     * @type {string}
     * @memberof AccessRequestApprovalsApiListPendingApprovals
     */
    readonly sorters?: string
}

/**
 * Request parameters for rejectAccessRequest operation in AccessRequestApprovalsApi.
 * @export
 * @interface AccessRequestApprovalsApiRejectAccessRequestRequest
 */
export interface AccessRequestApprovalsApiRejectAccessRequestRequest {
    /**
     * The id of the approval.
     * @type {string}
     * @memberof AccessRequestApprovalsApiRejectAccessRequest
     */
    readonly approvalId: string

    /**
     * Reviewer\&#39;s comment.
     * @type {CommentDto}
     * @memberof AccessRequestApprovalsApiRejectAccessRequest
     */
    readonly commentDto?: CommentDto
}

/**
 * AccessRequestApprovalsApi - object-oriented interface
 * @export
 * @class AccessRequestApprovalsApi
 * @extends {BaseAPI}
 */
export class AccessRequestApprovalsApi extends BaseAPI {
    /**
     * This endpoint approves an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
     * @summary Approves an access request approval.
     * @param {AccessRequestApprovalsApiApproveAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    public approveAccessRequest(requestParameters: AccessRequestApprovalsApiApproveAccessRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestApprovalsApiFp(this.configuration).approveAccessRequest(requestParameters.approvalId, requestParameters.commentDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint forwards an access request approval to a new owner. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
     * @summary Forwards an access request approval.
     * @param {AccessRequestApprovalsApiForwardAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    public forwardAccessRequest(requestParameters: AccessRequestApprovalsApiForwardAccessRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestApprovalsApiFp(this.configuration).forwardAccessRequest(requestParameters.approvalId, requestParameters.forwardApprovalDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns the number of pending, approved and rejected access requests approvals. See \"owner-id\" query parameter below for authorization info.
     * @summary Get the number of access-requests-approvals
     * @param {AccessRequestApprovalsApiGetAccessRequestApprovalSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    public getAccessRequestApprovalSummary(requestParameters: AccessRequestApprovalsApiGetAccessRequestApprovalSummaryRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestApprovalsApiFp(this.configuration).getAccessRequestApprovalSummary(requestParameters.ownerId, requestParameters.fromDate, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns list of completed approvals. See *owner-id* query parameter below for authorization info.
     * @summary Completed Access Request Approvals List
     * @param {AccessRequestApprovalsApiListCompletedApprovalsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    public listCompletedApprovals(requestParameters: AccessRequestApprovalsApiListCompletedApprovalsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestApprovalsApiFp(this.configuration).listCompletedApprovals(requestParameters.ownerId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list of pending approvals. See \"owner-id\" query parameter below for authorization info.
     * @summary Pending Access Request Approvals List
     * @param {AccessRequestApprovalsApiListPendingApprovalsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    public listPendingApprovals(requestParameters: AccessRequestApprovalsApiListPendingApprovalsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestApprovalsApiFp(this.configuration).listPendingApprovals(requestParameters.ownerId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint rejects an access request approval. Only the owner of the approval and admin users are allowed to perform this action.
     * @summary Rejects an access request approval.
     * @param {AccessRequestApprovalsApiRejectAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    public rejectAccessRequest(requestParameters: AccessRequestApprovalsApiRejectAccessRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestApprovalsApiFp(this.configuration).rejectAccessRequest(requestParameters.approvalId, requestParameters.commentDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AccessRequestsApi - axios parameter creator
 * @export
 */
export const AccessRequestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API endpoint cancels a pending access request. An access request can be cancelled only if it has not passed the approval step. Any token with ORG_ADMIN authority or token of the user who originally requested the access request is required to cancel it.
         * @summary Cancel Access Request
         * @param {CancelAccessRequest} cancelAccessRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelAccessRequest: async (cancelAccessRequest: CancelAccessRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cancelAccessRequest' is not null or undefined
            assertParamExists('cancelAccessRequest', 'cancelAccessRequest', cancelAccessRequest)
            const localVarPath = `/access-requests/cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelAccessRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This submits the access request into IdentityNow, where it will follow any IdentityNow approval processes.  Access requests are processed asynchronously by IdentityNow.  A success response from this endpoint means the request has been submitted to IDN and is queued for processing.  Because this endpoint is asynchronous, it will not return an error if you submit duplicate access requests in quick succession, or you submit an access request for access that is already in progress, approved, or rejected. It is best practice to check for any existing access requests that reference the same access items before submitting a new access request.  This can be accomplished by using the [access request status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) or the [pending access request approvals](https://developer.sailpoint.com/idn/api/v3/list-pending-approvals) endpoints.  You can also use the [search API](https://developer.sailpoint.com/idn/api/v3/search) to check the existing access items that an identity has before submitting an access request to ensure you are not requesting access that is already granted.  There are two types of access request:  __GRANT_ACCESS__ * Can be requested for multiple identities in a single request. * Supports self request and request on behalf of other users. Refer to the [Get Access Request Configuration](https://developer.sailpoint.com/idn/api/v3/get-access-request-config) endpoint for request configuration options.   * Allows any authenticated token (except API) to call this endpoint to request to grant access to themselves. Depending on the configuration, a user can request access for others. * Roles, access profiles and entitlements can be requested. * While requesting entitlements, maximum of 25 entitlements and 10 recipients are allowed in a request.   __REVOKE_ACCESS__ * Can only be requested for a single identity at a time. * Does not support self request. Only manager can request to revoke access for their directly managed employees. * If a `removeDate` is specified, then the access will be removed on that date and time only for roles and access profiles. Entitlements are currently unsupported for `removeDate`. * Roles, access profiles, and entitlements can be requested for revocation. * Revoke requests for entitlements are limited to 1 entitlement per access request currently. * [Roles, Access Profiles] You can specify a `removeDate` if the access doesn\'t already have a sunset date. The `removeDate` must be a future date, in the UTC timezone.  * Allows a manager to request to revoke access for direct employees. A token with ORG_ADMIN authority can also request to revoke access from anyone.  >**Note:** There is no indication to the approver in the IdentityNow UI that the approval request is for a revoke action. Take this into consideration when calling this API.  A token with API authority cannot be used to call this endpoint.  
         * @summary Submit an Access Request
         * @param {AccessRequest} accessRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccessRequest: async (accessRequest: AccessRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessRequest' is not null or undefined
            assertParamExists('createAccessRequest', 'accessRequest', accessRequest)
            const localVarPath = `/access-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns the current access-request configuration.
         * @summary Get Access Request Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestConfig: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-request-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * The Access Request Status API returns a list of access request statuses based on the specified query parameters. Any token with any authority can request their own status. A token with ORG_ADMIN authority is required to call this API to get a list of statuses for other users.
         * @summary Access Request Status
         * @param {string} [requestedFor] Filter the results by the identity for which the requests were made. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] Filter the results by the identity that made the requests. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] Filter the results by the specified identity which is either the requester or target of the requests. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {string} [assignedTo] Filter the results by the specified identity which is the owner of the Identity Request Work Item. *me* indicates the current user.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.
         * @param {number} [limit] Max number of results to return.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. Defaults to 0 if not specified.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **accountActivityItemId**: *eq, in, ge, gt, le, lt, ne, isnull, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified, accountActivityItemId, name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccessRequestStatus: async (requestedFor?: string, requestedBy?: string, regardingIdentity?: string, assignedTo?: string, count?: boolean, limit?: number, offset?: number, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-request-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (requestedFor !== undefined) {
                localVarQueryParameter['requested-for'] = requestedFor;
            }

            if (requestedBy !== undefined) {
                localVarQueryParameter['requested-by'] = requestedBy;
            }

            if (regardingIdentity !== undefined) {
                localVarQueryParameter['regarding-identity'] = regardingIdentity;
            }

            if (assignedTo !== undefined) {
                localVarQueryParameter['assigned-to'] = assignedTo;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint replaces the current access-request configuration. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Access Request Configuration
         * @param {AccessRequestConfig} accessRequestConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setAccessRequestConfig: async (accessRequestConfig: AccessRequestConfig, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessRequestConfig' is not null or undefined
            assertParamExists('setAccessRequestConfig', 'accessRequestConfig', accessRequestConfig)
            const localVarPath = `/access-request-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessRequestConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessRequestsApi - functional programming interface
 * @export
 */
export const AccessRequestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessRequestsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API endpoint cancels a pending access request. An access request can be cancelled only if it has not passed the approval step. Any token with ORG_ADMIN authority or token of the user who originally requested the access request is required to cancel it.
         * @summary Cancel Access Request
         * @param {CancelAccessRequest} cancelAccessRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async cancelAccessRequest(cancelAccessRequest: CancelAccessRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelAccessRequest(cancelAccessRequest, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccessRequestsApi.cancelAccessRequest']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This submits the access request into IdentityNow, where it will follow any IdentityNow approval processes.  Access requests are processed asynchronously by IdentityNow.  A success response from this endpoint means the request has been submitted to IDN and is queued for processing.  Because this endpoint is asynchronous, it will not return an error if you submit duplicate access requests in quick succession, or you submit an access request for access that is already in progress, approved, or rejected. It is best practice to check for any existing access requests that reference the same access items before submitting a new access request.  This can be accomplished by using the [access request status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) or the [pending access request approvals](https://developer.sailpoint.com/idn/api/v3/list-pending-approvals) endpoints.  You can also use the [search API](https://developer.sailpoint.com/idn/api/v3/search) to check the existing access items that an identity has before submitting an access request to ensure you are not requesting access that is already granted.  There are two types of access request:  __GRANT_ACCESS__ * Can be requested for multiple identities in a single request. * Supports self request and request on behalf of other users. Refer to the [Get Access Request Configuration](https://developer.sailpoint.com/idn/api/v3/get-access-request-config) endpoint for request configuration options.   * Allows any authenticated token (except API) to call this endpoint to request to grant access to themselves. Depending on the configuration, a user can request access for others. * Roles, access profiles and entitlements can be requested. * While requesting entitlements, maximum of 25 entitlements and 10 recipients are allowed in a request.   __REVOKE_ACCESS__ * Can only be requested for a single identity at a time. * Does not support self request. Only manager can request to revoke access for their directly managed employees. * If a `removeDate` is specified, then the access will be removed on that date and time only for roles and access profiles. Entitlements are currently unsupported for `removeDate`. * Roles, access profiles, and entitlements can be requested for revocation. * Revoke requests for entitlements are limited to 1 entitlement per access request currently. * [Roles, Access Profiles] You can specify a `removeDate` if the access doesn\'t already have a sunset date. The `removeDate` must be a future date, in the UTC timezone.  * Allows a manager to request to revoke access for direct employees. A token with ORG_ADMIN authority can also request to revoke access from anyone.  >**Note:** There is no indication to the approver in the IdentityNow UI that the approval request is for a revoke action. Take this into consideration when calling this API.  A token with API authority cannot be used to call this endpoint.  
         * @summary Submit an Access Request
         * @param {AccessRequest} accessRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createAccessRequest(accessRequest: AccessRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccessRequest(accessRequest, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccessRequestsApi.createAccessRequest']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint returns the current access-request configuration.
         * @summary Get Access Request Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessRequestConfig(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessRequestConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessRequestConfig(axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccessRequestsApi.getAccessRequestConfig']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * The Access Request Status API returns a list of access request statuses based on the specified query parameters. Any token with any authority can request their own status. A token with ORG_ADMIN authority is required to call this API to get a list of statuses for other users.
         * @summary Access Request Status
         * @param {string} [requestedFor] Filter the results by the identity for which the requests were made. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] Filter the results by the identity that made the requests. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] Filter the results by the specified identity which is either the requester or target of the requests. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {string} [assignedTo] Filter the results by the specified identity which is the owner of the Identity Request Work Item. *me* indicates the current user.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.
         * @param {number} [limit] Max number of results to return.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. Defaults to 0 if not specified.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **accountActivityItemId**: *eq, in, ge, gt, le, lt, ne, isnull, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified, accountActivityItemId, name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listAccessRequestStatus(requestedFor?: string, requestedBy?: string, regardingIdentity?: string, assignedTo?: string, count?: boolean, limit?: number, offset?: number, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RequestedItemStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccessRequestStatus(requestedFor, requestedBy, regardingIdentity, assignedTo, count, limit, offset, filters, sorters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccessRequestsApi.listAccessRequestStatus']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint replaces the current access-request configuration. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Access Request Configuration
         * @param {AccessRequestConfig} accessRequestConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setAccessRequestConfig(accessRequestConfig: AccessRequestConfig, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessRequestConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setAccessRequestConfig(accessRequestConfig, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccessRequestsApi.setAccessRequestConfig']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AccessRequestsApi - factory interface
 * @export
 */
export const AccessRequestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessRequestsApiFp(configuration)
    return {
        /**
         * This API endpoint cancels a pending access request. An access request can be cancelled only if it has not passed the approval step. Any token with ORG_ADMIN authority or token of the user who originally requested the access request is required to cancel it.
         * @summary Cancel Access Request
         * @param {AccessRequestsApiCancelAccessRequestRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        cancelAccessRequest(requestParameters: AccessRequestsApiCancelAccessRequestRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.cancelAccessRequest(requestParameters.cancelAccessRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This submits the access request into IdentityNow, where it will follow any IdentityNow approval processes.  Access requests are processed asynchronously by IdentityNow.  A success response from this endpoint means the request has been submitted to IDN and is queued for processing.  Because this endpoint is asynchronous, it will not return an error if you submit duplicate access requests in quick succession, or you submit an access request for access that is already in progress, approved, or rejected. It is best practice to check for any existing access requests that reference the same access items before submitting a new access request.  This can be accomplished by using the [access request status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) or the [pending access request approvals](https://developer.sailpoint.com/idn/api/v3/list-pending-approvals) endpoints.  You can also use the [search API](https://developer.sailpoint.com/idn/api/v3/search) to check the existing access items that an identity has before submitting an access request to ensure you are not requesting access that is already granted.  There are two types of access request:  __GRANT_ACCESS__ * Can be requested for multiple identities in a single request. * Supports self request and request on behalf of other users. Refer to the [Get Access Request Configuration](https://developer.sailpoint.com/idn/api/v3/get-access-request-config) endpoint for request configuration options.   * Allows any authenticated token (except API) to call this endpoint to request to grant access to themselves. Depending on the configuration, a user can request access for others. * Roles, access profiles and entitlements can be requested. * While requesting entitlements, maximum of 25 entitlements and 10 recipients are allowed in a request.   __REVOKE_ACCESS__ * Can only be requested for a single identity at a time. * Does not support self request. Only manager can request to revoke access for their directly managed employees. * If a `removeDate` is specified, then the access will be removed on that date and time only for roles and access profiles. Entitlements are currently unsupported for `removeDate`. * Roles, access profiles, and entitlements can be requested for revocation. * Revoke requests for entitlements are limited to 1 entitlement per access request currently. * [Roles, Access Profiles] You can specify a `removeDate` if the access doesn\'t already have a sunset date. The `removeDate` must be a future date, in the UTC timezone.  * Allows a manager to request to revoke access for direct employees. A token with ORG_ADMIN authority can also request to revoke access from anyone.  >**Note:** There is no indication to the approver in the IdentityNow UI that the approval request is for a revoke action. Take this into consideration when calling this API.  A token with API authority cannot be used to call this endpoint.  
         * @summary Submit an Access Request
         * @param {AccessRequestsApiCreateAccessRequestRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        createAccessRequest(requestParameters: AccessRequestsApiCreateAccessRequestRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.createAccessRequest(requestParameters.accessRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns the current access-request configuration.
         * @summary Get Access Request Configuration
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getAccessRequestConfig(options?: AxiosRequestConfig): AxiosPromise<AccessRequestConfig> {
            return localVarFp.getAccessRequestConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * The Access Request Status API returns a list of access request statuses based on the specified query parameters. Any token with any authority can request their own status. A token with ORG_ADMIN authority is required to call this API to get a list of statuses for other users.
         * @summary Access Request Status
         * @param {AccessRequestsApiListAccessRequestStatusRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listAccessRequestStatus(requestParameters: AccessRequestsApiListAccessRequestStatusRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<RequestedItemStatus>> {
            return localVarFp.listAccessRequestStatus(requestParameters.requestedFor, requestParameters.requestedBy, requestParameters.regardingIdentity, requestParameters.assignedTo, requestParameters.count, requestParameters.limit, requestParameters.offset, requestParameters.filters, requestParameters.sorters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint replaces the current access-request configuration. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Access Request Configuration
         * @param {AccessRequestsApiSetAccessRequestConfigRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        setAccessRequestConfig(requestParameters: AccessRequestsApiSetAccessRequestConfigRequest, options?: AxiosRequestConfig): AxiosPromise<AccessRequestConfig> {
            return localVarFp.setAccessRequestConfig(requestParameters.accessRequestConfig, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancelAccessRequest operation in AccessRequestsApi.
 * @export
 * @interface AccessRequestsApiCancelAccessRequestRequest
 */
export interface AccessRequestsApiCancelAccessRequestRequest {
    /**
     * 
     * @type {CancelAccessRequest}
     * @memberof AccessRequestsApiCancelAccessRequest
     */
    readonly cancelAccessRequest: CancelAccessRequest
}

/**
 * Request parameters for createAccessRequest operation in AccessRequestsApi.
 * @export
 * @interface AccessRequestsApiCreateAccessRequestRequest
 */
export interface AccessRequestsApiCreateAccessRequestRequest {
    /**
     * 
     * @type {AccessRequest}
     * @memberof AccessRequestsApiCreateAccessRequest
     */
    readonly accessRequest: AccessRequest
}

/**
 * Request parameters for listAccessRequestStatus operation in AccessRequestsApi.
 * @export
 * @interface AccessRequestsApiListAccessRequestStatusRequest
 */
export interface AccessRequestsApiListAccessRequestStatusRequest {
    /**
     * Filter the results by the identity for which the requests were made. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
     * @type {string}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly requestedFor?: string

    /**
     * Filter the results by the identity that made the requests. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
     * @type {string}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly requestedBy?: string

    /**
     * Filter the results by the specified identity which is either the requester or target of the requests. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
     * @type {string}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly regardingIdentity?: string

    /**
     * Filter the results by the specified identity which is the owner of the Identity Request Work Item. *me* indicates the current user.
     * @type {string}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly assignedTo?: string

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.
     * @type {boolean}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly count?: boolean

    /**
     * Max number of results to return.
     * @type {number}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. Defaults to 0 if not specified.
     * @type {number}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly offset?: number

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **accountActivityItemId**: *eq, in, ge, gt, le, lt, ne, isnull, sw*
     * @type {string}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified, accountActivityItemId, name**
     * @type {string}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly sorters?: string
}

/**
 * Request parameters for setAccessRequestConfig operation in AccessRequestsApi.
 * @export
 * @interface AccessRequestsApiSetAccessRequestConfigRequest
 */
export interface AccessRequestsApiSetAccessRequestConfigRequest {
    /**
     * 
     * @type {AccessRequestConfig}
     * @memberof AccessRequestsApiSetAccessRequestConfig
     */
    readonly accessRequestConfig: AccessRequestConfig
}

/**
 * AccessRequestsApi - object-oriented interface
 * @export
 * @class AccessRequestsApi
 * @extends {BaseAPI}
 */
export class AccessRequestsApi extends BaseAPI {
    /**
     * This API endpoint cancels a pending access request. An access request can be cancelled only if it has not passed the approval step. Any token with ORG_ADMIN authority or token of the user who originally requested the access request is required to cancel it.
     * @summary Cancel Access Request
     * @param {AccessRequestsApiCancelAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsApi
     */
    public cancelAccessRequest(requestParameters: AccessRequestsApiCancelAccessRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestsApiFp(this.configuration).cancelAccessRequest(requestParameters.cancelAccessRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This submits the access request into IdentityNow, where it will follow any IdentityNow approval processes.  Access requests are processed asynchronously by IdentityNow.  A success response from this endpoint means the request has been submitted to IDN and is queued for processing.  Because this endpoint is asynchronous, it will not return an error if you submit duplicate access requests in quick succession, or you submit an access request for access that is already in progress, approved, or rejected. It is best practice to check for any existing access requests that reference the same access items before submitting a new access request.  This can be accomplished by using the [access request status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) or the [pending access request approvals](https://developer.sailpoint.com/idn/api/v3/list-pending-approvals) endpoints.  You can also use the [search API](https://developer.sailpoint.com/idn/api/v3/search) to check the existing access items that an identity has before submitting an access request to ensure you are not requesting access that is already granted.  There are two types of access request:  __GRANT_ACCESS__ * Can be requested for multiple identities in a single request. * Supports self request and request on behalf of other users. Refer to the [Get Access Request Configuration](https://developer.sailpoint.com/idn/api/v3/get-access-request-config) endpoint for request configuration options.   * Allows any authenticated token (except API) to call this endpoint to request to grant access to themselves. Depending on the configuration, a user can request access for others. * Roles, access profiles and entitlements can be requested. * While requesting entitlements, maximum of 25 entitlements and 10 recipients are allowed in a request.   __REVOKE_ACCESS__ * Can only be requested for a single identity at a time. * Does not support self request. Only manager can request to revoke access for their directly managed employees. * If a `removeDate` is specified, then the access will be removed on that date and time only for roles and access profiles. Entitlements are currently unsupported for `removeDate`. * Roles, access profiles, and entitlements can be requested for revocation. * Revoke requests for entitlements are limited to 1 entitlement per access request currently. * [Roles, Access Profiles] You can specify a `removeDate` if the access doesn\'t already have a sunset date. The `removeDate` must be a future date, in the UTC timezone.  * Allows a manager to request to revoke access for direct employees. A token with ORG_ADMIN authority can also request to revoke access from anyone.  >**Note:** There is no indication to the approver in the IdentityNow UI that the approval request is for a revoke action. Take this into consideration when calling this API.  A token with API authority cannot be used to call this endpoint.  
     * @summary Submit an Access Request
     * @param {AccessRequestsApiCreateAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsApi
     */
    public createAccessRequest(requestParameters: AccessRequestsApiCreateAccessRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestsApiFp(this.configuration).createAccessRequest(requestParameters.accessRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns the current access-request configuration.
     * @summary Get Access Request Configuration
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsApi
     */
    public getAccessRequestConfig(axiosOptions?: AxiosRequestConfig) {
        return AccessRequestsApiFp(this.configuration).getAccessRequestConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The Access Request Status API returns a list of access request statuses based on the specified query parameters. Any token with any authority can request their own status. A token with ORG_ADMIN authority is required to call this API to get a list of statuses for other users.
     * @summary Access Request Status
     * @param {AccessRequestsApiListAccessRequestStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsApi
     */
    public listAccessRequestStatus(requestParameters: AccessRequestsApiListAccessRequestStatusRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestsApiFp(this.configuration).listAccessRequestStatus(requestParameters.requestedFor, requestParameters.requestedBy, requestParameters.regardingIdentity, requestParameters.assignedTo, requestParameters.count, requestParameters.limit, requestParameters.offset, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint replaces the current access-request configuration. A token with ORG_ADMIN authority is required to call this API.
     * @summary Update Access Request Configuration
     * @param {AccessRequestsApiSetAccessRequestConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsApi
     */
    public setAccessRequestConfig(requestParameters: AccessRequestsApiSetAccessRequestConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestsApiFp(this.configuration).setAccessRequestConfig(requestParameters.accessRequestConfig, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AccountActivitiesApi - axios parameter creator
 * @export
 */
export const AccountActivitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This gets a single account activity by its id.
         * @summary Get an Account Activity
         * @param {string} id The account activity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountActivity: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccountActivity', 'id', id)
            const localVarPath = `/account-activities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a collection of account activities that satisfy the given query parameters.
         * @summary List Account Activities
         * @param {string} [requestedFor] The identity that the activity was requested for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] The identity that requested the activity. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] The specified identity will be either the requester or target of the account activity. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **type**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **created**: *gt, lt, ge, le, eq, in, ne, isnull, sw*  **modified**: *gt, lt, ge, le, eq, in, ne, isnull, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccountActivities: async (requestedFor?: string, requestedBy?: string, regardingIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account-activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (requestedFor !== undefined) {
                localVarQueryParameter['requested-for'] = requestedFor;
            }

            if (requestedBy !== undefined) {
                localVarQueryParameter['requested-by'] = requestedBy;
            }

            if (regardingIdentity !== undefined) {
                localVarQueryParameter['regarding-identity'] = regardingIdentity;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountActivitiesApi - functional programming interface
 * @export
 */
export const AccountActivitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountActivitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * This gets a single account activity by its id.
         * @summary Get an Account Activity
         * @param {string} id The account activity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountActivity(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountActivity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountActivity(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccountActivitiesApi.getAccountActivity']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This gets a collection of account activities that satisfy the given query parameters.
         * @summary List Account Activities
         * @param {string} [requestedFor] The identity that the activity was requested for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] The identity that requested the activity. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] The specified identity will be either the requester or target of the account activity. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **type**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **created**: *gt, lt, ge, le, eq, in, ne, isnull, sw*  **modified**: *gt, lt, ge, le, eq, in, ne, isnull, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listAccountActivities(requestedFor?: string, requestedBy?: string, regardingIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountActivity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccountActivities(requestedFor, requestedBy, regardingIdentity, limit, offset, count, filters, sorters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccountActivitiesApi.listAccountActivities']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AccountActivitiesApi - factory interface
 * @export
 */
export const AccountActivitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountActivitiesApiFp(configuration)
    return {
        /**
         * This gets a single account activity by its id.
         * @summary Get an Account Activity
         * @param {AccountActivitiesApiGetAccountActivityRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getAccountActivity(requestParameters: AccountActivitiesApiGetAccountActivityRequest, options?: AxiosRequestConfig): AxiosPromise<AccountActivity> {
            return localVarFp.getAccountActivity(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This gets a collection of account activities that satisfy the given query parameters.
         * @summary List Account Activities
         * @param {AccountActivitiesApiListAccountActivitiesRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listAccountActivities(requestParameters: AccountActivitiesApiListAccountActivitiesRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<AccountActivity>> {
            return localVarFp.listAccountActivities(requestParameters.requestedFor, requestParameters.requestedBy, requestParameters.regardingIdentity, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAccountActivity operation in AccountActivitiesApi.
 * @export
 * @interface AccountActivitiesApiGetAccountActivityRequest
 */
export interface AccountActivitiesApiGetAccountActivityRequest {
    /**
     * The account activity id
     * @type {string}
     * @memberof AccountActivitiesApiGetAccountActivity
     */
    readonly id: string
}

/**
 * Request parameters for listAccountActivities operation in AccountActivitiesApi.
 * @export
 * @interface AccountActivitiesApiListAccountActivitiesRequest
 */
export interface AccountActivitiesApiListAccountActivitiesRequest {
    /**
     * The identity that the activity was requested for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
     * @type {string}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly requestedFor?: string

    /**
     * The identity that requested the activity. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
     * @type {string}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly requestedBy?: string

    /**
     * The specified identity will be either the requester or target of the account activity. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
     * @type {string}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly regardingIdentity?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **type**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **created**: *gt, lt, ge, le, eq, in, ne, isnull, sw*  **modified**: *gt, lt, ge, le, eq, in, ne, isnull, sw*
     * @type {string}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified**
     * @type {string}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly sorters?: string
}

/**
 * AccountActivitiesApi - object-oriented interface
 * @export
 * @class AccountActivitiesApi
 * @extends {BaseAPI}
 */
export class AccountActivitiesApi extends BaseAPI {
    /**
     * This gets a single account activity by its id.
     * @summary Get an Account Activity
     * @param {AccountActivitiesApiGetAccountActivityRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountActivitiesApi
     */
    public getAccountActivity(requestParameters: AccountActivitiesApiGetAccountActivityRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountActivitiesApiFp(this.configuration).getAccountActivity(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a collection of account activities that satisfy the given query parameters.
     * @summary List Account Activities
     * @param {AccountActivitiesApiListAccountActivitiesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountActivitiesApi
     */
    public listAccountActivities(requestParameters: AccountActivitiesApiListAccountActivitiesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccountActivitiesApiFp(this.configuration).listAccountActivities(requestParameters.requestedFor, requestParameters.requestedBy, requestParameters.regardingIdentity, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AccountUsagesApi - axios parameter creator
 * @export
 */
export const AccountUsagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API returns a summary of account usage insights for past 12 months.
         * @summary Returns account usage insights
         * @param {string} accountId ID of IDN account
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **date**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUsagesByAccountId: async (accountId: string, limit?: number, offset?: number, count?: boolean, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getUsagesByAccountId', 'accountId', accountId)
            const localVarPath = `/account-usages/{accountId}/summaries`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountUsagesApi - functional programming interface
 * @export
 */
export const AccountUsagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountUsagesApiAxiosParamCreator(configuration)
    return {
        /**
         * This API returns a summary of account usage insights for past 12 months.
         * @summary Returns account usage insights
         * @param {string} accountId ID of IDN account
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **date**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getUsagesByAccountId(accountId: string, limit?: number, offset?: number, count?: boolean, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountUsage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsagesByAccountId(accountId, limit, offset, count, sorters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccountUsagesApi.getUsagesByAccountId']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AccountUsagesApi - factory interface
 * @export
 */
export const AccountUsagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountUsagesApiFp(configuration)
    return {
        /**
         * This API returns a summary of account usage insights for past 12 months.
         * @summary Returns account usage insights
         * @param {AccountUsagesApiGetUsagesByAccountIdRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getUsagesByAccountId(requestParameters: AccountUsagesApiGetUsagesByAccountIdRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AccountUsage>> {
            return localVarFp.getUsagesByAccountId(requestParameters.accountId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getUsagesByAccountId operation in AccountUsagesApi.
 * @export
 * @interface AccountUsagesApiGetUsagesByAccountIdRequest
 */
export interface AccountUsagesApiGetUsagesByAccountIdRequest {
    /**
     * ID of IDN account
     * @type {string}
     * @memberof AccountUsagesApiGetUsagesByAccountId
     */
    readonly accountId: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountUsagesApiGetUsagesByAccountId
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountUsagesApiGetUsagesByAccountId
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccountUsagesApiGetUsagesByAccountId
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **date**
     * @type {string}
     * @memberof AccountUsagesApiGetUsagesByAccountId
     */
    readonly sorters?: string
}

/**
 * AccountUsagesApi - object-oriented interface
 * @export
 * @class AccountUsagesApi
 * @extends {BaseAPI}
 */
export class AccountUsagesApi extends BaseAPI {
    /**
     * This API returns a summary of account usage insights for past 12 months.
     * @summary Returns account usage insights
     * @param {AccountUsagesApiGetUsagesByAccountIdRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountUsagesApi
     */
    public getUsagesByAccountId(requestParameters: AccountUsagesApiGetUsagesByAccountIdRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountUsagesApiFp(this.configuration).getUsagesByAccountId(requestParameters.accountId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API submits an account creation task and returns the task ID.   The `sourceId` where this account will be created must be included in the `attributes` object. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Account
         * @param {AccountAttributesCreate} accountAttributesCreate 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (accountAttributesCreate: AccountAttributesCreate, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountAttributesCreate' is not null or undefined
            assertParamExists('createAccount', 'accountAttributesCreate', accountAttributesCreate)
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountAttributesCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits an account delete task and returns the task ID. This operation can only be used on Flat File Sources. Any attempt to execute this request on the source of other type will result in an error response with a status code of 400. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Account
         * @param {string} id The account ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAccount', 'id', id)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits a task to disable the account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Disable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        disableAccount: async (id: string, accountToggleRequest: AccountToggleRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('disableAccount', 'id', id)
            // verify required parameter 'accountToggleRequest' is not null or undefined
            assertParamExists('disableAccount', 'accountToggleRequest', accountToggleRequest)
            const localVarPath = `/accounts/{id}/disable`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountToggleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits a task to enable account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Enable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        enableAccount: async (id: string, accountToggleRequest: AccountToggleRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('enableAccount', 'id', id)
            // verify required parameter 'accountToggleRequest' is not null or undefined
            assertParamExists('enableAccount', 'accountToggleRequest', accountToggleRequest)
            const localVarPath = `/accounts/{id}/enable`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountToggleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the details for a single account based on the ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Account Details
         * @param {string} id The account ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccount', 'id', id)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns entitlements of the account.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Account Entitlements
         * @param {string} id The account id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountEntitlements: async (id: string, limit?: number, offset?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccountEntitlements', 'id', id)
            const localVarPath = `/accounts/{id}/entitlements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This returns a list of accounts.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Accounts List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **identityId**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **name**: *eq, in, ge, gt, ne, isnull, sw*  **nativeIdentity**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **sourceId**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **uncorrelated**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, created, modified, sourceId, identityId, nativeIdentity, uuid, manuallyCorrelated**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts: async (limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits an account update task and returns the task ID.   A token with ORG_ADMIN authority is required to call this API. >**NOTE: The PUT Account API is designated only for Delimited File sources.**
         * @summary Update Account
         * @param {string} id The account ID
         * @param {AccountAttributes} accountAttributes 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putAccount: async (id: string, accountAttributes: AccountAttributes, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putAccount', 'id', id)
            // verify required parameter 'accountAttributes' is not null or undefined
            assertParamExists('putAccount', 'accountAttributes', accountAttributes)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountAttributes, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API asynchronously reloads the account directly from the connector and performs a one-time aggregation process.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Reload Account
         * @param {string} id The account id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        reloadAccount: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reloadAccount', 'id', id)
            const localVarPath = `/accounts/{id}/reload`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits a task to unlock an account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Unlock Account
         * @param {string} id The account id
         * @param {AccountUnlockRequest} accountUnlockRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        unlockAccount: async (id: string, accountUnlockRequest: AccountUnlockRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unlockAccount', 'id', id)
            // verify required parameter 'accountUnlockRequest' is not null or undefined
            assertParamExists('unlockAccount', 'accountUnlockRequest', accountUnlockRequest)
            const localVarPath = `/accounts/{id}/unlock`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountUnlockRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to modify the following fields: * `identityId`  * `manuallyCorrelated`  >**NOTE: All other fields cannot be modified.**  The request must provide a JSONPatch payload.  A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Account
         * @param {string} id The account ID
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAccount', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateAccount', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API submits an account creation task and returns the task ID.   The `sourceId` where this account will be created must be included in the `attributes` object. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Account
         * @param {AccountAttributesCreate} accountAttributesCreate 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(accountAttributesCreate: AccountAttributesCreate, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(accountAttributesCreate, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccountsApi.createAccount']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API submits an account delete task and returns the task ID. This operation can only be used on Flat File Sources. Any attempt to execute this request on the source of other type will result in an error response with a status code of 400. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Account
         * @param {string} id The account ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccount(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccount(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccountsApi.deleteAccount']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API submits a task to disable the account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Disable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async disableAccount(id: string, accountToggleRequest: AccountToggleRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableAccount(id, accountToggleRequest, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccountsApi.disableAccount']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API submits a task to enable account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Enable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async enableAccount(id: string, accountToggleRequest: AccountToggleRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableAccount(id, accountToggleRequest, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccountsApi.enableAccount']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API returns the details for a single account based on the ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Account Details
         * @param {string} id The account ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccountsApi.getAccount']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API returns entitlements of the account.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Account Entitlements
         * @param {string} id The account id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountEntitlements(id: string, limit?: number, offset?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EntitlementDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountEntitlements(id, limit, offset, count, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccountsApi.getAccountEntitlements']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This returns a list of accounts.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Accounts List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **identityId**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **name**: *eq, in, ge, gt, ne, isnull, sw*  **nativeIdentity**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **sourceId**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **uncorrelated**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, created, modified, sourceId, identityId, nativeIdentity, uuid, manuallyCorrelated**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listAccounts(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccounts(limit, offset, count, filters, sorters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccountsApi.listAccounts']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API submits an account update task and returns the task ID.   A token with ORG_ADMIN authority is required to call this API. >**NOTE: The PUT Account API is designated only for Delimited File sources.**
         * @summary Update Account
         * @param {string} id The account ID
         * @param {AccountAttributes} accountAttributes 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putAccount(id: string, accountAttributes: AccountAttributes, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putAccount(id, accountAttributes, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccountsApi.putAccount']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API asynchronously reloads the account directly from the connector and performs a one-time aggregation process.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Reload Account
         * @param {string} id The account id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async reloadAccount(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reloadAccount(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccountsApi.reloadAccount']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API submits a task to unlock an account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Unlock Account
         * @param {string} id The account id
         * @param {AccountUnlockRequest} accountUnlockRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async unlockAccount(id: string, accountUnlockRequest: AccountUnlockRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlockAccount(id, accountUnlockRequest, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccountsApi.unlockAccount']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Use this API to modify the following fields: * `identityId`  * `manuallyCorrelated`  >**NOTE: All other fields cannot be modified.**  The request must provide a JSONPatch payload.  A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Account
         * @param {string} id The account ID
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccount(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccount(id, jsonPatchOperation, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccountsApi.updateAccount']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * This API submits an account creation task and returns the task ID.   The `sourceId` where this account will be created must be included in the `attributes` object. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Account
         * @param {AccountsApiCreateAccountRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        createAccount(requestParameters: AccountsApiCreateAccountRequest, options?: AxiosRequestConfig): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.createAccount(requestParameters.accountAttributesCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * This API submits an account delete task and returns the task ID. This operation can only be used on Flat File Sources. Any attempt to execute this request on the source of other type will result in an error response with a status code of 400. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Account
         * @param {AccountsApiDeleteAccountRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteAccount(requestParameters: AccountsApiDeleteAccountRequest, options?: AxiosRequestConfig): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.deleteAccount(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This API submits a task to disable the account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Disable Account
         * @param {AccountsApiDisableAccountRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        disableAccount(requestParameters: AccountsApiDisableAccountRequest, options?: AxiosRequestConfig): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.disableAccount(requestParameters.id, requestParameters.accountToggleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API submits a task to enable account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Enable Account
         * @param {AccountsApiEnableAccountRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        enableAccount(requestParameters: AccountsApiEnableAccountRequest, options?: AxiosRequestConfig): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.enableAccount(requestParameters.id, requestParameters.accountToggleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the details for a single account based on the ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Account Details
         * @param {AccountsApiGetAccountRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getAccount(requestParameters: AccountsApiGetAccountRequest, options?: AxiosRequestConfig): AxiosPromise<Account> {
            return localVarFp.getAccount(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This API returns entitlements of the account.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Account Entitlements
         * @param {AccountsApiGetAccountEntitlementsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getAccountEntitlements(requestParameters: AccountsApiGetAccountEntitlementsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<EntitlementDto>> {
            return localVarFp.getAccountEntitlements(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, options).then((request) => request(axios, basePath));
        },
        /**
         * This returns a list of accounts.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Accounts List
         * @param {AccountsApiListAccountsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listAccounts(requestParameters: AccountsApiListAccountsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<Account>> {
            return localVarFp.listAccounts(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, options).then((request) => request(axios, basePath));
        },
        /**
         * This API submits an account update task and returns the task ID.   A token with ORG_ADMIN authority is required to call this API. >**NOTE: The PUT Account API is designated only for Delimited File sources.**
         * @summary Update Account
         * @param {AccountsApiPutAccountRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        putAccount(requestParameters: AccountsApiPutAccountRequest, options?: AxiosRequestConfig): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.putAccount(requestParameters.id, requestParameters.accountAttributes, options).then((request) => request(axios, basePath));
        },
        /**
         * This API asynchronously reloads the account directly from the connector and performs a one-time aggregation process.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Reload Account
         * @param {AccountsApiReloadAccountRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        reloadAccount(requestParameters: AccountsApiReloadAccountRequest, options?: AxiosRequestConfig): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.reloadAccount(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This API submits a task to unlock an account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Unlock Account
         * @param {AccountsApiUnlockAccountRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        unlockAccount(requestParameters: AccountsApiUnlockAccountRequest, options?: AxiosRequestConfig): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.unlockAccount(requestParameters.id, requestParameters.accountUnlockRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to modify the following fields: * `identityId`  * `manuallyCorrelated`  >**NOTE: All other fields cannot be modified.**  The request must provide a JSONPatch payload.  A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Account
         * @param {AccountsApiUpdateAccountRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        updateAccount(requestParameters: AccountsApiUpdateAccountRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.updateAccount(requestParameters.id, requestParameters.jsonPatchOperation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiCreateAccountRequest
 */
export interface AccountsApiCreateAccountRequest {
    /**
     * 
     * @type {AccountAttributesCreate}
     * @memberof AccountsApiCreateAccount
     */
    readonly accountAttributesCreate: AccountAttributesCreate
}

/**
 * Request parameters for deleteAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiDeleteAccountRequest
 */
export interface AccountsApiDeleteAccountRequest {
    /**
     * The account ID
     * @type {string}
     * @memberof AccountsApiDeleteAccount
     */
    readonly id: string
}

/**
 * Request parameters for disableAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiDisableAccountRequest
 */
export interface AccountsApiDisableAccountRequest {
    /**
     * The account id
     * @type {string}
     * @memberof AccountsApiDisableAccount
     */
    readonly id: string

    /**
     * 
     * @type {AccountToggleRequest}
     * @memberof AccountsApiDisableAccount
     */
    readonly accountToggleRequest: AccountToggleRequest
}

/**
 * Request parameters for enableAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiEnableAccountRequest
 */
export interface AccountsApiEnableAccountRequest {
    /**
     * The account id
     * @type {string}
     * @memberof AccountsApiEnableAccount
     */
    readonly id: string

    /**
     * 
     * @type {AccountToggleRequest}
     * @memberof AccountsApiEnableAccount
     */
    readonly accountToggleRequest: AccountToggleRequest
}

/**
 * Request parameters for getAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiGetAccountRequest
 */
export interface AccountsApiGetAccountRequest {
    /**
     * The account ID
     * @type {string}
     * @memberof AccountsApiGetAccount
     */
    readonly id: string
}

/**
 * Request parameters for getAccountEntitlements operation in AccountsApi.
 * @export
 * @interface AccountsApiGetAccountEntitlementsRequest
 */
export interface AccountsApiGetAccountEntitlementsRequest {
    /**
     * The account id
     * @type {string}
     * @memberof AccountsApiGetAccountEntitlements
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountsApiGetAccountEntitlements
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountsApiGetAccountEntitlements
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccountsApiGetAccountEntitlements
     */
    readonly count?: boolean
}

/**
 * Request parameters for listAccounts operation in AccountsApi.
 * @export
 * @interface AccountsApiListAccountsRequest
 */
export interface AccountsApiListAccountsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountsApiListAccounts
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountsApiListAccounts
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccountsApiListAccounts
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **identityId**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **name**: *eq, in, ge, gt, ne, isnull, sw*  **nativeIdentity**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **sourceId**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **uncorrelated**: *eq*
     * @type {string}
     * @memberof AccountsApiListAccounts
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, created, modified, sourceId, identityId, nativeIdentity, uuid, manuallyCorrelated**
     * @type {string}
     * @memberof AccountsApiListAccounts
     */
    readonly sorters?: string
}

/**
 * Request parameters for putAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiPutAccountRequest
 */
export interface AccountsApiPutAccountRequest {
    /**
     * The account ID
     * @type {string}
     * @memberof AccountsApiPutAccount
     */
    readonly id: string

    /**
     * 
     * @type {AccountAttributes}
     * @memberof AccountsApiPutAccount
     */
    readonly accountAttributes: AccountAttributes
}

/**
 * Request parameters for reloadAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiReloadAccountRequest
 */
export interface AccountsApiReloadAccountRequest {
    /**
     * The account id
     * @type {string}
     * @memberof AccountsApiReloadAccount
     */
    readonly id: string
}

/**
 * Request parameters for unlockAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiUnlockAccountRequest
 */
export interface AccountsApiUnlockAccountRequest {
    /**
     * The account id
     * @type {string}
     * @memberof AccountsApiUnlockAccount
     */
    readonly id: string

    /**
     * 
     * @type {AccountUnlockRequest}
     * @memberof AccountsApiUnlockAccount
     */
    readonly accountUnlockRequest: AccountUnlockRequest
}

/**
 * Request parameters for updateAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiUpdateAccountRequest
 */
export interface AccountsApiUpdateAccountRequest {
    /**
     * The account ID
     * @type {string}
     * @memberof AccountsApiUpdateAccount
     */
    readonly id: string

    /**
     * A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
     * @type {Array<JsonPatchOperation>}
     * @memberof AccountsApiUpdateAccount
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * This API submits an account creation task and returns the task ID.   The `sourceId` where this account will be created must be included in the `attributes` object. A token with ORG_ADMIN authority is required to call this API.
     * @summary Create Account
     * @param {AccountsApiCreateAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public createAccount(requestParameters: AccountsApiCreateAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).createAccount(requestParameters.accountAttributesCreate, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits an account delete task and returns the task ID. This operation can only be used on Flat File Sources. Any attempt to execute this request on the source of other type will result in an error response with a status code of 400. A token with ORG_ADMIN authority is required to call this API.
     * @summary Delete Account
     * @param {AccountsApiDeleteAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public deleteAccount(requestParameters: AccountsApiDeleteAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).deleteAccount(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits a task to disable the account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Disable Account
     * @param {AccountsApiDisableAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public disableAccount(requestParameters: AccountsApiDisableAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).disableAccount(requestParameters.id, requestParameters.accountToggleRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits a task to enable account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Enable Account
     * @param {AccountsApiEnableAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public enableAccount(requestParameters: AccountsApiEnableAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).enableAccount(requestParameters.id, requestParameters.accountToggleRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the details for a single account based on the ID.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Account Details
     * @param {AccountsApiGetAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccount(requestParameters: AccountsApiGetAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccount(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns entitlements of the account.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Account Entitlements
     * @param {AccountsApiGetAccountEntitlementsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountEntitlements(requestParameters: AccountsApiGetAccountEntitlementsRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccountEntitlements(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns a list of accounts.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Accounts List
     * @param {AccountsApiListAccountsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listAccounts(requestParameters: AccountsApiListAccountsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).listAccounts(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits an account update task and returns the task ID.   A token with ORG_ADMIN authority is required to call this API. >**NOTE: The PUT Account API is designated only for Delimited File sources.**
     * @summary Update Account
     * @param {AccountsApiPutAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public putAccount(requestParameters: AccountsApiPutAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).putAccount(requestParameters.id, requestParameters.accountAttributes, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API asynchronously reloads the account directly from the connector and performs a one-time aggregation process.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Reload Account
     * @param {AccountsApiReloadAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public reloadAccount(requestParameters: AccountsApiReloadAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).reloadAccount(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits a task to unlock an account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Unlock Account
     * @param {AccountsApiUnlockAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public unlockAccount(requestParameters: AccountsApiUnlockAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).unlockAccount(requestParameters.id, requestParameters.accountUnlockRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to modify the following fields: * `identityId`  * `manuallyCorrelated`  >**NOTE: All other fields cannot be modified.**  The request must provide a JSONPatch payload.  A token with ORG_ADMIN authority is required to call this API.
     * @summary Update Account
     * @param {AccountsApiUpdateAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public updateAccount(requestParameters: AccountsApiUpdateAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).updateAccount(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthUserApi - axios parameter creator
 * @export
 */
export const AuthUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API returns the specified user\'s authentication system details. Requires security scope of:  \'sp:auth-user:read\'
         * @summary Auth User Details
         * @param {string} id Identity ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAuthUser: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAuthUser', 'id', id)
            const localVarPath = `/auth-users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update an existing user in the authentication system with a PATCH request.
         * @summary Auth User Update
         * @param {string} id Identity ID
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth user update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  PATCH can only be applied to the following fields:   *   \&quot;capabilities\&quot;  A list of valid capabilities can be found using the GET ams/v3/authorization/authorization-capabilities/ endpoint. Capabilities can only be patched if they are administrator assignable, as indicated by the \&#39;adminAssignable\&#39; field from the output of list authorization-capabilities. Capabilities that have a legacy group (\&#39;legacyGroup\&#39; field) need to be patched using the legacyGroup name (e.g. \&#39;ORG_ADMIN\&#39;). Capabilities that are adminAssignable but do not have a legacyGroup can be patched using the ams id (e.g. \&#39;cam:new-role\&#39;).  A 400.1.1 Illegal update attempt detail code indicates that you attempted to PATCH a field that is not allowed.  Requires security scope of \&#39;sp:auth-user:update\&#39; 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthUser: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchAuthUser', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchAuthUser', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/auth-users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthUserApi - functional programming interface
 * @export
 */
export const AuthUserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthUserApiAxiosParamCreator(configuration)
    return {
        /**
         * This API returns the specified user\'s authentication system details. Requires security scope of:  \'sp:auth-user:read\'
         * @summary Auth User Details
         * @param {string} id Identity ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthUser(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthUser(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthUserApi.getAuthUser']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update an existing user in the authentication system with a PATCH request.
         * @summary Auth User Update
         * @param {string} id Identity ID
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth user update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  PATCH can only be applied to the following fields:   *   \&quot;capabilities\&quot;  A list of valid capabilities can be found using the GET ams/v3/authorization/authorization-capabilities/ endpoint. Capabilities can only be patched if they are administrator assignable, as indicated by the \&#39;adminAssignable\&#39; field from the output of list authorization-capabilities. Capabilities that have a legacy group (\&#39;legacyGroup\&#39; field) need to be patched using the legacyGroup name (e.g. \&#39;ORG_ADMIN\&#39;). Capabilities that are adminAssignable but do not have a legacyGroup can be patched using the ams id (e.g. \&#39;cam:new-role\&#39;).  A 400.1.1 Illegal update attempt detail code indicates that you attempted to PATCH a field that is not allowed.  Requires security scope of \&#39;sp:auth-user:update\&#39; 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchAuthUser(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAuthUser(id, jsonPatchOperation, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthUserApi.patchAuthUser']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AuthUserApi - factory interface
 * @export
 */
export const AuthUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthUserApiFp(configuration)
    return {
        /**
         * This API returns the specified user\'s authentication system details. Requires security scope of:  \'sp:auth-user:read\'
         * @summary Auth User Details
         * @param {AuthUserApiGetAuthUserRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getAuthUser(requestParameters: AuthUserApiGetAuthUserRequest, options?: AxiosRequestConfig): AxiosPromise<AuthUser> {
            return localVarFp.getAuthUser(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing user in the authentication system with a PATCH request.
         * @summary Auth User Update
         * @param {AuthUserApiPatchAuthUserRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        patchAuthUser(requestParameters: AuthUserApiPatchAuthUserRequest, options?: AxiosRequestConfig): AxiosPromise<AuthUser> {
            return localVarFp.patchAuthUser(requestParameters.id, requestParameters.jsonPatchOperation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAuthUser operation in AuthUserApi.
 * @export
 * @interface AuthUserApiGetAuthUserRequest
 */
export interface AuthUserApiGetAuthUserRequest {
    /**
     * Identity ID
     * @type {string}
     * @memberof AuthUserApiGetAuthUser
     */
    readonly id: string
}

/**
 * Request parameters for patchAuthUser operation in AuthUserApi.
 * @export
 * @interface AuthUserApiPatchAuthUserRequest
 */
export interface AuthUserApiPatchAuthUserRequest {
    /**
     * Identity ID
     * @type {string}
     * @memberof AuthUserApiPatchAuthUser
     */
    readonly id: string

    /**
     * A list of auth user update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  PATCH can only be applied to the following fields:   *   \&quot;capabilities\&quot;  A list of valid capabilities can be found using the GET ams/v3/authorization/authorization-capabilities/ endpoint. Capabilities can only be patched if they are administrator assignable, as indicated by the \&#39;adminAssignable\&#39; field from the output of list authorization-capabilities. Capabilities that have a legacy group (\&#39;legacyGroup\&#39; field) need to be patched using the legacyGroup name (e.g. \&#39;ORG_ADMIN\&#39;). Capabilities that are adminAssignable but do not have a legacyGroup can be patched using the ams id (e.g. \&#39;cam:new-role\&#39;).  A 400.1.1 Illegal update attempt detail code indicates that you attempted to PATCH a field that is not allowed.  Requires security scope of \&#39;sp:auth-user:update\&#39; 
     * @type {Array<JsonPatchOperation>}
     * @memberof AuthUserApiPatchAuthUser
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * AuthUserApi - object-oriented interface
 * @export
 * @class AuthUserApi
 * @extends {BaseAPI}
 */
export class AuthUserApi extends BaseAPI {
    /**
     * This API returns the specified user\'s authentication system details. Requires security scope of:  \'sp:auth-user:read\'
     * @summary Auth User Details
     * @param {AuthUserApiGetAuthUserRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthUserApi
     */
    public getAuthUser(requestParameters: AuthUserApiGetAuthUserRequest, axiosOptions?: AxiosRequestConfig) {
        return AuthUserApiFp(this.configuration).getAuthUser(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing user in the authentication system with a PATCH request.
     * @summary Auth User Update
     * @param {AuthUserApiPatchAuthUserRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthUserApi
     */
    public patchAuthUser(requestParameters: AuthUserApiPatchAuthUserRequest, axiosOptions?: AxiosRequestConfig) {
        return AuthUserApiFp(this.configuration).patchAuthUser(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CertificationCampaignFiltersApi - axios parameter creator
 * @export
 */
export const CertificationCampaignFiltersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a campaign Filter based on filter details and criteria.
         * @summary Create a Campaign Filter
         * @param {CampaignFilterDetails} campaignFilterDetails 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCampaignFilter: async (campaignFilterDetails: CampaignFilterDetails, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignFilterDetails' is not null or undefined
            assertParamExists('createCampaignFilter', 'campaignFilterDetails', campaignFilterDetails)
            const localVarPath = `/campaign-filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaignFilterDetails, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes campaign filters whose Ids are specified in the provided list of campaign filter Ids. Authorized callers must be an ORG_ADMIN or a CERT_ADMIN.
         * @summary Deletes Campaign Filters
         * @param {Array<string>} requestBody A json list of IDs of campaign filters to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaignFilters: async (requestBody: Array<string>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('deleteCampaignFilters', 'requestBody', requestBody)
            const localVarPath = `/campaign-filters/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Retrieves information for an existing campaign filter using the filter\'s ID.
         * @summary Get Campaign Filter by ID
         * @param {string} filterId The ID of the campaign filter to be retrieved.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignFilterById: async (filterId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filterId' is not null or undefined
            assertParamExists('getCampaignFilterById', 'filterId', filterId)
            const localVarPath = `/campaign-filters/{id}`
                .replace(`{${"filterId"}}`, encodeURIComponent(String(filterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Lists all Campaign Filters. Scope can be reduced via standard V3 query params.  All Campaign Filters matching the query params
         * @summary List Campaign Filters
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [start] Start/Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [includeSystemFilters] If true, include system filters in the count and results, exclude them otherwise. If not provided any value for it then by default it is true.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCampaignFilters: async (limit?: number, start?: number, includeSystemFilters?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/campaign-filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (includeSystemFilters !== undefined) {
                localVarQueryParameter['includeSystemFilters'] = includeSystemFilters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing campaign filter using the filter\'s ID.
         * @summary Updates a Campaign Filter
         * @param {string} filterId The ID of the campaign filter being modified.
         * @param {CampaignFilterDetails} campaignFilterDetails A campaign filter details with updated field values.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateCampaignFilter: async (filterId: string, campaignFilterDetails: CampaignFilterDetails, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filterId' is not null or undefined
            assertParamExists('updateCampaignFilter', 'filterId', filterId)
            // verify required parameter 'campaignFilterDetails' is not null or undefined
            assertParamExists('updateCampaignFilter', 'campaignFilterDetails', campaignFilterDetails)
            const localVarPath = `/campaign-filters/{id}`
                .replace(`{${"filterId"}}`, encodeURIComponent(String(filterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaignFilterDetails, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * CertificationCampaignFiltersApi - functional programming interface
 * @export
 */
export const CertificationCampaignFiltersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CertificationCampaignFiltersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a campaign Filter based on filter details and criteria.
         * @summary Create a Campaign Filter
         * @param {CampaignFilterDetails} campaignFilterDetails 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createCampaignFilter(campaignFilterDetails: CampaignFilterDetails, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignFilterDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCampaignFilter(campaignFilterDetails, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationCampaignFiltersApi.createCampaignFilter']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Deletes campaign filters whose Ids are specified in the provided list of campaign filter Ids. Authorized callers must be an ORG_ADMIN or a CERT_ADMIN.
         * @summary Deletes Campaign Filters
         * @param {Array<string>} requestBody A json list of IDs of campaign filters to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCampaignFilters(requestBody: Array<string>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCampaignFilters(requestBody, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationCampaignFiltersApi.deleteCampaignFilters']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieves information for an existing campaign filter using the filter\'s ID.
         * @summary Get Campaign Filter by ID
         * @param {string} filterId The ID of the campaign filter to be retrieved.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaignFilterById(filterId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CampaignFilterDetails>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaignFilterById(filterId, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationCampaignFiltersApi.getCampaignFilterById']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Lists all Campaign Filters. Scope can be reduced via standard V3 query params.  All Campaign Filters matching the query params
         * @summary List Campaign Filters
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [start] Start/Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [includeSystemFilters] If true, include system filters in the count and results, exclude them otherwise. If not provided any value for it then by default it is true.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listCampaignFilters(limit?: number, start?: number, includeSystemFilters?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CampaignFilterDetails>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCampaignFilters(limit, start, includeSystemFilters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationCampaignFiltersApi.listCampaignFilters']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Updates an existing campaign filter using the filter\'s ID.
         * @summary Updates a Campaign Filter
         * @param {string} filterId The ID of the campaign filter being modified.
         * @param {CampaignFilterDetails} campaignFilterDetails A campaign filter details with updated field values.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateCampaignFilter(filterId: string, campaignFilterDetails: CampaignFilterDetails, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignFilterDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCampaignFilter(filterId, campaignFilterDetails, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationCampaignFiltersApi.updateCampaignFilter']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * CertificationCampaignFiltersApi - factory interface
 * @export
 */
export const CertificationCampaignFiltersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CertificationCampaignFiltersApiFp(configuration)
    return {
        /**
         * Create a campaign Filter based on filter details and criteria.
         * @summary Create a Campaign Filter
         * @param {CertificationCampaignFiltersApiCreateCampaignFilterRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        createCampaignFilter(requestParameters: CertificationCampaignFiltersApiCreateCampaignFilterRequest, options?: AxiosRequestConfig): AxiosPromise<CampaignFilterDetails> {
            return localVarFp.createCampaignFilter(requestParameters.campaignFilterDetails, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes campaign filters whose Ids are specified in the provided list of campaign filter Ids. Authorized callers must be an ORG_ADMIN or a CERT_ADMIN.
         * @summary Deletes Campaign Filters
         * @param {CertificationCampaignFiltersApiDeleteCampaignFiltersRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteCampaignFilters(requestParameters: CertificationCampaignFiltersApiDeleteCampaignFiltersRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCampaignFilters(requestParameters.requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves information for an existing campaign filter using the filter\'s ID.
         * @summary Get Campaign Filter by ID
         * @param {CertificationCampaignFiltersApiGetCampaignFilterByIdRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getCampaignFilterById(requestParameters: CertificationCampaignFiltersApiGetCampaignFilterByIdRequest, options?: AxiosRequestConfig): AxiosPromise<Array<CampaignFilterDetails>> {
            return localVarFp.getCampaignFilterById(requestParameters.filterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all Campaign Filters. Scope can be reduced via standard V3 query params.  All Campaign Filters matching the query params
         * @summary List Campaign Filters
         * @param {CertificationCampaignFiltersApiListCampaignFiltersRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listCampaignFilters(requestParameters: CertificationCampaignFiltersApiListCampaignFiltersRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<CampaignFilterDetails>> {
            return localVarFp.listCampaignFilters(requestParameters.limit, requestParameters.start, requestParameters.includeSystemFilters, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing campaign filter using the filter\'s ID.
         * @summary Updates a Campaign Filter
         * @param {CertificationCampaignFiltersApiUpdateCampaignFilterRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        updateCampaignFilter(requestParameters: CertificationCampaignFiltersApiUpdateCampaignFilterRequest, options?: AxiosRequestConfig): AxiosPromise<CampaignFilterDetails> {
            return localVarFp.updateCampaignFilter(requestParameters.filterId, requestParameters.campaignFilterDetails, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCampaignFilter operation in CertificationCampaignFiltersApi.
 * @export
 * @interface CertificationCampaignFiltersApiCreateCampaignFilterRequest
 */
export interface CertificationCampaignFiltersApiCreateCampaignFilterRequest {
    /**
     * 
     * @type {CampaignFilterDetails}
     * @memberof CertificationCampaignFiltersApiCreateCampaignFilter
     */
    readonly campaignFilterDetails: CampaignFilterDetails
}

/**
 * Request parameters for deleteCampaignFilters operation in CertificationCampaignFiltersApi.
 * @export
 * @interface CertificationCampaignFiltersApiDeleteCampaignFiltersRequest
 */
export interface CertificationCampaignFiltersApiDeleteCampaignFiltersRequest {
    /**
     * A json list of IDs of campaign filters to delete.
     * @type {Array<string>}
     * @memberof CertificationCampaignFiltersApiDeleteCampaignFilters
     */
    readonly requestBody: Array<string>
}

/**
 * Request parameters for getCampaignFilterById operation in CertificationCampaignFiltersApi.
 * @export
 * @interface CertificationCampaignFiltersApiGetCampaignFilterByIdRequest
 */
export interface CertificationCampaignFiltersApiGetCampaignFilterByIdRequest {
    /**
     * The ID of the campaign filter to be retrieved.
     * @type {string}
     * @memberof CertificationCampaignFiltersApiGetCampaignFilterById
     */
    readonly filterId: string
}

/**
 * Request parameters for listCampaignFilters operation in CertificationCampaignFiltersApi.
 * @export
 * @interface CertificationCampaignFiltersApiListCampaignFiltersRequest
 */
export interface CertificationCampaignFiltersApiListCampaignFiltersRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationCampaignFiltersApiListCampaignFilters
     */
    readonly limit?: number

    /**
     * Start/Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationCampaignFiltersApiListCampaignFilters
     */
    readonly start?: number

    /**
     * If true, include system filters in the count and results, exclude them otherwise. If not provided any value for it then by default it is true.
     * @type {boolean}
     * @memberof CertificationCampaignFiltersApiListCampaignFilters
     */
    readonly includeSystemFilters?: boolean
}

/**
 * Request parameters for updateCampaignFilter operation in CertificationCampaignFiltersApi.
 * @export
 * @interface CertificationCampaignFiltersApiUpdateCampaignFilterRequest
 */
export interface CertificationCampaignFiltersApiUpdateCampaignFilterRequest {
    /**
     * The ID of the campaign filter being modified.
     * @type {string}
     * @memberof CertificationCampaignFiltersApiUpdateCampaignFilter
     */
    readonly filterId: string

    /**
     * A campaign filter details with updated field values.
     * @type {CampaignFilterDetails}
     * @memberof CertificationCampaignFiltersApiUpdateCampaignFilter
     */
    readonly campaignFilterDetails: CampaignFilterDetails
}

/**
 * CertificationCampaignFiltersApi - object-oriented interface
 * @export
 * @class CertificationCampaignFiltersApi
 * @extends {BaseAPI}
 */
export class CertificationCampaignFiltersApi extends BaseAPI {
    /**
     * Create a campaign Filter based on filter details and criteria.
     * @summary Create a Campaign Filter
     * @param {CertificationCampaignFiltersApiCreateCampaignFilterRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignFiltersApi
     */
    public createCampaignFilter(requestParameters: CertificationCampaignFiltersApiCreateCampaignFilterRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignFiltersApiFp(this.configuration).createCampaignFilter(requestParameters.campaignFilterDetails, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes campaign filters whose Ids are specified in the provided list of campaign filter Ids. Authorized callers must be an ORG_ADMIN or a CERT_ADMIN.
     * @summary Deletes Campaign Filters
     * @param {CertificationCampaignFiltersApiDeleteCampaignFiltersRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignFiltersApi
     */
    public deleteCampaignFilters(requestParameters: CertificationCampaignFiltersApiDeleteCampaignFiltersRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignFiltersApiFp(this.configuration).deleteCampaignFilters(requestParameters.requestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves information for an existing campaign filter using the filter\'s ID.
     * @summary Get Campaign Filter by ID
     * @param {CertificationCampaignFiltersApiGetCampaignFilterByIdRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignFiltersApi
     */
    public getCampaignFilterById(requestParameters: CertificationCampaignFiltersApiGetCampaignFilterByIdRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignFiltersApiFp(this.configuration).getCampaignFilterById(requestParameters.filterId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all Campaign Filters. Scope can be reduced via standard V3 query params.  All Campaign Filters matching the query params
     * @summary List Campaign Filters
     * @param {CertificationCampaignFiltersApiListCampaignFiltersRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignFiltersApi
     */
    public listCampaignFilters(requestParameters: CertificationCampaignFiltersApiListCampaignFiltersRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignFiltersApiFp(this.configuration).listCampaignFilters(requestParameters.limit, requestParameters.start, requestParameters.includeSystemFilters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing campaign filter using the filter\'s ID.
     * @summary Updates a Campaign Filter
     * @param {CertificationCampaignFiltersApiUpdateCampaignFilterRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignFiltersApi
     */
    public updateCampaignFilter(requestParameters: CertificationCampaignFiltersApiUpdateCampaignFilterRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignFiltersApiFp(this.configuration).updateCampaignFilter(requestParameters.filterId, requestParameters.campaignFilterDetails, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CertificationCampaignsApi - axios parameter creator
 * @export
 */
export const CertificationCampaignsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * :::caution  This endpoint will run successfully for any campaigns that are **past due**.  This endpoint will return a content error if the campaign is **not past due**.  :::  Completes a certification campaign. This is provided to admins so that they can complete a certification even if all items have not been completed.  Requires roles of CERT_ADMIN and ORG_ADMIN 
         * @summary Complete a Campaign
         * @param {string} id The campaign id
         * @param {CampaignCompleteOptions} [campaignCompleteOptions] Optional. Default behavior is for the campaign to auto-approve upon completion, unless autoCompleteAction&#x3D;REVOKE
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        completeCampaign: async (id: string, campaignCompleteOptions?: CampaignCompleteOptions, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('completeCampaign', 'id', id)
            const localVarPath = `/campaigns/{id}/complete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaignCompleteOptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Creates a new Certification Campaign with the information provided in the request body.
         * @summary Create a campaign
         * @param {Campaign} campaign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCampaign: async (campaign: Campaign, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaign' is not null or undefined
            assertParamExists('createCampaign', 'campaign', campaign)
            const localVarPath = `/campaigns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaign, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Create a campaign Template based on campaign.
         * @summary Create a Campaign Template
         * @param {CampaignTemplate} campaignTemplate 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCampaignTemplate: async (campaignTemplate: CampaignTemplate, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignTemplate' is not null or undefined
            assertParamExists('createCampaignTemplate', 'campaignTemplate', campaignTemplate)
            const localVarPath = `/campaign-templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaignTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes a campaign template by ID.
         * @summary Delete a Campaign Template
         * @param {string} id The ID of the campaign template being deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaignTemplate: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCampaignTemplate', 'id', id)
            const localVarPath = `/campaign-templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes the schedule for a campaign template. Returns a 404 if there is no schedule set.
         * @summary Deletes a Campaign Template\'s Schedule
         * @param {string} id The ID of the campaign template whose schedule is being deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaignTemplateSchedule: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCampaignTemplateSchedule', 'id', id)
            const localVarPath = `/campaign-templates/{id}/schedule`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes campaigns whose Ids are specified in the provided list of campaign Ids. Authorized callers must be an ORG_ADMIN or a CERT_ADMIN.
         * @summary Deletes Campaigns
         * @param {CampaignsDeleteRequest} campaignsDeleteRequest The ids of the campaigns to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaigns: async (campaignsDeleteRequest: CampaignsDeleteRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignsDeleteRequest' is not null or undefined
            assertParamExists('deleteCampaigns', 'campaignsDeleteRequest', campaignsDeleteRequest)
            const localVarPath = `/campaigns/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaignsDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Gets campaigns and returns them in a list. Can provide increased level of detail for each campaign if provided the correct query.
         * @summary List Campaigns
         * @param {GetActiveCampaignsDetailEnum} [detail] Determines whether slim, or increased level of detail is provided for each campaign in the returned list. Slim is the default behavior.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **status**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getActiveCampaigns: async (detail?: 'SLIM' | 'FULL', limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/campaigns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (detail !== undefined) {
                localVarQueryParameter['detail'] = detail;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Retrieves information for an existing campaign using the campaign\'s ID. Authorized callers must be a reviewer for this campaign, an ORG_ADMIN, or a CERT_ADMIN.
         * @summary Get a campaign
         * @param {string} id The ID of the campaign to be retrieved
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaign: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCampaign', 'id', id)
            const localVarPath = `/campaigns/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Fetches all reports for a certification campaign by campaign ID. Requires roles of CERT_ADMIN, DASHBOARD, ORG_ADMIN and REPORT_ADMIN
         * @summary Get Campaign Reports
         * @param {string} id The ID of the campaign for which reports are being fetched.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignReports: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCampaignReports', 'id', id)
            const localVarPath = `/campaigns/{id}/reports`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Fetches configuration for campaign reports. Currently it includes only one element - identity attributes defined as custom report columns. Requires roles of CERT_ADMIN and ORG_ADMIN.
         * @summary Get Campaign Reports Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignReportsConfig: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/campaigns/reports-configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Fetches a campaign template by ID.
         * @summary Get a Campaign Template
         * @param {string} id The desired campaign template\&#39;s ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignTemplate: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCampaignTemplate', 'id', id)
            const localVarPath = `/campaign-templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Gets the schedule for a campaign template. Returns a 404 if there is no schedule set.
         * @summary Gets a Campaign Template\'s Schedule
         * @param {string} id The ID of the campaign template whose schedule is being fetched.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignTemplateSchedule: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCampaignTemplateSchedule', 'id', id)
            const localVarPath = `/campaign-templates/{id}/schedule`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Lists all CampaignTemplates. Scope can be reduced via standard V3 query params.  All CampaignTemplates matching the query params
         * @summary List Campaign Templates
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **name**: *eq, ge, gt, in, le, lt, ne, sw*  **id**: *eq, ge, gt, in, le, lt, ne, sw*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCampaignTemplates: async (limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/campaign-templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API reassigns the specified certifications from one identity to another. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Reassign Certifications
         * @param {string} id The certification campaign ID
         * @param {AdminReviewReassign} adminReviewReassign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        move: async (id: string, adminReviewReassign: AdminReviewReassign, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('move', 'id', id)
            // verify required parameter 'adminReviewReassign' is not null or undefined
            assertParamExists('move', 'adminReviewReassign', adminReviewReassign)
            const localVarPath = `/campaigns/{id}/reassign`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminReviewReassign, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Allows updating individual fields on a campaign template using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @summary Update a Campaign Template
         * @param {string} id The ID of the campaign template being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * deadlineDuration * campaign (all fields that are allowed during create) 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchCampaignTemplate: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchCampaignTemplate', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchCampaignTemplate', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/campaign-templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Overwrites configuration for campaign reports. Requires roles CERT_ADMIN and ORG_ADMIN.
         * @summary Set Campaign Reports Configuration
         * @param {CampaignReportsConfig} campaignReportsConfig Campaign Report Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setCampaignReportsConfig: async (campaignReportsConfig: CampaignReportsConfig, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignReportsConfig' is not null or undefined
            assertParamExists('setCampaignReportsConfig', 'campaignReportsConfig', campaignReportsConfig)
            const localVarPath = `/campaigns/reports-configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaignReportsConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Sets the schedule for a campaign template. If a schedule already exists, it will be overwritten with the new one.
         * @summary Sets a Campaign Template\'s Schedule
         * @param {string} id The ID of the campaign template being scheduled.
         * @param {Schedule} [schedule] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setCampaignTemplateSchedule: async (id: string, schedule?: Schedule, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setCampaignTemplateSchedule', 'id', id)
            const localVarPath = `/campaign-templates/{id}/schedule`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schedule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Submits a job to activate the campaign with the given Id. The campaign must be staged. Requires roles of CERT_ADMIN and ORG_ADMIN
         * @summary Activate a Campaign
         * @param {string} id The campaign id
         * @param {ActivateCampaignOptions} [activateCampaignOptions] Optional. If no timezone is specified, the standard UTC timezone is used (i.e. UTC+00:00). Although this can take any timezone, the intended value is the caller\&#39;s timezone. The activation time calculated from the given timezone may cause the campaign deadline time to be modified, but it will remain within the original date. The timezone must be in a valid ISO 8601 format.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startCampaign: async (id: string, activateCampaignOptions?: ActivateCampaignOptions, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startCampaign', 'id', id)
            const localVarPath = `/campaigns/{id}/activate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activateCampaignOptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Kicks off remediation scan task for a certification campaign. Requires roles of CERT_ADMIN and ORG_ADMIN
         * @summary Run Campaign Remediation Scan
         * @param {string} id The ID of the campaign for which remediation scan is being run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startCampaignRemediationScan: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startCampaignRemediationScan', 'id', id)
            const localVarPath = `/campaigns/{id}/run-remediation-scan`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Runs a report for a certification campaign. Requires the following roles: CERT_ADMIN, DASHBOARD, ORG_ADMIN and REPORT_ADMIN.
         * @summary Run Campaign Report
         * @param {string} id The ID of the campaign for which report is being run.
         * @param {ReportType} type The type of the report to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startCampaignReport: async (id: string, type: ReportType, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startCampaignReport', 'id', id)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('startCampaignReport', 'type', type)
            const localVarPath = `/campaigns/{id}/run-report/{type}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Generates a new campaign from a campaign template. The campaign object contained in the template has special formatting applied to its name and description fields in order to determine the generated campaign\'s name/description. Placeholders in those fields are formatted with the current date and time upon generation. Placeholders consist of a percent sign followed by a letter indicating what should be inserted; for example, \"%Y\" will insert the current year; a campaign template named \"Campaign for %y\" would generate a campaign called \"Campaign for 2020\" (assuming the year at generation time is 2020). Valid placeholders are the date/time conversion suffix characters supported by [java.util.Formatter](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). Requires roles ORG_ADMIN.
         * @summary Generate a Campaign from Template
         * @param {string} id The ID of the campaign template to use for generation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startGenerateCampaignTemplate: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startGenerateCampaignTemplate', 'id', id)
            const localVarPath = `/campaign-templates/{id}/generate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Allows updating individual fields on a campaign using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @summary Update a Campaign
         * @param {string} id The ID of the campaign template being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The fields that can be patched differ based on the status of the campaign.  In the *STAGED* status, the following fields can be patched: * name * description * recommendationsEnabled * deadline * emailNotificationEnabled * autoRevokeAllowed  In the *ACTIVE* status, the following fields can be patched: * deadline 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateCampaign: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCampaign', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateCampaign', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/campaigns/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * CertificationCampaignsApi - functional programming interface
 * @export
 */
export const CertificationCampaignsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CertificationCampaignsApiAxiosParamCreator(configuration)
    return {
        /**
         * :::caution  This endpoint will run successfully for any campaigns that are **past due**.  This endpoint will return a content error if the campaign is **not past due**.  :::  Completes a certification campaign. This is provided to admins so that they can complete a certification even if all items have not been completed.  Requires roles of CERT_ADMIN and ORG_ADMIN 
         * @summary Complete a Campaign
         * @param {string} id The campaign id
         * @param {CampaignCompleteOptions} [campaignCompleteOptions] Optional. Default behavior is for the campaign to auto-approve upon completion, unless autoCompleteAction&#x3D;REVOKE
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async completeCampaign(id: string, campaignCompleteOptions?: CampaignCompleteOptions, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeCampaign(id, campaignCompleteOptions, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationCampaignsApi.completeCampaign']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Creates a new Certification Campaign with the information provided in the request body.
         * @summary Create a campaign
         * @param {Campaign} campaign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createCampaign(campaign: Campaign, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Campaign>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCampaign(campaign, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationCampaignsApi.createCampaign']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create a campaign Template based on campaign.
         * @summary Create a Campaign Template
         * @param {CampaignTemplate} campaignTemplate 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createCampaignTemplate(campaignTemplate: CampaignTemplate, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCampaignTemplate(campaignTemplate, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationCampaignsApi.createCampaignTemplate']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Deletes a campaign template by ID.
         * @summary Delete a Campaign Template
         * @param {string} id The ID of the campaign template being deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCampaignTemplate(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCampaignTemplate(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationCampaignsApi.deleteCampaignTemplate']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Deletes the schedule for a campaign template. Returns a 404 if there is no schedule set.
         * @summary Deletes a Campaign Template\'s Schedule
         * @param {string} id The ID of the campaign template whose schedule is being deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCampaignTemplateSchedule(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCampaignTemplateSchedule(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationCampaignsApi.deleteCampaignTemplateSchedule']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Deletes campaigns whose Ids are specified in the provided list of campaign Ids. Authorized callers must be an ORG_ADMIN or a CERT_ADMIN.
         * @summary Deletes Campaigns
         * @param {CampaignsDeleteRequest} campaignsDeleteRequest The ids of the campaigns to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCampaigns(campaignsDeleteRequest: CampaignsDeleteRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCampaigns(campaignsDeleteRequest, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationCampaignsApi.deleteCampaigns']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Gets campaigns and returns them in a list. Can provide increased level of detail for each campaign if provided the correct query.
         * @summary List Campaigns
         * @param {GetActiveCampaignsDetailEnum} [detail] Determines whether slim, or increased level of detail is provided for each campaign in the returned list. Slim is the default behavior.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **status**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveCampaigns(detail?: GetActiveCampaignsDetailEnum, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetActiveCampaigns200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveCampaigns(detail, limit, offset, count, filters, sorters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationCampaignsApi.getActiveCampaigns']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieves information for an existing campaign using the campaign\'s ID. Authorized callers must be a reviewer for this campaign, an ORG_ADMIN, or a CERT_ADMIN.
         * @summary Get a campaign
         * @param {string} id The ID of the campaign to be retrieved
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaign(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SlimCampaign>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaign(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationCampaignsApi.getCampaign']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Fetches all reports for a certification campaign by campaign ID. Requires roles of CERT_ADMIN, DASHBOARD, ORG_ADMIN and REPORT_ADMIN
         * @summary Get Campaign Reports
         * @param {string} id The ID of the campaign for which reports are being fetched.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaignReports(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CampaignReport>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaignReports(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationCampaignsApi.getCampaignReports']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Fetches configuration for campaign reports. Currently it includes only one element - identity attributes defined as custom report columns. Requires roles of CERT_ADMIN and ORG_ADMIN.
         * @summary Get Campaign Reports Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaignReportsConfig(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignReportsConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaignReportsConfig(axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationCampaignsApi.getCampaignReportsConfig']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Fetches a campaign template by ID.
         * @summary Get a Campaign Template
         * @param {string} id The desired campaign template\&#39;s ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaignTemplate(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaignTemplate(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationCampaignsApi.getCampaignTemplate']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Gets the schedule for a campaign template. Returns a 404 if there is no schedule set.
         * @summary Gets a Campaign Template\'s Schedule
         * @param {string} id The ID of the campaign template whose schedule is being fetched.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaignTemplateSchedule(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaignTemplateSchedule(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationCampaignsApi.getCampaignTemplateSchedule']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Lists all CampaignTemplates. Scope can be reduced via standard V3 query params.  All CampaignTemplates matching the query params
         * @summary List Campaign Templates
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **name**: *eq, ge, gt, in, le, lt, ne, sw*  **id**: *eq, ge, gt, in, le, lt, ne, sw*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listCampaignTemplates(limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CampaignTemplate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCampaignTemplates(limit, offset, count, sorters, filters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationCampaignsApi.listCampaignTemplates']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API reassigns the specified certifications from one identity to another. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Reassign Certifications
         * @param {string} id The certification campaign ID
         * @param {AdminReviewReassign} adminReviewReassign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async move(id: string, adminReviewReassign: AdminReviewReassign, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CertificationTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.move(id, adminReviewReassign, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationCampaignsApi.move']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Allows updating individual fields on a campaign template using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @summary Update a Campaign Template
         * @param {string} id The ID of the campaign template being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * deadlineDuration * campaign (all fields that are allowed during create) 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchCampaignTemplate(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchCampaignTemplate(id, jsonPatchOperation, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationCampaignsApi.patchCampaignTemplate']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Overwrites configuration for campaign reports. Requires roles CERT_ADMIN and ORG_ADMIN.
         * @summary Set Campaign Reports Configuration
         * @param {CampaignReportsConfig} campaignReportsConfig Campaign Report Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setCampaignReportsConfig(campaignReportsConfig: CampaignReportsConfig, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignReportsConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setCampaignReportsConfig(campaignReportsConfig, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationCampaignsApi.setCampaignReportsConfig']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Sets the schedule for a campaign template. If a schedule already exists, it will be overwritten with the new one.
         * @summary Sets a Campaign Template\'s Schedule
         * @param {string} id The ID of the campaign template being scheduled.
         * @param {Schedule} [schedule] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setCampaignTemplateSchedule(id: string, schedule?: Schedule, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setCampaignTemplateSchedule(id, schedule, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationCampaignsApi.setCampaignTemplateSchedule']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Submits a job to activate the campaign with the given Id. The campaign must be staged. Requires roles of CERT_ADMIN and ORG_ADMIN
         * @summary Activate a Campaign
         * @param {string} id The campaign id
         * @param {ActivateCampaignOptions} [activateCampaignOptions] Optional. If no timezone is specified, the standard UTC timezone is used (i.e. UTC+00:00). Although this can take any timezone, the intended value is the caller\&#39;s timezone. The activation time calculated from the given timezone may cause the campaign deadline time to be modified, but it will remain within the original date. The timezone must be in a valid ISO 8601 format.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startCampaign(id: string, activateCampaignOptions?: ActivateCampaignOptions, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startCampaign(id, activateCampaignOptions, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationCampaignsApi.startCampaign']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Kicks off remediation scan task for a certification campaign. Requires roles of CERT_ADMIN and ORG_ADMIN
         * @summary Run Campaign Remediation Scan
         * @param {string} id The ID of the campaign for which remediation scan is being run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startCampaignRemediationScan(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startCampaignRemediationScan(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationCampaignsApi.startCampaignRemediationScan']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Runs a report for a certification campaign. Requires the following roles: CERT_ADMIN, DASHBOARD, ORG_ADMIN and REPORT_ADMIN.
         * @summary Run Campaign Report
         * @param {string} id The ID of the campaign for which report is being run.
         * @param {ReportType} type The type of the report to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startCampaignReport(id: string, type: ReportType, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startCampaignReport(id, type, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationCampaignsApi.startCampaignReport']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Generates a new campaign from a campaign template. The campaign object contained in the template has special formatting applied to its name and description fields in order to determine the generated campaign\'s name/description. Placeholders in those fields are formatted with the current date and time upon generation. Placeholders consist of a percent sign followed by a letter indicating what should be inserted; for example, \"%Y\" will insert the current year; a campaign template named \"Campaign for %y\" would generate a campaign called \"Campaign for 2020\" (assuming the year at generation time is 2020). Valid placeholders are the date/time conversion suffix characters supported by [java.util.Formatter](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). Requires roles ORG_ADMIN.
         * @summary Generate a Campaign from Template
         * @param {string} id The ID of the campaign template to use for generation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startGenerateCampaignTemplate(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startGenerateCampaignTemplate(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationCampaignsApi.startGenerateCampaignTemplate']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Allows updating individual fields on a campaign using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @summary Update a Campaign
         * @param {string} id The ID of the campaign template being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The fields that can be patched differ based on the status of the campaign.  In the *STAGED* status, the following fields can be patched: * name * description * recommendationsEnabled * deadline * emailNotificationEnabled * autoRevokeAllowed  In the *ACTIVE* status, the following fields can be patched: * deadline 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateCampaign(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SlimCampaign>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCampaign(id, jsonPatchOperation, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationCampaignsApi.updateCampaign']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * CertificationCampaignsApi - factory interface
 * @export
 */
export const CertificationCampaignsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CertificationCampaignsApiFp(configuration)
    return {
        /**
         * :::caution  This endpoint will run successfully for any campaigns that are **past due**.  This endpoint will return a content error if the campaign is **not past due**.  :::  Completes a certification campaign. This is provided to admins so that they can complete a certification even if all items have not been completed.  Requires roles of CERT_ADMIN and ORG_ADMIN 
         * @summary Complete a Campaign
         * @param {CertificationCampaignsApiCompleteCampaignRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        completeCampaign(requestParameters: CertificationCampaignsApiCompleteCampaignRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.completeCampaign(requestParameters.id, requestParameters.campaignCompleteOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new Certification Campaign with the information provided in the request body.
         * @summary Create a campaign
         * @param {CertificationCampaignsApiCreateCampaignRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        createCampaign(requestParameters: CertificationCampaignsApiCreateCampaignRequest, options?: AxiosRequestConfig): AxiosPromise<Campaign> {
            return localVarFp.createCampaign(requestParameters.campaign, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a campaign Template based on campaign.
         * @summary Create a Campaign Template
         * @param {CertificationCampaignsApiCreateCampaignTemplateRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        createCampaignTemplate(requestParameters: CertificationCampaignsApiCreateCampaignTemplateRequest, options?: AxiosRequestConfig): AxiosPromise<CampaignTemplate> {
            return localVarFp.createCampaignTemplate(requestParameters.campaignTemplate, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a campaign template by ID.
         * @summary Delete a Campaign Template
         * @param {CertificationCampaignsApiDeleteCampaignTemplateRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteCampaignTemplate(requestParameters: CertificationCampaignsApiDeleteCampaignTemplateRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCampaignTemplate(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the schedule for a campaign template. Returns a 404 if there is no schedule set.
         * @summary Deletes a Campaign Template\'s Schedule
         * @param {CertificationCampaignsApiDeleteCampaignTemplateScheduleRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteCampaignTemplateSchedule(requestParameters: CertificationCampaignsApiDeleteCampaignTemplateScheduleRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCampaignTemplateSchedule(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes campaigns whose Ids are specified in the provided list of campaign Ids. Authorized callers must be an ORG_ADMIN or a CERT_ADMIN.
         * @summary Deletes Campaigns
         * @param {CertificationCampaignsApiDeleteCampaignsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteCampaigns(requestParameters: CertificationCampaignsApiDeleteCampaignsRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.deleteCampaigns(requestParameters.campaignsDeleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets campaigns and returns them in a list. Can provide increased level of detail for each campaign if provided the correct query.
         * @summary List Campaigns
         * @param {CertificationCampaignsApiGetActiveCampaignsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getActiveCampaigns(requestParameters: CertificationCampaignsApiGetActiveCampaignsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<GetActiveCampaigns200ResponseInner>> {
            return localVarFp.getActiveCampaigns(requestParameters.detail, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves information for an existing campaign using the campaign\'s ID. Authorized callers must be a reviewer for this campaign, an ORG_ADMIN, or a CERT_ADMIN.
         * @summary Get a campaign
         * @param {CertificationCampaignsApiGetCampaignRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getCampaign(requestParameters: CertificationCampaignsApiGetCampaignRequest, options?: AxiosRequestConfig): AxiosPromise<SlimCampaign> {
            return localVarFp.getCampaign(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches all reports for a certification campaign by campaign ID. Requires roles of CERT_ADMIN, DASHBOARD, ORG_ADMIN and REPORT_ADMIN
         * @summary Get Campaign Reports
         * @param {CertificationCampaignsApiGetCampaignReportsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getCampaignReports(requestParameters: CertificationCampaignsApiGetCampaignReportsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<CampaignReport>> {
            return localVarFp.getCampaignReports(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches configuration for campaign reports. Currently it includes only one element - identity attributes defined as custom report columns. Requires roles of CERT_ADMIN and ORG_ADMIN.
         * @summary Get Campaign Reports Configuration
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getCampaignReportsConfig(options?: AxiosRequestConfig): AxiosPromise<CampaignReportsConfig> {
            return localVarFp.getCampaignReportsConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a campaign template by ID.
         * @summary Get a Campaign Template
         * @param {CertificationCampaignsApiGetCampaignTemplateRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getCampaignTemplate(requestParameters: CertificationCampaignsApiGetCampaignTemplateRequest, options?: AxiosRequestConfig): AxiosPromise<CampaignTemplate> {
            return localVarFp.getCampaignTemplate(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the schedule for a campaign template. Returns a 404 if there is no schedule set.
         * @summary Gets a Campaign Template\'s Schedule
         * @param {CertificationCampaignsApiGetCampaignTemplateScheduleRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getCampaignTemplateSchedule(requestParameters: CertificationCampaignsApiGetCampaignTemplateScheduleRequest, options?: AxiosRequestConfig): AxiosPromise<Schedule> {
            return localVarFp.getCampaignTemplateSchedule(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all CampaignTemplates. Scope can be reduced via standard V3 query params.  All CampaignTemplates matching the query params
         * @summary List Campaign Templates
         * @param {CertificationCampaignsApiListCampaignTemplatesRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listCampaignTemplates(requestParameters: CertificationCampaignsApiListCampaignTemplatesRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<CampaignTemplate>> {
            return localVarFp.listCampaignTemplates(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, requestParameters.filters, options).then((request) => request(axios, basePath));
        },
        /**
         * This API reassigns the specified certifications from one identity to another. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Reassign Certifications
         * @param {CertificationCampaignsApiMoveRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        move(requestParameters: CertificationCampaignsApiMoveRequest, options?: AxiosRequestConfig): AxiosPromise<CertificationTask> {
            return localVarFp.move(requestParameters.id, requestParameters.adminReviewReassign, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows updating individual fields on a campaign template using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @summary Update a Campaign Template
         * @param {CertificationCampaignsApiPatchCampaignTemplateRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        patchCampaignTemplate(requestParameters: CertificationCampaignsApiPatchCampaignTemplateRequest, options?: AxiosRequestConfig): AxiosPromise<CampaignTemplate> {
            return localVarFp.patchCampaignTemplate(requestParameters.id, requestParameters.jsonPatchOperation, options).then((request) => request(axios, basePath));
        },
        /**
         * Overwrites configuration for campaign reports. Requires roles CERT_ADMIN and ORG_ADMIN.
         * @summary Set Campaign Reports Configuration
         * @param {CertificationCampaignsApiSetCampaignReportsConfigRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        setCampaignReportsConfig(requestParameters: CertificationCampaignsApiSetCampaignReportsConfigRequest, options?: AxiosRequestConfig): AxiosPromise<CampaignReportsConfig> {
            return localVarFp.setCampaignReportsConfig(requestParameters.campaignReportsConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the schedule for a campaign template. If a schedule already exists, it will be overwritten with the new one.
         * @summary Sets a Campaign Template\'s Schedule
         * @param {CertificationCampaignsApiSetCampaignTemplateScheduleRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        setCampaignTemplateSchedule(requestParameters: CertificationCampaignsApiSetCampaignTemplateScheduleRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setCampaignTemplateSchedule(requestParameters.id, requestParameters.schedule, options).then((request) => request(axios, basePath));
        },
        /**
         * Submits a job to activate the campaign with the given Id. The campaign must be staged. Requires roles of CERT_ADMIN and ORG_ADMIN
         * @summary Activate a Campaign
         * @param {CertificationCampaignsApiStartCampaignRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        startCampaign(requestParameters: CertificationCampaignsApiStartCampaignRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.startCampaign(requestParameters.id, requestParameters.activateCampaignOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * Kicks off remediation scan task for a certification campaign. Requires roles of CERT_ADMIN and ORG_ADMIN
         * @summary Run Campaign Remediation Scan
         * @param {CertificationCampaignsApiStartCampaignRemediationScanRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        startCampaignRemediationScan(requestParameters: CertificationCampaignsApiStartCampaignRemediationScanRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.startCampaignRemediationScan(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Runs a report for a certification campaign. Requires the following roles: CERT_ADMIN, DASHBOARD, ORG_ADMIN and REPORT_ADMIN.
         * @summary Run Campaign Report
         * @param {CertificationCampaignsApiStartCampaignReportRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        startCampaignReport(requestParameters: CertificationCampaignsApiStartCampaignReportRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.startCampaignReport(requestParameters.id, requestParameters.type, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a new campaign from a campaign template. The campaign object contained in the template has special formatting applied to its name and description fields in order to determine the generated campaign\'s name/description. Placeholders in those fields are formatted with the current date and time upon generation. Placeholders consist of a percent sign followed by a letter indicating what should be inserted; for example, \"%Y\" will insert the current year; a campaign template named \"Campaign for %y\" would generate a campaign called \"Campaign for 2020\" (assuming the year at generation time is 2020). Valid placeholders are the date/time conversion suffix characters supported by [java.util.Formatter](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). Requires roles ORG_ADMIN.
         * @summary Generate a Campaign from Template
         * @param {CertificationCampaignsApiStartGenerateCampaignTemplateRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        startGenerateCampaignTemplate(requestParameters: CertificationCampaignsApiStartGenerateCampaignTemplateRequest, options?: AxiosRequestConfig): AxiosPromise<CampaignReference> {
            return localVarFp.startGenerateCampaignTemplate(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows updating individual fields on a campaign using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @summary Update a Campaign
         * @param {CertificationCampaignsApiUpdateCampaignRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        updateCampaign(requestParameters: CertificationCampaignsApiUpdateCampaignRequest, options?: AxiosRequestConfig): AxiosPromise<SlimCampaign> {
            return localVarFp.updateCampaign(requestParameters.id, requestParameters.jsonPatchOperation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for completeCampaign operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiCompleteCampaignRequest
 */
export interface CertificationCampaignsApiCompleteCampaignRequest {
    /**
     * The campaign id
     * @type {string}
     * @memberof CertificationCampaignsApiCompleteCampaign
     */
    readonly id: string

    /**
     * Optional. Default behavior is for the campaign to auto-approve upon completion, unless autoCompleteAction&#x3D;REVOKE
     * @type {CampaignCompleteOptions}
     * @memberof CertificationCampaignsApiCompleteCampaign
     */
    readonly campaignCompleteOptions?: CampaignCompleteOptions
}

/**
 * Request parameters for createCampaign operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiCreateCampaignRequest
 */
export interface CertificationCampaignsApiCreateCampaignRequest {
    /**
     * 
     * @type {Campaign}
     * @memberof CertificationCampaignsApiCreateCampaign
     */
    readonly campaign: Campaign
}

/**
 * Request parameters for createCampaignTemplate operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiCreateCampaignTemplateRequest
 */
export interface CertificationCampaignsApiCreateCampaignTemplateRequest {
    /**
     * 
     * @type {CampaignTemplate}
     * @memberof CertificationCampaignsApiCreateCampaignTemplate
     */
    readonly campaignTemplate: CampaignTemplate
}

/**
 * Request parameters for deleteCampaignTemplate operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiDeleteCampaignTemplateRequest
 */
export interface CertificationCampaignsApiDeleteCampaignTemplateRequest {
    /**
     * The ID of the campaign template being deleted.
     * @type {string}
     * @memberof CertificationCampaignsApiDeleteCampaignTemplate
     */
    readonly id: string
}

/**
 * Request parameters for deleteCampaignTemplateSchedule operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiDeleteCampaignTemplateScheduleRequest
 */
export interface CertificationCampaignsApiDeleteCampaignTemplateScheduleRequest {
    /**
     * The ID of the campaign template whose schedule is being deleted.
     * @type {string}
     * @memberof CertificationCampaignsApiDeleteCampaignTemplateSchedule
     */
    readonly id: string
}

/**
 * Request parameters for deleteCampaigns operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiDeleteCampaignsRequest
 */
export interface CertificationCampaignsApiDeleteCampaignsRequest {
    /**
     * The ids of the campaigns to delete.
     * @type {CampaignsDeleteRequest}
     * @memberof CertificationCampaignsApiDeleteCampaigns
     */
    readonly campaignsDeleteRequest: CampaignsDeleteRequest
}

/**
 * Request parameters for getActiveCampaigns operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiGetActiveCampaignsRequest
 */
export interface CertificationCampaignsApiGetActiveCampaignsRequest {
    /**
     * Determines whether slim, or increased level of detail is provided for each campaign in the returned list. Slim is the default behavior.
     * @type {'SLIM' | 'FULL'}
     * @memberof CertificationCampaignsApiGetActiveCampaigns
     */
    readonly detail?: GetActiveCampaignsDetailEnum

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationCampaignsApiGetActiveCampaigns
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationCampaignsApiGetActiveCampaigns
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationCampaignsApiGetActiveCampaigns
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **status**: *eq, in*
     * @type {string}
     * @memberof CertificationCampaignsApiGetActiveCampaigns
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created**
     * @type {string}
     * @memberof CertificationCampaignsApiGetActiveCampaigns
     */
    readonly sorters?: string
}

/**
 * Request parameters for getCampaign operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiGetCampaignRequest
 */
export interface CertificationCampaignsApiGetCampaignRequest {
    /**
     * The ID of the campaign to be retrieved
     * @type {string}
     * @memberof CertificationCampaignsApiGetCampaign
     */
    readonly id: string
}

/**
 * Request parameters for getCampaignReports operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiGetCampaignReportsRequest
 */
export interface CertificationCampaignsApiGetCampaignReportsRequest {
    /**
     * The ID of the campaign for which reports are being fetched.
     * @type {string}
     * @memberof CertificationCampaignsApiGetCampaignReports
     */
    readonly id: string
}

/**
 * Request parameters for getCampaignTemplate operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiGetCampaignTemplateRequest
 */
export interface CertificationCampaignsApiGetCampaignTemplateRequest {
    /**
     * The desired campaign template\&#39;s ID.
     * @type {string}
     * @memberof CertificationCampaignsApiGetCampaignTemplate
     */
    readonly id: string
}

/**
 * Request parameters for getCampaignTemplateSchedule operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiGetCampaignTemplateScheduleRequest
 */
export interface CertificationCampaignsApiGetCampaignTemplateScheduleRequest {
    /**
     * The ID of the campaign template whose schedule is being fetched.
     * @type {string}
     * @memberof CertificationCampaignsApiGetCampaignTemplateSchedule
     */
    readonly id: string
}

/**
 * Request parameters for listCampaignTemplates operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiListCampaignTemplatesRequest
 */
export interface CertificationCampaignsApiListCampaignTemplatesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationCampaignsApiListCampaignTemplates
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationCampaignsApiListCampaignTemplates
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationCampaignsApiListCampaignTemplates
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
     * @type {string}
     * @memberof CertificationCampaignsApiListCampaignTemplates
     */
    readonly sorters?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **name**: *eq, ge, gt, in, le, lt, ne, sw*  **id**: *eq, ge, gt, in, le, lt, ne, sw*
     * @type {string}
     * @memberof CertificationCampaignsApiListCampaignTemplates
     */
    readonly filters?: string
}

/**
 * Request parameters for move operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiMoveRequest
 */
export interface CertificationCampaignsApiMoveRequest {
    /**
     * The certification campaign ID
     * @type {string}
     * @memberof CertificationCampaignsApiMove
     */
    readonly id: string

    /**
     * 
     * @type {AdminReviewReassign}
     * @memberof CertificationCampaignsApiMove
     */
    readonly adminReviewReassign: AdminReviewReassign
}

/**
 * Request parameters for patchCampaignTemplate operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiPatchCampaignTemplateRequest
 */
export interface CertificationCampaignsApiPatchCampaignTemplateRequest {
    /**
     * The ID of the campaign template being modified.
     * @type {string}
     * @memberof CertificationCampaignsApiPatchCampaignTemplate
     */
    readonly id: string

    /**
     * A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * deadlineDuration * campaign (all fields that are allowed during create) 
     * @type {Array<JsonPatchOperation>}
     * @memberof CertificationCampaignsApiPatchCampaignTemplate
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for setCampaignReportsConfig operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiSetCampaignReportsConfigRequest
 */
export interface CertificationCampaignsApiSetCampaignReportsConfigRequest {
    /**
     * Campaign Report Configuration
     * @type {CampaignReportsConfig}
     * @memberof CertificationCampaignsApiSetCampaignReportsConfig
     */
    readonly campaignReportsConfig: CampaignReportsConfig
}

/**
 * Request parameters for setCampaignTemplateSchedule operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiSetCampaignTemplateScheduleRequest
 */
export interface CertificationCampaignsApiSetCampaignTemplateScheduleRequest {
    /**
     * The ID of the campaign template being scheduled.
     * @type {string}
     * @memberof CertificationCampaignsApiSetCampaignTemplateSchedule
     */
    readonly id: string

    /**
     * 
     * @type {Schedule}
     * @memberof CertificationCampaignsApiSetCampaignTemplateSchedule
     */
    readonly schedule?: Schedule
}

/**
 * Request parameters for startCampaign operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiStartCampaignRequest
 */
export interface CertificationCampaignsApiStartCampaignRequest {
    /**
     * The campaign id
     * @type {string}
     * @memberof CertificationCampaignsApiStartCampaign
     */
    readonly id: string

    /**
     * Optional. If no timezone is specified, the standard UTC timezone is used (i.e. UTC+00:00). Although this can take any timezone, the intended value is the caller\&#39;s timezone. The activation time calculated from the given timezone may cause the campaign deadline time to be modified, but it will remain within the original date. The timezone must be in a valid ISO 8601 format.
     * @type {ActivateCampaignOptions}
     * @memberof CertificationCampaignsApiStartCampaign
     */
    readonly activateCampaignOptions?: ActivateCampaignOptions
}

/**
 * Request parameters for startCampaignRemediationScan operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiStartCampaignRemediationScanRequest
 */
export interface CertificationCampaignsApiStartCampaignRemediationScanRequest {
    /**
     * The ID of the campaign for which remediation scan is being run.
     * @type {string}
     * @memberof CertificationCampaignsApiStartCampaignRemediationScan
     */
    readonly id: string
}

/**
 * Request parameters for startCampaignReport operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiStartCampaignReportRequest
 */
export interface CertificationCampaignsApiStartCampaignReportRequest {
    /**
     * The ID of the campaign for which report is being run.
     * @type {string}
     * @memberof CertificationCampaignsApiStartCampaignReport
     */
    readonly id: string

    /**
     * The type of the report to run.
     * @type {ReportType}
     * @memberof CertificationCampaignsApiStartCampaignReport
     */
    readonly type: ReportType
}

/**
 * Request parameters for startGenerateCampaignTemplate operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiStartGenerateCampaignTemplateRequest
 */
export interface CertificationCampaignsApiStartGenerateCampaignTemplateRequest {
    /**
     * The ID of the campaign template to use for generation.
     * @type {string}
     * @memberof CertificationCampaignsApiStartGenerateCampaignTemplate
     */
    readonly id: string
}

/**
 * Request parameters for updateCampaign operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiUpdateCampaignRequest
 */
export interface CertificationCampaignsApiUpdateCampaignRequest {
    /**
     * The ID of the campaign template being modified.
     * @type {string}
     * @memberof CertificationCampaignsApiUpdateCampaign
     */
    readonly id: string

    /**
     * A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The fields that can be patched differ based on the status of the campaign.  In the *STAGED* status, the following fields can be patched: * name * description * recommendationsEnabled * deadline * emailNotificationEnabled * autoRevokeAllowed  In the *ACTIVE* status, the following fields can be patched: * deadline 
     * @type {Array<JsonPatchOperation>}
     * @memberof CertificationCampaignsApiUpdateCampaign
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * CertificationCampaignsApi - object-oriented interface
 * @export
 * @class CertificationCampaignsApi
 * @extends {BaseAPI}
 */
export class CertificationCampaignsApi extends BaseAPI {
    /**
     * :::caution  This endpoint will run successfully for any campaigns that are **past due**.  This endpoint will return a content error if the campaign is **not past due**.  :::  Completes a certification campaign. This is provided to admins so that they can complete a certification even if all items have not been completed.  Requires roles of CERT_ADMIN and ORG_ADMIN 
     * @summary Complete a Campaign
     * @param {CertificationCampaignsApiCompleteCampaignRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public completeCampaign(requestParameters: CertificationCampaignsApiCompleteCampaignRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).completeCampaign(requestParameters.id, requestParameters.campaignCompleteOptions, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new Certification Campaign with the information provided in the request body.
     * @summary Create a campaign
     * @param {CertificationCampaignsApiCreateCampaignRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public createCampaign(requestParameters: CertificationCampaignsApiCreateCampaignRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).createCampaign(requestParameters.campaign, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a campaign Template based on campaign.
     * @summary Create a Campaign Template
     * @param {CertificationCampaignsApiCreateCampaignTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public createCampaignTemplate(requestParameters: CertificationCampaignsApiCreateCampaignTemplateRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).createCampaignTemplate(requestParameters.campaignTemplate, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a campaign template by ID.
     * @summary Delete a Campaign Template
     * @param {CertificationCampaignsApiDeleteCampaignTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public deleteCampaignTemplate(requestParameters: CertificationCampaignsApiDeleteCampaignTemplateRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).deleteCampaignTemplate(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the schedule for a campaign template. Returns a 404 if there is no schedule set.
     * @summary Deletes a Campaign Template\'s Schedule
     * @param {CertificationCampaignsApiDeleteCampaignTemplateScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public deleteCampaignTemplateSchedule(requestParameters: CertificationCampaignsApiDeleteCampaignTemplateScheduleRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).deleteCampaignTemplateSchedule(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes campaigns whose Ids are specified in the provided list of campaign Ids. Authorized callers must be an ORG_ADMIN or a CERT_ADMIN.
     * @summary Deletes Campaigns
     * @param {CertificationCampaignsApiDeleteCampaignsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public deleteCampaigns(requestParameters: CertificationCampaignsApiDeleteCampaignsRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).deleteCampaigns(requestParameters.campaignsDeleteRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets campaigns and returns them in a list. Can provide increased level of detail for each campaign if provided the correct query.
     * @summary List Campaigns
     * @param {CertificationCampaignsApiGetActiveCampaignsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public getActiveCampaigns(requestParameters: CertificationCampaignsApiGetActiveCampaignsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).getActiveCampaigns(requestParameters.detail, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves information for an existing campaign using the campaign\'s ID. Authorized callers must be a reviewer for this campaign, an ORG_ADMIN, or a CERT_ADMIN.
     * @summary Get a campaign
     * @param {CertificationCampaignsApiGetCampaignRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public getCampaign(requestParameters: CertificationCampaignsApiGetCampaignRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).getCampaign(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches all reports for a certification campaign by campaign ID. Requires roles of CERT_ADMIN, DASHBOARD, ORG_ADMIN and REPORT_ADMIN
     * @summary Get Campaign Reports
     * @param {CertificationCampaignsApiGetCampaignReportsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public getCampaignReports(requestParameters: CertificationCampaignsApiGetCampaignReportsRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).getCampaignReports(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches configuration for campaign reports. Currently it includes only one element - identity attributes defined as custom report columns. Requires roles of CERT_ADMIN and ORG_ADMIN.
     * @summary Get Campaign Reports Configuration
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public getCampaignReportsConfig(axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).getCampaignReportsConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches a campaign template by ID.
     * @summary Get a Campaign Template
     * @param {CertificationCampaignsApiGetCampaignTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public getCampaignTemplate(requestParameters: CertificationCampaignsApiGetCampaignTemplateRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).getCampaignTemplate(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the schedule for a campaign template. Returns a 404 if there is no schedule set.
     * @summary Gets a Campaign Template\'s Schedule
     * @param {CertificationCampaignsApiGetCampaignTemplateScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public getCampaignTemplateSchedule(requestParameters: CertificationCampaignsApiGetCampaignTemplateScheduleRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).getCampaignTemplateSchedule(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all CampaignTemplates. Scope can be reduced via standard V3 query params.  All CampaignTemplates matching the query params
     * @summary List Campaign Templates
     * @param {CertificationCampaignsApiListCampaignTemplatesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public listCampaignTemplates(requestParameters: CertificationCampaignsApiListCampaignTemplatesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).listCampaignTemplates(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API reassigns the specified certifications from one identity to another. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
     * @summary Reassign Certifications
     * @param {CertificationCampaignsApiMoveRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public move(requestParameters: CertificationCampaignsApiMoveRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).move(requestParameters.id, requestParameters.adminReviewReassign, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows updating individual fields on a campaign template using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
     * @summary Update a Campaign Template
     * @param {CertificationCampaignsApiPatchCampaignTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public patchCampaignTemplate(requestParameters: CertificationCampaignsApiPatchCampaignTemplateRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).patchCampaignTemplate(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Overwrites configuration for campaign reports. Requires roles CERT_ADMIN and ORG_ADMIN.
     * @summary Set Campaign Reports Configuration
     * @param {CertificationCampaignsApiSetCampaignReportsConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public setCampaignReportsConfig(requestParameters: CertificationCampaignsApiSetCampaignReportsConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).setCampaignReportsConfig(requestParameters.campaignReportsConfig, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets the schedule for a campaign template. If a schedule already exists, it will be overwritten with the new one.
     * @summary Sets a Campaign Template\'s Schedule
     * @param {CertificationCampaignsApiSetCampaignTemplateScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public setCampaignTemplateSchedule(requestParameters: CertificationCampaignsApiSetCampaignTemplateScheduleRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).setCampaignTemplateSchedule(requestParameters.id, requestParameters.schedule, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submits a job to activate the campaign with the given Id. The campaign must be staged. Requires roles of CERT_ADMIN and ORG_ADMIN
     * @summary Activate a Campaign
     * @param {CertificationCampaignsApiStartCampaignRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public startCampaign(requestParameters: CertificationCampaignsApiStartCampaignRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).startCampaign(requestParameters.id, requestParameters.activateCampaignOptions, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kicks off remediation scan task for a certification campaign. Requires roles of CERT_ADMIN and ORG_ADMIN
     * @summary Run Campaign Remediation Scan
     * @param {CertificationCampaignsApiStartCampaignRemediationScanRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public startCampaignRemediationScan(requestParameters: CertificationCampaignsApiStartCampaignRemediationScanRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).startCampaignRemediationScan(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Runs a report for a certification campaign. Requires the following roles: CERT_ADMIN, DASHBOARD, ORG_ADMIN and REPORT_ADMIN.
     * @summary Run Campaign Report
     * @param {CertificationCampaignsApiStartCampaignReportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public startCampaignReport(requestParameters: CertificationCampaignsApiStartCampaignReportRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).startCampaignReport(requestParameters.id, requestParameters.type, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a new campaign from a campaign template. The campaign object contained in the template has special formatting applied to its name and description fields in order to determine the generated campaign\'s name/description. Placeholders in those fields are formatted with the current date and time upon generation. Placeholders consist of a percent sign followed by a letter indicating what should be inserted; for example, \"%Y\" will insert the current year; a campaign template named \"Campaign for %y\" would generate a campaign called \"Campaign for 2020\" (assuming the year at generation time is 2020). Valid placeholders are the date/time conversion suffix characters supported by [java.util.Formatter](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). Requires roles ORG_ADMIN.
     * @summary Generate a Campaign from Template
     * @param {CertificationCampaignsApiStartGenerateCampaignTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public startGenerateCampaignTemplate(requestParameters: CertificationCampaignsApiStartGenerateCampaignTemplateRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).startGenerateCampaignTemplate(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows updating individual fields on a campaign using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
     * @summary Update a Campaign
     * @param {CertificationCampaignsApiUpdateCampaignRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public updateCampaign(requestParameters: CertificationCampaignsApiUpdateCampaignRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).updateCampaign(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetActiveCampaignsDetailEnum = {
    Slim: 'SLIM',
    Full: 'FULL'
} as const;
export type GetActiveCampaignsDetailEnum = typeof GetActiveCampaignsDetailEnum[keyof typeof GetActiveCampaignsDetailEnum];


/**
 * CertificationSummariesApi - axios parameter creator
 * @export
 */
export const CertificationSummariesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API returns a list of access summaries for the specified identity campaign certification and type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Access Summaries
         * @param {string} id The identity campaign certification ID
         * @param {GetIdentityAccessSummariesTypeEnum} type The type of access review item to retrieve summaries for
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **completed**: *eq, ne*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityAccessSummaries: async (id: string, type: 'ROLE' | 'ACCESS_PROFILE' | 'ENTITLEMENT', limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentityAccessSummaries', 'id', id)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getIdentityAccessSummaries', 'type', type)
            const localVarPath = `/certifications/{id}/access-summaries/{type}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a summary of the decisions made on an identity campaign certification. The decisions are summarized by type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Summary of Certification Decisions
         * @param {string} id The certification ID
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **identitySummary.id**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityDecisionSummary: async (id: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentityDecisionSummary', 'id', id)
            const localVarPath = `/certifications/{id}/decision-summary`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of the identity summaries for a specific identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Identity Summaries for Campaign Certification
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **completed**: *eq, ne*  **name**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentitySummaries: async (id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentitySummaries', 'id', id)
            const localVarPath = `/certifications/{id}/identity-summaries`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the summary for an identity on a specified identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Summary for Identity
         * @param {string} id The identity campaign certification ID
         * @param {string} identitySummaryId The identity summary ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentitySummary: async (id: string, identitySummaryId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentitySummary', 'id', id)
            // verify required parameter 'identitySummaryId' is not null or undefined
            assertParamExists('getIdentitySummary', 'identitySummaryId', identitySummaryId)
            const localVarPath = `/certifications/{id}/identity-summaries/{identitySummaryId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"identitySummaryId"}}`, encodeURIComponent(String(identitySummaryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * CertificationSummariesApi - functional programming interface
 * @export
 */
export const CertificationSummariesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CertificationSummariesApiAxiosParamCreator(configuration)
    return {
        /**
         * This API returns a list of access summaries for the specified identity campaign certification and type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Access Summaries
         * @param {string} id The identity campaign certification ID
         * @param {GetIdentityAccessSummariesTypeEnum} type The type of access review item to retrieve summaries for
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **completed**: *eq, ne*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityAccessSummaries(id: string, type: GetIdentityAccessSummariesTypeEnum, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccessSummary>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityAccessSummaries(id, type, limit, offset, count, filters, sorters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationSummariesApi.getIdentityAccessSummaries']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API returns a summary of the decisions made on an identity campaign certification. The decisions are summarized by type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Summary of Certification Decisions
         * @param {string} id The certification ID
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **identitySummary.id**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityDecisionSummary(id: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityCertDecisionSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityDecisionSummary(id, filters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationSummariesApi.getIdentityDecisionSummary']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API returns a list of the identity summaries for a specific identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Identity Summaries for Campaign Certification
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **completed**: *eq, ne*  **name**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentitySummaries(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CertificationIdentitySummary>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentitySummaries(id, limit, offset, count, filters, sorters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationSummariesApi.getIdentitySummaries']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API returns the summary for an identity on a specified identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Summary for Identity
         * @param {string} id The identity campaign certification ID
         * @param {string} identitySummaryId The identity summary ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentitySummary(id: string, identitySummaryId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CertificationIdentitySummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentitySummary(id, identitySummaryId, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationSummariesApi.getIdentitySummary']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * CertificationSummariesApi - factory interface
 * @export
 */
export const CertificationSummariesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CertificationSummariesApiFp(configuration)
    return {
        /**
         * This API returns a list of access summaries for the specified identity campaign certification and type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Access Summaries
         * @param {CertificationSummariesApiGetIdentityAccessSummariesRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getIdentityAccessSummaries(requestParameters: CertificationSummariesApiGetIdentityAccessSummariesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AccessSummary>> {
            return localVarFp.getIdentityAccessSummaries(requestParameters.id, requestParameters.type, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, options).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a summary of the decisions made on an identity campaign certification. The decisions are summarized by type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Summary of Certification Decisions
         * @param {CertificationSummariesApiGetIdentityDecisionSummaryRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getIdentityDecisionSummary(requestParameters: CertificationSummariesApiGetIdentityDecisionSummaryRequest, options?: AxiosRequestConfig): AxiosPromise<IdentityCertDecisionSummary> {
            return localVarFp.getIdentityDecisionSummary(requestParameters.id, requestParameters.filters, options).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of the identity summaries for a specific identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Identity Summaries for Campaign Certification
         * @param {CertificationSummariesApiGetIdentitySummariesRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getIdentitySummaries(requestParameters: CertificationSummariesApiGetIdentitySummariesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<CertificationIdentitySummary>> {
            return localVarFp.getIdentitySummaries(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, options).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the summary for an identity on a specified identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Summary for Identity
         * @param {CertificationSummariesApiGetIdentitySummaryRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getIdentitySummary(requestParameters: CertificationSummariesApiGetIdentitySummaryRequest, options?: AxiosRequestConfig): AxiosPromise<CertificationIdentitySummary> {
            return localVarFp.getIdentitySummary(requestParameters.id, requestParameters.identitySummaryId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getIdentityAccessSummaries operation in CertificationSummariesApi.
 * @export
 * @interface CertificationSummariesApiGetIdentityAccessSummariesRequest
 */
export interface CertificationSummariesApiGetIdentityAccessSummariesRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly id: string

    /**
     * The type of access review item to retrieve summaries for
     * @type {'ROLE' | 'ACCESS_PROFILE' | 'ENTITLEMENT'}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly type: GetIdentityAccessSummariesTypeEnum

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **completed**: *eq, ne*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.name**
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly sorters?: string
}

/**
 * Request parameters for getIdentityDecisionSummary operation in CertificationSummariesApi.
 * @export
 * @interface CertificationSummariesApiGetIdentityDecisionSummaryRequest
 */
export interface CertificationSummariesApiGetIdentityDecisionSummaryRequest {
    /**
     * The certification ID
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentityDecisionSummary
     */
    readonly id: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **identitySummary.id**: *eq, in*
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentityDecisionSummary
     */
    readonly filters?: string
}

/**
 * Request parameters for getIdentitySummaries operation in CertificationSummariesApi.
 * @export
 * @interface CertificationSummariesApiGetIdentitySummariesRequest
 */
export interface CertificationSummariesApiGetIdentitySummariesRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentitySummaries
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationSummariesApiGetIdentitySummaries
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationSummariesApiGetIdentitySummaries
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationSummariesApiGetIdentitySummaries
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **completed**: *eq, ne*  **name**: *eq, sw*
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentitySummaries
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentitySummaries
     */
    readonly sorters?: string
}

/**
 * Request parameters for getIdentitySummary operation in CertificationSummariesApi.
 * @export
 * @interface CertificationSummariesApiGetIdentitySummaryRequest
 */
export interface CertificationSummariesApiGetIdentitySummaryRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentitySummary
     */
    readonly id: string

    /**
     * The identity summary ID
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentitySummary
     */
    readonly identitySummaryId: string
}

/**
 * CertificationSummariesApi - object-oriented interface
 * @export
 * @class CertificationSummariesApi
 * @extends {BaseAPI}
 */
export class CertificationSummariesApi extends BaseAPI {
    /**
     * This API returns a list of access summaries for the specified identity campaign certification and type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary Access Summaries
     * @param {CertificationSummariesApiGetIdentityAccessSummariesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationSummariesApi
     */
    public getIdentityAccessSummaries(requestParameters: CertificationSummariesApiGetIdentityAccessSummariesRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationSummariesApiFp(this.configuration).getIdentityAccessSummaries(requestParameters.id, requestParameters.type, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a summary of the decisions made on an identity campaign certification. The decisions are summarized by type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary Summary of Certification Decisions
     * @param {CertificationSummariesApiGetIdentityDecisionSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationSummariesApi
     */
    public getIdentityDecisionSummary(requestParameters: CertificationSummariesApiGetIdentityDecisionSummaryRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationSummariesApiFp(this.configuration).getIdentityDecisionSummary(requestParameters.id, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of the identity summaries for a specific identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary Identity Summaries for Campaign Certification
     * @param {CertificationSummariesApiGetIdentitySummariesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationSummariesApi
     */
    public getIdentitySummaries(requestParameters: CertificationSummariesApiGetIdentitySummariesRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationSummariesApiFp(this.configuration).getIdentitySummaries(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the summary for an identity on a specified identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary Summary for Identity
     * @param {CertificationSummariesApiGetIdentitySummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationSummariesApi
     */
    public getIdentitySummary(requestParameters: CertificationSummariesApiGetIdentitySummaryRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationSummariesApiFp(this.configuration).getIdentitySummary(requestParameters.id, requestParameters.identitySummaryId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetIdentityAccessSummariesTypeEnum = {
    Role: 'ROLE',
    AccessProfile: 'ACCESS_PROFILE',
    Entitlement: 'ENTITLEMENT'
} as const;
export type GetIdentityAccessSummariesTypeEnum = typeof GetIdentityAccessSummariesTypeEnum[keyof typeof GetIdentityAccessSummariesTypeEnum];


/**
 * CertificationsApi - axios parameter creator
 * @export
 */
export const CertificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API returns the certification task for the specified ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for the specified certification can also call this API.
         * @summary Certification Task by ID
         * @param {string} id The task ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCertificationTask: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCertificationTask', 'id', id)
            const localVarPath = `/certification-tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a single identity campaign certification by its ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Identity Certification by ID
         * @param {string} id The certification id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityCertification: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentityCertification', 'id', id)
            const localVarPath = `/certifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the permissions associated with an entitlement certification item based on the certification item\'s ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Permissions for Entitlement Certification Item
         * @param {string} certificationId The certification ID
         * @param {string} itemId The certification item ID
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **target**: *eq, sw*  **rights**: *ca*  Supported composite operators: *and, or*  All field values (second filter operands) are case-insensitive for this API.  Only a single *and* or *or* composite filter operator may be used. It must also be used between a target filter and a rights filter, not between 2 filters for the same field.  For example, the following is valid: &#x60;?filters&#x3D;rights+ca+(%22CREATE%22)+and+target+eq+%22SYS.OBJAUTH2%22&#x60;  The following is invalid: 1?filters&#x3D;rights+ca+(%22CREATE%22)+and+rights+ca+(%SELECT%22)1
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityCertificationItemPermissions: async (certificationId: string, itemId: string, filters?: string, limit?: number, offset?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'certificationId' is not null or undefined
            assertParamExists('getIdentityCertificationItemPermissions', 'certificationId', certificationId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getIdentityCertificationItemPermissions', 'itemId', itemId)
            const localVarPath = `/certifications/{certificationId}/access-review-items/{itemId}/permissions`
                .replace(`{${"certificationId"}}`, encodeURIComponent(String(certificationId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of pending (`QUEUED` or `IN_PROGRESS`) certification tasks. Any authenticated token can call this API, but only certification tasks you are authorized to review will be returned.
         * @summary List of Pending Certification Tasks
         * @param {string} [reviewerIdentity] The ID of reviewer identity. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **targetId**: *eq, in*  **type**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPendingCertificationTasks: async (reviewerIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/certification-tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (reviewerIdentity !== undefined) {
                localVarQueryParameter['reviewer-identity'] = reviewerIdentity;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of reviewers for the certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary List of Reviewers for certification
         * @param {string} id The certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **email**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCertificationReviewers: async (id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listCertificationReviewers', 'id', id)
            const localVarPath = `/certifications/{id}/reviewers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of access review items for an identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary List of Access Review Items
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **type**: *eq*  **access.type**: *eq*  **completed**: *eq, ne*  **identitySummary.id**: *eq, in*  **identitySummary.name**: *eq, sw*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **identitySummary.name, access.name, access.type, entitlement.sourceName, accessProfile.sourceName**
         * @param {string} [entitlements] Filter results to view access review items that pertain to any of the specified comma-separated entitlement IDs.  An error will occur if this param is used with **access-profiles** or **roles** as only one of these query params can be used at a time.
         * @param {string} [accessProfiles] Filter results to view access review items that pertain to any of the specified comma-separated access-profle IDs.  An error will occur if this param is used with **entitlements** or **roles** as only one of these query params can be used at a time.
         * @param {string} [roles] Filter results to view access review items that pertain to any of the specified comma-separated role IDs.  An error will occur if this param is used with **entitlements** or **access-profiles** as only one of these query params can be used at a time.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityAccessReviewItems: async (id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, entitlements?: string, accessProfiles?: string, roles?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listIdentityAccessReviewItems', 'id', id)
            const localVarPath = `/certifications/{id}/access-review-items`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (entitlements !== undefined) {
                localVarQueryParameter['entitlements'] = entitlements;
            }

            if (accessProfiles !== undefined) {
                localVarQueryParameter['access-profiles'] = accessProfiles;
            }

            if (roles !== undefined) {
                localVarQueryParameter['roles'] = roles;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of identity campaign certifications that satisfy the given query parameters. Any authenticated token can call this API, but only certifications you are authorized to review will be returned. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Identity Campaign Certifications by IDs
         * @param {string} [reviewerIdentity] The ID of reviewer identity. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **campaign.id**: *eq, in*  **phase**: *eq*  **completed**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, due, signed**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityCertifications: async (reviewerIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/certifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (reviewerIdentity !== undefined) {
                localVarQueryParameter['reviewer-identity'] = reviewerIdentity;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * The API makes a decision to approve or revoke one or more identity campaign certification items. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Decide on a Certification Item
         * @param {string} id The ID of the identity campaign certification on which to make decisions
         * @param {Array<ReviewDecision>} reviewDecision A non-empty array of decisions to be made.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        makeIdentityDecision: async (id: string, reviewDecision: Array<ReviewDecision>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('makeIdentityDecision', 'id', id)
            // verify required parameter 'reviewDecision' is not null or undefined
            assertParamExists('makeIdentityDecision', 'reviewDecision', reviewDecision)
            const localVarPath = `/certifications/{id}/decide`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reviewDecision, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API reassigns up to 50 identities or items in an identity campaign certification to another reviewer. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Reassign Identities or Items
         * @param {string} id The identity campaign certification ID
         * @param {ReviewReassign} reviewReassign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        reassignIdentityCertifications: async (id: string, reviewReassign: ReviewReassign, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reassignIdentityCertifications', 'id', id)
            // verify required parameter 'reviewReassign' is not null or undefined
            assertParamExists('reassignIdentityCertifications', 'reviewReassign', reviewReassign)
            const localVarPath = `/certifications/{id}/reassign`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reviewReassign, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API finalizes all decisions made on an identity campaign certification and initiates any remediations required. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Finalize Identity Certification Decisions
         * @param {string} id The identity campaign certification ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        signOffIdentityCertification: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('signOffIdentityCertification', 'id', id)
            const localVarPath = `/certifications/{id}/sign-off`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API initiates a task to reassign up to 500 identities or items in an identity campaign certification to another reviewer. The `certification-tasks` API can be used to get an updated status on the task and determine when the reassignment is complete. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Reassign Certifications Asynchronously
         * @param {string} id The identity campaign certification ID
         * @param {ReviewReassign} reviewReassign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        submitReassignCertsAsync: async (id: string, reviewReassign: ReviewReassign, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submitReassignCertsAsync', 'id', id)
            // verify required parameter 'reviewReassign' is not null or undefined
            assertParamExists('submitReassignCertsAsync', 'reviewReassign', reviewReassign)
            const localVarPath = `/certifications/{id}/reassign-async`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reviewReassign, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * CertificationsApi - functional programming interface
 * @export
 */
export const CertificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CertificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API returns the certification task for the specified ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for the specified certification can also call this API.
         * @summary Certification Task by ID
         * @param {string} id The task ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCertificationTask(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CertificationTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCertificationTask(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationsApi.getCertificationTask']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API returns a single identity campaign certification by its ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Identity Certification by ID
         * @param {string} id The certification id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityCertification(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityCertificationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityCertification(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationsApi.getIdentityCertification']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API returns the permissions associated with an entitlement certification item based on the certification item\'s ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Permissions for Entitlement Certification Item
         * @param {string} certificationId The certification ID
         * @param {string} itemId The certification item ID
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **target**: *eq, sw*  **rights**: *ca*  Supported composite operators: *and, or*  All field values (second filter operands) are case-insensitive for this API.  Only a single *and* or *or* composite filter operator may be used. It must also be used between a target filter and a rights filter, not between 2 filters for the same field.  For example, the following is valid: &#x60;?filters&#x3D;rights+ca+(%22CREATE%22)+and+target+eq+%22SYS.OBJAUTH2%22&#x60;  The following is invalid: 1?filters&#x3D;rights+ca+(%22CREATE%22)+and+rights+ca+(%SELECT%22)1
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityCertificationItemPermissions(certificationId: string, itemId: string, filters?: string, limit?: number, offset?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PermissionDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityCertificationItemPermissions(certificationId, itemId, filters, limit, offset, count, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationsApi.getIdentityCertificationItemPermissions']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API returns a list of pending (`QUEUED` or `IN_PROGRESS`) certification tasks. Any authenticated token can call this API, but only certification tasks you are authorized to review will be returned.
         * @summary List of Pending Certification Tasks
         * @param {string} [reviewerIdentity] The ID of reviewer identity. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **targetId**: *eq, in*  **type**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPendingCertificationTasks(reviewerIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CertificationTask>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPendingCertificationTasks(reviewerIdentity, limit, offset, count, filters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationsApi.getPendingCertificationTasks']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API returns a list of reviewers for the certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary List of Reviewers for certification
         * @param {string} id The certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **email**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listCertificationReviewers(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentityReferenceWithNameAndEmail>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCertificationReviewers(id, limit, offset, count, filters, sorters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationsApi.listCertificationReviewers']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API returns a list of access review items for an identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary List of Access Review Items
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **type**: *eq*  **access.type**: *eq*  **completed**: *eq, ne*  **identitySummary.id**: *eq, in*  **identitySummary.name**: *eq, sw*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **identitySummary.name, access.name, access.type, entitlement.sourceName, accessProfile.sourceName**
         * @param {string} [entitlements] Filter results to view access review items that pertain to any of the specified comma-separated entitlement IDs.  An error will occur if this param is used with **access-profiles** or **roles** as only one of these query params can be used at a time.
         * @param {string} [accessProfiles] Filter results to view access review items that pertain to any of the specified comma-separated access-profle IDs.  An error will occur if this param is used with **entitlements** or **roles** as only one of these query params can be used at a time.
         * @param {string} [roles] Filter results to view access review items that pertain to any of the specified comma-separated role IDs.  An error will occur if this param is used with **entitlements** or **access-profiles** as only one of these query params can be used at a time.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listIdentityAccessReviewItems(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, entitlements?: string, accessProfiles?: string, roles?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccessReviewItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdentityAccessReviewItems(id, limit, offset, count, filters, sorters, entitlements, accessProfiles, roles, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationsApi.listIdentityAccessReviewItems']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API returns a list of identity campaign certifications that satisfy the given query parameters. Any authenticated token can call this API, but only certifications you are authorized to review will be returned. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Identity Campaign Certifications by IDs
         * @param {string} [reviewerIdentity] The ID of reviewer identity. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **campaign.id**: *eq, in*  **phase**: *eq*  **completed**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, due, signed**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listIdentityCertifications(reviewerIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentityCertificationDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdentityCertifications(reviewerIdentity, limit, offset, count, filters, sorters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationsApi.listIdentityCertifications']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * The API makes a decision to approve or revoke one or more identity campaign certification items. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Decide on a Certification Item
         * @param {string} id The ID of the identity campaign certification on which to make decisions
         * @param {Array<ReviewDecision>} reviewDecision A non-empty array of decisions to be made.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async makeIdentityDecision(id: string, reviewDecision: Array<ReviewDecision>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityCertificationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.makeIdentityDecision(id, reviewDecision, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationsApi.makeIdentityDecision']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API reassigns up to 50 identities or items in an identity campaign certification to another reviewer. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Reassign Identities or Items
         * @param {string} id The identity campaign certification ID
         * @param {ReviewReassign} reviewReassign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async reassignIdentityCertifications(id: string, reviewReassign: ReviewReassign, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityCertificationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reassignIdentityCertifications(id, reviewReassign, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationsApi.reassignIdentityCertifications']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API finalizes all decisions made on an identity campaign certification and initiates any remediations required. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Finalize Identity Certification Decisions
         * @param {string} id The identity campaign certification ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async signOffIdentityCertification(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityCertificationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signOffIdentityCertification(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationsApi.signOffIdentityCertification']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API initiates a task to reassign up to 500 identities or items in an identity campaign certification to another reviewer. The `certification-tasks` API can be used to get an updated status on the task and determine when the reassignment is complete. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Reassign Certifications Asynchronously
         * @param {string} id The identity campaign certification ID
         * @param {ReviewReassign} reviewReassign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async submitReassignCertsAsync(id: string, reviewReassign: ReviewReassign, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CertificationTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitReassignCertsAsync(id, reviewReassign, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CertificationsApi.submitReassignCertsAsync']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * CertificationsApi - factory interface
 * @export
 */
export const CertificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CertificationsApiFp(configuration)
    return {
        /**
         * This API returns the certification task for the specified ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for the specified certification can also call this API.
         * @summary Certification Task by ID
         * @param {CertificationsApiGetCertificationTaskRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getCertificationTask(requestParameters: CertificationsApiGetCertificationTaskRequest, options?: AxiosRequestConfig): AxiosPromise<CertificationTask> {
            return localVarFp.getCertificationTask(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a single identity campaign certification by its ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Identity Certification by ID
         * @param {CertificationsApiGetIdentityCertificationRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getIdentityCertification(requestParameters: CertificationsApiGetIdentityCertificationRequest, options?: AxiosRequestConfig): AxiosPromise<IdentityCertificationDto> {
            return localVarFp.getIdentityCertification(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the permissions associated with an entitlement certification item based on the certification item\'s ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Permissions for Entitlement Certification Item
         * @param {CertificationsApiGetIdentityCertificationItemPermissionsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getIdentityCertificationItemPermissions(requestParameters: CertificationsApiGetIdentityCertificationItemPermissionsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<PermissionDto>> {
            return localVarFp.getIdentityCertificationItemPermissions(requestParameters.certificationId, requestParameters.itemId, requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.count, options).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of pending (`QUEUED` or `IN_PROGRESS`) certification tasks. Any authenticated token can call this API, but only certification tasks you are authorized to review will be returned.
         * @summary List of Pending Certification Tasks
         * @param {CertificationsApiGetPendingCertificationTasksRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getPendingCertificationTasks(requestParameters: CertificationsApiGetPendingCertificationTasksRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<CertificationTask>> {
            return localVarFp.getPendingCertificationTasks(requestParameters.reviewerIdentity, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, options).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of reviewers for the certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary List of Reviewers for certification
         * @param {CertificationsApiListCertificationReviewersRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listCertificationReviewers(requestParameters: CertificationsApiListCertificationReviewersRequest, options?: AxiosRequestConfig): AxiosPromise<Array<IdentityReferenceWithNameAndEmail>> {
            return localVarFp.listCertificationReviewers(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, options).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of access review items for an identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary List of Access Review Items
         * @param {CertificationsApiListIdentityAccessReviewItemsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listIdentityAccessReviewItems(requestParameters: CertificationsApiListIdentityAccessReviewItemsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AccessReviewItem>> {
            return localVarFp.listIdentityAccessReviewItems(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.entitlements, requestParameters.accessProfiles, requestParameters.roles, options).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of identity campaign certifications that satisfy the given query parameters. Any authenticated token can call this API, but only certifications you are authorized to review will be returned. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Identity Campaign Certifications by IDs
         * @param {CertificationsApiListIdentityCertificationsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listIdentityCertifications(requestParameters: CertificationsApiListIdentityCertificationsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<IdentityCertificationDto>> {
            return localVarFp.listIdentityCertifications(requestParameters.reviewerIdentity, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, options).then((request) => request(axios, basePath));
        },
        /**
         * The API makes a decision to approve or revoke one or more identity campaign certification items. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Decide on a Certification Item
         * @param {CertificationsApiMakeIdentityDecisionRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        makeIdentityDecision(requestParameters: CertificationsApiMakeIdentityDecisionRequest, options?: AxiosRequestConfig): AxiosPromise<IdentityCertificationDto> {
            return localVarFp.makeIdentityDecision(requestParameters.id, requestParameters.reviewDecision, options).then((request) => request(axios, basePath));
        },
        /**
         * This API reassigns up to 50 identities or items in an identity campaign certification to another reviewer. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Reassign Identities or Items
         * @param {CertificationsApiReassignIdentityCertificationsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        reassignIdentityCertifications(requestParameters: CertificationsApiReassignIdentityCertificationsRequest, options?: AxiosRequestConfig): AxiosPromise<IdentityCertificationDto> {
            return localVarFp.reassignIdentityCertifications(requestParameters.id, requestParameters.reviewReassign, options).then((request) => request(axios, basePath));
        },
        /**
         * This API finalizes all decisions made on an identity campaign certification and initiates any remediations required. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Finalize Identity Certification Decisions
         * @param {CertificationsApiSignOffIdentityCertificationRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        signOffIdentityCertification(requestParameters: CertificationsApiSignOffIdentityCertificationRequest, options?: AxiosRequestConfig): AxiosPromise<IdentityCertificationDto> {
            return localVarFp.signOffIdentityCertification(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This API initiates a task to reassign up to 500 identities or items in an identity campaign certification to another reviewer. The `certification-tasks` API can be used to get an updated status on the task and determine when the reassignment is complete. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Reassign Certifications Asynchronously
         * @param {CertificationsApiSubmitReassignCertsAsyncRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        submitReassignCertsAsync(requestParameters: CertificationsApiSubmitReassignCertsAsyncRequest, options?: AxiosRequestConfig): AxiosPromise<CertificationTask> {
            return localVarFp.submitReassignCertsAsync(requestParameters.id, requestParameters.reviewReassign, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getCertificationTask operation in CertificationsApi.
 * @export
 * @interface CertificationsApiGetCertificationTaskRequest
 */
export interface CertificationsApiGetCertificationTaskRequest {
    /**
     * The task ID
     * @type {string}
     * @memberof CertificationsApiGetCertificationTask
     */
    readonly id: string
}

/**
 * Request parameters for getIdentityCertification operation in CertificationsApi.
 * @export
 * @interface CertificationsApiGetIdentityCertificationRequest
 */
export interface CertificationsApiGetIdentityCertificationRequest {
    /**
     * The certification id
     * @type {string}
     * @memberof CertificationsApiGetIdentityCertification
     */
    readonly id: string
}

/**
 * Request parameters for getIdentityCertificationItemPermissions operation in CertificationsApi.
 * @export
 * @interface CertificationsApiGetIdentityCertificationItemPermissionsRequest
 */
export interface CertificationsApiGetIdentityCertificationItemPermissionsRequest {
    /**
     * The certification ID
     * @type {string}
     * @memberof CertificationsApiGetIdentityCertificationItemPermissions
     */
    readonly certificationId: string

    /**
     * The certification item ID
     * @type {string}
     * @memberof CertificationsApiGetIdentityCertificationItemPermissions
     */
    readonly itemId: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **target**: *eq, sw*  **rights**: *ca*  Supported composite operators: *and, or*  All field values (second filter operands) are case-insensitive for this API.  Only a single *and* or *or* composite filter operator may be used. It must also be used between a target filter and a rights filter, not between 2 filters for the same field.  For example, the following is valid: &#x60;?filters&#x3D;rights+ca+(%22CREATE%22)+and+target+eq+%22SYS.OBJAUTH2%22&#x60;  The following is invalid: 1?filters&#x3D;rights+ca+(%22CREATE%22)+and+rights+ca+(%SELECT%22)1
     * @type {string}
     * @memberof CertificationsApiGetIdentityCertificationItemPermissions
     */
    readonly filters?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiGetIdentityCertificationItemPermissions
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiGetIdentityCertificationItemPermissions
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationsApiGetIdentityCertificationItemPermissions
     */
    readonly count?: boolean
}

/**
 * Request parameters for getPendingCertificationTasks operation in CertificationsApi.
 * @export
 * @interface CertificationsApiGetPendingCertificationTasksRequest
 */
export interface CertificationsApiGetPendingCertificationTasksRequest {
    /**
     * The ID of reviewer identity. *me* indicates the current user.
     * @type {string}
     * @memberof CertificationsApiGetPendingCertificationTasks
     */
    readonly reviewerIdentity?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiGetPendingCertificationTasks
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiGetPendingCertificationTasks
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationsApiGetPendingCertificationTasks
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **targetId**: *eq, in*  **type**: *eq, in*
     * @type {string}
     * @memberof CertificationsApiGetPendingCertificationTasks
     */
    readonly filters?: string
}

/**
 * Request parameters for listCertificationReviewers operation in CertificationsApi.
 * @export
 * @interface CertificationsApiListCertificationReviewersRequest
 */
export interface CertificationsApiListCertificationReviewersRequest {
    /**
     * The certification ID
     * @type {string}
     * @memberof CertificationsApiListCertificationReviewers
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiListCertificationReviewers
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiListCertificationReviewers
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationsApiListCertificationReviewers
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **email**: *eq, sw*
     * @type {string}
     * @memberof CertificationsApiListCertificationReviewers
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, email**
     * @type {string}
     * @memberof CertificationsApiListCertificationReviewers
     */
    readonly sorters?: string
}

/**
 * Request parameters for listIdentityAccessReviewItems operation in CertificationsApi.
 * @export
 * @interface CertificationsApiListIdentityAccessReviewItemsRequest
 */
export interface CertificationsApiListIdentityAccessReviewItemsRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **type**: *eq*  **access.type**: *eq*  **completed**: *eq, ne*  **identitySummary.id**: *eq, in*  **identitySummary.name**: *eq, sw*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
     * @type {string}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **identitySummary.name, access.name, access.type, entitlement.sourceName, accessProfile.sourceName**
     * @type {string}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly sorters?: string

    /**
     * Filter results to view access review items that pertain to any of the specified comma-separated entitlement IDs.  An error will occur if this param is used with **access-profiles** or **roles** as only one of these query params can be used at a time.
     * @type {string}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly entitlements?: string

    /**
     * Filter results to view access review items that pertain to any of the specified comma-separated access-profle IDs.  An error will occur if this param is used with **entitlements** or **roles** as only one of these query params can be used at a time.
     * @type {string}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly accessProfiles?: string

    /**
     * Filter results to view access review items that pertain to any of the specified comma-separated role IDs.  An error will occur if this param is used with **entitlements** or **access-profiles** as only one of these query params can be used at a time.
     * @type {string}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly roles?: string
}

/**
 * Request parameters for listIdentityCertifications operation in CertificationsApi.
 * @export
 * @interface CertificationsApiListIdentityCertificationsRequest
 */
export interface CertificationsApiListIdentityCertificationsRequest {
    /**
     * The ID of reviewer identity. *me* indicates the current user.
     * @type {string}
     * @memberof CertificationsApiListIdentityCertifications
     */
    readonly reviewerIdentity?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiListIdentityCertifications
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiListIdentityCertifications
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationsApiListIdentityCertifications
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **campaign.id**: *eq, in*  **phase**: *eq*  **completed**: *eq, ne*
     * @type {string}
     * @memberof CertificationsApiListIdentityCertifications
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, due, signed**
     * @type {string}
     * @memberof CertificationsApiListIdentityCertifications
     */
    readonly sorters?: string
}

/**
 * Request parameters for makeIdentityDecision operation in CertificationsApi.
 * @export
 * @interface CertificationsApiMakeIdentityDecisionRequest
 */
export interface CertificationsApiMakeIdentityDecisionRequest {
    /**
     * The ID of the identity campaign certification on which to make decisions
     * @type {string}
     * @memberof CertificationsApiMakeIdentityDecision
     */
    readonly id: string

    /**
     * A non-empty array of decisions to be made.
     * @type {Array<ReviewDecision>}
     * @memberof CertificationsApiMakeIdentityDecision
     */
    readonly reviewDecision: Array<ReviewDecision>
}

/**
 * Request parameters for reassignIdentityCertifications operation in CertificationsApi.
 * @export
 * @interface CertificationsApiReassignIdentityCertificationsRequest
 */
export interface CertificationsApiReassignIdentityCertificationsRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationsApiReassignIdentityCertifications
     */
    readonly id: string

    /**
     * 
     * @type {ReviewReassign}
     * @memberof CertificationsApiReassignIdentityCertifications
     */
    readonly reviewReassign: ReviewReassign
}

/**
 * Request parameters for signOffIdentityCertification operation in CertificationsApi.
 * @export
 * @interface CertificationsApiSignOffIdentityCertificationRequest
 */
export interface CertificationsApiSignOffIdentityCertificationRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationsApiSignOffIdentityCertification
     */
    readonly id: string
}

/**
 * Request parameters for submitReassignCertsAsync operation in CertificationsApi.
 * @export
 * @interface CertificationsApiSubmitReassignCertsAsyncRequest
 */
export interface CertificationsApiSubmitReassignCertsAsyncRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationsApiSubmitReassignCertsAsync
     */
    readonly id: string

    /**
     * 
     * @type {ReviewReassign}
     * @memberof CertificationsApiSubmitReassignCertsAsync
     */
    readonly reviewReassign: ReviewReassign
}

/**
 * CertificationsApi - object-oriented interface
 * @export
 * @class CertificationsApi
 * @extends {BaseAPI}
 */
export class CertificationsApi extends BaseAPI {
    /**
     * This API returns the certification task for the specified ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for the specified certification can also call this API.
     * @summary Certification Task by ID
     * @param {CertificationsApiGetCertificationTaskRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public getCertificationTask(requestParameters: CertificationsApiGetCertificationTaskRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).getCertificationTask(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a single identity campaign certification by its ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
     * @summary Identity Certification by ID
     * @param {CertificationsApiGetIdentityCertificationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public getIdentityCertification(requestParameters: CertificationsApiGetIdentityCertificationRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).getIdentityCertification(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the permissions associated with an entitlement certification item based on the certification item\'s ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary Permissions for Entitlement Certification Item
     * @param {CertificationsApiGetIdentityCertificationItemPermissionsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public getIdentityCertificationItemPermissions(requestParameters: CertificationsApiGetIdentityCertificationItemPermissionsRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).getIdentityCertificationItemPermissions(requestParameters.certificationId, requestParameters.itemId, requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of pending (`QUEUED` or `IN_PROGRESS`) certification tasks. Any authenticated token can call this API, but only certification tasks you are authorized to review will be returned.
     * @summary List of Pending Certification Tasks
     * @param {CertificationsApiGetPendingCertificationTasksRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public getPendingCertificationTasks(requestParameters: CertificationsApiGetPendingCertificationTasksRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).getPendingCertificationTasks(requestParameters.reviewerIdentity, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of reviewers for the certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary List of Reviewers for certification
     * @param {CertificationsApiListCertificationReviewersRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public listCertificationReviewers(requestParameters: CertificationsApiListCertificationReviewersRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).listCertificationReviewers(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of access review items for an identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
     * @summary List of Access Review Items
     * @param {CertificationsApiListIdentityAccessReviewItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public listIdentityAccessReviewItems(requestParameters: CertificationsApiListIdentityAccessReviewItemsRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).listIdentityAccessReviewItems(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.entitlements, requestParameters.accessProfiles, requestParameters.roles, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of identity campaign certifications that satisfy the given query parameters. Any authenticated token can call this API, but only certifications you are authorized to review will be returned. This API does not support requests for certifications assigned to Governance Groups.
     * @summary Identity Campaign Certifications by IDs
     * @param {CertificationsApiListIdentityCertificationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public listIdentityCertifications(requestParameters: CertificationsApiListIdentityCertificationsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).listIdentityCertifications(requestParameters.reviewerIdentity, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The API makes a decision to approve or revoke one or more identity campaign certification items. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
     * @summary Decide on a Certification Item
     * @param {CertificationsApiMakeIdentityDecisionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public makeIdentityDecision(requestParameters: CertificationsApiMakeIdentityDecisionRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).makeIdentityDecision(requestParameters.id, requestParameters.reviewDecision, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API reassigns up to 50 identities or items in an identity campaign certification to another reviewer. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
     * @summary Reassign Identities or Items
     * @param {CertificationsApiReassignIdentityCertificationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public reassignIdentityCertifications(requestParameters: CertificationsApiReassignIdentityCertificationsRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).reassignIdentityCertifications(requestParameters.id, requestParameters.reviewReassign, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API finalizes all decisions made on an identity campaign certification and initiates any remediations required. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
     * @summary Finalize Identity Certification Decisions
     * @param {CertificationsApiSignOffIdentityCertificationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public signOffIdentityCertification(requestParameters: CertificationsApiSignOffIdentityCertificationRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).signOffIdentityCertification(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API initiates a task to reassign up to 500 identities or items in an identity campaign certification to another reviewer. The `certification-tasks` API can be used to get an updated status on the task and determine when the reassignment is complete. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary Reassign Certifications Asynchronously
     * @param {CertificationsApiSubmitReassignCertsAsyncRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public submitReassignCertsAsync(requestParameters: CertificationsApiSubmitReassignCertsAsyncRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).submitReassignCertsAsync(requestParameters.id, requestParameters.reviewReassign, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GlobalTenantSecuritySettingsApi - axios parameter creator
 * @export
 */
export const GlobalTenantSecuritySettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API returns the details of an org\'s network auth configuration. Requires security scope of: \'sp:auth-org:create\'
         * @summary Create security network configuration.
         * @param {NetworkConfiguration} networkConfiguration Network configuration creation request body.   The following constraints ensure the request body conforms to certain logical guidelines, which are:   1. Each string element in the range array must be a valid ip address or ip subnet mask.   2. Each string element in the geolocation array must be 2 characters, and they can only be uppercase letters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAuthOrgNetworkConfig: async (networkConfiguration: NetworkConfiguration, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkConfiguration' is not null or undefined
            assertParamExists('createAuthOrgNetworkConfig', 'networkConfiguration', networkConfiguration)
            const localVarPath = `/auth-org/network-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkConfiguration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the details of an org\'s network auth configuration. Requires security scope of: \'sp:auth-org:read\'
         * @summary Get security network configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAuthOrgNetworkConfig: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth-org/network-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates an existing network configuration for an org using PATCH  Requires security scope of:  \'sp:auth-org:update\'
         * @summary Update security network configuration.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth org network configuration update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Ensures that the patched Network Config conforms to certain logical guidelines, which are:   1. Each string element in the range array must be a valid ip address or ip subnet mask.   2. Each string element in the geolocation array must be 2 characters, and they can only be uppercase letters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthOrgNetworkConfig: async (jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchAuthOrgNetworkConfig', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/auth-org/network-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * GlobalTenantSecuritySettingsApi - functional programming interface
 * @export
 */
export const GlobalTenantSecuritySettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GlobalTenantSecuritySettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API returns the details of an org\'s network auth configuration. Requires security scope of: \'sp:auth-org:create\'
         * @summary Create security network configuration.
         * @param {NetworkConfiguration} networkConfiguration Network configuration creation request body.   The following constraints ensure the request body conforms to certain logical guidelines, which are:   1. Each string element in the range array must be a valid ip address or ip subnet mask.   2. Each string element in the geolocation array must be 2 characters, and they can only be uppercase letters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createAuthOrgNetworkConfig(networkConfiguration: NetworkConfiguration, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAuthOrgNetworkConfig(networkConfiguration, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GlobalTenantSecuritySettingsApi.createAuthOrgNetworkConfig']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API returns the details of an org\'s network auth configuration. Requires security scope of: \'sp:auth-org:read\'
         * @summary Get security network configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthOrgNetworkConfig(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthOrgNetworkConfig(axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GlobalTenantSecuritySettingsApi.getAuthOrgNetworkConfig']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API updates an existing network configuration for an org using PATCH  Requires security scope of:  \'sp:auth-org:update\'
         * @summary Update security network configuration.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth org network configuration update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Ensures that the patched Network Config conforms to certain logical guidelines, which are:   1. Each string element in the range array must be a valid ip address or ip subnet mask.   2. Each string element in the geolocation array must be 2 characters, and they can only be uppercase letters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchAuthOrgNetworkConfig(jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAuthOrgNetworkConfig(jsonPatchOperation, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GlobalTenantSecuritySettingsApi.patchAuthOrgNetworkConfig']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * GlobalTenantSecuritySettingsApi - factory interface
 * @export
 */
export const GlobalTenantSecuritySettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GlobalTenantSecuritySettingsApiFp(configuration)
    return {
        /**
         * This API returns the details of an org\'s network auth configuration. Requires security scope of: \'sp:auth-org:create\'
         * @summary Create security network configuration.
         * @param {GlobalTenantSecuritySettingsApiCreateAuthOrgNetworkConfigRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        createAuthOrgNetworkConfig(requestParameters: GlobalTenantSecuritySettingsApiCreateAuthOrgNetworkConfigRequest, options?: AxiosRequestConfig): AxiosPromise<NetworkConfiguration> {
            return localVarFp.createAuthOrgNetworkConfig(requestParameters.networkConfiguration, options).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the details of an org\'s network auth configuration. Requires security scope of: \'sp:auth-org:read\'
         * @summary Get security network configuration.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getAuthOrgNetworkConfig(options?: AxiosRequestConfig): AxiosPromise<NetworkConfiguration> {
            return localVarFp.getAuthOrgNetworkConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * This API updates an existing network configuration for an org using PATCH  Requires security scope of:  \'sp:auth-org:update\'
         * @summary Update security network configuration.
         * @param {GlobalTenantSecuritySettingsApiPatchAuthOrgNetworkConfigRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        patchAuthOrgNetworkConfig(requestParameters: GlobalTenantSecuritySettingsApiPatchAuthOrgNetworkConfigRequest, options?: AxiosRequestConfig): AxiosPromise<NetworkConfiguration> {
            return localVarFp.patchAuthOrgNetworkConfig(requestParameters.jsonPatchOperation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAuthOrgNetworkConfig operation in GlobalTenantSecuritySettingsApi.
 * @export
 * @interface GlobalTenantSecuritySettingsApiCreateAuthOrgNetworkConfigRequest
 */
export interface GlobalTenantSecuritySettingsApiCreateAuthOrgNetworkConfigRequest {
    /**
     * Network configuration creation request body.   The following constraints ensure the request body conforms to certain logical guidelines, which are:   1. Each string element in the range array must be a valid ip address or ip subnet mask.   2. Each string element in the geolocation array must be 2 characters, and they can only be uppercase letters.
     * @type {NetworkConfiguration}
     * @memberof GlobalTenantSecuritySettingsApiCreateAuthOrgNetworkConfig
     */
    readonly networkConfiguration: NetworkConfiguration
}

/**
 * Request parameters for patchAuthOrgNetworkConfig operation in GlobalTenantSecuritySettingsApi.
 * @export
 * @interface GlobalTenantSecuritySettingsApiPatchAuthOrgNetworkConfigRequest
 */
export interface GlobalTenantSecuritySettingsApiPatchAuthOrgNetworkConfigRequest {
    /**
     * A list of auth org network configuration update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Ensures that the patched Network Config conforms to certain logical guidelines, which are:   1. Each string element in the range array must be a valid ip address or ip subnet mask.   2. Each string element in the geolocation array must be 2 characters, and they can only be uppercase letters.
     * @type {Array<JsonPatchOperation>}
     * @memberof GlobalTenantSecuritySettingsApiPatchAuthOrgNetworkConfig
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * GlobalTenantSecuritySettingsApi - object-oriented interface
 * @export
 * @class GlobalTenantSecuritySettingsApi
 * @extends {BaseAPI}
 */
export class GlobalTenantSecuritySettingsApi extends BaseAPI {
    /**
     * This API returns the details of an org\'s network auth configuration. Requires security scope of: \'sp:auth-org:create\'
     * @summary Create security network configuration.
     * @param {GlobalTenantSecuritySettingsApiCreateAuthOrgNetworkConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalTenantSecuritySettingsApi
     */
    public createAuthOrgNetworkConfig(requestParameters: GlobalTenantSecuritySettingsApiCreateAuthOrgNetworkConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return GlobalTenantSecuritySettingsApiFp(this.configuration).createAuthOrgNetworkConfig(requestParameters.networkConfiguration, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the details of an org\'s network auth configuration. Requires security scope of: \'sp:auth-org:read\'
     * @summary Get security network configuration.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalTenantSecuritySettingsApi
     */
    public getAuthOrgNetworkConfig(axiosOptions?: AxiosRequestConfig) {
        return GlobalTenantSecuritySettingsApiFp(this.configuration).getAuthOrgNetworkConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates an existing network configuration for an org using PATCH  Requires security scope of:  \'sp:auth-org:update\'
     * @summary Update security network configuration.
     * @param {GlobalTenantSecuritySettingsApiPatchAuthOrgNetworkConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalTenantSecuritySettingsApi
     */
    public patchAuthOrgNetworkConfig(requestParameters: GlobalTenantSecuritySettingsApiPatchAuthOrgNetworkConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return GlobalTenantSecuritySettingsApiFp(this.configuration).patchAuthOrgNetworkConfig(requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IdentityProfilesApi - axios parameter creator
 * @export
 */
export const IdentityProfilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This deletes an Identity Profile based on ID.  On success, this endpoint will return a reference to the bulk delete task result.  A token with ORG_ADMIN authority is required to call this API.  The following rights are required to access this endpoint: idn:identity-profile:delete
         * @summary Delete an Identity Profile
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityProfile: async (identityProfileId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('deleteIdentityProfile', 'identityProfileId', identityProfileId)
            const localVarPath = `/identity-profiles/{identity-profile-id}`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This deletes multiple Identity Profiles via a list of supplied IDs.  On success, this endpoint will return a reference to the bulk delete task result.  A token with ORG_ADMIN authority is required to call this API.  The following rights are required to access this endpoint: idn:identity-profile:delete
         * @summary Delete Identity Profiles
         * @param {Array<string>} requestBody Identity Profile bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityProfiles: async (requestBody: Array<string>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('deleteIdentityProfiles', 'requestBody', requestBody)
            const localVarPath = `/identity-profiles/bulk-delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This exports existing identity profiles in the format specified by the sp-config service.
         * @summary Export Identity Profiles
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, priority**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportIdentityProfiles: async (limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identity-profiles/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This returns the default identity attribute config. A token with ORG_ADMIN authority is required to call this API to get the default identity attribute config.
         * @summary Get default Identity Attribute Config
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultIdentityAttributeConfig: async (identityProfileId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('getDefaultIdentityAttributeConfig', 'identityProfileId', identityProfileId)
            const localVarPath = `/identity-profiles/{identity-profile-id}/default-identity-attribute-config`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This returns a single Identity Profile based on ID. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get single Identity Profile
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityProfile: async (identityProfileId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('getIdentityProfile', 'identityProfileId', identityProfileId)
            const localVarPath = `/identity-profiles/{identity-profile-id}`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This imports previously exported identity profiles.
         * @summary Import Identity Profiles
         * @param {Array<IdentityProfileExportedObject>} identityProfileExportedObject Previously exported Identity Profiles.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importIdentityProfiles: async (identityProfileExportedObject: Array<IdentityProfileExportedObject>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileExportedObject' is not null or undefined
            assertParamExists('importIdentityProfiles', 'identityProfileExportedObject', identityProfileExportedObject)
            const localVarPath = `/identity-profiles/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityProfileExportedObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This returns a list of Identity Profiles based on the specified query parameters. A token with ORG_ADMIN or API authority is required to call this API to get a list of Identity Profiles.
         * @summary Identity Profiles List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne, ge, gt, in, le, lt, isnull, sw*  **name**: *eq, ne, in, le, lt, isnull, sw*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, priority, created, modified, owner.id, owner.name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityProfiles: async (limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identity-profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Process identities under the profile  A token with ORG_ADMIN authority is required to call this API.
         * @summary Process identities under profile
         * @param {string} identityProfileId The Identity Profile ID to be processed
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        syncIdentityProfile: async (identityProfileId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('syncIdentityProfile', 'identityProfileId', identityProfileId)
            const localVarPath = `/identity-profiles/{identity-profile-id}/process-identities`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdentityProfilesApi - functional programming interface
 * @export
 */
export const IdentityProfilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdentityProfilesApiAxiosParamCreator(configuration)
    return {
        /**
         * This deletes an Identity Profile based on ID.  On success, this endpoint will return a reference to the bulk delete task result.  A token with ORG_ADMIN authority is required to call this API.  The following rights are required to access this endpoint: idn:identity-profile:delete
         * @summary Delete an Identity Profile
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIdentityProfile(identityProfileId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResultSimplified>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIdentityProfile(identityProfileId, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['IdentityProfilesApi.deleteIdentityProfile']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This deletes multiple Identity Profiles via a list of supplied IDs.  On success, this endpoint will return a reference to the bulk delete task result.  A token with ORG_ADMIN authority is required to call this API.  The following rights are required to access this endpoint: idn:identity-profile:delete
         * @summary Delete Identity Profiles
         * @param {Array<string>} requestBody Identity Profile bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIdentityProfiles(requestBody: Array<string>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResultSimplified>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIdentityProfiles(requestBody, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['IdentityProfilesApi.deleteIdentityProfiles']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This exports existing identity profiles in the format specified by the sp-config service.
         * @summary Export Identity Profiles
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, priority**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async exportIdentityProfiles(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentityProfileExportedObject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportIdentityProfiles(limit, offset, count, filters, sorters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['IdentityProfilesApi.exportIdentityProfiles']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This returns the default identity attribute config. A token with ORG_ADMIN authority is required to call this API to get the default identity attribute config.
         * @summary Get default Identity Attribute Config
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultIdentityAttributeConfig(identityProfileId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityAttributeConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultIdentityAttributeConfig(identityProfileId, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['IdentityProfilesApi.getDefaultIdentityAttributeConfig']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This returns a single Identity Profile based on ID. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get single Identity Profile
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityProfile(identityProfileId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityProfile(identityProfileId, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['IdentityProfilesApi.getIdentityProfile']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This imports previously exported identity profiles.
         * @summary Import Identity Profiles
         * @param {Array<IdentityProfileExportedObject>} identityProfileExportedObject Previously exported Identity Profiles.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async importIdentityProfiles(identityProfileExportedObject: Array<IdentityProfileExportedObject>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectImportResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importIdentityProfiles(identityProfileExportedObject, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['IdentityProfilesApi.importIdentityProfiles']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This returns a list of Identity Profiles based on the specified query parameters. A token with ORG_ADMIN or API authority is required to call this API to get a list of Identity Profiles.
         * @summary Identity Profiles List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne, ge, gt, in, le, lt, isnull, sw*  **name**: *eq, ne, in, le, lt, isnull, sw*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, priority, created, modified, owner.id, owner.name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listIdentityProfiles(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentityProfile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdentityProfiles(limit, offset, count, filters, sorters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['IdentityProfilesApi.listIdentityProfiles']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Process identities under the profile  A token with ORG_ADMIN authority is required to call this API.
         * @summary Process identities under profile
         * @param {string} identityProfileId The Identity Profile ID to be processed
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async syncIdentityProfile(identityProfileId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncIdentityProfile(identityProfileId, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['IdentityProfilesApi.syncIdentityProfile']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * IdentityProfilesApi - factory interface
 * @export
 */
export const IdentityProfilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdentityProfilesApiFp(configuration)
    return {
        /**
         * This deletes an Identity Profile based on ID.  On success, this endpoint will return a reference to the bulk delete task result.  A token with ORG_ADMIN authority is required to call this API.  The following rights are required to access this endpoint: idn:identity-profile:delete
         * @summary Delete an Identity Profile
         * @param {IdentityProfilesApiDeleteIdentityProfileRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteIdentityProfile(requestParameters: IdentityProfilesApiDeleteIdentityProfileRequest, options?: AxiosRequestConfig): AxiosPromise<TaskResultSimplified> {
            return localVarFp.deleteIdentityProfile(requestParameters.identityProfileId, options).then((request) => request(axios, basePath));
        },
        /**
         * This deletes multiple Identity Profiles via a list of supplied IDs.  On success, this endpoint will return a reference to the bulk delete task result.  A token with ORG_ADMIN authority is required to call this API.  The following rights are required to access this endpoint: idn:identity-profile:delete
         * @summary Delete Identity Profiles
         * @param {IdentityProfilesApiDeleteIdentityProfilesRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteIdentityProfiles(requestParameters: IdentityProfilesApiDeleteIdentityProfilesRequest, options?: AxiosRequestConfig): AxiosPromise<TaskResultSimplified> {
            return localVarFp.deleteIdentityProfiles(requestParameters.requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * This exports existing identity profiles in the format specified by the sp-config service.
         * @summary Export Identity Profiles
         * @param {IdentityProfilesApiExportIdentityProfilesRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        exportIdentityProfiles(requestParameters: IdentityProfilesApiExportIdentityProfilesRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<IdentityProfileExportedObject>> {
            return localVarFp.exportIdentityProfiles(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, options).then((request) => request(axios, basePath));
        },
        /**
         * This returns the default identity attribute config. A token with ORG_ADMIN authority is required to call this API to get the default identity attribute config.
         * @summary Get default Identity Attribute Config
         * @param {IdentityProfilesApiGetDefaultIdentityAttributeConfigRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getDefaultIdentityAttributeConfig(requestParameters: IdentityProfilesApiGetDefaultIdentityAttributeConfigRequest, options?: AxiosRequestConfig): AxiosPromise<IdentityAttributeConfig> {
            return localVarFp.getDefaultIdentityAttributeConfig(requestParameters.identityProfileId, options).then((request) => request(axios, basePath));
        },
        /**
         * This returns a single Identity Profile based on ID. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get single Identity Profile
         * @param {IdentityProfilesApiGetIdentityProfileRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getIdentityProfile(requestParameters: IdentityProfilesApiGetIdentityProfileRequest, options?: AxiosRequestConfig): AxiosPromise<IdentityProfile> {
            return localVarFp.getIdentityProfile(requestParameters.identityProfileId, options).then((request) => request(axios, basePath));
        },
        /**
         * This imports previously exported identity profiles.
         * @summary Import Identity Profiles
         * @param {IdentityProfilesApiImportIdentityProfilesRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        importIdentityProfiles(requestParameters: IdentityProfilesApiImportIdentityProfilesRequest, options?: AxiosRequestConfig): AxiosPromise<ObjectImportResult> {
            return localVarFp.importIdentityProfiles(requestParameters.identityProfileExportedObject, options).then((request) => request(axios, basePath));
        },
        /**
         * This returns a list of Identity Profiles based on the specified query parameters. A token with ORG_ADMIN or API authority is required to call this API to get a list of Identity Profiles.
         * @summary Identity Profiles List
         * @param {IdentityProfilesApiListIdentityProfilesRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listIdentityProfiles(requestParameters: IdentityProfilesApiListIdentityProfilesRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<IdentityProfile>> {
            return localVarFp.listIdentityProfiles(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, options).then((request) => request(axios, basePath));
        },
        /**
         * Process identities under the profile  A token with ORG_ADMIN authority is required to call this API.
         * @summary Process identities under profile
         * @param {IdentityProfilesApiSyncIdentityProfileRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        syncIdentityProfile(requestParameters: IdentityProfilesApiSyncIdentityProfileRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.syncIdentityProfile(requestParameters.identityProfileId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteIdentityProfile operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiDeleteIdentityProfileRequest
 */
export interface IdentityProfilesApiDeleteIdentityProfileRequest {
    /**
     * The Identity Profile ID.
     * @type {string}
     * @memberof IdentityProfilesApiDeleteIdentityProfile
     */
    readonly identityProfileId: string
}

/**
 * Request parameters for deleteIdentityProfiles operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiDeleteIdentityProfilesRequest
 */
export interface IdentityProfilesApiDeleteIdentityProfilesRequest {
    /**
     * Identity Profile bulk delete request body.
     * @type {Array<string>}
     * @memberof IdentityProfilesApiDeleteIdentityProfiles
     */
    readonly requestBody: Array<string>
}

/**
 * Request parameters for exportIdentityProfiles operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiExportIdentityProfilesRequest
 */
export interface IdentityProfilesApiExportIdentityProfilesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityProfilesApiExportIdentityProfiles
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityProfilesApiExportIdentityProfiles
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IdentityProfilesApiExportIdentityProfiles
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
     * @type {string}
     * @memberof IdentityProfilesApiExportIdentityProfiles
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, priority**
     * @type {string}
     * @memberof IdentityProfilesApiExportIdentityProfiles
     */
    readonly sorters?: string
}

/**
 * Request parameters for getDefaultIdentityAttributeConfig operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiGetDefaultIdentityAttributeConfigRequest
 */
export interface IdentityProfilesApiGetDefaultIdentityAttributeConfigRequest {
    /**
     * The Identity Profile ID.
     * @type {string}
     * @memberof IdentityProfilesApiGetDefaultIdentityAttributeConfig
     */
    readonly identityProfileId: string
}

/**
 * Request parameters for getIdentityProfile operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiGetIdentityProfileRequest
 */
export interface IdentityProfilesApiGetIdentityProfileRequest {
    /**
     * The Identity Profile ID.
     * @type {string}
     * @memberof IdentityProfilesApiGetIdentityProfile
     */
    readonly identityProfileId: string
}

/**
 * Request parameters for importIdentityProfiles operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiImportIdentityProfilesRequest
 */
export interface IdentityProfilesApiImportIdentityProfilesRequest {
    /**
     * Previously exported Identity Profiles.
     * @type {Array<IdentityProfileExportedObject>}
     * @memberof IdentityProfilesApiImportIdentityProfiles
     */
    readonly identityProfileExportedObject: Array<IdentityProfileExportedObject>
}

/**
 * Request parameters for listIdentityProfiles operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiListIdentityProfilesRequest
 */
export interface IdentityProfilesApiListIdentityProfilesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityProfilesApiListIdentityProfiles
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityProfilesApiListIdentityProfiles
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IdentityProfilesApiListIdentityProfiles
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne, ge, gt, in, le, lt, isnull, sw*  **name**: *eq, ne, in, le, lt, isnull, sw*  **priority**: *eq, ne*
     * @type {string}
     * @memberof IdentityProfilesApiListIdentityProfiles
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, priority, created, modified, owner.id, owner.name**
     * @type {string}
     * @memberof IdentityProfilesApiListIdentityProfiles
     */
    readonly sorters?: string
}

/**
 * Request parameters for syncIdentityProfile operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiSyncIdentityProfileRequest
 */
export interface IdentityProfilesApiSyncIdentityProfileRequest {
    /**
     * The Identity Profile ID to be processed
     * @type {string}
     * @memberof IdentityProfilesApiSyncIdentityProfile
     */
    readonly identityProfileId: string
}

/**
 * IdentityProfilesApi - object-oriented interface
 * @export
 * @class IdentityProfilesApi
 * @extends {BaseAPI}
 */
export class IdentityProfilesApi extends BaseAPI {
    /**
     * This deletes an Identity Profile based on ID.  On success, this endpoint will return a reference to the bulk delete task result.  A token with ORG_ADMIN authority is required to call this API.  The following rights are required to access this endpoint: idn:identity-profile:delete
     * @summary Delete an Identity Profile
     * @param {IdentityProfilesApiDeleteIdentityProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public deleteIdentityProfile(requestParameters: IdentityProfilesApiDeleteIdentityProfileRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).deleteIdentityProfile(requestParameters.identityProfileId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes multiple Identity Profiles via a list of supplied IDs.  On success, this endpoint will return a reference to the bulk delete task result.  A token with ORG_ADMIN authority is required to call this API.  The following rights are required to access this endpoint: idn:identity-profile:delete
     * @summary Delete Identity Profiles
     * @param {IdentityProfilesApiDeleteIdentityProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public deleteIdentityProfiles(requestParameters: IdentityProfilesApiDeleteIdentityProfilesRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).deleteIdentityProfiles(requestParameters.requestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This exports existing identity profiles in the format specified by the sp-config service.
     * @summary Export Identity Profiles
     * @param {IdentityProfilesApiExportIdentityProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public exportIdentityProfiles(requestParameters: IdentityProfilesApiExportIdentityProfilesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).exportIdentityProfiles(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns the default identity attribute config. A token with ORG_ADMIN authority is required to call this API to get the default identity attribute config.
     * @summary Get default Identity Attribute Config
     * @param {IdentityProfilesApiGetDefaultIdentityAttributeConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public getDefaultIdentityAttributeConfig(requestParameters: IdentityProfilesApiGetDefaultIdentityAttributeConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).getDefaultIdentityAttributeConfig(requestParameters.identityProfileId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns a single Identity Profile based on ID. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Get single Identity Profile
     * @param {IdentityProfilesApiGetIdentityProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public getIdentityProfile(requestParameters: IdentityProfilesApiGetIdentityProfileRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).getIdentityProfile(requestParameters.identityProfileId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This imports previously exported identity profiles.
     * @summary Import Identity Profiles
     * @param {IdentityProfilesApiImportIdentityProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public importIdentityProfiles(requestParameters: IdentityProfilesApiImportIdentityProfilesRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).importIdentityProfiles(requestParameters.identityProfileExportedObject, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns a list of Identity Profiles based on the specified query parameters. A token with ORG_ADMIN or API authority is required to call this API to get a list of Identity Profiles.
     * @summary Identity Profiles List
     * @param {IdentityProfilesApiListIdentityProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public listIdentityProfiles(requestParameters: IdentityProfilesApiListIdentityProfilesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).listIdentityProfiles(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Process identities under the profile  A token with ORG_ADMIN authority is required to call this API.
     * @summary Process identities under profile
     * @param {IdentityProfilesApiSyncIdentityProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public syncIdentityProfile(requestParameters: IdentityProfilesApiSyncIdentityProfileRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).syncIdentityProfile(requestParameters.identityProfileId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LifecycleStatesApi - axios parameter creator
 * @export
 */
export const LifecycleStatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates a new Lifecycle State. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Create Lifecycle State
         * @param {string} identityProfileId Identity Profile ID
         * @param {LifecycleState} lifecycleState Lifecycle State
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createLifecycleState: async (identityProfileId: string, lifecycleState: LifecycleState, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('createLifecycleState', 'identityProfileId', identityProfileId)
            // verify required parameter 'lifecycleState' is not null or undefined
            assertParamExists('createLifecycleState', 'lifecycleState', lifecycleState)
            const localVarPath = `/identity-profiles/{identity-profile-id}/lifecycle-states`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lifecycleState, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint deletes the Lifecycle State using its ID. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Lifecycle State by ID
         * @param {string} identityProfileId Identity Profile ID
         * @param {string} lifecycleStateId Lifecycle State ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteLifecycleState: async (identityProfileId: string, lifecycleStateId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('deleteLifecycleState', 'identityProfileId', identityProfileId)
            // verify required parameter 'lifecycleStateId' is not null or undefined
            assertParamExists('deleteLifecycleState', 'lifecycleStateId', lifecycleStateId)
            const localVarPath = `/identity-profiles/{identity-profile-id}/lifecycle-states/{lifecycle-state-id}`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)))
                .replace(`{${"lifecycle-state-id"}}`, encodeURIComponent(String(lifecycleStateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves a Lifecycle State. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Retrieves Lifecycle State
         * @param {string} identityProfileId Identity Profile ID
         * @param {string} lifecycleStateId Lifecycle State ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLifecycleState: async (identityProfileId: string, lifecycleStateId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('getLifecycleState', 'identityProfileId', identityProfileId)
            // verify required parameter 'lifecycleStateId' is not null or undefined
            assertParamExists('getLifecycleState', 'lifecycleStateId', lifecycleStateId)
            const localVarPath = `/identity-profiles/{identity-profile-id}/lifecycle-states/{lifecycle-state-id}`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)))
                .replace(`{${"lifecycle-state-id"}}`, encodeURIComponent(String(lifecycleStateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point lists all the LifecycleStates associated with IdentityProfiles. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists LifecycleStates
         * @param {string} identityProfileId The IdentityProfile id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listLifecycleStates: async (identityProfileId: string, limit?: number, offset?: number, count?: boolean, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('listLifecycleStates', 'identityProfileId', identityProfileId)
            const localVarPath = `/identity-profiles/{identity-profile-id}/lifecycle-states`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will set/update an identity\'s lifecycle state to the one provided and updates the corresponding Identity Profile. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Set Lifecycle State
         * @param {string} identityId The ID of the identity to update
         * @param {SetLifecycleStateRequest} setLifecycleStateRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setLifecycleState: async (identityId: string, setLifecycleStateRequest: SetLifecycleStateRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('setLifecycleState', 'identityId', identityId)
            // verify required parameter 'setLifecycleStateRequest' is not null or undefined
            assertParamExists('setLifecycleState', 'setLifecycleStateRequest', setLifecycleStateRequest)
            const localVarPath = `/identities/{identity-id}/set-lifecycle-state`
                .replace(`{${"identity-id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setLifecycleStateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint updates individual Lifecycle State fields using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Update Lifecycle State
         * @param {string} identityProfileId Identity Profile ID
         * @param {string} lifecycleStateId Lifecycle State ID
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of lifecycle state update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields can be updated: * enabled * description * accountActions * accessProfileIds * emailNotificationOption 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateLifecycleStates: async (identityProfileId: string, lifecycleStateId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('updateLifecycleStates', 'identityProfileId', identityProfileId)
            // verify required parameter 'lifecycleStateId' is not null or undefined
            assertParamExists('updateLifecycleStates', 'lifecycleStateId', lifecycleStateId)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateLifecycleStates', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/identity-profiles/{identity-profile-id}/lifecycle-states/{lifecycle-state-id}`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)))
                .replace(`{${"lifecycle-state-id"}}`, encodeURIComponent(String(lifecycleStateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * LifecycleStatesApi - functional programming interface
 * @export
 */
export const LifecycleStatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LifecycleStatesApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates a new Lifecycle State. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Create Lifecycle State
         * @param {string} identityProfileId Identity Profile ID
         * @param {LifecycleState} lifecycleState Lifecycle State
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createLifecycleState(identityProfileId: string, lifecycleState: LifecycleState, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifecycleState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLifecycleState(identityProfileId, lifecycleState, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LifecycleStatesApi.createLifecycleState']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint deletes the Lifecycle State using its ID. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Lifecycle State by ID
         * @param {string} identityProfileId Identity Profile ID
         * @param {string} lifecycleStateId Lifecycle State ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLifecycleState(identityProfileId: string, lifecycleStateId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifecyclestateDeleted>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLifecycleState(identityProfileId, lifecycleStateId, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LifecycleStatesApi.deleteLifecycleState']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint retrieves a Lifecycle State. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Retrieves Lifecycle State
         * @param {string} identityProfileId Identity Profile ID
         * @param {string} lifecycleStateId Lifecycle State ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getLifecycleState(identityProfileId: string, lifecycleStateId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifecycleState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLifecycleState(identityProfileId, lifecycleStateId, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LifecycleStatesApi.getLifecycleState']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This end-point lists all the LifecycleStates associated with IdentityProfiles. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists LifecycleStates
         * @param {string} identityProfileId The IdentityProfile id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listLifecycleStates(identityProfileId: string, limit?: number, offset?: number, count?: boolean, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifecycleState>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLifecycleStates(identityProfileId, limit, offset, count, sorters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LifecycleStatesApi.listLifecycleStates']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint will set/update an identity\'s lifecycle state to the one provided and updates the corresponding Identity Profile. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Set Lifecycle State
         * @param {string} identityId The ID of the identity to update
         * @param {SetLifecycleStateRequest} setLifecycleStateRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setLifecycleState(identityId: string, setLifecycleStateRequest: SetLifecycleStateRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetLifecycleState200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setLifecycleState(identityId, setLifecycleStateRequest, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LifecycleStatesApi.setLifecycleState']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint updates individual Lifecycle State fields using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Update Lifecycle State
         * @param {string} identityProfileId Identity Profile ID
         * @param {string} lifecycleStateId Lifecycle State ID
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of lifecycle state update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields can be updated: * enabled * description * accountActions * accessProfileIds * emailNotificationOption 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateLifecycleStates(identityProfileId: string, lifecycleStateId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifecycleState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLifecycleStates(identityProfileId, lifecycleStateId, jsonPatchOperation, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LifecycleStatesApi.updateLifecycleStates']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * LifecycleStatesApi - factory interface
 * @export
 */
export const LifecycleStatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LifecycleStatesApiFp(configuration)
    return {
        /**
         * This API creates a new Lifecycle State. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Create Lifecycle State
         * @param {LifecycleStatesApiCreateLifecycleStateRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        createLifecycleState(requestParameters: LifecycleStatesApiCreateLifecycleStateRequest, options?: AxiosRequestConfig): AxiosPromise<LifecycleState> {
            return localVarFp.createLifecycleState(requestParameters.identityProfileId, requestParameters.lifecycleState, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint deletes the Lifecycle State using its ID. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Lifecycle State by ID
         * @param {LifecycleStatesApiDeleteLifecycleStateRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteLifecycleState(requestParameters: LifecycleStatesApiDeleteLifecycleStateRequest, options?: AxiosRequestConfig): AxiosPromise<LifecyclestateDeleted> {
            return localVarFp.deleteLifecycleState(requestParameters.identityProfileId, requestParameters.lifecycleStateId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves a Lifecycle State. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Retrieves Lifecycle State
         * @param {LifecycleStatesApiGetLifecycleStateRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getLifecycleState(requestParameters: LifecycleStatesApiGetLifecycleStateRequest, options?: AxiosRequestConfig): AxiosPromise<LifecycleState> {
            return localVarFp.getLifecycleState(requestParameters.identityProfileId, requestParameters.lifecycleStateId, options).then((request) => request(axios, basePath));
        },
        /**
         * This end-point lists all the LifecycleStates associated with IdentityProfiles. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists LifecycleStates
         * @param {LifecycleStatesApiListLifecycleStatesRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listLifecycleStates(requestParameters: LifecycleStatesApiListLifecycleStatesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<LifecycleState>> {
            return localVarFp.listLifecycleStates(requestParameters.identityProfileId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will set/update an identity\'s lifecycle state to the one provided and updates the corresponding Identity Profile. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Set Lifecycle State
         * @param {LifecycleStatesApiSetLifecycleStateRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        setLifecycleState(requestParameters: LifecycleStatesApiSetLifecycleStateRequest, options?: AxiosRequestConfig): AxiosPromise<SetLifecycleState200Response> {
            return localVarFp.setLifecycleState(requestParameters.identityId, requestParameters.setLifecycleStateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint updates individual Lifecycle State fields using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Update Lifecycle State
         * @param {LifecycleStatesApiUpdateLifecycleStatesRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        updateLifecycleStates(requestParameters: LifecycleStatesApiUpdateLifecycleStatesRequest, options?: AxiosRequestConfig): AxiosPromise<LifecycleState> {
            return localVarFp.updateLifecycleStates(requestParameters.identityProfileId, requestParameters.lifecycleStateId, requestParameters.jsonPatchOperation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createLifecycleState operation in LifecycleStatesApi.
 * @export
 * @interface LifecycleStatesApiCreateLifecycleStateRequest
 */
export interface LifecycleStatesApiCreateLifecycleStateRequest {
    /**
     * Identity Profile ID
     * @type {string}
     * @memberof LifecycleStatesApiCreateLifecycleState
     */
    readonly identityProfileId: string

    /**
     * Lifecycle State
     * @type {LifecycleState}
     * @memberof LifecycleStatesApiCreateLifecycleState
     */
    readonly lifecycleState: LifecycleState
}

/**
 * Request parameters for deleteLifecycleState operation in LifecycleStatesApi.
 * @export
 * @interface LifecycleStatesApiDeleteLifecycleStateRequest
 */
export interface LifecycleStatesApiDeleteLifecycleStateRequest {
    /**
     * Identity Profile ID
     * @type {string}
     * @memberof LifecycleStatesApiDeleteLifecycleState
     */
    readonly identityProfileId: string

    /**
     * Lifecycle State ID
     * @type {string}
     * @memberof LifecycleStatesApiDeleteLifecycleState
     */
    readonly lifecycleStateId: string
}

/**
 * Request parameters for getLifecycleState operation in LifecycleStatesApi.
 * @export
 * @interface LifecycleStatesApiGetLifecycleStateRequest
 */
export interface LifecycleStatesApiGetLifecycleStateRequest {
    /**
     * Identity Profile ID
     * @type {string}
     * @memberof LifecycleStatesApiGetLifecycleState
     */
    readonly identityProfileId: string

    /**
     * Lifecycle State ID
     * @type {string}
     * @memberof LifecycleStatesApiGetLifecycleState
     */
    readonly lifecycleStateId: string
}

/**
 * Request parameters for listLifecycleStates operation in LifecycleStatesApi.
 * @export
 * @interface LifecycleStatesApiListLifecycleStatesRequest
 */
export interface LifecycleStatesApiListLifecycleStatesRequest {
    /**
     * The IdentityProfile id
     * @type {string}
     * @memberof LifecycleStatesApiListLifecycleStates
     */
    readonly identityProfileId: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof LifecycleStatesApiListLifecycleStates
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof LifecycleStatesApiListLifecycleStates
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof LifecycleStatesApiListLifecycleStates
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
     * @type {string}
     * @memberof LifecycleStatesApiListLifecycleStates
     */
    readonly sorters?: string
}

/**
 * Request parameters for setLifecycleState operation in LifecycleStatesApi.
 * @export
 * @interface LifecycleStatesApiSetLifecycleStateRequest
 */
export interface LifecycleStatesApiSetLifecycleStateRequest {
    /**
     * The ID of the identity to update
     * @type {string}
     * @memberof LifecycleStatesApiSetLifecycleState
     */
    readonly identityId: string

    /**
     * 
     * @type {SetLifecycleStateRequest}
     * @memberof LifecycleStatesApiSetLifecycleState
     */
    readonly setLifecycleStateRequest: SetLifecycleStateRequest
}

/**
 * Request parameters for updateLifecycleStates operation in LifecycleStatesApi.
 * @export
 * @interface LifecycleStatesApiUpdateLifecycleStatesRequest
 */
export interface LifecycleStatesApiUpdateLifecycleStatesRequest {
    /**
     * Identity Profile ID
     * @type {string}
     * @memberof LifecycleStatesApiUpdateLifecycleStates
     */
    readonly identityProfileId: string

    /**
     * Lifecycle State ID
     * @type {string}
     * @memberof LifecycleStatesApiUpdateLifecycleStates
     */
    readonly lifecycleStateId: string

    /**
     * A list of lifecycle state update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields can be updated: * enabled * description * accountActions * accessProfileIds * emailNotificationOption 
     * @type {Array<JsonPatchOperation>}
     * @memberof LifecycleStatesApiUpdateLifecycleStates
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * LifecycleStatesApi - object-oriented interface
 * @export
 * @class LifecycleStatesApi
 * @extends {BaseAPI}
 */
export class LifecycleStatesApi extends BaseAPI {
    /**
     * This API creates a new Lifecycle State. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Create Lifecycle State
     * @param {LifecycleStatesApiCreateLifecycleStateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    public createLifecycleState(requestParameters: LifecycleStatesApiCreateLifecycleStateRequest, axiosOptions?: AxiosRequestConfig) {
        return LifecycleStatesApiFp(this.configuration).createLifecycleState(requestParameters.identityProfileId, requestParameters.lifecycleState, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint deletes the Lifecycle State using its ID. A token with API, or ORG_ADMIN authority is required to call this API.
     * @summary Delete Lifecycle State by ID
     * @param {LifecycleStatesApiDeleteLifecycleStateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    public deleteLifecycleState(requestParameters: LifecycleStatesApiDeleteLifecycleStateRequest, axiosOptions?: AxiosRequestConfig) {
        return LifecycleStatesApiFp(this.configuration).deleteLifecycleState(requestParameters.identityProfileId, requestParameters.lifecycleStateId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves a Lifecycle State. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Retrieves Lifecycle State
     * @param {LifecycleStatesApiGetLifecycleStateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    public getLifecycleState(requestParameters: LifecycleStatesApiGetLifecycleStateRequest, axiosOptions?: AxiosRequestConfig) {
        return LifecycleStatesApiFp(this.configuration).getLifecycleState(requestParameters.identityProfileId, requestParameters.lifecycleStateId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point lists all the LifecycleStates associated with IdentityProfiles. A token with API, or ORG_ADMIN authority is required to call this API.
     * @summary Lists LifecycleStates
     * @param {LifecycleStatesApiListLifecycleStatesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    public listLifecycleStates(requestParameters: LifecycleStatesApiListLifecycleStatesRequest, axiosOptions?: AxiosRequestConfig) {
        return LifecycleStatesApiFp(this.configuration).listLifecycleStates(requestParameters.identityProfileId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will set/update an identity\'s lifecycle state to the one provided and updates the corresponding Identity Profile. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Set Lifecycle State
     * @param {LifecycleStatesApiSetLifecycleStateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    public setLifecycleState(requestParameters: LifecycleStatesApiSetLifecycleStateRequest, axiosOptions?: AxiosRequestConfig) {
        return LifecycleStatesApiFp(this.configuration).setLifecycleState(requestParameters.identityId, requestParameters.setLifecycleStateRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint updates individual Lifecycle State fields using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Update Lifecycle State
     * @param {LifecycleStatesApiUpdateLifecycleStatesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    public updateLifecycleStates(requestParameters: LifecycleStatesApiUpdateLifecycleStatesRequest, axiosOptions?: AxiosRequestConfig) {
        return LifecycleStatesApiFp(this.configuration).updateLifecycleStates(requestParameters.identityProfileId, requestParameters.lifecycleStateId, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NonEmployeeLifecycleManagementApi - axios parameter creator
 * @export
 */
export const NonEmployeeLifecycleManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Approves a non-employee approval request and notifies the next approver. The current user must be the requested approver.
         * @summary Approve a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeApprovalDecision} nonEmployeeApprovalDecision 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveNonEmployeeRequest: async (id: string, nonEmployeeApprovalDecision: NonEmployeeApprovalDecision, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('approveNonEmployeeRequest', 'id', id)
            // verify required parameter 'nonEmployeeApprovalDecision' is not null or undefined
            assertParamExists('approveNonEmployeeRequest', 'nonEmployeeApprovalDecision', nonEmployeeApprovalDecision)
            const localVarPath = `/non-employee-approvals/{id}/approve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeApprovalDecision, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will create a non-employee record. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Record
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee record creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeRecord: async (nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nonEmployeeRequestBody' is not null or undefined
            assertParamExists('createNonEmployeeRecord', 'nonEmployeeRequestBody', nonEmployeeRequestBody)
            const localVarPath = `/non-employee-records`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will create a non-employee request and notify the approver. Requires role context of `idn:nesr:create` or the user must own the source.
         * @summary Create Non-Employee Request
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee creation request body
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeRequest: async (nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nonEmployeeRequestBody' is not null or undefined
            assertParamExists('createNonEmployeeRequest', 'nonEmployeeRequestBody', nonEmployeeRequestBody)
            const localVarPath = `/non-employee-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will create a non-employee source. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Source
         * @param {NonEmployeeSourceRequestBody} nonEmployeeSourceRequestBody Non-Employee source creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeSource: async (nonEmployeeSourceRequestBody: NonEmployeeSourceRequestBody, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nonEmployeeSourceRequestBody' is not null or undefined
            assertParamExists('createNonEmployeeSource', 'nonEmployeeSourceRequestBody', nonEmployeeSourceRequestBody)
            const localVarPath = `/non-employee-sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeSourceRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API creates a new schema attribute for Non-Employee Source. The schema technical name must be unique in the source. Attempts to create a schema attribute with an existing name will result in a \"400.1.409 Reference conflict\" response. At most, 10 custom attributes can be created per schema. Attempts to create more than 10 will result in a \"400.1.4 Limit violation\" response. Requires role context of `idn:nesr:create`
         * @summary Create a new Schema Attribute for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {NonEmployeeSchemaAttributeBody} nonEmployeeSchemaAttributeBody 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeSourceSchemaAttributes: async (sourceId: string, nonEmployeeSchemaAttributeBody: NonEmployeeSchemaAttributeBody, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('createNonEmployeeSourceSchemaAttributes', 'sourceId', sourceId)
            // verify required parameter 'nonEmployeeSchemaAttributeBody' is not null or undefined
            assertParamExists('createNonEmployeeSourceSchemaAttributes', 'nonEmployeeSchemaAttributeBody', nonEmployeeSchemaAttributeBody)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeSchemaAttributeBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will delete a non-employee record. Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRecord: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteNonEmployeeRecord', 'id', id)
            const localVarPath = `/non-employee-records/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will delete multiple non-employee records based on the non-employee ids provided. Requires role context of `idn:nesr:delete`
         * @summary Delete Multiple Non-Employee Records
         * @param {DeleteNonEmployeeRecordsInBulkRequest} deleteNonEmployeeRecordsInBulkRequest Non-Employee bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRecordsInBulk: async (deleteNonEmployeeRecordsInBulkRequest: DeleteNonEmployeeRecordsInBulkRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteNonEmployeeRecordsInBulkRequest' is not null or undefined
            assertParamExists('deleteNonEmployeeRecordsInBulk', 'deleteNonEmployeeRecordsInBulkRequest', deleteNonEmployeeRecordsInBulkRequest)
            const localVarPath = `/non-employee-records/bulk-delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteNonEmployeeRecordsInBulkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will delete a non-employee request.  Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Request
         * @param {string} id Non-Employee request id in the UUID format
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRequest: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteNonEmployeeRequest', 'id', id)
            const localVarPath = `/non-employee-requests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point deletes a specific schema attribute for a non-employee source. Requires role context of `idn:nesr:delete` 
         * @summary Delete a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSchemaAttribute: async (attributeId: string, sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('deleteNonEmployeeSchemaAttribute', 'attributeId', attributeId)
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteNonEmployeeSchemaAttribute', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes/{attributeId}`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will delete a non-employee source. Requires role context of `idn:nesr:delete`.
         * @summary Delete Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSource: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteNonEmployeeSource', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point deletes all custom schema attributes for a non-employee source. Requires role context of `idn:nesr:delete`
         * @summary Delete all custom schema attributes for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSourceSchemaAttributes: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteNonEmployeeSourceSchemaAttributes', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This requests a CSV download for all non-employees from a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Non-Employee Records to CSV
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportNonEmployeeRecords: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('exportNonEmployeeRecords', 'id', id)
            const localVarPath = `/non-employee-sources/{id}/non-employees/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This requests a download for the Source Schema Template for a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Source Schema Template
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportNonEmployeeSourceSchemaTemplate: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('exportNonEmployeeSourceSchemaTemplate', 'id', id)
            const localVarPath = `/non-employee-sources/{id}/schema-attributes-template/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Gets a non-employee approval item detail. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get any approval.   2. The user owns the requested approval.
         * @summary Get a non-employee approval item detail
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {boolean} [includeDetail] The object nonEmployeeRequest will not be included detail when set to false. *Default value is true*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeApproval: async (id: string, includeDetail?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNonEmployeeApproval', 'id', id)
            const localVarPath = `/non-employee-approvals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (includeDetail !== undefined) {
                localVarQueryParameter['include-detail'] = includeDetail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will retrieve a summary of non-employee approval requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular approver by passing in that approver\'s id.   2. The current user is an approver, in which case \"me\" should be provided as the `requested-for` value. This will provide the approver with a summary of the approval items assigned to him or her.
         * @summary Get Summary of Non-Employee Approval Requests
         * @param {string} requestedFor The identity (UUID) of the approver for whom for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeApprovalSummary: async (requestedFor: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestedFor' is not null or undefined
            assertParamExists('getNonEmployeeApprovalSummary', 'requestedFor', requestedFor)
            const localVarPath = `/non-employee-approvals/summary/{requested-for}`
                .replace(`{${"requested-for"}}`, encodeURIComponent(String(requestedFor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * The nonEmployeeBulkUploadStatus API returns the status of the newest bulk upload job for the specified source. Requires role context of `idn:nesr:read` 
         * @summary Obtain the status of bulk upload on the source
         * @param {string} id Source ID (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeBulkUploadStatus: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNonEmployeeBulkUploadStatus', 'id', id)
            const localVarPath = `/non-employee-sources/{id}/non-employee-bulk-upload/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a non-employee record. Requires role context of `idn:nesr:read`
         * @summary Get a Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRecord: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNonEmployeeRecord', 'id', id)
            const localVarPath = `/non-employee-records/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a non-employee request. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in this case the user can get the non-employee request for any user.   2. The user must be the owner of the non-employee request.
         * @summary Get a Non-Employee Request
         * @param {string} id Non-Employee request id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRequest: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNonEmployeeRequest', 'id', id)
            const localVarPath = `/non-employee-requests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will retrieve a summary of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a summary of the non-employee requests in the source(s) he or she manages.
         * @summary Get Summary of Non-Employee Requests
         * @param {string} requestedFor The identity (UUID) of the non-employee account manager for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRequestSummary: async (requestedFor: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestedFor' is not null or undefined
            assertParamExists('getNonEmployeeRequestSummary', 'requestedFor', requestedFor)
            const localVarPath = `/non-employee-requests/summary/{requested-for}`
                .replace(`{${"requested-for"}}`, encodeURIComponent(String(requestedFor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API gets a schema attribute by Id for the specified Non-Employee SourceId. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary Get Schema Attribute Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSchemaAttribute: async (attributeId: string, sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('getNonEmployeeSchemaAttribute', 'attributeId', attributeId)
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getNonEmployeeSchemaAttribute', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes/{attributeId}`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a non-employee source. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request any source.   2. The current user is an account manager, in which case the user can only request sources that they own.
         * @summary Get a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSource: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getNonEmployeeSource', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API gets the list of schema attributes for the specified Non-Employee SourceId. There are 8 mandatory attributes added to each new Non-Employee Source automatically. Additionaly, user can add up to 10 custom attributes. This interface returns all the mandatory attributes followed by any custom attributes. At most, a total of 18 attributes will be returned. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary List Schema Attributes Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSourceSchemaAttributes: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getNonEmployeeSourceSchemaAttributes', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This post will import, or update, Non-Employee records found in the CSV. Requires role context of `idn:nesr:create`
         * @summary Imports, or Updates, Non-Employee Records
         * @param {string} id Source Id (UUID)
         * @param {File} data 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importNonEmployeeRecordsInBulk: async (id: string, data: File, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('importNonEmployeeRecordsInBulk', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('importNonEmployeeRecordsInBulk', 'data', data)
            const localVarPath = `/non-employee-sources/{id}/non-employee-bulk-upload`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


            if (data !== undefined) { 
                localVarFormParams.append('data', data as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a list of non-employee approval requests. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can list the approvals for any approver.   2. The user owns the requested approval.
         * @summary Get List of Non-Employee Approval Requests
         * @param {string} [requestedFor] The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **approvalStatus**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeApprovals: async (requestedFor?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/non-employee-approvals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (requestedFor !== undefined) {
                localVarQueryParameter['requested-for'] = requestedFor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a list of non-employee records. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get a list of all of the non-employees.   2. The user is an account manager, in which case they can get a list of the non-employees that they manage.
         * @summary List Non-Employee Records
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, accountName, sourceId, manager, firstName, lastName, email, phone, startDate, endDate, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **sourceId**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeRecords: async (limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/non-employee-records`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a list of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list non-employee requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the non-employee requests in the source(s) he or she manages.
         * @summary List Non-Employee Requests
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, approvalStatus, firstName, lastName, email, phone, accountName, startDate, endDate**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **sourceId**: *eq* 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeRequests: async (requestedFor: string, limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestedFor' is not null or undefined
            assertParamExists('listNonEmployeeRequests', 'requestedFor', requestedFor)
            const localVarPath = `/non-employee-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (requestedFor !== undefined) {
                localVarQueryParameter['requested-for'] = requestedFor;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a list of non-employee sources. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list sources assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the sources that he or she owns.
         * @summary List Non-Employee Sources
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [nonEmployeeCount] The flag to determine whether return a non-employee count associate with source.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, sourceId**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeSources: async (requestedFor: string, limit?: number, offset?: number, count?: boolean, nonEmployeeCount?: boolean, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestedFor' is not null or undefined
            assertParamExists('listNonEmployeeSources', 'requestedFor', requestedFor)
            const localVarPath = `/non-employee-sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (requestedFor !== undefined) {
                localVarQueryParameter['requested-for'] = requestedFor;
            }

            if (nonEmployeeCount !== undefined) {
                localVarQueryParameter['non-employee-count'] = nonEmployeeCount;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will patch a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Patch Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeRecord: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchNonEmployeeRecord', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchNonEmployeeRecord', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/non-employee-records/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point patches a specific schema attribute for a non-employee SourceId. Requires role context of `idn:nesr:update` 
         * @summary Patch a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of schema attribute update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The following properties are allowed for update \&#39;:\&#39; \&#39;label\&#39;, \&#39;helpText\&#39;, \&#39;placeholder\&#39;, \&#39;required\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeSchemaAttribute: async (attributeId: string, sourceId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('patchNonEmployeeSchemaAttribute', 'attributeId', attributeId)
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('patchNonEmployeeSchemaAttribute', 'sourceId', sourceId)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchNonEmployeeSchemaAttribute', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes/{attributeId}`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * patch a non-employee source. (partial update) <br/> Patchable field: **name, description, approvers, accountManagers** Requires role context of `idn:nesr:update`.
         * @summary Patch a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee source update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeSource: async (sourceId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('patchNonEmployeeSource', 'sourceId', sourceId)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchNonEmployeeSource', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/non-employee-sources/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will reject an approval item request and notify user. The current user must be the requested approver.
         * @summary Reject a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeRejectApprovalDecision} nonEmployeeRejectApprovalDecision 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectNonEmployeeRequest: async (id: string, nonEmployeeRejectApprovalDecision: NonEmployeeRejectApprovalDecision, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rejectNonEmployeeRequest', 'id', id)
            // verify required parameter 'nonEmployeeRejectApprovalDecision' is not null or undefined
            assertParamExists('rejectNonEmployeeRequest', 'nonEmployeeRejectApprovalDecision', nonEmployeeRejectApprovalDecision)
            const localVarPath = `/non-employee-approvals/{id}/reject`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeRejectApprovalDecision, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will update a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Update Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-employee record creation request body. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateNonEmployeeRecord: async (id: string, nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateNonEmployeeRecord', 'id', id)
            // verify required parameter 'nonEmployeeRequestBody' is not null or undefined
            assertParamExists('updateNonEmployeeRecord', 'nonEmployeeRequestBody', nonEmployeeRequestBody)
            const localVarPath = `/non-employee-records/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * NonEmployeeLifecycleManagementApi - functional programming interface
 * @export
 */
export const NonEmployeeLifecycleManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NonEmployeeLifecycleManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * Approves a non-employee approval request and notifies the next approver. The current user must be the requested approver.
         * @summary Approve a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeApprovalDecision} nonEmployeeApprovalDecision 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async approveNonEmployeeRequest(id: string, nonEmployeeApprovalDecision: NonEmployeeApprovalDecision, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeApprovalItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveNonEmployeeRequest(id, nonEmployeeApprovalDecision, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.approveNonEmployeeRequest']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This request will create a non-employee record. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Record
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee record creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createNonEmployeeRecord(nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNonEmployeeRecord(nonEmployeeRequestBody, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.createNonEmployeeRecord']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This request will create a non-employee request and notify the approver. Requires role context of `idn:nesr:create` or the user must own the source.
         * @summary Create Non-Employee Request
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee creation request body
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createNonEmployeeRequest(nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNonEmployeeRequest(nonEmployeeRequestBody, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.createNonEmployeeRequest']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This request will create a non-employee source. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Source
         * @param {NonEmployeeSourceRequestBody} nonEmployeeSourceRequestBody Non-Employee source creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createNonEmployeeSource(nonEmployeeSourceRequestBody: NonEmployeeSourceRequestBody, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSourceWithCloudExternalId>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNonEmployeeSource(nonEmployeeSourceRequestBody, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.createNonEmployeeSource']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API creates a new schema attribute for Non-Employee Source. The schema technical name must be unique in the source. Attempts to create a schema attribute with an existing name will result in a \"400.1.409 Reference conflict\" response. At most, 10 custom attributes can be created per schema. Attempts to create more than 10 will result in a \"400.1.4 Limit violation\" response. Requires role context of `idn:nesr:create`
         * @summary Create a new Schema Attribute for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {NonEmployeeSchemaAttributeBody} nonEmployeeSchemaAttributeBody 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createNonEmployeeSourceSchemaAttributes(sourceId: string, nonEmployeeSchemaAttributeBody: NonEmployeeSchemaAttributeBody, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSchemaAttribute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNonEmployeeSourceSchemaAttributes(sourceId, nonEmployeeSchemaAttributeBody, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.createNonEmployeeSourceSchemaAttributes']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This request will delete a non-employee record. Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNonEmployeeRecord(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNonEmployeeRecord(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.deleteNonEmployeeRecord']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This request will delete multiple non-employee records based on the non-employee ids provided. Requires role context of `idn:nesr:delete`
         * @summary Delete Multiple Non-Employee Records
         * @param {DeleteNonEmployeeRecordsInBulkRequest} deleteNonEmployeeRecordsInBulkRequest Non-Employee bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNonEmployeeRecordsInBulk(deleteNonEmployeeRecordsInBulkRequest: DeleteNonEmployeeRecordsInBulkRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNonEmployeeRecordsInBulk(deleteNonEmployeeRecordsInBulkRequest, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.deleteNonEmployeeRecordsInBulk']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This request will delete a non-employee request.  Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Request
         * @param {string} id Non-Employee request id in the UUID format
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNonEmployeeRequest(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNonEmployeeRequest(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.deleteNonEmployeeRequest']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This end-point deletes a specific schema attribute for a non-employee source. Requires role context of `idn:nesr:delete` 
         * @summary Delete a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNonEmployeeSchemaAttribute(attributeId: string, sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNonEmployeeSchemaAttribute(attributeId, sourceId, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.deleteNonEmployeeSchemaAttribute']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This request will delete a non-employee source. Requires role context of `idn:nesr:delete`.
         * @summary Delete Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNonEmployeeSource(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNonEmployeeSource(sourceId, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.deleteNonEmployeeSource']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This end-point deletes all custom schema attributes for a non-employee source. Requires role context of `idn:nesr:delete`
         * @summary Delete all custom schema attributes for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNonEmployeeSourceSchemaAttributes(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNonEmployeeSourceSchemaAttributes(sourceId, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.deleteNonEmployeeSourceSchemaAttributes']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This requests a CSV download for all non-employees from a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Non-Employee Records to CSV
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async exportNonEmployeeRecords(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportNonEmployeeRecords(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.exportNonEmployeeRecords']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This requests a download for the Source Schema Template for a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Source Schema Template
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async exportNonEmployeeSourceSchemaTemplate(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportNonEmployeeSourceSchemaTemplate(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.exportNonEmployeeSourceSchemaTemplate']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Gets a non-employee approval item detail. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get any approval.   2. The user owns the requested approval.
         * @summary Get a non-employee approval item detail
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {boolean} [includeDetail] The object nonEmployeeRequest will not be included detail when set to false. *Default value is true*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeApproval(id: string, includeDetail?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeApprovalItemDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeApproval(id, includeDetail, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.getNonEmployeeApproval']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This request will retrieve a summary of non-employee approval requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular approver by passing in that approver\'s id.   2. The current user is an approver, in which case \"me\" should be provided as the `requested-for` value. This will provide the approver with a summary of the approval items assigned to him or her.
         * @summary Get Summary of Non-Employee Approval Requests
         * @param {string} requestedFor The identity (UUID) of the approver for whom for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeApprovalSummary(requestedFor: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeApprovalSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeApprovalSummary(requestedFor, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.getNonEmployeeApprovalSummary']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * The nonEmployeeBulkUploadStatus API returns the status of the newest bulk upload job for the specified source. Requires role context of `idn:nesr:read` 
         * @summary Obtain the status of bulk upload on the source
         * @param {string} id Source ID (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeBulkUploadStatus(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeBulkUploadStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeBulkUploadStatus(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.getNonEmployeeBulkUploadStatus']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This gets a non-employee record. Requires role context of `idn:nesr:read`
         * @summary Get a Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeRecord(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeRecord(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.getNonEmployeeRecord']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This gets a non-employee request. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in this case the user can get the non-employee request for any user.   2. The user must be the owner of the non-employee request.
         * @summary Get a Non-Employee Request
         * @param {string} id Non-Employee request id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeRequest(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeRequest(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.getNonEmployeeRequest']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This request will retrieve a summary of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a summary of the non-employee requests in the source(s) he or she manages.
         * @summary Get Summary of Non-Employee Requests
         * @param {string} requestedFor The identity (UUID) of the non-employee account manager for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeRequestSummary(requestedFor: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRequestSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeRequestSummary(requestedFor, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.getNonEmployeeRequestSummary']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API gets a schema attribute by Id for the specified Non-Employee SourceId. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary Get Schema Attribute Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeSchemaAttribute(attributeId: string, sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSchemaAttribute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeSchemaAttribute(attributeId, sourceId, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.getNonEmployeeSchemaAttribute']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This gets a non-employee source. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request any source.   2. The current user is an account manager, in which case the user can only request sources that they own.
         * @summary Get a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeSource(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeSource(sourceId, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.getNonEmployeeSource']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API gets the list of schema attributes for the specified Non-Employee SourceId. There are 8 mandatory attributes added to each new Non-Employee Source automatically. Additionaly, user can add up to 10 custom attributes. This interface returns all the mandatory attributes followed by any custom attributes. At most, a total of 18 attributes will be returned. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary List Schema Attributes Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeSourceSchemaAttributes(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NonEmployeeSchemaAttribute>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeSourceSchemaAttributes(sourceId, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.getNonEmployeeSourceSchemaAttributes']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This post will import, or update, Non-Employee records found in the CSV. Requires role context of `idn:nesr:create`
         * @summary Imports, or Updates, Non-Employee Records
         * @param {string} id Source Id (UUID)
         * @param {File} data 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async importNonEmployeeRecordsInBulk(id: string, data: File, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeBulkUploadJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importNonEmployeeRecordsInBulk(id, data, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.importNonEmployeeRecordsInBulk']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This gets a list of non-employee approval requests. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can list the approvals for any approver.   2. The user owns the requested approval.
         * @summary Get List of Non-Employee Approval Requests
         * @param {string} [requestedFor] The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **approvalStatus**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listNonEmployeeApprovals(requestedFor?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NonEmployeeApprovalItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNonEmployeeApprovals(requestedFor, limit, offset, count, filters, sorters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.listNonEmployeeApprovals']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This gets a list of non-employee records. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get a list of all of the non-employees.   2. The user is an account manager, in which case they can get a list of the non-employees that they manage.
         * @summary List Non-Employee Records
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, accountName, sourceId, manager, firstName, lastName, email, phone, startDate, endDate, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **sourceId**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listNonEmployeeRecords(limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NonEmployeeRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNonEmployeeRecords(limit, offset, count, sorters, filters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.listNonEmployeeRecords']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This gets a list of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list non-employee requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the non-employee requests in the source(s) he or she manages.
         * @summary List Non-Employee Requests
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, approvalStatus, firstName, lastName, email, phone, accountName, startDate, endDate**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **sourceId**: *eq* 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listNonEmployeeRequests(requestedFor: string, limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NonEmployeeRequest>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNonEmployeeRequests(requestedFor, limit, offset, count, sorters, filters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.listNonEmployeeRequests']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This gets a list of non-employee sources. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list sources assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the sources that he or she owns.
         * @summary List Non-Employee Sources
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [nonEmployeeCount] The flag to determine whether return a non-employee count associate with source.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, sourceId**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listNonEmployeeSources(requestedFor: string, limit?: number, offset?: number, count?: boolean, nonEmployeeCount?: boolean, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NonEmployeeSourceWithNECount>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNonEmployeeSources(requestedFor, limit, offset, count, nonEmployeeCount, sorters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.listNonEmployeeSources']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This request will patch a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Patch Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchNonEmployeeRecord(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchNonEmployeeRecord(id, jsonPatchOperation, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.patchNonEmployeeRecord']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This end-point patches a specific schema attribute for a non-employee SourceId. Requires role context of `idn:nesr:update` 
         * @summary Patch a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of schema attribute update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The following properties are allowed for update \&#39;:\&#39; \&#39;label\&#39;, \&#39;helpText\&#39;, \&#39;placeholder\&#39;, \&#39;required\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchNonEmployeeSchemaAttribute(attributeId: string, sourceId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSchemaAttribute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchNonEmployeeSchemaAttribute(attributeId, sourceId, jsonPatchOperation, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.patchNonEmployeeSchemaAttribute']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * patch a non-employee source. (partial update) <br/> Patchable field: **name, description, approvers, accountManagers** Requires role context of `idn:nesr:update`.
         * @summary Patch a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee source update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchNonEmployeeSource(sourceId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchNonEmployeeSource(sourceId, jsonPatchOperation, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.patchNonEmployeeSource']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint will reject an approval item request and notify user. The current user must be the requested approver.
         * @summary Reject a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeRejectApprovalDecision} nonEmployeeRejectApprovalDecision 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async rejectNonEmployeeRequest(id: string, nonEmployeeRejectApprovalDecision: NonEmployeeRejectApprovalDecision, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeApprovalItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectNonEmployeeRequest(id, nonEmployeeRejectApprovalDecision, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.rejectNonEmployeeRequest']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This request will update a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Update Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-employee record creation request body. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateNonEmployeeRecord(id: string, nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNonEmployeeRecord(id, nonEmployeeRequestBody, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.updateNonEmployeeRecord']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * NonEmployeeLifecycleManagementApi - factory interface
 * @export
 */
export const NonEmployeeLifecycleManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NonEmployeeLifecycleManagementApiFp(configuration)
    return {
        /**
         * Approves a non-employee approval request and notifies the next approver. The current user must be the requested approver.
         * @summary Approve a Non-Employee Request
         * @param {NonEmployeeLifecycleManagementApiApproveNonEmployeeRequestRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        approveNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementApiApproveNonEmployeeRequestRequest, options?: AxiosRequestConfig): AxiosPromise<NonEmployeeApprovalItem> {
            return localVarFp.approveNonEmployeeRequest(requestParameters.id, requestParameters.nonEmployeeApprovalDecision, options).then((request) => request(axios, basePath));
        },
        /**
         * This request will create a non-employee record. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Record
         * @param {NonEmployeeLifecycleManagementApiCreateNonEmployeeRecordRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        createNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementApiCreateNonEmployeeRecordRequest, options?: AxiosRequestConfig): AxiosPromise<NonEmployeeRecord> {
            return localVarFp.createNonEmployeeRecord(requestParameters.nonEmployeeRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * This request will create a non-employee request and notify the approver. Requires role context of `idn:nesr:create` or the user must own the source.
         * @summary Create Non-Employee Request
         * @param {NonEmployeeLifecycleManagementApiCreateNonEmployeeRequestRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        createNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementApiCreateNonEmployeeRequestRequest, options?: AxiosRequestConfig): AxiosPromise<NonEmployeeRequest> {
            return localVarFp.createNonEmployeeRequest(requestParameters.nonEmployeeRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * This request will create a non-employee source. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Source
         * @param {NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        createNonEmployeeSource(requestParameters: NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceRequest, options?: AxiosRequestConfig): AxiosPromise<NonEmployeeSourceWithCloudExternalId> {
            return localVarFp.createNonEmployeeSource(requestParameters.nonEmployeeSourceRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * This API creates a new schema attribute for Non-Employee Source. The schema technical name must be unique in the source. Attempts to create a schema attribute with an existing name will result in a \"400.1.409 Reference conflict\" response. At most, 10 custom attributes can be created per schema. Attempts to create more than 10 will result in a \"400.1.4 Limit violation\" response. Requires role context of `idn:nesr:create`
         * @summary Create a new Schema Attribute for Non-Employee Source
         * @param {NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceSchemaAttributesRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        createNonEmployeeSourceSchemaAttributes(requestParameters: NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceSchemaAttributesRequest, options?: AxiosRequestConfig): AxiosPromise<NonEmployeeSchemaAttribute> {
            return localVarFp.createNonEmployeeSourceSchemaAttributes(requestParameters.sourceId, requestParameters.nonEmployeeSchemaAttributeBody, options).then((request) => request(axios, basePath));
        },
        /**
         * This request will delete a non-employee record. Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Record
         * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteNonEmployeeRecord(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This request will delete multiple non-employee records based on the non-employee ids provided. Requires role context of `idn:nesr:delete`
         * @summary Delete Multiple Non-Employee Records
         * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordsInBulkRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteNonEmployeeRecordsInBulk(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordsInBulkRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteNonEmployeeRecordsInBulk(requestParameters.deleteNonEmployeeRecordsInBulkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This request will delete a non-employee request.  Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Request
         * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeRequestRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeRequestRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteNonEmployeeRequest(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This end-point deletes a specific schema attribute for a non-employee source. Requires role context of `idn:nesr:delete` 
         * @summary Delete a Schema Attribute for Non-Employee Source
         * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeSchemaAttributeRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteNonEmployeeSchemaAttribute(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeSchemaAttributeRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteNonEmployeeSchemaAttribute(requestParameters.attributeId, requestParameters.sourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * This request will delete a non-employee source. Requires role context of `idn:nesr:delete`.
         * @summary Delete Non-Employee Source
         * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteNonEmployeeSource(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteNonEmployeeSource(requestParameters.sourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * This end-point deletes all custom schema attributes for a non-employee source. Requires role context of `idn:nesr:delete`
         * @summary Delete all custom schema attributes for Non-Employee Source
         * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceSchemaAttributesRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteNonEmployeeSourceSchemaAttributes(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceSchemaAttributesRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteNonEmployeeSourceSchemaAttributes(requestParameters.sourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * This requests a CSV download for all non-employees from a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Non-Employee Records to CSV
         * @param {NonEmployeeLifecycleManagementApiExportNonEmployeeRecordsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        exportNonEmployeeRecords(requestParameters: NonEmployeeLifecycleManagementApiExportNonEmployeeRecordsRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.exportNonEmployeeRecords(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This requests a download for the Source Schema Template for a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Source Schema Template
         * @param {NonEmployeeLifecycleManagementApiExportNonEmployeeSourceSchemaTemplateRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        exportNonEmployeeSourceSchemaTemplate(requestParameters: NonEmployeeLifecycleManagementApiExportNonEmployeeSourceSchemaTemplateRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.exportNonEmployeeSourceSchemaTemplate(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a non-employee approval item detail. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get any approval.   2. The user owns the requested approval.
         * @summary Get a non-employee approval item detail
         * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getNonEmployeeApproval(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalRequest, options?: AxiosRequestConfig): AxiosPromise<NonEmployeeApprovalItemDetail> {
            return localVarFp.getNonEmployeeApproval(requestParameters.id, requestParameters.includeDetail, options).then((request) => request(axios, basePath));
        },
        /**
         * This request will retrieve a summary of non-employee approval requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular approver by passing in that approver\'s id.   2. The current user is an approver, in which case \"me\" should be provided as the `requested-for` value. This will provide the approver with a summary of the approval items assigned to him or her.
         * @summary Get Summary of Non-Employee Approval Requests
         * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalSummaryRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getNonEmployeeApprovalSummary(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalSummaryRequest, options?: AxiosRequestConfig): AxiosPromise<NonEmployeeApprovalSummary> {
            return localVarFp.getNonEmployeeApprovalSummary(requestParameters.requestedFor, options).then((request) => request(axios, basePath));
        },
        /**
         * The nonEmployeeBulkUploadStatus API returns the status of the newest bulk upload job for the specified source. Requires role context of `idn:nesr:read` 
         * @summary Obtain the status of bulk upload on the source
         * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeBulkUploadStatusRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getNonEmployeeBulkUploadStatus(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeBulkUploadStatusRequest, options?: AxiosRequestConfig): AxiosPromise<NonEmployeeBulkUploadStatus> {
            return localVarFp.getNonEmployeeBulkUploadStatus(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This gets a non-employee record. Requires role context of `idn:nesr:read`
         * @summary Get a Non-Employee Record
         * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeRecordRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeRecordRequest, options?: AxiosRequestConfig): AxiosPromise<NonEmployeeRecord> {
            return localVarFp.getNonEmployeeRecord(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This gets a non-employee request. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in this case the user can get the non-employee request for any user.   2. The user must be the owner of the non-employee request.
         * @summary Get a Non-Employee Request
         * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeRequestRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeRequestRequest, options?: AxiosRequestConfig): AxiosPromise<NonEmployeeRequest> {
            return localVarFp.getNonEmployeeRequest(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This request will retrieve a summary of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a summary of the non-employee requests in the source(s) he or she manages.
         * @summary Get Summary of Non-Employee Requests
         * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeRequestSummaryRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getNonEmployeeRequestSummary(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeRequestSummaryRequest, options?: AxiosRequestConfig): AxiosPromise<NonEmployeeRequestSummary> {
            return localVarFp.getNonEmployeeRequestSummary(requestParameters.requestedFor, options).then((request) => request(axios, basePath));
        },
        /**
         * This API gets a schema attribute by Id for the specified Non-Employee SourceId. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary Get Schema Attribute Non-Employee Source
         * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeSchemaAttributeRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getNonEmployeeSchemaAttribute(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeSchemaAttributeRequest, options?: AxiosRequestConfig): AxiosPromise<NonEmployeeSchemaAttribute> {
            return localVarFp.getNonEmployeeSchemaAttribute(requestParameters.attributeId, requestParameters.sourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * This gets a non-employee source. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request any source.   2. The current user is an account manager, in which case the user can only request sources that they own.
         * @summary Get a Non-Employee Source
         * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeSourceRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getNonEmployeeSource(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeSourceRequest, options?: AxiosRequestConfig): AxiosPromise<NonEmployeeSource> {
            return localVarFp.getNonEmployeeSource(requestParameters.sourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * This API gets the list of schema attributes for the specified Non-Employee SourceId. There are 8 mandatory attributes added to each new Non-Employee Source automatically. Additionaly, user can add up to 10 custom attributes. This interface returns all the mandatory attributes followed by any custom attributes. At most, a total of 18 attributes will be returned. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary List Schema Attributes Non-Employee Source
         * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeSourceSchemaAttributesRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getNonEmployeeSourceSchemaAttributes(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeSourceSchemaAttributesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<NonEmployeeSchemaAttribute>> {
            return localVarFp.getNonEmployeeSourceSchemaAttributes(requestParameters.sourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * This post will import, or update, Non-Employee records found in the CSV. Requires role context of `idn:nesr:create`
         * @summary Imports, or Updates, Non-Employee Records
         * @param {NonEmployeeLifecycleManagementApiImportNonEmployeeRecordsInBulkRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        importNonEmployeeRecordsInBulk(requestParameters: NonEmployeeLifecycleManagementApiImportNonEmployeeRecordsInBulkRequest, options?: AxiosRequestConfig): AxiosPromise<NonEmployeeBulkUploadJob> {
            return localVarFp.importNonEmployeeRecordsInBulk(requestParameters.id, requestParameters.data, options).then((request) => request(axios, basePath));
        },
        /**
         * This gets a list of non-employee approval requests. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can list the approvals for any approver.   2. The user owns the requested approval.
         * @summary Get List of Non-Employee Approval Requests
         * @param {NonEmployeeLifecycleManagementApiListNonEmployeeApprovalsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listNonEmployeeApprovals(requestParameters: NonEmployeeLifecycleManagementApiListNonEmployeeApprovalsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<NonEmployeeApprovalItem>> {
            return localVarFp.listNonEmployeeApprovals(requestParameters.requestedFor, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, options).then((request) => request(axios, basePath));
        },
        /**
         * This gets a list of non-employee records. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get a list of all of the non-employees.   2. The user is an account manager, in which case they can get a list of the non-employees that they manage.
         * @summary List Non-Employee Records
         * @param {NonEmployeeLifecycleManagementApiListNonEmployeeRecordsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listNonEmployeeRecords(requestParameters: NonEmployeeLifecycleManagementApiListNonEmployeeRecordsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<NonEmployeeRecord>> {
            return localVarFp.listNonEmployeeRecords(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, requestParameters.filters, options).then((request) => request(axios, basePath));
        },
        /**
         * This gets a list of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list non-employee requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the non-employee requests in the source(s) he or she manages.
         * @summary List Non-Employee Requests
         * @param {NonEmployeeLifecycleManagementApiListNonEmployeeRequestsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listNonEmployeeRequests(requestParameters: NonEmployeeLifecycleManagementApiListNonEmployeeRequestsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<NonEmployeeRequest>> {
            return localVarFp.listNonEmployeeRequests(requestParameters.requestedFor, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, requestParameters.filters, options).then((request) => request(axios, basePath));
        },
        /**
         * This gets a list of non-employee sources. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list sources assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the sources that he or she owns.
         * @summary List Non-Employee Sources
         * @param {NonEmployeeLifecycleManagementApiListNonEmployeeSourcesRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listNonEmployeeSources(requestParameters: NonEmployeeLifecycleManagementApiListNonEmployeeSourcesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<NonEmployeeSourceWithNECount>> {
            return localVarFp.listNonEmployeeSources(requestParameters.requestedFor, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.nonEmployeeCount, requestParameters.sorters, options).then((request) => request(axios, basePath));
        },
        /**
         * This request will patch a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Patch Non-Employee Record
         * @param {NonEmployeeLifecycleManagementApiPatchNonEmployeeRecordRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        patchNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementApiPatchNonEmployeeRecordRequest, options?: AxiosRequestConfig): AxiosPromise<NonEmployeeRecord> {
            return localVarFp.patchNonEmployeeRecord(requestParameters.id, requestParameters.jsonPatchOperation, options).then((request) => request(axios, basePath));
        },
        /**
         * This end-point patches a specific schema attribute for a non-employee SourceId. Requires role context of `idn:nesr:update` 
         * @summary Patch a Schema Attribute for Non-Employee Source
         * @param {NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttributeRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        patchNonEmployeeSchemaAttribute(requestParameters: NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttributeRequest, options?: AxiosRequestConfig): AxiosPromise<NonEmployeeSchemaAttribute> {
            return localVarFp.patchNonEmployeeSchemaAttribute(requestParameters.attributeId, requestParameters.sourceId, requestParameters.jsonPatchOperation, options).then((request) => request(axios, basePath));
        },
        /**
         * patch a non-employee source. (partial update) <br/> Patchable field: **name, description, approvers, accountManagers** Requires role context of `idn:nesr:update`.
         * @summary Patch a Non-Employee Source
         * @param {NonEmployeeLifecycleManagementApiPatchNonEmployeeSourceRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        patchNonEmployeeSource(requestParameters: NonEmployeeLifecycleManagementApiPatchNonEmployeeSourceRequest, options?: AxiosRequestConfig): AxiosPromise<NonEmployeeSource> {
            return localVarFp.patchNonEmployeeSource(requestParameters.sourceId, requestParameters.jsonPatchOperation, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will reject an approval item request and notify user. The current user must be the requested approver.
         * @summary Reject a Non-Employee Request
         * @param {NonEmployeeLifecycleManagementApiRejectNonEmployeeRequestRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        rejectNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementApiRejectNonEmployeeRequestRequest, options?: AxiosRequestConfig): AxiosPromise<NonEmployeeApprovalItem> {
            return localVarFp.rejectNonEmployeeRequest(requestParameters.id, requestParameters.nonEmployeeRejectApprovalDecision, options).then((request) => request(axios, basePath));
        },
        /**
         * This request will update a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Update Non-Employee Record
         * @param {NonEmployeeLifecycleManagementApiUpdateNonEmployeeRecordRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        updateNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementApiUpdateNonEmployeeRecordRequest, options?: AxiosRequestConfig): AxiosPromise<NonEmployeeRecord> {
            return localVarFp.updateNonEmployeeRecord(requestParameters.id, requestParameters.nonEmployeeRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for approveNonEmployeeRequest operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiApproveNonEmployeeRequestRequest
 */
export interface NonEmployeeLifecycleManagementApiApproveNonEmployeeRequestRequest {
    /**
     * Non-Employee approval item id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiApproveNonEmployeeRequest
     */
    readonly id: string

    /**
     * 
     * @type {NonEmployeeApprovalDecision}
     * @memberof NonEmployeeLifecycleManagementApiApproveNonEmployeeRequest
     */
    readonly nonEmployeeApprovalDecision: NonEmployeeApprovalDecision
}

/**
 * Request parameters for createNonEmployeeRecord operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiCreateNonEmployeeRecordRequest
 */
export interface NonEmployeeLifecycleManagementApiCreateNonEmployeeRecordRequest {
    /**
     * Non-Employee record creation request body.
     * @type {NonEmployeeRequestBody}
     * @memberof NonEmployeeLifecycleManagementApiCreateNonEmployeeRecord
     */
    readonly nonEmployeeRequestBody: NonEmployeeRequestBody
}

/**
 * Request parameters for createNonEmployeeRequest operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiCreateNonEmployeeRequestRequest
 */
export interface NonEmployeeLifecycleManagementApiCreateNonEmployeeRequestRequest {
    /**
     * Non-Employee creation request body
     * @type {NonEmployeeRequestBody}
     * @memberof NonEmployeeLifecycleManagementApiCreateNonEmployeeRequest
     */
    readonly nonEmployeeRequestBody: NonEmployeeRequestBody
}

/**
 * Request parameters for createNonEmployeeSource operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceRequest
 */
export interface NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceRequest {
    /**
     * Non-Employee source creation request body.
     * @type {NonEmployeeSourceRequestBody}
     * @memberof NonEmployeeLifecycleManagementApiCreateNonEmployeeSource
     */
    readonly nonEmployeeSourceRequestBody: NonEmployeeSourceRequestBody
}

/**
 * Request parameters for createNonEmployeeSourceSchemaAttributes operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceSchemaAttributesRequest
 */
export interface NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceSchemaAttributesRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceSchemaAttributes
     */
    readonly sourceId: string

    /**
     * 
     * @type {NonEmployeeSchemaAttributeBody}
     * @memberof NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceSchemaAttributes
     */
    readonly nonEmployeeSchemaAttributeBody: NonEmployeeSchemaAttributeBody
}

/**
 * Request parameters for deleteNonEmployeeRecord operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordRequest
 */
export interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordRequest {
    /**
     * Non-Employee record id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecord
     */
    readonly id: string
}

/**
 * Request parameters for deleteNonEmployeeRecordsInBulk operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordsInBulkRequest
 */
export interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordsInBulkRequest {
    /**
     * Non-Employee bulk delete request body.
     * @type {DeleteNonEmployeeRecordsInBulkRequest}
     * @memberof NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordsInBulk
     */
    readonly deleteNonEmployeeRecordsInBulkRequest: DeleteNonEmployeeRecordsInBulkRequest
}

/**
 * Request parameters for deleteNonEmployeeRequest operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeRequestRequest
 */
export interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeRequestRequest {
    /**
     * Non-Employee request id in the UUID format
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiDeleteNonEmployeeRequest
     */
    readonly id: string
}

/**
 * Request parameters for deleteNonEmployeeSchemaAttribute operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeSchemaAttributeRequest
 */
export interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeSchemaAttributeRequest {
    /**
     * The Schema Attribute Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiDeleteNonEmployeeSchemaAttribute
     */
    readonly attributeId: string

    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiDeleteNonEmployeeSchemaAttribute
     */
    readonly sourceId: string
}

/**
 * Request parameters for deleteNonEmployeeSource operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceRequest
 */
export interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceRequest {
    /**
     * Source Id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiDeleteNonEmployeeSource
     */
    readonly sourceId: string
}

/**
 * Request parameters for deleteNonEmployeeSourceSchemaAttributes operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceSchemaAttributesRequest
 */
export interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceSchemaAttributesRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceSchemaAttributes
     */
    readonly sourceId: string
}

/**
 * Request parameters for exportNonEmployeeRecords operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiExportNonEmployeeRecordsRequest
 */
export interface NonEmployeeLifecycleManagementApiExportNonEmployeeRecordsRequest {
    /**
     * Source Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiExportNonEmployeeRecords
     */
    readonly id: string
}

/**
 * Request parameters for exportNonEmployeeSourceSchemaTemplate operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiExportNonEmployeeSourceSchemaTemplateRequest
 */
export interface NonEmployeeLifecycleManagementApiExportNonEmployeeSourceSchemaTemplateRequest {
    /**
     * Source Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiExportNonEmployeeSourceSchemaTemplate
     */
    readonly id: string
}

/**
 * Request parameters for getNonEmployeeApproval operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalRequest {
    /**
     * Non-Employee approval item id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeApproval
     */
    readonly id: string

    /**
     * The object nonEmployeeRequest will not be included detail when set to false. *Default value is true*
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeApproval
     */
    readonly includeDetail?: boolean
}

/**
 * Request parameters for getNonEmployeeApprovalSummary operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalSummaryRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalSummaryRequest {
    /**
     * The identity (UUID) of the approver for whom for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalSummary
     */
    readonly requestedFor: string
}

/**
 * Request parameters for getNonEmployeeBulkUploadStatus operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeBulkUploadStatusRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeBulkUploadStatusRequest {
    /**
     * Source ID (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeBulkUploadStatus
     */
    readonly id: string
}

/**
 * Request parameters for getNonEmployeeRecord operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeRecordRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeRecordRequest {
    /**
     * Non-Employee record id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeRecord
     */
    readonly id: string
}

/**
 * Request parameters for getNonEmployeeRequest operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeRequestRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeRequestRequest {
    /**
     * Non-Employee request id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeRequest
     */
    readonly id: string
}

/**
 * Request parameters for getNonEmployeeRequestSummary operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeRequestSummaryRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeRequestSummaryRequest {
    /**
     * The identity (UUID) of the non-employee account manager for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeRequestSummary
     */
    readonly requestedFor: string
}

/**
 * Request parameters for getNonEmployeeSchemaAttribute operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeSchemaAttributeRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeSchemaAttributeRequest {
    /**
     * The Schema Attribute Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeSchemaAttribute
     */
    readonly attributeId: string

    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeSchemaAttribute
     */
    readonly sourceId: string
}

/**
 * Request parameters for getNonEmployeeSource operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeSourceRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeSourceRequest {
    /**
     * Source Id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeSource
     */
    readonly sourceId: string
}

/**
 * Request parameters for getNonEmployeeSourceSchemaAttributes operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeSourceSchemaAttributesRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeSourceSchemaAttributesRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeSourceSchemaAttributes
     */
    readonly sourceId: string
}

/**
 * Request parameters for importNonEmployeeRecordsInBulk operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiImportNonEmployeeRecordsInBulkRequest
 */
export interface NonEmployeeLifecycleManagementApiImportNonEmployeeRecordsInBulkRequest {
    /**
     * Source Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiImportNonEmployeeRecordsInBulk
     */
    readonly id: string

    /**
     * 
     * @type {File}
     * @memberof NonEmployeeLifecycleManagementApiImportNonEmployeeRecordsInBulk
     */
    readonly data: File
}

/**
 * Request parameters for listNonEmployeeApprovals operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiListNonEmployeeApprovalsRequest
 */
export interface NonEmployeeLifecycleManagementApiListNonEmployeeApprovalsRequest {
    /**
     * The identity for whom the request was made. *me* indicates the current user.
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeApprovals
     */
    readonly requestedFor?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeApprovals
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeApprovals
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeApprovals
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **approvalStatus**: *eq*
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeApprovals
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeApprovals
     */
    readonly sorters?: string
}

/**
 * Request parameters for listNonEmployeeRecords operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiListNonEmployeeRecordsRequest
 */
export interface NonEmployeeLifecycleManagementApiListNonEmployeeRecordsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRecords
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRecords
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRecords
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, accountName, sourceId, manager, firstName, lastName, email, phone, startDate, endDate, created, modified**
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRecords
     */
    readonly sorters?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **sourceId**: *eq*
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRecords
     */
    readonly filters?: string
}

/**
 * Request parameters for listNonEmployeeRequests operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiListNonEmployeeRequestsRequest
 */
export interface NonEmployeeLifecycleManagementApiListNonEmployeeRequestsRequest {
    /**
     * The identity for whom the request was made. *me* indicates the current user.
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRequests
     */
    readonly requestedFor: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRequests
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRequests
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRequests
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, approvalStatus, firstName, lastName, email, phone, accountName, startDate, endDate**
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRequests
     */
    readonly sorters?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **sourceId**: *eq* 
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRequests
     */
    readonly filters?: string
}

/**
 * Request parameters for listNonEmployeeSources operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiListNonEmployeeSourcesRequest
 */
export interface NonEmployeeLifecycleManagementApiListNonEmployeeSourcesRequest {
    /**
     * The identity for whom the request was made. *me* indicates the current user.
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeSources
     */
    readonly requestedFor: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeSources
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeSources
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeSources
     */
    readonly count?: boolean

    /**
     * The flag to determine whether return a non-employee count associate with source.
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeSources
     */
    readonly nonEmployeeCount?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, sourceId**
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeSources
     */
    readonly sorters?: string
}

/**
 * Request parameters for patchNonEmployeeRecord operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiPatchNonEmployeeRecordRequest
 */
export interface NonEmployeeLifecycleManagementApiPatchNonEmployeeRecordRequest {
    /**
     * Non-employee record id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiPatchNonEmployeeRecord
     */
    readonly id: string

    /**
     * A list of non-employee update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
     * @type {Array<JsonPatchOperation>}
     * @memberof NonEmployeeLifecycleManagementApiPatchNonEmployeeRecord
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for patchNonEmployeeSchemaAttribute operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttributeRequest
 */
export interface NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttributeRequest {
    /**
     * The Schema Attribute Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttribute
     */
    readonly attributeId: string

    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttribute
     */
    readonly sourceId: string

    /**
     * A list of schema attribute update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The following properties are allowed for update \&#39;:\&#39; \&#39;label\&#39;, \&#39;helpText\&#39;, \&#39;placeholder\&#39;, \&#39;required\&#39;.
     * @type {Array<JsonPatchOperation>}
     * @memberof NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttribute
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for patchNonEmployeeSource operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiPatchNonEmployeeSourceRequest
 */
export interface NonEmployeeLifecycleManagementApiPatchNonEmployeeSourceRequest {
    /**
     * Source Id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiPatchNonEmployeeSource
     */
    readonly sourceId: string

    /**
     * A list of non-employee source update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
     * @type {Array<JsonPatchOperation>}
     * @memberof NonEmployeeLifecycleManagementApiPatchNonEmployeeSource
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for rejectNonEmployeeRequest operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiRejectNonEmployeeRequestRequest
 */
export interface NonEmployeeLifecycleManagementApiRejectNonEmployeeRequestRequest {
    /**
     * Non-Employee approval item id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiRejectNonEmployeeRequest
     */
    readonly id: string

    /**
     * 
     * @type {NonEmployeeRejectApprovalDecision}
     * @memberof NonEmployeeLifecycleManagementApiRejectNonEmployeeRequest
     */
    readonly nonEmployeeRejectApprovalDecision: NonEmployeeRejectApprovalDecision
}

/**
 * Request parameters for updateNonEmployeeRecord operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiUpdateNonEmployeeRecordRequest
 */
export interface NonEmployeeLifecycleManagementApiUpdateNonEmployeeRecordRequest {
    /**
     * Non-employee record id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiUpdateNonEmployeeRecord
     */
    readonly id: string

    /**
     * Non-employee record creation request body. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
     * @type {NonEmployeeRequestBody}
     * @memberof NonEmployeeLifecycleManagementApiUpdateNonEmployeeRecord
     */
    readonly nonEmployeeRequestBody: NonEmployeeRequestBody
}

/**
 * NonEmployeeLifecycleManagementApi - object-oriented interface
 * @export
 * @class NonEmployeeLifecycleManagementApi
 * @extends {BaseAPI}
 */
export class NonEmployeeLifecycleManagementApi extends BaseAPI {
    /**
     * Approves a non-employee approval request and notifies the next approver. The current user must be the requested approver.
     * @summary Approve a Non-Employee Request
     * @param {NonEmployeeLifecycleManagementApiApproveNonEmployeeRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public approveNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementApiApproveNonEmployeeRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).approveNonEmployeeRequest(requestParameters.id, requestParameters.nonEmployeeApprovalDecision, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will create a non-employee record. Requires role context of `idn:nesr:create`
     * @summary Create Non-Employee Record
     * @param {NonEmployeeLifecycleManagementApiCreateNonEmployeeRecordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public createNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementApiCreateNonEmployeeRecordRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).createNonEmployeeRecord(requestParameters.nonEmployeeRequestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will create a non-employee request and notify the approver. Requires role context of `idn:nesr:create` or the user must own the source.
     * @summary Create Non-Employee Request
     * @param {NonEmployeeLifecycleManagementApiCreateNonEmployeeRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public createNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementApiCreateNonEmployeeRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).createNonEmployeeRequest(requestParameters.nonEmployeeRequestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will create a non-employee source. Requires role context of `idn:nesr:create`
     * @summary Create Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public createNonEmployeeSource(requestParameters: NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).createNonEmployeeSource(requestParameters.nonEmployeeSourceRequestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API creates a new schema attribute for Non-Employee Source. The schema technical name must be unique in the source. Attempts to create a schema attribute with an existing name will result in a \"400.1.409 Reference conflict\" response. At most, 10 custom attributes can be created per schema. Attempts to create more than 10 will result in a \"400.1.4 Limit violation\" response. Requires role context of `idn:nesr:create`
     * @summary Create a new Schema Attribute for Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceSchemaAttributesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public createNonEmployeeSourceSchemaAttributes(requestParameters: NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceSchemaAttributesRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).createNonEmployeeSourceSchemaAttributes(requestParameters.sourceId, requestParameters.nonEmployeeSchemaAttributeBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will delete a non-employee record. Requires role context of `idn:nesr:delete`
     * @summary Delete Non-Employee Record
     * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public deleteNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).deleteNonEmployeeRecord(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will delete multiple non-employee records based on the non-employee ids provided. Requires role context of `idn:nesr:delete`
     * @summary Delete Multiple Non-Employee Records
     * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordsInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public deleteNonEmployeeRecordsInBulk(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordsInBulkRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).deleteNonEmployeeRecordsInBulk(requestParameters.deleteNonEmployeeRecordsInBulkRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will delete a non-employee request.  Requires role context of `idn:nesr:delete`
     * @summary Delete Non-Employee Request
     * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public deleteNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).deleteNonEmployeeRequest(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point deletes a specific schema attribute for a non-employee source. Requires role context of `idn:nesr:delete` 
     * @summary Delete a Schema Attribute for Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeSchemaAttributeRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public deleteNonEmployeeSchemaAttribute(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeSchemaAttributeRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).deleteNonEmployeeSchemaAttribute(requestParameters.attributeId, requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will delete a non-employee source. Requires role context of `idn:nesr:delete`.
     * @summary Delete Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public deleteNonEmployeeSource(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).deleteNonEmployeeSource(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point deletes all custom schema attributes for a non-employee source. Requires role context of `idn:nesr:delete`
     * @summary Delete all custom schema attributes for Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceSchemaAttributesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public deleteNonEmployeeSourceSchemaAttributes(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceSchemaAttributesRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).deleteNonEmployeeSourceSchemaAttributes(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This requests a CSV download for all non-employees from a provided source. Requires role context of `idn:nesr:read`
     * @summary Exports Non-Employee Records to CSV
     * @param {NonEmployeeLifecycleManagementApiExportNonEmployeeRecordsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public exportNonEmployeeRecords(requestParameters: NonEmployeeLifecycleManagementApiExportNonEmployeeRecordsRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).exportNonEmployeeRecords(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This requests a download for the Source Schema Template for a provided source. Requires role context of `idn:nesr:read`
     * @summary Exports Source Schema Template
     * @param {NonEmployeeLifecycleManagementApiExportNonEmployeeSourceSchemaTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public exportNonEmployeeSourceSchemaTemplate(requestParameters: NonEmployeeLifecycleManagementApiExportNonEmployeeSourceSchemaTemplateRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).exportNonEmployeeSourceSchemaTemplate(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a non-employee approval item detail. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get any approval.   2. The user owns the requested approval.
     * @summary Get a non-employee approval item detail
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeApproval(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeApproval(requestParameters.id, requestParameters.includeDetail, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will retrieve a summary of non-employee approval requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular approver by passing in that approver\'s id.   2. The current user is an approver, in which case \"me\" should be provided as the `requested-for` value. This will provide the approver with a summary of the approval items assigned to him or her.
     * @summary Get Summary of Non-Employee Approval Requests
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeApprovalSummary(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalSummaryRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeApprovalSummary(requestParameters.requestedFor, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The nonEmployeeBulkUploadStatus API returns the status of the newest bulk upload job for the specified source. Requires role context of `idn:nesr:read` 
     * @summary Obtain the status of bulk upload on the source
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeBulkUploadStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeBulkUploadStatus(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeBulkUploadStatusRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeBulkUploadStatus(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a non-employee record. Requires role context of `idn:nesr:read`
     * @summary Get a Non-Employee Record
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeRecordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeRecordRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeRecord(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a non-employee request. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in this case the user can get the non-employee request for any user.   2. The user must be the owner of the non-employee request.
     * @summary Get a Non-Employee Request
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeRequest(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will retrieve a summary of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a summary of the non-employee requests in the source(s) he or she manages.
     * @summary Get Summary of Non-Employee Requests
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeRequestSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeRequestSummary(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeRequestSummaryRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeRequestSummary(requestParameters.requestedFor, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API gets a schema attribute by Id for the specified Non-Employee SourceId. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
     * @summary Get Schema Attribute Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeSchemaAttributeRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeSchemaAttribute(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeSchemaAttributeRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeSchemaAttribute(requestParameters.attributeId, requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a non-employee source. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request any source.   2. The current user is an account manager, in which case the user can only request sources that they own.
     * @summary Get a Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeSource(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeSource(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API gets the list of schema attributes for the specified Non-Employee SourceId. There are 8 mandatory attributes added to each new Non-Employee Source automatically. Additionaly, user can add up to 10 custom attributes. This interface returns all the mandatory attributes followed by any custom attributes. At most, a total of 18 attributes will be returned. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
     * @summary List Schema Attributes Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeSourceSchemaAttributesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeSourceSchemaAttributes(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeSourceSchemaAttributesRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeSourceSchemaAttributes(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This post will import, or update, Non-Employee records found in the CSV. Requires role context of `idn:nesr:create`
     * @summary Imports, or Updates, Non-Employee Records
     * @param {NonEmployeeLifecycleManagementApiImportNonEmployeeRecordsInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public importNonEmployeeRecordsInBulk(requestParameters: NonEmployeeLifecycleManagementApiImportNonEmployeeRecordsInBulkRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).importNonEmployeeRecordsInBulk(requestParameters.id, requestParameters.data, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a list of non-employee approval requests. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can list the approvals for any approver.   2. The user owns the requested approval.
     * @summary Get List of Non-Employee Approval Requests
     * @param {NonEmployeeLifecycleManagementApiListNonEmployeeApprovalsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public listNonEmployeeApprovals(requestParameters: NonEmployeeLifecycleManagementApiListNonEmployeeApprovalsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).listNonEmployeeApprovals(requestParameters.requestedFor, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a list of non-employee records. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get a list of all of the non-employees.   2. The user is an account manager, in which case they can get a list of the non-employees that they manage.
     * @summary List Non-Employee Records
     * @param {NonEmployeeLifecycleManagementApiListNonEmployeeRecordsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public listNonEmployeeRecords(requestParameters: NonEmployeeLifecycleManagementApiListNonEmployeeRecordsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).listNonEmployeeRecords(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a list of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list non-employee requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the non-employee requests in the source(s) he or she manages.
     * @summary List Non-Employee Requests
     * @param {NonEmployeeLifecycleManagementApiListNonEmployeeRequestsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public listNonEmployeeRequests(requestParameters: NonEmployeeLifecycleManagementApiListNonEmployeeRequestsRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).listNonEmployeeRequests(requestParameters.requestedFor, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a list of non-employee sources. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list sources assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the sources that he or she owns.
     * @summary List Non-Employee Sources
     * @param {NonEmployeeLifecycleManagementApiListNonEmployeeSourcesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public listNonEmployeeSources(requestParameters: NonEmployeeLifecycleManagementApiListNonEmployeeSourcesRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).listNonEmployeeSources(requestParameters.requestedFor, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.nonEmployeeCount, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will patch a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
     * @summary Patch Non-Employee Record
     * @param {NonEmployeeLifecycleManagementApiPatchNonEmployeeRecordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public patchNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementApiPatchNonEmployeeRecordRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).patchNonEmployeeRecord(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point patches a specific schema attribute for a non-employee SourceId. Requires role context of `idn:nesr:update` 
     * @summary Patch a Schema Attribute for Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttributeRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public patchNonEmployeeSchemaAttribute(requestParameters: NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttributeRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).patchNonEmployeeSchemaAttribute(requestParameters.attributeId, requestParameters.sourceId, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch a non-employee source. (partial update) <br/> Patchable field: **name, description, approvers, accountManagers** Requires role context of `idn:nesr:update`.
     * @summary Patch a Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiPatchNonEmployeeSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public patchNonEmployeeSource(requestParameters: NonEmployeeLifecycleManagementApiPatchNonEmployeeSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).patchNonEmployeeSource(requestParameters.sourceId, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will reject an approval item request and notify user. The current user must be the requested approver.
     * @summary Reject a Non-Employee Request
     * @param {NonEmployeeLifecycleManagementApiRejectNonEmployeeRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public rejectNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementApiRejectNonEmployeeRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).rejectNonEmployeeRequest(requestParameters.id, requestParameters.nonEmployeeRejectApprovalDecision, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will update a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
     * @summary Update Non-Employee Record
     * @param {NonEmployeeLifecycleManagementApiUpdateNonEmployeeRecordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public updateNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementApiUpdateNonEmployeeRecordRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).updateNonEmployeeRecord(requestParameters.id, requestParameters.nonEmployeeRequestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OAuthClientsApi - axios parameter creator
 * @export
 */
export const OAuthClientsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This creates an OAuth client.
         * @summary Create OAuth Client
         * @param {CreateOAuthClientRequest} createOAuthClientRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createOauthClient: async (createOAuthClientRequest: CreateOAuthClientRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOAuthClientRequest' is not null or undefined
            assertParamExists('createOauthClient', 'createOAuthClientRequest', createOAuthClientRequest)
            const localVarPath = `/oauth-clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOAuthClientRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This deletes an OAuth client.
         * @summary Delete OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteOauthClient: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOauthClient', 'id', id)
            const localVarPath = `/oauth-clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets details of an OAuth client.
         * @summary Get OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getOauthClient: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOauthClient', 'id', id)
            const localVarPath = `/oauth-clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a list of OAuth clients.
         * @summary List OAuth Clients
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listOauthClients: async (filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth-clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This performs a targeted update to the field(s) of an OAuth client.
         * @summary Patch OAuth Client
         * @param {string} id The OAuth client id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * tenant * businessName * homepageUrl * name * description * accessTokenValiditySeconds * refreshTokenValiditySeconds * redirectUris * grantTypes * accessType * enabled * strongAuthSupported * claimsSupported 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchOauthClient: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchOauthClient', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchOauthClient', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/oauth-clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * OAuthClientsApi - functional programming interface
 * @export
 */
export const OAuthClientsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OAuthClientsApiAxiosParamCreator(configuration)
    return {
        /**
         * This creates an OAuth client.
         * @summary Create OAuth Client
         * @param {CreateOAuthClientRequest} createOAuthClientRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createOauthClient(createOAuthClientRequest: CreateOAuthClientRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOAuthClientResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOauthClient(createOAuthClientRequest, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OAuthClientsApi.createOauthClient']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This deletes an OAuth client.
         * @summary Delete OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOauthClient(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOauthClient(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OAuthClientsApi.deleteOauthClient']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This gets details of an OAuth client.
         * @summary Get OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getOauthClient(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOAuthClientResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOauthClient(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OAuthClientsApi.getOauthClient']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This gets a list of OAuth clients.
         * @summary List OAuth Clients
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listOauthClients(filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOAuthClientResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOauthClients(filters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OAuthClientsApi.listOauthClients']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This performs a targeted update to the field(s) of an OAuth client.
         * @summary Patch OAuth Client
         * @param {string} id The OAuth client id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * tenant * businessName * homepageUrl * name * description * accessTokenValiditySeconds * refreshTokenValiditySeconds * redirectUris * grantTypes * accessType * enabled * strongAuthSupported * claimsSupported 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchOauthClient(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOAuthClientResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchOauthClient(id, jsonPatchOperation, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OAuthClientsApi.patchOauthClient']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OAuthClientsApi - factory interface
 * @export
 */
export const OAuthClientsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OAuthClientsApiFp(configuration)
    return {
        /**
         * This creates an OAuth client.
         * @summary Create OAuth Client
         * @param {OAuthClientsApiCreateOauthClientRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        createOauthClient(requestParameters: OAuthClientsApiCreateOauthClientRequest, options?: AxiosRequestConfig): AxiosPromise<CreateOAuthClientResponse> {
            return localVarFp.createOauthClient(requestParameters.createOAuthClientRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This deletes an OAuth client.
         * @summary Delete OAuth Client
         * @param {OAuthClientsApiDeleteOauthClientRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteOauthClient(requestParameters: OAuthClientsApiDeleteOauthClientRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteOauthClient(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This gets details of an OAuth client.
         * @summary Get OAuth Client
         * @param {OAuthClientsApiGetOauthClientRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getOauthClient(requestParameters: OAuthClientsApiGetOauthClientRequest, options?: AxiosRequestConfig): AxiosPromise<GetOAuthClientResponse> {
            return localVarFp.getOauthClient(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This gets a list of OAuth clients.
         * @summary List OAuth Clients
         * @param {OAuthClientsApiListOauthClientsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listOauthClients(requestParameters: OAuthClientsApiListOauthClientsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<GetOAuthClientResponse>> {
            return localVarFp.listOauthClients(requestParameters.filters, options).then((request) => request(axios, basePath));
        },
        /**
         * This performs a targeted update to the field(s) of an OAuth client.
         * @summary Patch OAuth Client
         * @param {OAuthClientsApiPatchOauthClientRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        patchOauthClient(requestParameters: OAuthClientsApiPatchOauthClientRequest, options?: AxiosRequestConfig): AxiosPromise<GetOAuthClientResponse> {
            return localVarFp.patchOauthClient(requestParameters.id, requestParameters.jsonPatchOperation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createOauthClient operation in OAuthClientsApi.
 * @export
 * @interface OAuthClientsApiCreateOauthClientRequest
 */
export interface OAuthClientsApiCreateOauthClientRequest {
    /**
     * 
     * @type {CreateOAuthClientRequest}
     * @memberof OAuthClientsApiCreateOauthClient
     */
    readonly createOAuthClientRequest: CreateOAuthClientRequest
}

/**
 * Request parameters for deleteOauthClient operation in OAuthClientsApi.
 * @export
 * @interface OAuthClientsApiDeleteOauthClientRequest
 */
export interface OAuthClientsApiDeleteOauthClientRequest {
    /**
     * The OAuth client id
     * @type {string}
     * @memberof OAuthClientsApiDeleteOauthClient
     */
    readonly id: string
}

/**
 * Request parameters for getOauthClient operation in OAuthClientsApi.
 * @export
 * @interface OAuthClientsApiGetOauthClientRequest
 */
export interface OAuthClientsApiGetOauthClientRequest {
    /**
     * The OAuth client id
     * @type {string}
     * @memberof OAuthClientsApiGetOauthClient
     */
    readonly id: string
}

/**
 * Request parameters for listOauthClients operation in OAuthClientsApi.
 * @export
 * @interface OAuthClientsApiListOauthClientsRequest
 */
export interface OAuthClientsApiListOauthClientsRequest {
    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
     * @type {string}
     * @memberof OAuthClientsApiListOauthClients
     */
    readonly filters?: string
}

/**
 * Request parameters for patchOauthClient operation in OAuthClientsApi.
 * @export
 * @interface OAuthClientsApiPatchOauthClientRequest
 */
export interface OAuthClientsApiPatchOauthClientRequest {
    /**
     * The OAuth client id
     * @type {string}
     * @memberof OAuthClientsApiPatchOauthClient
     */
    readonly id: string

    /**
     * A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * tenant * businessName * homepageUrl * name * description * accessTokenValiditySeconds * refreshTokenValiditySeconds * redirectUris * grantTypes * accessType * enabled * strongAuthSupported * claimsSupported 
     * @type {Array<JsonPatchOperation>}
     * @memberof OAuthClientsApiPatchOauthClient
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * OAuthClientsApi - object-oriented interface
 * @export
 * @class OAuthClientsApi
 * @extends {BaseAPI}
 */
export class OAuthClientsApi extends BaseAPI {
    /**
     * This creates an OAuth client.
     * @summary Create OAuth Client
     * @param {OAuthClientsApiCreateOauthClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsApi
     */
    public createOauthClient(requestParameters: OAuthClientsApiCreateOauthClientRequest, axiosOptions?: AxiosRequestConfig) {
        return OAuthClientsApiFp(this.configuration).createOauthClient(requestParameters.createOAuthClientRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes an OAuth client.
     * @summary Delete OAuth Client
     * @param {OAuthClientsApiDeleteOauthClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsApi
     */
    public deleteOauthClient(requestParameters: OAuthClientsApiDeleteOauthClientRequest, axiosOptions?: AxiosRequestConfig) {
        return OAuthClientsApiFp(this.configuration).deleteOauthClient(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets details of an OAuth client.
     * @summary Get OAuth Client
     * @param {OAuthClientsApiGetOauthClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsApi
     */
    public getOauthClient(requestParameters: OAuthClientsApiGetOauthClientRequest, axiosOptions?: AxiosRequestConfig) {
        return OAuthClientsApiFp(this.configuration).getOauthClient(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a list of OAuth clients.
     * @summary List OAuth Clients
     * @param {OAuthClientsApiListOauthClientsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsApi
     */
    public listOauthClients(requestParameters: OAuthClientsApiListOauthClientsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return OAuthClientsApiFp(this.configuration).listOauthClients(requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This performs a targeted update to the field(s) of an OAuth client.
     * @summary Patch OAuth Client
     * @param {OAuthClientsApiPatchOauthClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsApi
     */
    public patchOauthClient(requestParameters: OAuthClientsApiPatchOauthClientRequest, axiosOptions?: AxiosRequestConfig) {
        return OAuthClientsApiFp(this.configuration).patchOauthClient(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PasswordConfigurationApi - axios parameter creator
 * @export
 */
export const PasswordConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates the password org config. Unspecified fields will use default value. To be able to use the custom password instructions, you must set the `customInstructionsEnabled` field to \"true\". Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Create Password Org Config
         * @param {PasswordOrgConfig} passwordOrgConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPasswordOrgConfig: async (passwordOrgConfig: PasswordOrgConfig, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordOrgConfig' is not null or undefined
            assertParamExists('createPasswordOrgConfig', 'passwordOrgConfig', passwordOrgConfig)
            const localVarPath = `/password-org-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordOrgConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the password org config . Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:read\'
         * @summary Get Password Org Config
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordOrgConfig: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/password-org-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates the password org config for specified fields. Other fields will keep original value. You must set the `customInstructionsEnabled` field to \"true\" to be able to use custom password instructions.  Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Update Password Org Config
         * @param {PasswordOrgConfig} passwordOrgConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putPasswordOrgConfig: async (passwordOrgConfig: PasswordOrgConfig, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordOrgConfig' is not null or undefined
            assertParamExists('putPasswordOrgConfig', 'passwordOrgConfig', passwordOrgConfig)
            const localVarPath = `/password-org-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordOrgConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasswordConfigurationApi - functional programming interface
 * @export
 */
export const PasswordConfigurationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasswordConfigurationApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates the password org config. Unspecified fields will use default value. To be able to use the custom password instructions, you must set the `customInstructionsEnabled` field to \"true\". Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Create Password Org Config
         * @param {PasswordOrgConfig} passwordOrgConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createPasswordOrgConfig(passwordOrgConfig: PasswordOrgConfig, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordOrgConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPasswordOrgConfig(passwordOrgConfig, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PasswordConfigurationApi.createPasswordOrgConfig']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API returns the password org config . Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:read\'
         * @summary Get Password Org Config
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPasswordOrgConfig(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordOrgConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordOrgConfig(axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PasswordConfigurationApi.getPasswordOrgConfig']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API updates the password org config for specified fields. Other fields will keep original value. You must set the `customInstructionsEnabled` field to \"true\" to be able to use custom password instructions.  Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Update Password Org Config
         * @param {PasswordOrgConfig} passwordOrgConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putPasswordOrgConfig(passwordOrgConfig: PasswordOrgConfig, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordOrgConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putPasswordOrgConfig(passwordOrgConfig, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PasswordConfigurationApi.putPasswordOrgConfig']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PasswordConfigurationApi - factory interface
 * @export
 */
export const PasswordConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasswordConfigurationApiFp(configuration)
    return {
        /**
         * This API creates the password org config. Unspecified fields will use default value. To be able to use the custom password instructions, you must set the `customInstructionsEnabled` field to \"true\". Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Create Password Org Config
         * @param {PasswordConfigurationApiCreatePasswordOrgConfigRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        createPasswordOrgConfig(requestParameters: PasswordConfigurationApiCreatePasswordOrgConfigRequest, options?: AxiosRequestConfig): AxiosPromise<PasswordOrgConfig> {
            return localVarFp.createPasswordOrgConfig(requestParameters.passwordOrgConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the password org config . Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:read\'
         * @summary Get Password Org Config
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getPasswordOrgConfig(options?: AxiosRequestConfig): AxiosPromise<PasswordOrgConfig> {
            return localVarFp.getPasswordOrgConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * This API updates the password org config for specified fields. Other fields will keep original value. You must set the `customInstructionsEnabled` field to \"true\" to be able to use custom password instructions.  Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Update Password Org Config
         * @param {PasswordConfigurationApiPutPasswordOrgConfigRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        putPasswordOrgConfig(requestParameters: PasswordConfigurationApiPutPasswordOrgConfigRequest, options?: AxiosRequestConfig): AxiosPromise<PasswordOrgConfig> {
            return localVarFp.putPasswordOrgConfig(requestParameters.passwordOrgConfig, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPasswordOrgConfig operation in PasswordConfigurationApi.
 * @export
 * @interface PasswordConfigurationApiCreatePasswordOrgConfigRequest
 */
export interface PasswordConfigurationApiCreatePasswordOrgConfigRequest {
    /**
     * 
     * @type {PasswordOrgConfig}
     * @memberof PasswordConfigurationApiCreatePasswordOrgConfig
     */
    readonly passwordOrgConfig: PasswordOrgConfig
}

/**
 * Request parameters for putPasswordOrgConfig operation in PasswordConfigurationApi.
 * @export
 * @interface PasswordConfigurationApiPutPasswordOrgConfigRequest
 */
export interface PasswordConfigurationApiPutPasswordOrgConfigRequest {
    /**
     * 
     * @type {PasswordOrgConfig}
     * @memberof PasswordConfigurationApiPutPasswordOrgConfig
     */
    readonly passwordOrgConfig: PasswordOrgConfig
}

/**
 * PasswordConfigurationApi - object-oriented interface
 * @export
 * @class PasswordConfigurationApi
 * @extends {BaseAPI}
 */
export class PasswordConfigurationApi extends BaseAPI {
    /**
     * This API creates the password org config. Unspecified fields will use default value. To be able to use the custom password instructions, you must set the `customInstructionsEnabled` field to \"true\". Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
     * @summary Create Password Org Config
     * @param {PasswordConfigurationApiCreatePasswordOrgConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordConfigurationApi
     */
    public createPasswordOrgConfig(requestParameters: PasswordConfigurationApiCreatePasswordOrgConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordConfigurationApiFp(this.configuration).createPasswordOrgConfig(requestParameters.passwordOrgConfig, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the password org config . Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:read\'
     * @summary Get Password Org Config
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordConfigurationApi
     */
    public getPasswordOrgConfig(axiosOptions?: AxiosRequestConfig) {
        return PasswordConfigurationApiFp(this.configuration).getPasswordOrgConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates the password org config for specified fields. Other fields will keep original value. You must set the `customInstructionsEnabled` field to \"true\" to be able to use custom password instructions.  Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
     * @summary Update Password Org Config
     * @param {PasswordConfigurationApiPutPasswordOrgConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordConfigurationApi
     */
    public putPasswordOrgConfig(requestParameters: PasswordConfigurationApiPutPasswordOrgConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordConfigurationApiFp(this.configuration).putPasswordOrgConfig(requestParameters.passwordOrgConfig, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PasswordDictionaryApi - axios parameter creator
 * @export
 */
export const PasswordDictionaryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This gets password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Dictionary
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordDictionary: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/password-dictionary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This updates password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Password Dictionary
         * @param {File} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePasswordDictionary: async (file?: File, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/password-dictionary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasswordDictionaryApi - functional programming interface
 * @export
 */
export const PasswordDictionaryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasswordDictionaryApiAxiosParamCreator(configuration)
    return {
        /**
         * This gets password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Dictionary
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPasswordDictionary(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordDictionary(axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PasswordDictionaryApi.getPasswordDictionary']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This updates password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Password Dictionary
         * @param {File} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updatePasswordDictionary(file?: File, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePasswordDictionary(file, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PasswordDictionaryApi.updatePasswordDictionary']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PasswordDictionaryApi - factory interface
 * @export
 */
export const PasswordDictionaryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasswordDictionaryApiFp(configuration)
    return {
        /**
         * This gets password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Dictionary
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getPasswordDictionary(options?: AxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getPasswordDictionary(options).then((request) => request(axios, basePath));
        },
        /**
         * This updates password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Password Dictionary
         * @param {PasswordDictionaryApiUpdatePasswordDictionaryRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        updatePasswordDictionary(requestParameters: PasswordDictionaryApiUpdatePasswordDictionaryRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updatePasswordDictionary(requestParameters.file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for updatePasswordDictionary operation in PasswordDictionaryApi.
 * @export
 * @interface PasswordDictionaryApiUpdatePasswordDictionaryRequest
 */
export interface PasswordDictionaryApiUpdatePasswordDictionaryRequest {
    /**
     * 
     * @type {File}
     * @memberof PasswordDictionaryApiUpdatePasswordDictionary
     */
    readonly file?: File
}

/**
 * PasswordDictionaryApi - object-oriented interface
 * @export
 * @class PasswordDictionaryApi
 * @extends {BaseAPI}
 */
export class PasswordDictionaryApi extends BaseAPI {
    /**
     * This gets password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API.
     * @summary Get Password Dictionary
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordDictionaryApi
     */
    public getPasswordDictionary(axiosOptions?: AxiosRequestConfig) {
        return PasswordDictionaryApiFp(this.configuration).getPasswordDictionary(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This updates password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API.
     * @summary Update Password Dictionary
     * @param {PasswordDictionaryApiUpdatePasswordDictionaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordDictionaryApi
     */
    public updatePasswordDictionary(requestParameters: PasswordDictionaryApiUpdatePasswordDictionaryRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return PasswordDictionaryApiFp(this.configuration).updatePasswordDictionary(requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PasswordManagementApi - axios parameter creator
 * @export
 */
export const PasswordManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API returns the status of a password change request. A token with identity owner or trusted API client application authority is required to call this API.
         * @summary Get Password Change Request Status
         * @param {string} id Password change request ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordChangeStatus: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPasswordChangeStatus', 'id', id)
            const localVarPath = `/password-change-status/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API is used to query password related information.   A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow)  is required to call this API.  \"API authority\" refers to a token that only has the \"client_credentials\"  grant type, and therefore no user context. A [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens)  or a token generated with the [authorization_code](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow)  grant type will **NOT** work on this endpoint, and a `403 Forbidden` response  will be returned. 
         * @summary Query Password Info
         * @param {PasswordInfoQueryDTO} passwordInfoQueryDTO 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        queryPasswordInfo: async (passwordInfoQueryDTO: PasswordInfoQueryDTO, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordInfoQueryDTO' is not null or undefined
            assertParamExists('queryPasswordInfo', 'passwordInfoQueryDTO', passwordInfoQueryDTO)
            const localVarPath = `/query-password-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordInfoQueryDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API is used to set a password for an identity.   An identity can change their own password (as well as any of their accounts\' passwords) if they use a token generated by their IDN user, such as a [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens) or [\"authorization_code\" derived OAuth token](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow).  A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow) can be used to change **any** identity\'s password or the password of any of the identity\'s accounts.  \"API authority\" refers to a token that only has the \"client_credentials\" grant type.  You can use this endpoint to generate an `encryptedPassword` (RSA encrypted using publicKey).  To do so, follow these steps:  1. Use [Query Password Info](https://developer.sailpoint.com/idn/api/v3/query-password-info) to get the following information: `identityId`, `sourceId`, `publicKeyId`, `publicKey`, `accounts`, and `policies`.   2. Choose an account from the previous response that you will provide as an `accountId` in your request to set an encrypted password.   3. Use [Set Identity\'s Password](https://developer.sailpoint.com/idn/api/v3/set-password) and provide the information you got from your earlier query. Then add this code to your request to get the encrypted password:  ```java import javax.crypto.Cipher; import java.security.KeyFactory; import java.security.PublicKey; import java.security.spec.X509EncodedKeySpec; import java util.Base64;  String encrypt(String publicKey, String toEncrypt) throws Exception {   byte[] publicKeyBytes = Base64.getDecoder().decode(publicKey);   byte[] encryptedBytes = encryptRsa(publicKeyBytes, toEncrypt.getBytes(\"UTF-8\"));   return Base64.getEncoder().encodeToString(encryptedBytes); }  private byte[] encryptRsa(byte[] publicKeyBytes, byte[] toEncryptBytes) throws Exception {   PublicKey key = KeyFactory.getInstance(\"RSA\").generatePublic(new X509EncodedKeySpec(publicKeyBytes));   String transformation = \"RSA/ECB/PKCS1Padding\";   Cipher cipher = Cipher.getInstance(transformation);   cipher.init(1, key);   return cipher.doFinal(toEncryptBytes); } ```      In this example, `toEncrypt` refers to the plain text password you are setting and then encrypting, and the `publicKey` refers to the publicKey you got from the first request you sent.   You can then use [Get Password Change Request Status](https://developer.sailpoint.com/idn/api/v3/get-password-change-status) to check the password change request status. To do so, you must provide the `requestId` from your earlier request to set the password.  
         * @summary Set Identity\'s Password
         * @param {PasswordChangeRequest} passwordChangeRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setPassword: async (passwordChangeRequest: PasswordChangeRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordChangeRequest' is not null or undefined
            assertParamExists('setPassword', 'passwordChangeRequest', passwordChangeRequest)
            const localVarPath = `/set-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordChangeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasswordManagementApi - functional programming interface
 * @export
 */
export const PasswordManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasswordManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * This API returns the status of a password change request. A token with identity owner or trusted API client application authority is required to call this API.
         * @summary Get Password Change Request Status
         * @param {string} id Password change request ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPasswordChangeStatus(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordChangeStatus(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PasswordManagementApi.getPasswordChangeStatus']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API is used to query password related information.   A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow)  is required to call this API.  \"API authority\" refers to a token that only has the \"client_credentials\"  grant type, and therefore no user context. A [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens)  or a token generated with the [authorization_code](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow)  grant type will **NOT** work on this endpoint, and a `403 Forbidden` response  will be returned. 
         * @summary Query Password Info
         * @param {PasswordInfoQueryDTO} passwordInfoQueryDTO 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async queryPasswordInfo(passwordInfoQueryDTO: PasswordInfoQueryDTO, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryPasswordInfo(passwordInfoQueryDTO, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PasswordManagementApi.queryPasswordInfo']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API is used to set a password for an identity.   An identity can change their own password (as well as any of their accounts\' passwords) if they use a token generated by their IDN user, such as a [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens) or [\"authorization_code\" derived OAuth token](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow).  A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow) can be used to change **any** identity\'s password or the password of any of the identity\'s accounts.  \"API authority\" refers to a token that only has the \"client_credentials\" grant type.  You can use this endpoint to generate an `encryptedPassword` (RSA encrypted using publicKey).  To do so, follow these steps:  1. Use [Query Password Info](https://developer.sailpoint.com/idn/api/v3/query-password-info) to get the following information: `identityId`, `sourceId`, `publicKeyId`, `publicKey`, `accounts`, and `policies`.   2. Choose an account from the previous response that you will provide as an `accountId` in your request to set an encrypted password.   3. Use [Set Identity\'s Password](https://developer.sailpoint.com/idn/api/v3/set-password) and provide the information you got from your earlier query. Then add this code to your request to get the encrypted password:  ```java import javax.crypto.Cipher; import java.security.KeyFactory; import java.security.PublicKey; import java.security.spec.X509EncodedKeySpec; import java util.Base64;  String encrypt(String publicKey, String toEncrypt) throws Exception {   byte[] publicKeyBytes = Base64.getDecoder().decode(publicKey);   byte[] encryptedBytes = encryptRsa(publicKeyBytes, toEncrypt.getBytes(\"UTF-8\"));   return Base64.getEncoder().encodeToString(encryptedBytes); }  private byte[] encryptRsa(byte[] publicKeyBytes, byte[] toEncryptBytes) throws Exception {   PublicKey key = KeyFactory.getInstance(\"RSA\").generatePublic(new X509EncodedKeySpec(publicKeyBytes));   String transformation = \"RSA/ECB/PKCS1Padding\";   Cipher cipher = Cipher.getInstance(transformation);   cipher.init(1, key);   return cipher.doFinal(toEncryptBytes); } ```      In this example, `toEncrypt` refers to the plain text password you are setting and then encrypting, and the `publicKey` refers to the publicKey you got from the first request you sent.   You can then use [Get Password Change Request Status](https://developer.sailpoint.com/idn/api/v3/get-password-change-status) to check the password change request status. To do so, you must provide the `requestId` from your earlier request to set the password.  
         * @summary Set Identity\'s Password
         * @param {PasswordChangeRequest} passwordChangeRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setPassword(passwordChangeRequest: PasswordChangeRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordChangeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPassword(passwordChangeRequest, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PasswordManagementApi.setPassword']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PasswordManagementApi - factory interface
 * @export
 */
export const PasswordManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasswordManagementApiFp(configuration)
    return {
        /**
         * This API returns the status of a password change request. A token with identity owner or trusted API client application authority is required to call this API.
         * @summary Get Password Change Request Status
         * @param {PasswordManagementApiGetPasswordChangeStatusRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getPasswordChangeStatus(requestParameters: PasswordManagementApiGetPasswordChangeStatusRequest, options?: AxiosRequestConfig): AxiosPromise<PasswordStatus> {
            return localVarFp.getPasswordChangeStatus(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This API is used to query password related information.   A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow)  is required to call this API.  \"API authority\" refers to a token that only has the \"client_credentials\"  grant type, and therefore no user context. A [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens)  or a token generated with the [authorization_code](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow)  grant type will **NOT** work on this endpoint, and a `403 Forbidden` response  will be returned. 
         * @summary Query Password Info
         * @param {PasswordManagementApiQueryPasswordInfoRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        queryPasswordInfo(requestParameters: PasswordManagementApiQueryPasswordInfoRequest, options?: AxiosRequestConfig): AxiosPromise<PasswordInfo> {
            return localVarFp.queryPasswordInfo(requestParameters.passwordInfoQueryDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * This API is used to set a password for an identity.   An identity can change their own password (as well as any of their accounts\' passwords) if they use a token generated by their IDN user, such as a [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens) or [\"authorization_code\" derived OAuth token](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow).  A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow) can be used to change **any** identity\'s password or the password of any of the identity\'s accounts.  \"API authority\" refers to a token that only has the \"client_credentials\" grant type.  You can use this endpoint to generate an `encryptedPassword` (RSA encrypted using publicKey).  To do so, follow these steps:  1. Use [Query Password Info](https://developer.sailpoint.com/idn/api/v3/query-password-info) to get the following information: `identityId`, `sourceId`, `publicKeyId`, `publicKey`, `accounts`, and `policies`.   2. Choose an account from the previous response that you will provide as an `accountId` in your request to set an encrypted password.   3. Use [Set Identity\'s Password](https://developer.sailpoint.com/idn/api/v3/set-password) and provide the information you got from your earlier query. Then add this code to your request to get the encrypted password:  ```java import javax.crypto.Cipher; import java.security.KeyFactory; import java.security.PublicKey; import java.security.spec.X509EncodedKeySpec; import java util.Base64;  String encrypt(String publicKey, String toEncrypt) throws Exception {   byte[] publicKeyBytes = Base64.getDecoder().decode(publicKey);   byte[] encryptedBytes = encryptRsa(publicKeyBytes, toEncrypt.getBytes(\"UTF-8\"));   return Base64.getEncoder().encodeToString(encryptedBytes); }  private byte[] encryptRsa(byte[] publicKeyBytes, byte[] toEncryptBytes) throws Exception {   PublicKey key = KeyFactory.getInstance(\"RSA\").generatePublic(new X509EncodedKeySpec(publicKeyBytes));   String transformation = \"RSA/ECB/PKCS1Padding\";   Cipher cipher = Cipher.getInstance(transformation);   cipher.init(1, key);   return cipher.doFinal(toEncryptBytes); } ```      In this example, `toEncrypt` refers to the plain text password you are setting and then encrypting, and the `publicKey` refers to the publicKey you got from the first request you sent.   You can then use [Get Password Change Request Status](https://developer.sailpoint.com/idn/api/v3/get-password-change-status) to check the password change request status. To do so, you must provide the `requestId` from your earlier request to set the password.  
         * @summary Set Identity\'s Password
         * @param {PasswordManagementApiSetPasswordRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        setPassword(requestParameters: PasswordManagementApiSetPasswordRequest, options?: AxiosRequestConfig): AxiosPromise<PasswordChangeResponse> {
            return localVarFp.setPassword(requestParameters.passwordChangeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getPasswordChangeStatus operation in PasswordManagementApi.
 * @export
 * @interface PasswordManagementApiGetPasswordChangeStatusRequest
 */
export interface PasswordManagementApiGetPasswordChangeStatusRequest {
    /**
     * Password change request ID
     * @type {string}
     * @memberof PasswordManagementApiGetPasswordChangeStatus
     */
    readonly id: string
}

/**
 * Request parameters for queryPasswordInfo operation in PasswordManagementApi.
 * @export
 * @interface PasswordManagementApiQueryPasswordInfoRequest
 */
export interface PasswordManagementApiQueryPasswordInfoRequest {
    /**
     * 
     * @type {PasswordInfoQueryDTO}
     * @memberof PasswordManagementApiQueryPasswordInfo
     */
    readonly passwordInfoQueryDTO: PasswordInfoQueryDTO
}

/**
 * Request parameters for setPassword operation in PasswordManagementApi.
 * @export
 * @interface PasswordManagementApiSetPasswordRequest
 */
export interface PasswordManagementApiSetPasswordRequest {
    /**
     * 
     * @type {PasswordChangeRequest}
     * @memberof PasswordManagementApiSetPassword
     */
    readonly passwordChangeRequest: PasswordChangeRequest
}

/**
 * PasswordManagementApi - object-oriented interface
 * @export
 * @class PasswordManagementApi
 * @extends {BaseAPI}
 */
export class PasswordManagementApi extends BaseAPI {
    /**
     * This API returns the status of a password change request. A token with identity owner or trusted API client application authority is required to call this API.
     * @summary Get Password Change Request Status
     * @param {PasswordManagementApiGetPasswordChangeStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordManagementApi
     */
    public getPasswordChangeStatus(requestParameters: PasswordManagementApiGetPasswordChangeStatusRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordManagementApiFp(this.configuration).getPasswordChangeStatus(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API is used to query password related information.   A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow)  is required to call this API.  \"API authority\" refers to a token that only has the \"client_credentials\"  grant type, and therefore no user context. A [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens)  or a token generated with the [authorization_code](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow)  grant type will **NOT** work on this endpoint, and a `403 Forbidden` response  will be returned. 
     * @summary Query Password Info
     * @param {PasswordManagementApiQueryPasswordInfoRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordManagementApi
     */
    public queryPasswordInfo(requestParameters: PasswordManagementApiQueryPasswordInfoRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordManagementApiFp(this.configuration).queryPasswordInfo(requestParameters.passwordInfoQueryDTO, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API is used to set a password for an identity.   An identity can change their own password (as well as any of their accounts\' passwords) if they use a token generated by their IDN user, such as a [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens) or [\"authorization_code\" derived OAuth token](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow).  A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow) can be used to change **any** identity\'s password or the password of any of the identity\'s accounts.  \"API authority\" refers to a token that only has the \"client_credentials\" grant type.  You can use this endpoint to generate an `encryptedPassword` (RSA encrypted using publicKey).  To do so, follow these steps:  1. Use [Query Password Info](https://developer.sailpoint.com/idn/api/v3/query-password-info) to get the following information: `identityId`, `sourceId`, `publicKeyId`, `publicKey`, `accounts`, and `policies`.   2. Choose an account from the previous response that you will provide as an `accountId` in your request to set an encrypted password.   3. Use [Set Identity\'s Password](https://developer.sailpoint.com/idn/api/v3/set-password) and provide the information you got from your earlier query. Then add this code to your request to get the encrypted password:  ```java import javax.crypto.Cipher; import java.security.KeyFactory; import java.security.PublicKey; import java.security.spec.X509EncodedKeySpec; import java util.Base64;  String encrypt(String publicKey, String toEncrypt) throws Exception {   byte[] publicKeyBytes = Base64.getDecoder().decode(publicKey);   byte[] encryptedBytes = encryptRsa(publicKeyBytes, toEncrypt.getBytes(\"UTF-8\"));   return Base64.getEncoder().encodeToString(encryptedBytes); }  private byte[] encryptRsa(byte[] publicKeyBytes, byte[] toEncryptBytes) throws Exception {   PublicKey key = KeyFactory.getInstance(\"RSA\").generatePublic(new X509EncodedKeySpec(publicKeyBytes));   String transformation = \"RSA/ECB/PKCS1Padding\";   Cipher cipher = Cipher.getInstance(transformation);   cipher.init(1, key);   return cipher.doFinal(toEncryptBytes); } ```      In this example, `toEncrypt` refers to the plain text password you are setting and then encrypting, and the `publicKey` refers to the publicKey you got from the first request you sent.   You can then use [Get Password Change Request Status](https://developer.sailpoint.com/idn/api/v3/get-password-change-status) to check the password change request status. To do so, you must provide the `requestId` from your earlier request to set the password.  
     * @summary Set Identity\'s Password
     * @param {PasswordManagementApiSetPasswordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordManagementApi
     */
    public setPassword(requestParameters: PasswordManagementApiSetPasswordRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordManagementApiFp(this.configuration).setPassword(requestParameters.passwordChangeRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PasswordSyncGroupsApi - axios parameter creator
 * @export
 */
export const PasswordSyncGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates a password sync group based on the specifications provided. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Password Sync Group
         * @param {PasswordSyncGroup} passwordSyncGroup 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPasswordSyncGroup: async (passwordSyncGroup: PasswordSyncGroup, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordSyncGroup' is not null or undefined
            assertParamExists('createPasswordSyncGroup', 'passwordSyncGroup', passwordSyncGroup)
            const localVarPath = `/password-sync-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordSyncGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API deletes the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Password Sync Group by ID
         * @param {string} id The ID of password sync group to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePasswordSyncGroup: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePasswordSyncGroup', 'id', id)
            const localVarPath = `/password-sync-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the sync group for the specified ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Sync Group by ID
         * @param {string} id The ID of password sync group to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordSyncGroup: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPasswordSyncGroup', 'id', id)
            const localVarPath = `/password-sync-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of password sync groups. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Sync Group List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordSyncGroups: async (limit?: number, offset?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/password-sync-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Password Sync Group by ID
         * @param {string} id The ID of password sync group to update.
         * @param {PasswordSyncGroup} passwordSyncGroup 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePasswordSyncGroup: async (id: string, passwordSyncGroup: PasswordSyncGroup, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePasswordSyncGroup', 'id', id)
            // verify required parameter 'passwordSyncGroup' is not null or undefined
            assertParamExists('updatePasswordSyncGroup', 'passwordSyncGroup', passwordSyncGroup)
            const localVarPath = `/password-sync-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordSyncGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasswordSyncGroupsApi - functional programming interface
 * @export
 */
export const PasswordSyncGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasswordSyncGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates a password sync group based on the specifications provided. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Password Sync Group
         * @param {PasswordSyncGroup} passwordSyncGroup 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createPasswordSyncGroup(passwordSyncGroup: PasswordSyncGroup, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordSyncGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPasswordSyncGroup(passwordSyncGroup, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PasswordSyncGroupsApi.createPasswordSyncGroup']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API deletes the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Password Sync Group by ID
         * @param {string} id The ID of password sync group to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deletePasswordSyncGroup(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePasswordSyncGroup(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PasswordSyncGroupsApi.deletePasswordSyncGroup']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API returns the sync group for the specified ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Sync Group by ID
         * @param {string} id The ID of password sync group to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPasswordSyncGroup(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordSyncGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordSyncGroup(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PasswordSyncGroupsApi.getPasswordSyncGroup']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API returns a list of password sync groups. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Sync Group List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPasswordSyncGroups(limit?: number, offset?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PasswordSyncGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordSyncGroups(limit, offset, count, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PasswordSyncGroupsApi.getPasswordSyncGroups']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API updates the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Password Sync Group by ID
         * @param {string} id The ID of password sync group to update.
         * @param {PasswordSyncGroup} passwordSyncGroup 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updatePasswordSyncGroup(id: string, passwordSyncGroup: PasswordSyncGroup, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordSyncGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePasswordSyncGroup(id, passwordSyncGroup, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PasswordSyncGroupsApi.updatePasswordSyncGroup']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PasswordSyncGroupsApi - factory interface
 * @export
 */
export const PasswordSyncGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasswordSyncGroupsApiFp(configuration)
    return {
        /**
         * This API creates a password sync group based on the specifications provided. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Password Sync Group
         * @param {PasswordSyncGroupsApiCreatePasswordSyncGroupRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        createPasswordSyncGroup(requestParameters: PasswordSyncGroupsApiCreatePasswordSyncGroupRequest, options?: AxiosRequestConfig): AxiosPromise<PasswordSyncGroup> {
            return localVarFp.createPasswordSyncGroup(requestParameters.passwordSyncGroup, options).then((request) => request(axios, basePath));
        },
        /**
         * This API deletes the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Password Sync Group by ID
         * @param {PasswordSyncGroupsApiDeletePasswordSyncGroupRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deletePasswordSyncGroup(requestParameters: PasswordSyncGroupsApiDeletePasswordSyncGroupRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePasswordSyncGroup(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the sync group for the specified ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Sync Group by ID
         * @param {PasswordSyncGroupsApiGetPasswordSyncGroupRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getPasswordSyncGroup(requestParameters: PasswordSyncGroupsApiGetPasswordSyncGroupRequest, options?: AxiosRequestConfig): AxiosPromise<PasswordSyncGroup> {
            return localVarFp.getPasswordSyncGroup(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of password sync groups. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Sync Group List
         * @param {PasswordSyncGroupsApiGetPasswordSyncGroupsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getPasswordSyncGroups(requestParameters: PasswordSyncGroupsApiGetPasswordSyncGroupsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<PasswordSyncGroup>> {
            return localVarFp.getPasswordSyncGroups(requestParameters.limit, requestParameters.offset, requestParameters.count, options).then((request) => request(axios, basePath));
        },
        /**
         * This API updates the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Password Sync Group by ID
         * @param {PasswordSyncGroupsApiUpdatePasswordSyncGroupRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        updatePasswordSyncGroup(requestParameters: PasswordSyncGroupsApiUpdatePasswordSyncGroupRequest, options?: AxiosRequestConfig): AxiosPromise<PasswordSyncGroup> {
            return localVarFp.updatePasswordSyncGroup(requestParameters.id, requestParameters.passwordSyncGroup, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPasswordSyncGroup operation in PasswordSyncGroupsApi.
 * @export
 * @interface PasswordSyncGroupsApiCreatePasswordSyncGroupRequest
 */
export interface PasswordSyncGroupsApiCreatePasswordSyncGroupRequest {
    /**
     * 
     * @type {PasswordSyncGroup}
     * @memberof PasswordSyncGroupsApiCreatePasswordSyncGroup
     */
    readonly passwordSyncGroup: PasswordSyncGroup
}

/**
 * Request parameters for deletePasswordSyncGroup operation in PasswordSyncGroupsApi.
 * @export
 * @interface PasswordSyncGroupsApiDeletePasswordSyncGroupRequest
 */
export interface PasswordSyncGroupsApiDeletePasswordSyncGroupRequest {
    /**
     * The ID of password sync group to delete.
     * @type {string}
     * @memberof PasswordSyncGroupsApiDeletePasswordSyncGroup
     */
    readonly id: string
}

/**
 * Request parameters for getPasswordSyncGroup operation in PasswordSyncGroupsApi.
 * @export
 * @interface PasswordSyncGroupsApiGetPasswordSyncGroupRequest
 */
export interface PasswordSyncGroupsApiGetPasswordSyncGroupRequest {
    /**
     * The ID of password sync group to retrieve.
     * @type {string}
     * @memberof PasswordSyncGroupsApiGetPasswordSyncGroup
     */
    readonly id: string
}

/**
 * Request parameters for getPasswordSyncGroups operation in PasswordSyncGroupsApi.
 * @export
 * @interface PasswordSyncGroupsApiGetPasswordSyncGroupsRequest
 */
export interface PasswordSyncGroupsApiGetPasswordSyncGroupsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof PasswordSyncGroupsApiGetPasswordSyncGroups
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof PasswordSyncGroupsApiGetPasswordSyncGroups
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof PasswordSyncGroupsApiGetPasswordSyncGroups
     */
    readonly count?: boolean
}

/**
 * Request parameters for updatePasswordSyncGroup operation in PasswordSyncGroupsApi.
 * @export
 * @interface PasswordSyncGroupsApiUpdatePasswordSyncGroupRequest
 */
export interface PasswordSyncGroupsApiUpdatePasswordSyncGroupRequest {
    /**
     * The ID of password sync group to update.
     * @type {string}
     * @memberof PasswordSyncGroupsApiUpdatePasswordSyncGroup
     */
    readonly id: string

    /**
     * 
     * @type {PasswordSyncGroup}
     * @memberof PasswordSyncGroupsApiUpdatePasswordSyncGroup
     */
    readonly passwordSyncGroup: PasswordSyncGroup
}

/**
 * PasswordSyncGroupsApi - object-oriented interface
 * @export
 * @class PasswordSyncGroupsApi
 * @extends {BaseAPI}
 */
export class PasswordSyncGroupsApi extends BaseAPI {
    /**
     * This API creates a password sync group based on the specifications provided. A token with ORG_ADMIN authority is required to call this API.
     * @summary Create Password Sync Group
     * @param {PasswordSyncGroupsApiCreatePasswordSyncGroupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordSyncGroupsApi
     */
    public createPasswordSyncGroup(requestParameters: PasswordSyncGroupsApiCreatePasswordSyncGroupRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordSyncGroupsApiFp(this.configuration).createPasswordSyncGroup(requestParameters.passwordSyncGroup, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API deletes the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
     * @summary Delete Password Sync Group by ID
     * @param {PasswordSyncGroupsApiDeletePasswordSyncGroupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordSyncGroupsApi
     */
    public deletePasswordSyncGroup(requestParameters: PasswordSyncGroupsApiDeletePasswordSyncGroupRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordSyncGroupsApiFp(this.configuration).deletePasswordSyncGroup(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the sync group for the specified ID. A token with ORG_ADMIN authority is required to call this API.
     * @summary Get Password Sync Group by ID
     * @param {PasswordSyncGroupsApiGetPasswordSyncGroupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordSyncGroupsApi
     */
    public getPasswordSyncGroup(requestParameters: PasswordSyncGroupsApiGetPasswordSyncGroupRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordSyncGroupsApiFp(this.configuration).getPasswordSyncGroup(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of password sync groups. A token with ORG_ADMIN authority is required to call this API.
     * @summary Get Password Sync Group List
     * @param {PasswordSyncGroupsApiGetPasswordSyncGroupsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordSyncGroupsApi
     */
    public getPasswordSyncGroups(requestParameters: PasswordSyncGroupsApiGetPasswordSyncGroupsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return PasswordSyncGroupsApiFp(this.configuration).getPasswordSyncGroups(requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
     * @summary Update Password Sync Group by ID
     * @param {PasswordSyncGroupsApiUpdatePasswordSyncGroupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordSyncGroupsApi
     */
    public updatePasswordSyncGroup(requestParameters: PasswordSyncGroupsApiUpdatePasswordSyncGroupRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordSyncGroupsApiFp(this.configuration).updatePasswordSyncGroup(requestParameters.id, requestParameters.passwordSyncGroup, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PersonalAccessTokensApi - axios parameter creator
 * @export
 */
export const PersonalAccessTokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This creates a personal access token.
         * @summary Create Personal Access Token
         * @param {CreatePersonalAccessTokenRequest} createPersonalAccessTokenRequest Name and scope of personal access token.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPersonalAccessToken: async (createPersonalAccessTokenRequest: CreatePersonalAccessTokenRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPersonalAccessTokenRequest' is not null or undefined
            assertParamExists('createPersonalAccessToken', 'createPersonalAccessTokenRequest', createPersonalAccessTokenRequest)
            const localVarPath = `/personal-access-tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPersonalAccessTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This deletes a personal access token.
         * @summary Delete Personal Access Token
         * @param {string} id The personal access token id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonalAccessToken: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePersonalAccessToken', 'id', id)
            const localVarPath = `/personal-access-tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a collection of personal access tokens associated with the optional `owner-id`.  query parameter. If the `owner-id` query parameter is omitted, all personal access tokens  for a tenant will be retrieved, but the caller must have the \'idn:all-personal-access-tokens:read\' right.
         * @summary List Personal Access Tokens
         * @param {string} [ownerId] The identity ID of the owner whose personal access tokens should be listed.  If \&quot;me\&quot;, the caller should have the following right: \&#39;idn:my-personal-access-tokens:read\&#39; If an actual owner ID or if the &#x60;owner-id&#x60; parameter is omitted in the request,  the caller should have the following right: \&#39;idn:all-personal-access-tokens:read\&#39;.  If the caller has the following right, then managed personal access tokens associated with &#x60;owner-id&#x60;  will be retrieved: \&#39;idn:managed-personal-access-tokens:read\&#39;
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPersonalAccessTokens: async (ownerId?: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/personal-access-tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['owner-id'] = ownerId;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This performs a targeted update to the field(s) of a Personal Access Token.
         * @summary Patch Personal Access Token
         * @param {string} id The Personal Access Token id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * scope 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchPersonalAccessToken: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchPersonalAccessToken', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchPersonalAccessToken', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/personal-access-tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonalAccessTokensApi - functional programming interface
 * @export
 */
export const PersonalAccessTokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonalAccessTokensApiAxiosParamCreator(configuration)
    return {
        /**
         * This creates a personal access token.
         * @summary Create Personal Access Token
         * @param {CreatePersonalAccessTokenRequest} createPersonalAccessTokenRequest Name and scope of personal access token.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createPersonalAccessToken(createPersonalAccessTokenRequest: CreatePersonalAccessTokenRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePersonalAccessTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPersonalAccessToken(createPersonalAccessTokenRequest, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PersonalAccessTokensApi.createPersonalAccessToken']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This deletes a personal access token.
         * @summary Delete Personal Access Token
         * @param {string} id The personal access token id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deletePersonalAccessToken(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePersonalAccessToken(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PersonalAccessTokensApi.deletePersonalAccessToken']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This gets a collection of personal access tokens associated with the optional `owner-id`.  query parameter. If the `owner-id` query parameter is omitted, all personal access tokens  for a tenant will be retrieved, but the caller must have the \'idn:all-personal-access-tokens:read\' right.
         * @summary List Personal Access Tokens
         * @param {string} [ownerId] The identity ID of the owner whose personal access tokens should be listed.  If \&quot;me\&quot;, the caller should have the following right: \&#39;idn:my-personal-access-tokens:read\&#39; If an actual owner ID or if the &#x60;owner-id&#x60; parameter is omitted in the request,  the caller should have the following right: \&#39;idn:all-personal-access-tokens:read\&#39;.  If the caller has the following right, then managed personal access tokens associated with &#x60;owner-id&#x60;  will be retrieved: \&#39;idn:managed-personal-access-tokens:read\&#39;
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listPersonalAccessTokens(ownerId?: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPersonalAccessTokenResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPersonalAccessTokens(ownerId, filters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PersonalAccessTokensApi.listPersonalAccessTokens']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This performs a targeted update to the field(s) of a Personal Access Token.
         * @summary Patch Personal Access Token
         * @param {string} id The Personal Access Token id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * scope 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchPersonalAccessToken(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPersonalAccessTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchPersonalAccessToken(id, jsonPatchOperation, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PersonalAccessTokensApi.patchPersonalAccessToken']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PersonalAccessTokensApi - factory interface
 * @export
 */
export const PersonalAccessTokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonalAccessTokensApiFp(configuration)
    return {
        /**
         * This creates a personal access token.
         * @summary Create Personal Access Token
         * @param {PersonalAccessTokensApiCreatePersonalAccessTokenRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        createPersonalAccessToken(requestParameters: PersonalAccessTokensApiCreatePersonalAccessTokenRequest, options?: AxiosRequestConfig): AxiosPromise<CreatePersonalAccessTokenResponse> {
            return localVarFp.createPersonalAccessToken(requestParameters.createPersonalAccessTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This deletes a personal access token.
         * @summary Delete Personal Access Token
         * @param {PersonalAccessTokensApiDeletePersonalAccessTokenRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deletePersonalAccessToken(requestParameters: PersonalAccessTokensApiDeletePersonalAccessTokenRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePersonalAccessToken(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This gets a collection of personal access tokens associated with the optional `owner-id`.  query parameter. If the `owner-id` query parameter is omitted, all personal access tokens  for a tenant will be retrieved, but the caller must have the \'idn:all-personal-access-tokens:read\' right.
         * @summary List Personal Access Tokens
         * @param {PersonalAccessTokensApiListPersonalAccessTokensRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listPersonalAccessTokens(requestParameters: PersonalAccessTokensApiListPersonalAccessTokensRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<GetPersonalAccessTokenResponse>> {
            return localVarFp.listPersonalAccessTokens(requestParameters.ownerId, requestParameters.filters, options).then((request) => request(axios, basePath));
        },
        /**
         * This performs a targeted update to the field(s) of a Personal Access Token.
         * @summary Patch Personal Access Token
         * @param {PersonalAccessTokensApiPatchPersonalAccessTokenRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        patchPersonalAccessToken(requestParameters: PersonalAccessTokensApiPatchPersonalAccessTokenRequest, options?: AxiosRequestConfig): AxiosPromise<GetPersonalAccessTokenResponse> {
            return localVarFp.patchPersonalAccessToken(requestParameters.id, requestParameters.jsonPatchOperation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPersonalAccessToken operation in PersonalAccessTokensApi.
 * @export
 * @interface PersonalAccessTokensApiCreatePersonalAccessTokenRequest
 */
export interface PersonalAccessTokensApiCreatePersonalAccessTokenRequest {
    /**
     * Name and scope of personal access token.
     * @type {CreatePersonalAccessTokenRequest}
     * @memberof PersonalAccessTokensApiCreatePersonalAccessToken
     */
    readonly createPersonalAccessTokenRequest: CreatePersonalAccessTokenRequest
}

/**
 * Request parameters for deletePersonalAccessToken operation in PersonalAccessTokensApi.
 * @export
 * @interface PersonalAccessTokensApiDeletePersonalAccessTokenRequest
 */
export interface PersonalAccessTokensApiDeletePersonalAccessTokenRequest {
    /**
     * The personal access token id
     * @type {string}
     * @memberof PersonalAccessTokensApiDeletePersonalAccessToken
     */
    readonly id: string
}

/**
 * Request parameters for listPersonalAccessTokens operation in PersonalAccessTokensApi.
 * @export
 * @interface PersonalAccessTokensApiListPersonalAccessTokensRequest
 */
export interface PersonalAccessTokensApiListPersonalAccessTokensRequest {
    /**
     * The identity ID of the owner whose personal access tokens should be listed.  If \&quot;me\&quot;, the caller should have the following right: \&#39;idn:my-personal-access-tokens:read\&#39; If an actual owner ID or if the &#x60;owner-id&#x60; parameter is omitted in the request,  the caller should have the following right: \&#39;idn:all-personal-access-tokens:read\&#39;.  If the caller has the following right, then managed personal access tokens associated with &#x60;owner-id&#x60;  will be retrieved: \&#39;idn:managed-personal-access-tokens:read\&#39;
     * @type {string}
     * @memberof PersonalAccessTokensApiListPersonalAccessTokens
     */
    readonly ownerId?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
     * @type {string}
     * @memberof PersonalAccessTokensApiListPersonalAccessTokens
     */
    readonly filters?: string
}

/**
 * Request parameters for patchPersonalAccessToken operation in PersonalAccessTokensApi.
 * @export
 * @interface PersonalAccessTokensApiPatchPersonalAccessTokenRequest
 */
export interface PersonalAccessTokensApiPatchPersonalAccessTokenRequest {
    /**
     * The Personal Access Token id
     * @type {string}
     * @memberof PersonalAccessTokensApiPatchPersonalAccessToken
     */
    readonly id: string

    /**
     * A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * scope 
     * @type {Array<JsonPatchOperation>}
     * @memberof PersonalAccessTokensApiPatchPersonalAccessToken
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * PersonalAccessTokensApi - object-oriented interface
 * @export
 * @class PersonalAccessTokensApi
 * @extends {BaseAPI}
 */
export class PersonalAccessTokensApi extends BaseAPI {
    /**
     * This creates a personal access token.
     * @summary Create Personal Access Token
     * @param {PersonalAccessTokensApiCreatePersonalAccessTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    public createPersonalAccessToken(requestParameters: PersonalAccessTokensApiCreatePersonalAccessTokenRequest, axiosOptions?: AxiosRequestConfig) {
        return PersonalAccessTokensApiFp(this.configuration).createPersonalAccessToken(requestParameters.createPersonalAccessTokenRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes a personal access token.
     * @summary Delete Personal Access Token
     * @param {PersonalAccessTokensApiDeletePersonalAccessTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    public deletePersonalAccessToken(requestParameters: PersonalAccessTokensApiDeletePersonalAccessTokenRequest, axiosOptions?: AxiosRequestConfig) {
        return PersonalAccessTokensApiFp(this.configuration).deletePersonalAccessToken(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a collection of personal access tokens associated with the optional `owner-id`.  query parameter. If the `owner-id` query parameter is omitted, all personal access tokens  for a tenant will be retrieved, but the caller must have the \'idn:all-personal-access-tokens:read\' right.
     * @summary List Personal Access Tokens
     * @param {PersonalAccessTokensApiListPersonalAccessTokensRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    public listPersonalAccessTokens(requestParameters: PersonalAccessTokensApiListPersonalAccessTokensRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return PersonalAccessTokensApiFp(this.configuration).listPersonalAccessTokens(requestParameters.ownerId, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This performs a targeted update to the field(s) of a Personal Access Token.
     * @summary Patch Personal Access Token
     * @param {PersonalAccessTokensApiPatchPersonalAccessTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    public patchPersonalAccessToken(requestParameters: PersonalAccessTokensApiPatchPersonalAccessTokenRequest, axiosOptions?: AxiosRequestConfig) {
        return PersonalAccessTokensApiFp(this.configuration).patchPersonalAccessToken(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PublicIdentitiesApi - axios parameter creator
 * @export
 */
export const PublicIdentitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a list of public identities
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **alias**: *eq, sw*  **email**: *eq, sw*  **firstname**: *eq, sw*  **lastname**: *eq, sw*
         * @param {boolean} [addCoreFilters] If *true*, only get identities which satisfy ALL the following criteria in addition to any criteria specified by *filters*:   - Should be either correlated or protected.   - Should not be \&quot;spadmin\&quot; or \&quot;cloudadmin\&quot;.   - uid should not be null.   - lastname should not be null.   - email should not be null.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPublicIdentities: async (limit?: number, offset?: number, count?: boolean, filters?: string, addCoreFilters?: boolean, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public-identities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (addCoreFilters !== undefined) {
                localVarQueryParameter['add-core-filters'] = addCoreFilters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicIdentitiesApi - functional programming interface
 * @export
 */
export const PublicIdentitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicIdentitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a list of public identities
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **alias**: *eq, sw*  **email**: *eq, sw*  **firstname**: *eq, sw*  **lastname**: *eq, sw*
         * @param {boolean} [addCoreFilters] If *true*, only get identities which satisfy ALL the following criteria in addition to any criteria specified by *filters*:   - Should be either correlated or protected.   - Should not be \&quot;spadmin\&quot; or \&quot;cloudadmin\&quot;.   - uid should not be null.   - lastname should not be null.   - email should not be null.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicIdentities(limit?: number, offset?: number, count?: boolean, filters?: string, addCoreFilters?: boolean, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PublicIdentity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicIdentities(limit, offset, count, filters, addCoreFilters, sorters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PublicIdentitiesApi.getPublicIdentities']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PublicIdentitiesApi - factory interface
 * @export
 */
export const PublicIdentitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicIdentitiesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a list of public identities
         * @param {PublicIdentitiesApiGetPublicIdentitiesRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getPublicIdentities(requestParameters: PublicIdentitiesApiGetPublicIdentitiesRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<PublicIdentity>> {
            return localVarFp.getPublicIdentities(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.addCoreFilters, requestParameters.sorters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getPublicIdentities operation in PublicIdentitiesApi.
 * @export
 * @interface PublicIdentitiesApiGetPublicIdentitiesRequest
 */
export interface PublicIdentitiesApiGetPublicIdentitiesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof PublicIdentitiesApiGetPublicIdentities
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof PublicIdentitiesApiGetPublicIdentities
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof PublicIdentitiesApiGetPublicIdentities
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **alias**: *eq, sw*  **email**: *eq, sw*  **firstname**: *eq, sw*  **lastname**: *eq, sw*
     * @type {string}
     * @memberof PublicIdentitiesApiGetPublicIdentities
     */
    readonly filters?: string

    /**
     * If *true*, only get identities which satisfy ALL the following criteria in addition to any criteria specified by *filters*:   - Should be either correlated or protected.   - Should not be \&quot;spadmin\&quot; or \&quot;cloudadmin\&quot;.   - uid should not be null.   - lastname should not be null.   - email should not be null.
     * @type {boolean}
     * @memberof PublicIdentitiesApiGetPublicIdentities
     */
    readonly addCoreFilters?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
     * @type {string}
     * @memberof PublicIdentitiesApiGetPublicIdentities
     */
    readonly sorters?: string
}

/**
 * PublicIdentitiesApi - object-oriented interface
 * @export
 * @class PublicIdentitiesApi
 * @extends {BaseAPI}
 */
export class PublicIdentitiesApi extends BaseAPI {
    /**
     * 
     * @summary Get a list of public identities
     * @param {PublicIdentitiesApiGetPublicIdentitiesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicIdentitiesApi
     */
    public getPublicIdentities(requestParameters: PublicIdentitiesApiGetPublicIdentitiesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return PublicIdentitiesApiFp(this.configuration).getPublicIdentities(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.addCoreFilters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PublicIdentitiesConfigApi - axios parameter creator
 * @export
 */
export const PublicIdentitiesConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
         * @summary Get the Public Identities Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPublicIdentityConfig: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public-identities-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Updates the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
         * @summary Update the Public Identities Configuration
         * @param {PublicIdentityConfig} publicIdentityConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicIdentityConfig: async (publicIdentityConfig: PublicIdentityConfig, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publicIdentityConfig' is not null or undefined
            assertParamExists('updatePublicIdentityConfig', 'publicIdentityConfig', publicIdentityConfig)
            const localVarPath = `/public-identities-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publicIdentityConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicIdentitiesConfigApi - functional programming interface
 * @export
 */
export const PublicIdentitiesConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicIdentitiesConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
         * @summary Get the Public Identities Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicIdentityConfig(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicIdentityConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicIdentityConfig(axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PublicIdentitiesConfigApi.getPublicIdentityConfig']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Updates the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
         * @summary Update the Public Identities Configuration
         * @param {PublicIdentityConfig} publicIdentityConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updatePublicIdentityConfig(publicIdentityConfig: PublicIdentityConfig, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicIdentityConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePublicIdentityConfig(publicIdentityConfig, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PublicIdentitiesConfigApi.updatePublicIdentityConfig']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PublicIdentitiesConfigApi - factory interface
 * @export
 */
export const PublicIdentitiesConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicIdentitiesConfigApiFp(configuration)
    return {
        /**
         * Returns the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
         * @summary Get the Public Identities Configuration
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getPublicIdentityConfig(options?: AxiosRequestConfig): AxiosPromise<PublicIdentityConfig> {
            return localVarFp.getPublicIdentityConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
         * @summary Update the Public Identities Configuration
         * @param {PublicIdentitiesConfigApiUpdatePublicIdentityConfigRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        updatePublicIdentityConfig(requestParameters: PublicIdentitiesConfigApiUpdatePublicIdentityConfigRequest, options?: AxiosRequestConfig): AxiosPromise<PublicIdentityConfig> {
            return localVarFp.updatePublicIdentityConfig(requestParameters.publicIdentityConfig, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for updatePublicIdentityConfig operation in PublicIdentitiesConfigApi.
 * @export
 * @interface PublicIdentitiesConfigApiUpdatePublicIdentityConfigRequest
 */
export interface PublicIdentitiesConfigApiUpdatePublicIdentityConfigRequest {
    /**
     * 
     * @type {PublicIdentityConfig}
     * @memberof PublicIdentitiesConfigApiUpdatePublicIdentityConfig
     */
    readonly publicIdentityConfig: PublicIdentityConfig
}

/**
 * PublicIdentitiesConfigApi - object-oriented interface
 * @export
 * @class PublicIdentitiesConfigApi
 * @extends {BaseAPI}
 */
export class PublicIdentitiesConfigApi extends BaseAPI {
    /**
     * Returns the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
     * @summary Get the Public Identities Configuration
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicIdentitiesConfigApi
     */
    public getPublicIdentityConfig(axiosOptions?: AxiosRequestConfig) {
        return PublicIdentitiesConfigApiFp(this.configuration).getPublicIdentityConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
     * @summary Update the Public Identities Configuration
     * @param {PublicIdentitiesConfigApiUpdatePublicIdentityConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicIdentitiesConfigApi
     */
    public updatePublicIdentityConfig(requestParameters: PublicIdentitiesConfigApiUpdatePublicIdentityConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return PublicIdentitiesConfigApiFp(this.configuration).updatePublicIdentityConfig(requestParameters.publicIdentityConfig, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportsDataExtractionApi - axios parameter creator
 * @export
 */
export const ReportsDataExtractionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancels a running report.
         * @summary Cancel Report
         * @param {string} id ID of the running Report to cancel
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelReport: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelReport', 'id', id)
            const localVarPath = `/reports/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Gets a report in file format.
         * @summary Get Report File
         * @param {string} taskResultId Unique identifier of the task result which handled report
         * @param {GetReportFileFormatEnum} fileFormat Output format of the requested report file
         * @param {string} [name] preferred Report file name, by default will be used report name from task result.
         * @param {boolean} [auditable] Enables auditing for current report download. Will create an audit event and sent it to the REPORT cloud-audit kafka topic.  Event will be created if there is any result present by requested taskResultId.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getReport: async (taskResultId: string, fileFormat: 'csv' | 'pdf', name?: string, auditable?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskResultId' is not null or undefined
            assertParamExists('getReport', 'taskResultId', taskResultId)
            // verify required parameter 'fileFormat' is not null or undefined
            assertParamExists('getReport', 'fileFormat', fileFormat)
            const localVarPath = `/reports/{taskResultId}`
                .replace(`{${"taskResultId"}}`, encodeURIComponent(String(taskResultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (fileFormat !== undefined) {
                localVarQueryParameter['fileFormat'] = fileFormat;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (auditable !== undefined) {
                localVarQueryParameter['auditable'] = auditable;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get the report results for a report that was run or is running. Returns empty report result in case there are no active task definitions with used in payload task definition name.
         * @summary Get Report Result
         * @param {string} taskResultId Unique identifier of the task result which handled report
         * @param {boolean} [completed] state of task result to apply ordering when results are fetching from the DB
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getReportResult: async (taskResultId: string, completed?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskResultId' is not null or undefined
            assertParamExists('getReportResult', 'taskResultId', taskResultId)
            const localVarPath = `/reports/{taskResultId}/result`
                .replace(`{${"taskResultId"}}`, encodeURIComponent(String(taskResultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (completed !== undefined) {
                localVarQueryParameter['completed'] = completed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Runs a report according to input report details. If non-concurrent task is already running then it returns, otherwise new task creates and returns.
         * @summary Run Report
         * @param {ReportDetails} reportDetails 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startReport: async (reportDetails: ReportDetails, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportDetails' is not null or undefined
            assertParamExists('startReport', 'reportDetails', reportDetails)
            const localVarPath = `/reports/run`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reportDetails, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportsDataExtractionApi - functional programming interface
 * @export
 */
export const ReportsDataExtractionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportsDataExtractionApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancels a running report.
         * @summary Cancel Report
         * @param {string} id ID of the running Report to cancel
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async cancelReport(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelReport(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ReportsDataExtractionApi.cancelReport']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Gets a report in file format.
         * @summary Get Report File
         * @param {string} taskResultId Unique identifier of the task result which handled report
         * @param {GetReportFileFormatEnum} fileFormat Output format of the requested report file
         * @param {string} [name] preferred Report file name, by default will be used report name from task result.
         * @param {boolean} [auditable] Enables auditing for current report download. Will create an audit event and sent it to the REPORT cloud-audit kafka topic.  Event will be created if there is any result present by requested taskResultId.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getReport(taskResultId: string, fileFormat: GetReportFileFormatEnum, name?: string, auditable?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReport(taskResultId, fileFormat, name, auditable, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ReportsDataExtractionApi.getReport']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get the report results for a report that was run or is running. Returns empty report result in case there are no active task definitions with used in payload task definition name.
         * @summary Get Report Result
         * @param {string} taskResultId Unique identifier of the task result which handled report
         * @param {boolean} [completed] state of task result to apply ordering when results are fetching from the DB
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getReportResult(taskResultId: string, completed?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReportResult(taskResultId, completed, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ReportsDataExtractionApi.getReportResult']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Runs a report according to input report details. If non-concurrent task is already running then it returns, otherwise new task creates and returns.
         * @summary Run Report
         * @param {ReportDetails} reportDetails 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startReport(reportDetails: ReportDetails, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResultDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startReport(reportDetails, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ReportsDataExtractionApi.startReport']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ReportsDataExtractionApi - factory interface
 * @export
 */
export const ReportsDataExtractionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportsDataExtractionApiFp(configuration)
    return {
        /**
         * Cancels a running report.
         * @summary Cancel Report
         * @param {ReportsDataExtractionApiCancelReportRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        cancelReport(requestParameters: ReportsDataExtractionApiCancelReportRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cancelReport(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a report in file format.
         * @summary Get Report File
         * @param {ReportsDataExtractionApiGetReportRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getReport(requestParameters: ReportsDataExtractionApiGetReportRequest, options?: AxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.getReport(requestParameters.taskResultId, requestParameters.fileFormat, requestParameters.name, requestParameters.auditable, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the report results for a report that was run or is running. Returns empty report result in case there are no active task definitions with used in payload task definition name.
         * @summary Get Report Result
         * @param {ReportsDataExtractionApiGetReportResultRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getReportResult(requestParameters: ReportsDataExtractionApiGetReportResultRequest, options?: AxiosRequestConfig): AxiosPromise<ReportResults> {
            return localVarFp.getReportResult(requestParameters.taskResultId, requestParameters.completed, options).then((request) => request(axios, basePath));
        },
        /**
         * Runs a report according to input report details. If non-concurrent task is already running then it returns, otherwise new task creates and returns.
         * @summary Run Report
         * @param {ReportsDataExtractionApiStartReportRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        startReport(requestParameters: ReportsDataExtractionApiStartReportRequest, options?: AxiosRequestConfig): AxiosPromise<TaskResultDetails> {
            return localVarFp.startReport(requestParameters.reportDetails, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancelReport operation in ReportsDataExtractionApi.
 * @export
 * @interface ReportsDataExtractionApiCancelReportRequest
 */
export interface ReportsDataExtractionApiCancelReportRequest {
    /**
     * ID of the running Report to cancel
     * @type {string}
     * @memberof ReportsDataExtractionApiCancelReport
     */
    readonly id: string
}

/**
 * Request parameters for getReport operation in ReportsDataExtractionApi.
 * @export
 * @interface ReportsDataExtractionApiGetReportRequest
 */
export interface ReportsDataExtractionApiGetReportRequest {
    /**
     * Unique identifier of the task result which handled report
     * @type {string}
     * @memberof ReportsDataExtractionApiGetReport
     */
    readonly taskResultId: string

    /**
     * Output format of the requested report file
     * @type {'csv' | 'pdf'}
     * @memberof ReportsDataExtractionApiGetReport
     */
    readonly fileFormat: GetReportFileFormatEnum

    /**
     * preferred Report file name, by default will be used report name from task result.
     * @type {string}
     * @memberof ReportsDataExtractionApiGetReport
     */
    readonly name?: string

    /**
     * Enables auditing for current report download. Will create an audit event and sent it to the REPORT cloud-audit kafka topic.  Event will be created if there is any result present by requested taskResultId.
     * @type {boolean}
     * @memberof ReportsDataExtractionApiGetReport
     */
    readonly auditable?: boolean
}

/**
 * Request parameters for getReportResult operation in ReportsDataExtractionApi.
 * @export
 * @interface ReportsDataExtractionApiGetReportResultRequest
 */
export interface ReportsDataExtractionApiGetReportResultRequest {
    /**
     * Unique identifier of the task result which handled report
     * @type {string}
     * @memberof ReportsDataExtractionApiGetReportResult
     */
    readonly taskResultId: string

    /**
     * state of task result to apply ordering when results are fetching from the DB
     * @type {boolean}
     * @memberof ReportsDataExtractionApiGetReportResult
     */
    readonly completed?: boolean
}

/**
 * Request parameters for startReport operation in ReportsDataExtractionApi.
 * @export
 * @interface ReportsDataExtractionApiStartReportRequest
 */
export interface ReportsDataExtractionApiStartReportRequest {
    /**
     * 
     * @type {ReportDetails}
     * @memberof ReportsDataExtractionApiStartReport
     */
    readonly reportDetails: ReportDetails
}

/**
 * ReportsDataExtractionApi - object-oriented interface
 * @export
 * @class ReportsDataExtractionApi
 * @extends {BaseAPI}
 */
export class ReportsDataExtractionApi extends BaseAPI {
    /**
     * Cancels a running report.
     * @summary Cancel Report
     * @param {ReportsDataExtractionApiCancelReportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsDataExtractionApi
     */
    public cancelReport(requestParameters: ReportsDataExtractionApiCancelReportRequest, axiosOptions?: AxiosRequestConfig) {
        return ReportsDataExtractionApiFp(this.configuration).cancelReport(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a report in file format.
     * @summary Get Report File
     * @param {ReportsDataExtractionApiGetReportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsDataExtractionApi
     */
    public getReport(requestParameters: ReportsDataExtractionApiGetReportRequest, axiosOptions?: AxiosRequestConfig) {
        return ReportsDataExtractionApiFp(this.configuration).getReport(requestParameters.taskResultId, requestParameters.fileFormat, requestParameters.name, requestParameters.auditable, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the report results for a report that was run or is running. Returns empty report result in case there are no active task definitions with used in payload task definition name.
     * @summary Get Report Result
     * @param {ReportsDataExtractionApiGetReportResultRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsDataExtractionApi
     */
    public getReportResult(requestParameters: ReportsDataExtractionApiGetReportResultRequest, axiosOptions?: AxiosRequestConfig) {
        return ReportsDataExtractionApiFp(this.configuration).getReportResult(requestParameters.taskResultId, requestParameters.completed, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Runs a report according to input report details. If non-concurrent task is already running then it returns, otherwise new task creates and returns.
     * @summary Run Report
     * @param {ReportsDataExtractionApiStartReportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsDataExtractionApi
     */
    public startReport(requestParameters: ReportsDataExtractionApiStartReportRequest, axiosOptions?: AxiosRequestConfig) {
        return ReportsDataExtractionApiFp(this.configuration).startReport(requestParameters.reportDetails, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetReportFileFormatEnum = {
    Csv: 'csv',
    Pdf: 'pdf'
} as const;
export type GetReportFileFormatEnum = typeof GetReportFileFormatEnum[keyof typeof GetReportFileFormatEnum];


/**
 * RequestableObjectsApi - axios parameter creator
 * @export
 */
export const RequestableObjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns a list of acccess items that that can be requested through the Access Request endpoints. Access items are marked with AVAILABLE, PENDING or ASSIGNED with respect to the identity provided using *identity-id* query param. Any authenticated token can call this endpoint to see their requestable access items. A token with ORG_ADMIN authority is required to call this endpoint to return a list of all of the requestable access items for the org or for another identity.
         * @summary Requestable Objects List
         * @param {string} [identityId] If present, the value returns only requestable objects for the specified identity.  * Admin users can call this with any identity ID value.  * Non-admin users can only specify *me* or pass their own identity ID value.  * If absent, returns a list of all requestable objects for the tenant. Only admin users can make such a call. In this case, the available, pending, assigned accesses will not be annotated in the result.
         * @param {Array<RequestableObjectType>} [types] Filters the results to the specified type/types, where each type is one of ROLE or ACCESS_PROFILE. If absent, all types are returned. Support for additional types may be added in the future without notice.
         * @param {string} [term] It allows searching requestable access items with a partial match on the name or description. If term is provided, then the *filter* query parameter will be ignored.
         * @param {Array<RequestableObjectRequestStatus>} [statuses] Filters the result to the specified status/statuses, where each status is one of AVAILABLE, ASSIGNED, or PENDING. It is an error to specify this parameter without also specifying an *identity-id* parameter. Additional statuses may be added in the future without notice.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw* 
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name** 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listRequestableObjects: async (identityId?: string, types?: Array<RequestableObjectType>, term?: string, statuses?: Array<RequestableObjectRequestStatus>, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/requestable-objects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (identityId !== undefined) {
                localVarQueryParameter['identity-id'] = identityId;
            }

            if (types) {
                localVarQueryParameter['types'] = types.join(COLLECTION_FORMATS.csv);
            }

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * RequestableObjectsApi - functional programming interface
 * @export
 */
export const RequestableObjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RequestableObjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint returns a list of acccess items that that can be requested through the Access Request endpoints. Access items are marked with AVAILABLE, PENDING or ASSIGNED with respect to the identity provided using *identity-id* query param. Any authenticated token can call this endpoint to see their requestable access items. A token with ORG_ADMIN authority is required to call this endpoint to return a list of all of the requestable access items for the org or for another identity.
         * @summary Requestable Objects List
         * @param {string} [identityId] If present, the value returns only requestable objects for the specified identity.  * Admin users can call this with any identity ID value.  * Non-admin users can only specify *me* or pass their own identity ID value.  * If absent, returns a list of all requestable objects for the tenant. Only admin users can make such a call. In this case, the available, pending, assigned accesses will not be annotated in the result.
         * @param {Array<RequestableObjectType>} [types] Filters the results to the specified type/types, where each type is one of ROLE or ACCESS_PROFILE. If absent, all types are returned. Support for additional types may be added in the future without notice.
         * @param {string} [term] It allows searching requestable access items with a partial match on the name or description. If term is provided, then the *filter* query parameter will be ignored.
         * @param {Array<RequestableObjectRequestStatus>} [statuses] Filters the result to the specified status/statuses, where each status is one of AVAILABLE, ASSIGNED, or PENDING. It is an error to specify this parameter without also specifying an *identity-id* parameter. Additional statuses may be added in the future without notice.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw* 
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name** 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listRequestableObjects(identityId?: string, types?: Array<RequestableObjectType>, term?: string, statuses?: Array<RequestableObjectRequestStatus>, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RequestableObject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRequestableObjects(identityId, types, term, statuses, limit, offset, count, filters, sorters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RequestableObjectsApi.listRequestableObjects']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * RequestableObjectsApi - factory interface
 * @export
 */
export const RequestableObjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RequestableObjectsApiFp(configuration)
    return {
        /**
         * This endpoint returns a list of acccess items that that can be requested through the Access Request endpoints. Access items are marked with AVAILABLE, PENDING or ASSIGNED with respect to the identity provided using *identity-id* query param. Any authenticated token can call this endpoint to see their requestable access items. A token with ORG_ADMIN authority is required to call this endpoint to return a list of all of the requestable access items for the org or for another identity.
         * @summary Requestable Objects List
         * @param {RequestableObjectsApiListRequestableObjectsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listRequestableObjects(requestParameters: RequestableObjectsApiListRequestableObjectsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<RequestableObject>> {
            return localVarFp.listRequestableObjects(requestParameters.identityId, requestParameters.types, requestParameters.term, requestParameters.statuses, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listRequestableObjects operation in RequestableObjectsApi.
 * @export
 * @interface RequestableObjectsApiListRequestableObjectsRequest
 */
export interface RequestableObjectsApiListRequestableObjectsRequest {
    /**
     * If present, the value returns only requestable objects for the specified identity.  * Admin users can call this with any identity ID value.  * Non-admin users can only specify *me* or pass their own identity ID value.  * If absent, returns a list of all requestable objects for the tenant. Only admin users can make such a call. In this case, the available, pending, assigned accesses will not be annotated in the result.
     * @type {string}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly identityId?: string

    /**
     * Filters the results to the specified type/types, where each type is one of ROLE or ACCESS_PROFILE. If absent, all types are returned. Support for additional types may be added in the future without notice.
     * @type {Array<RequestableObjectType>}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly types?: Array<RequestableObjectType>

    /**
     * It allows searching requestable access items with a partial match on the name or description. If term is provided, then the *filter* query parameter will be ignored.
     * @type {string}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly term?: string

    /**
     * Filters the result to the specified status/statuses, where each status is one of AVAILABLE, ASSIGNED, or PENDING. It is an error to specify this parameter without also specifying an *identity-id* parameter. Additional statuses may be added in the future without notice.
     * @type {Array<RequestableObjectRequestStatus>}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly statuses?: Array<RequestableObjectRequestStatus>

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw* 
     * @type {string}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name** 
     * @type {string}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly sorters?: string
}

/**
 * RequestableObjectsApi - object-oriented interface
 * @export
 * @class RequestableObjectsApi
 * @extends {BaseAPI}
 */
export class RequestableObjectsApi extends BaseAPI {
    /**
     * This endpoint returns a list of acccess items that that can be requested through the Access Request endpoints. Access items are marked with AVAILABLE, PENDING or ASSIGNED with respect to the identity provided using *identity-id* query param. Any authenticated token can call this endpoint to see their requestable access items. A token with ORG_ADMIN authority is required to call this endpoint to return a list of all of the requestable access items for the org or for another identity.
     * @summary Requestable Objects List
     * @param {RequestableObjectsApiListRequestableObjectsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestableObjectsApi
     */
    public listRequestableObjects(requestParameters: RequestableObjectsApiListRequestableObjectsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return RequestableObjectsApiFp(this.configuration).listRequestableObjects(requestParameters.identityId, requestParameters.types, requestParameters.term, requestParameters.statuses, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RolesApi - axios parameter creator
 * @export
 */
export const RolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates a role. You must have a token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority to call this API.  In addition, a ROLE_SUBADMIN may not create a role including an access profile if that access profile is associated with a source the ROLE_SUBADMIN is not associated with themselves.  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles. However, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Create a Role
         * @param {Role} role 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createRole: async (role: Role, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'role' is not null or undefined
            assertParamExists('createRole', 'role', role)
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(role, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API initiates a bulk deletion of one or more Roles.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Roles included in the request are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Delete Role(s)
         * @param {RoleBulkDeleteRequest} roleBulkDeleteRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteBulkRoles: async (roleBulkDeleteRequest: RoleBulkDeleteRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleBulkDeleteRequest' is not null or undefined
            assertParamExists('deleteBulkRoles', 'roleBulkDeleteRequest', roleBulkDeleteRequest)
            const localVarPath = `/roles/bulk-delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleBulkDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API deletes a Role by its ID. A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Delete a Role
         * @param {string} id ID of the Role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRole', 'id', id)
            const localVarPath = `/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a Role by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Get a Role
         * @param {string} id ID of the Role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRole: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRole', 'id', id)
            const localVarPath = `/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Identities assigned a Role
         * @param {string} id ID of the Role for which the assigned Identities are to be listed
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **aliasName**: *eq, sw*  **email**: *eq, sw*  **name**: *eq, sw, co*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, aliasName, email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRoleAssignedIdentities: async (id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRoleAssignedIdentities', 'id', id)
            const localVarPath = `/roles/{id}/assigned-identities`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of Roles.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary List Roles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID. A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters Roles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Whether or not the response list should contain unsegmented Roles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listRoles: async (forSubadmin?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSegmentIds?: string, includeUnsegmented?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (forSubadmin !== undefined) {
                localVarQueryParameter['for-subadmin'] = forSubadmin;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (forSegmentIds !== undefined) {
                localVarQueryParameter['for-segment-ids'] = forSegmentIds;
            }

            if (includeUnsegmented !== undefined) {
                localVarQueryParameter['include-unsegmented'] = includeUnsegmented;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates an existing Role using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.  The following fields are patchable: **name**, **description**, **enabled**, **owner**, **accessProfiles**, **membership**, **requestable**, **accessRequestConfig**, **revokeRequestConfig**, **segments** A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles, however, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Patch a specified Role
         * @param {string} id ID of the Role to patch
         * @param {Array<JsonPatchOperation>} jsonPatchOperation 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchRole: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchRole', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchRole', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesApi - functional programming interface
 * @export
 */
export const RolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RolesApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates a role. You must have a token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority to call this API.  In addition, a ROLE_SUBADMIN may not create a role including an access profile if that access profile is associated with a source the ROLE_SUBADMIN is not associated with themselves.  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles. However, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Create a Role
         * @param {Role} role 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createRole(role: Role, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRole(role, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.createRole']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API initiates a bulk deletion of one or more Roles.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Roles included in the request are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Delete Role(s)
         * @param {RoleBulkDeleteRequest} roleBulkDeleteRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBulkRoles(roleBulkDeleteRequest: RoleBulkDeleteRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBulkRoles(roleBulkDeleteRequest, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.deleteBulkRoles']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API deletes a Role by its ID. A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Delete a Role
         * @param {string} id ID of the Role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRole(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRole(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.deleteRole']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API returns a Role by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Get a Role
         * @param {string} id ID of the Role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getRole(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRole(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.getRole']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary List Identities assigned a Role
         * @param {string} id ID of the Role for which the assigned Identities are to be listed
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **aliasName**: *eq, sw*  **email**: *eq, sw*  **name**: *eq, sw, co*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, aliasName, email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleAssignedIdentities(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleIdentity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleAssignedIdentities(id, limit, offset, count, filters, sorters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.getRoleAssignedIdentities']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API returns a list of Roles.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary List Roles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID. A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters Roles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Whether or not the response list should contain unsegmented Roles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listRoles(forSubadmin?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSegmentIds?: string, includeUnsegmented?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Role>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoles(forSubadmin, limit, offset, count, filters, sorters, forSegmentIds, includeUnsegmented, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.listRoles']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API updates an existing Role using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.  The following fields are patchable: **name**, **description**, **enabled**, **owner**, **accessProfiles**, **membership**, **requestable**, **accessRequestConfig**, **revokeRequestConfig**, **segments** A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles, however, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Patch a specified Role
         * @param {string} id ID of the Role to patch
         * @param {Array<JsonPatchOperation>} jsonPatchOperation 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchRole(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchRole(id, jsonPatchOperation, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.patchRole']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * RolesApi - factory interface
 * @export
 */
export const RolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RolesApiFp(configuration)
    return {
        /**
         * This API creates a role. You must have a token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority to call this API.  In addition, a ROLE_SUBADMIN may not create a role including an access profile if that access profile is associated with a source the ROLE_SUBADMIN is not associated with themselves.  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles. However, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Create a Role
         * @param {RolesApiCreateRoleRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        createRole(requestParameters: RolesApiCreateRoleRequest, options?: AxiosRequestConfig): AxiosPromise<Role> {
            return localVarFp.createRole(requestParameters.role, options).then((request) => request(axios, basePath));
        },
        /**
         * This API initiates a bulk deletion of one or more Roles.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Roles included in the request are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Delete Role(s)
         * @param {RolesApiDeleteBulkRolesRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteBulkRoles(requestParameters: RolesApiDeleteBulkRolesRequest, options?: AxiosRequestConfig): AxiosPromise<TaskResultDto> {
            return localVarFp.deleteBulkRoles(requestParameters.roleBulkDeleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API deletes a Role by its ID. A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Delete a Role
         * @param {RolesApiDeleteRoleRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteRole(requestParameters: RolesApiDeleteRoleRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRole(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a Role by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Get a Role
         * @param {RolesApiGetRoleRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getRole(requestParameters: RolesApiGetRoleRequest, options?: AxiosRequestConfig): AxiosPromise<Role> {
            return localVarFp.getRole(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Identities assigned a Role
         * @param {RolesApiGetRoleAssignedIdentitiesRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getRoleAssignedIdentities(requestParameters: RolesApiGetRoleAssignedIdentitiesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<RoleIdentity>> {
            return localVarFp.getRoleAssignedIdentities(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, options).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of Roles.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary List Roles
         * @param {RolesApiListRolesRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listRoles(requestParameters: RolesApiListRolesRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<Role>> {
            return localVarFp.listRoles(requestParameters.forSubadmin, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.forSegmentIds, requestParameters.includeUnsegmented, options).then((request) => request(axios, basePath));
        },
        /**
         * This API updates an existing Role using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.  The following fields are patchable: **name**, **description**, **enabled**, **owner**, **accessProfiles**, **membership**, **requestable**, **accessRequestConfig**, **revokeRequestConfig**, **segments** A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles, however, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Patch a specified Role
         * @param {RolesApiPatchRoleRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        patchRole(requestParameters: RolesApiPatchRoleRequest, options?: AxiosRequestConfig): AxiosPromise<Role> {
            return localVarFp.patchRole(requestParameters.id, requestParameters.jsonPatchOperation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createRole operation in RolesApi.
 * @export
 * @interface RolesApiCreateRoleRequest
 */
export interface RolesApiCreateRoleRequest {
    /**
     * 
     * @type {Role}
     * @memberof RolesApiCreateRole
     */
    readonly role: Role
}

/**
 * Request parameters for deleteBulkRoles operation in RolesApi.
 * @export
 * @interface RolesApiDeleteBulkRolesRequest
 */
export interface RolesApiDeleteBulkRolesRequest {
    /**
     * 
     * @type {RoleBulkDeleteRequest}
     * @memberof RolesApiDeleteBulkRoles
     */
    readonly roleBulkDeleteRequest: RoleBulkDeleteRequest
}

/**
 * Request parameters for deleteRole operation in RolesApi.
 * @export
 * @interface RolesApiDeleteRoleRequest
 */
export interface RolesApiDeleteRoleRequest {
    /**
     * ID of the Role
     * @type {string}
     * @memberof RolesApiDeleteRole
     */
    readonly id: string
}

/**
 * Request parameters for getRole operation in RolesApi.
 * @export
 * @interface RolesApiGetRoleRequest
 */
export interface RolesApiGetRoleRequest {
    /**
     * ID of the Role
     * @type {string}
     * @memberof RolesApiGetRole
     */
    readonly id: string
}

/**
 * Request parameters for getRoleAssignedIdentities operation in RolesApi.
 * @export
 * @interface RolesApiGetRoleAssignedIdentitiesRequest
 */
export interface RolesApiGetRoleAssignedIdentitiesRequest {
    /**
     * ID of the Role for which the assigned Identities are to be listed
     * @type {string}
     * @memberof RolesApiGetRoleAssignedIdentities
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RolesApiGetRoleAssignedIdentities
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RolesApiGetRoleAssignedIdentities
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof RolesApiGetRoleAssignedIdentities
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **aliasName**: *eq, sw*  **email**: *eq, sw*  **name**: *eq, sw, co*
     * @type {string}
     * @memberof RolesApiGetRoleAssignedIdentities
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, aliasName, email**
     * @type {string}
     * @memberof RolesApiGetRoleAssignedIdentities
     */
    readonly sorters?: string
}

/**
 * Request parameters for listRoles operation in RolesApi.
 * @export
 * @interface RolesApiListRolesRequest
 */
export interface RolesApiListRolesRequest {
    /**
     * If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID. A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
     * @type {string}
     * @memberof RolesApiListRoles
     */
    readonly forSubadmin?: string

    /**
     * Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RolesApiListRoles
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RolesApiListRoles
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof RolesApiListRoles
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*
     * @type {string}
     * @memberof RolesApiListRoles
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
     * @type {string}
     * @memberof RolesApiListRoles
     */
    readonly sorters?: string

    /**
     * If present and not empty, additionally filters Roles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
     * @type {string}
     * @memberof RolesApiListRoles
     */
    readonly forSegmentIds?: string

    /**
     * Whether or not the response list should contain unsegmented Roles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
     * @type {boolean}
     * @memberof RolesApiListRoles
     */
    readonly includeUnsegmented?: boolean
}

/**
 * Request parameters for patchRole operation in RolesApi.
 * @export
 * @interface RolesApiPatchRoleRequest
 */
export interface RolesApiPatchRoleRequest {
    /**
     * ID of the Role to patch
     * @type {string}
     * @memberof RolesApiPatchRole
     */
    readonly id: string

    /**
     * 
     * @type {Array<JsonPatchOperation>}
     * @memberof RolesApiPatchRole
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export class RolesApi extends BaseAPI {
    /**
     * This API creates a role. You must have a token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority to call this API.  In addition, a ROLE_SUBADMIN may not create a role including an access profile if that access profile is associated with a source the ROLE_SUBADMIN is not associated with themselves.  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles. However, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
     * @summary Create a Role
     * @param {RolesApiCreateRoleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public createRole(requestParameters: RolesApiCreateRoleRequest, axiosOptions?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).createRole(requestParameters.role, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API initiates a bulk deletion of one or more Roles.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Roles included in the request are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
     * @summary Delete Role(s)
     * @param {RolesApiDeleteBulkRolesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public deleteBulkRoles(requestParameters: RolesApiDeleteBulkRolesRequest, axiosOptions?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).deleteBulkRoles(requestParameters.roleBulkDeleteRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API deletes a Role by its ID. A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
     * @summary Delete a Role
     * @param {RolesApiDeleteRoleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public deleteRole(requestParameters: RolesApiDeleteRoleRequest, axiosOptions?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).deleteRole(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a Role by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
     * @summary Get a Role
     * @param {RolesApiGetRoleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRole(requestParameters: RolesApiGetRoleRequest, axiosOptions?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).getRole(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Identities assigned a Role
     * @param {RolesApiGetRoleAssignedIdentitiesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRoleAssignedIdentities(requestParameters: RolesApiGetRoleAssignedIdentitiesRequest, axiosOptions?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).getRoleAssignedIdentities(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of Roles.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API.
     * @summary List Roles
     * @param {RolesApiListRolesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public listRoles(requestParameters: RolesApiListRolesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).listRoles(requestParameters.forSubadmin, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.forSegmentIds, requestParameters.includeUnsegmented, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates an existing Role using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.  The following fields are patchable: **name**, **description**, **enabled**, **owner**, **accessProfiles**, **membership**, **requestable**, **accessRequestConfig**, **revokeRequestConfig**, **segments** A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles, however, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
     * @summary Patch a specified Role
     * @param {RolesApiPatchRoleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public patchRole(requestParameters: RolesApiPatchRoleRequest, axiosOptions?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).patchRole(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SODPolicyApi - axios parameter creator
 * @export
 */
export const SODPolicyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This creates both General and Conflicting Access Based policy, with a limit of 50 entitlements for each (left & right) criteria for Conflicting Access Based SOD policy. Requires role of ORG_ADMIN.
         * @summary Create SOD policy
         * @param {SodPolicy} sodPolicy 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSodPolicy: async (sodPolicy: SodPolicy, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sodPolicy' is not null or undefined
            assertParamExists('createSodPolicy', 'sodPolicy', sodPolicy)
            const localVarPath = `/sod-policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sodPolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This deletes a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Delete SOD policy by ID
         * @param {string} id The ID of the SOD Policy to delete.
         * @param {boolean} [logical] Indicates whether this is a soft delete (logical true) or a hard delete.  Soft delete marks the policy as deleted and just save it with this status. It could be fully deleted or recovered further.  Hard delete vise versa permanently delete SOD request during this call.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSodPolicy: async (id: string, logical?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSodPolicy', 'id', id)
            const localVarPath = `/sod-policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (logical !== undefined) {
                localVarQueryParameter['logical'] = logical;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This deletes schedule for a specified SOD policy by ID.
         * @summary Delete SOD policy schedule
         * @param {string} id The ID of the SOD policy the schedule must be deleted for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSodPolicySchedule: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSodPolicySchedule', 'id', id)
            const localVarPath = `/sod-policies/{id}/schedule`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This allows to download a specified named violation report for a given report reference.
         * @summary Download custom violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {string} fileName Custom Name for the  file.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCustomViolationReport: async (reportResultId: string, fileName: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportResultId' is not null or undefined
            assertParamExists('getCustomViolationReport', 'reportResultId', reportResultId)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('getCustomViolationReport', 'fileName', fileName)
            const localVarPath = `/sod-violation-report/{reportResultId}/download/{fileName}`
                .replace(`{${"reportResultId"}}`, encodeURIComponent(String(reportResultId)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This allows to download a violation report for a given report reference.
         * @summary Download violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultViolationReport: async (reportResultId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportResultId' is not null or undefined
            assertParamExists('getDefaultViolationReport', 'reportResultId', reportResultId)
            const localVarPath = `/sod-violation-report/{reportResultId}/download`
                .replace(`{${"reportResultId"}}`, encodeURIComponent(String(reportResultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gets the status for a violation report for all policy run.
         * @summary Get multi-report run task status
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodAllReportRunStatus: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sod-violation-report`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Get SOD policy by ID
         * @param {string} id The ID of the SOD Policy to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodPolicy: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSodPolicy', 'id', id)
            const localVarPath = `/sod-policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gets a specified SOD policy\'s schedule.
         * @summary Get SOD policy schedule
         * @param {string} id The ID of the SOD policy schedule to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodPolicySchedule: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSodPolicySchedule', 'id', id)
            const localVarPath = `/sod-policies/{id}/schedule`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets the status for a violation report run task that has already been invoked.
         * @summary Get violation report run status
         * @param {string} reportResultId The ID of the report reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodViolationReportRunStatus: async (reportResultId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportResultId' is not null or undefined
            assertParamExists('getSodViolationReportRunStatus', 'reportResultId', reportResultId)
            const localVarPath = `/sod-policies/sod-violation-report-status/{reportResultId}`
                .replace(`{${"reportResultId"}}`, encodeURIComponent(String(reportResultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets the status for a violation report run task that has already been invoked.
         * @summary Get SOD violation report status
         * @param {string} id The ID of the violation report to retrieve status for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodViolationReportStatus: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSodViolationReportStatus', 'id', id)
            const localVarPath = `/sod-policies/{id}/violation-report`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets list of all SOD policies. Requires role of ORG_ADMIN
         * @summary List SOD policies
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*  **name**: *eq*  **state**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSodPolicies: async (limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sod-policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Allows updating SOD Policy fields other than [\"id\",\"created\",\"creatorId\",\"policyQuery\",\"type\"] using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Requires role of ORG_ADMIN. This endpoint can only patch CONFLICTING_ACCESS_BASED type policies. Do not use this endpoint to patch general policies - doing so will build an API exception. 
         * @summary Patch SOD policy by ID
         * @param {string} id The ID of the SOD policy being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of SOD Policy update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * ownerRef * externalPolicyReference * compensatingControls * correctionAdvice * state * tags * violationOwnerAssignmentConfig * scheduled * conflictingAccessCriteria 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSodPolicy: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchSodPolicy', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchSodPolicy', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/sod-policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This updates schedule for a specified SOD policy.
         * @summary Update SOD Policy schedule
         * @param {string} id The ID of the SOD policy to update its schedule.
         * @param {SodPolicySchedule} sodPolicySchedule 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putPolicySchedule: async (id: string, sodPolicySchedule: SodPolicySchedule, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putPolicySchedule', 'id', id)
            // verify required parameter 'sodPolicySchedule' is not null or undefined
            assertParamExists('putPolicySchedule', 'sodPolicySchedule', sodPolicySchedule)
            const localVarPath = `/sod-policies/{id}/schedule`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sodPolicySchedule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This updates a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Update SOD policy by ID
         * @param {string} id The ID of the SOD policy to update.
         * @param {SodPolicy} sodPolicy 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSodPolicy: async (id: string, sodPolicy: SodPolicy, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putSodPolicy', 'id', id)
            // verify required parameter 'sodPolicy' is not null or undefined
            assertParamExists('putSodPolicy', 'sodPolicy', sodPolicy)
            const localVarPath = `/sod-policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sodPolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Runs the scheduled report for the policy retrieved by passed policy ID.  The report schedule is fetched from the policy retrieved by ID.
         * @summary Evaluate one policy by ID
         * @param {string} id The SOD policy ID to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startEvaluateSodPolicy: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startEvaluateSodPolicy', 'id', id)
            const localVarPath = `/sod-policies/{id}/evaluate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Runs multi-policy report for the org. If a policy reports more than 5000 violations, the report mentions that the violation limit was exceeded for that policy. If the request is empty, the report runs for all policies. Otherwise, the report runs for only the filtered policy list provided.
         * @summary Runs all policies for org
         * @param {MultiPolicyRequest} [multiPolicyRequest] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startSodAllPoliciesForOrg: async (multiPolicyRequest?: MultiPolicyRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sod-violation-report/run`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(multiPolicyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This invokes processing of violation report for given SOD policy. If the policy reports more than 5000 violations, the report returns with violation limit exceeded message.
         * @summary Runs SOD policy violation report
         * @param {string} id The SOD policy ID to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startSodPolicy: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startSodPolicy', 'id', id)
            const localVarPath = `/sod-policies/{id}/violation-report/run`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SODPolicyApi - functional programming interface
 * @export
 */
export const SODPolicyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SODPolicyApiAxiosParamCreator(configuration)
    return {
        /**
         * This creates both General and Conflicting Access Based policy, with a limit of 50 entitlements for each (left & right) criteria for Conflicting Access Based SOD policy. Requires role of ORG_ADMIN.
         * @summary Create SOD policy
         * @param {SodPolicy} sodPolicy 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSodPolicy(sodPolicy: SodPolicy, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodPolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSodPolicy(sodPolicy, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SODPolicyApi.createSodPolicy']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This deletes a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Delete SOD policy by ID
         * @param {string} id The ID of the SOD Policy to delete.
         * @param {boolean} [logical] Indicates whether this is a soft delete (logical true) or a hard delete.  Soft delete marks the policy as deleted and just save it with this status. It could be fully deleted or recovered further.  Hard delete vise versa permanently delete SOD request during this call.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSodPolicy(id: string, logical?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSodPolicy(id, logical, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SODPolicyApi.deleteSodPolicy']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This deletes schedule for a specified SOD policy by ID.
         * @summary Delete SOD policy schedule
         * @param {string} id The ID of the SOD policy the schedule must be deleted for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSodPolicySchedule(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSodPolicySchedule(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SODPolicyApi.deleteSodPolicySchedule']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This allows to download a specified named violation report for a given report reference.
         * @summary Download custom violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {string} fileName Custom Name for the  file.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomViolationReport(reportResultId: string, fileName: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomViolationReport(reportResultId, fileName, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SODPolicyApi.getCustomViolationReport']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This allows to download a violation report for a given report reference.
         * @summary Download violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultViolationReport(reportResultId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultViolationReport(reportResultId, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SODPolicyApi.getDefaultViolationReport']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint gets the status for a violation report for all policy run.
         * @summary Get multi-report run task status
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSodAllReportRunStatus(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResultReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSodAllReportRunStatus(axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SODPolicyApi.getSodAllReportRunStatus']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This gets specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Get SOD policy by ID
         * @param {string} id The ID of the SOD Policy to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSodPolicy(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodPolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSodPolicy(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SODPolicyApi.getSodPolicy']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint gets a specified SOD policy\'s schedule.
         * @summary Get SOD policy schedule
         * @param {string} id The ID of the SOD policy schedule to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSodPolicySchedule(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodPolicySchedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSodPolicySchedule(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SODPolicyApi.getSodPolicySchedule']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This gets the status for a violation report run task that has already been invoked.
         * @summary Get violation report run status
         * @param {string} reportResultId The ID of the report reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSodViolationReportRunStatus(reportResultId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResultReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSodViolationReportRunStatus(reportResultId, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SODPolicyApi.getSodViolationReportRunStatus']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This gets the status for a violation report run task that has already been invoked.
         * @summary Get SOD violation report status
         * @param {string} id The ID of the violation report to retrieve status for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSodViolationReportStatus(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResultReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSodViolationReportStatus(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SODPolicyApi.getSodViolationReportStatus']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This gets list of all SOD policies. Requires role of ORG_ADMIN
         * @summary List SOD policies
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*  **name**: *eq*  **state**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listSodPolicies(limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SodPolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSodPolicies(limit, offset, count, filters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SODPolicyApi.listSodPolicies']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Allows updating SOD Policy fields other than [\"id\",\"created\",\"creatorId\",\"policyQuery\",\"type\"] using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Requires role of ORG_ADMIN. This endpoint can only patch CONFLICTING_ACCESS_BASED type policies. Do not use this endpoint to patch general policies - doing so will build an API exception. 
         * @summary Patch SOD policy by ID
         * @param {string} id The ID of the SOD policy being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of SOD Policy update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * ownerRef * externalPolicyReference * compensatingControls * correctionAdvice * state * tags * violationOwnerAssignmentConfig * scheduled * conflictingAccessCriteria 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchSodPolicy(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodPolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchSodPolicy(id, jsonPatchOperation, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SODPolicyApi.patchSodPolicy']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This updates schedule for a specified SOD policy.
         * @summary Update SOD Policy schedule
         * @param {string} id The ID of the SOD policy to update its schedule.
         * @param {SodPolicySchedule} sodPolicySchedule 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putPolicySchedule(id: string, sodPolicySchedule: SodPolicySchedule, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodPolicySchedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putPolicySchedule(id, sodPolicySchedule, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SODPolicyApi.putPolicySchedule']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This updates a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Update SOD policy by ID
         * @param {string} id The ID of the SOD policy to update.
         * @param {SodPolicy} sodPolicy 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putSodPolicy(id: string, sodPolicy: SodPolicy, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodPolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putSodPolicy(id, sodPolicy, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SODPolicyApi.putSodPolicy']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Runs the scheduled report for the policy retrieved by passed policy ID.  The report schedule is fetched from the policy retrieved by ID.
         * @summary Evaluate one policy by ID
         * @param {string} id The SOD policy ID to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startEvaluateSodPolicy(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResultReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startEvaluateSodPolicy(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SODPolicyApi.startEvaluateSodPolicy']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Runs multi-policy report for the org. If a policy reports more than 5000 violations, the report mentions that the violation limit was exceeded for that policy. If the request is empty, the report runs for all policies. Otherwise, the report runs for only the filtered policy list provided.
         * @summary Runs all policies for org
         * @param {MultiPolicyRequest} [multiPolicyRequest] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startSodAllPoliciesForOrg(multiPolicyRequest?: MultiPolicyRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResultReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startSodAllPoliciesForOrg(multiPolicyRequest, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SODPolicyApi.startSodAllPoliciesForOrg']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This invokes processing of violation report for given SOD policy. If the policy reports more than 5000 violations, the report returns with violation limit exceeded message.
         * @summary Runs SOD policy violation report
         * @param {string} id The SOD policy ID to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startSodPolicy(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResultReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startSodPolicy(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SODPolicyApi.startSodPolicy']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SODPolicyApi - factory interface
 * @export
 */
export const SODPolicyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SODPolicyApiFp(configuration)
    return {
        /**
         * This creates both General and Conflicting Access Based policy, with a limit of 50 entitlements for each (left & right) criteria for Conflicting Access Based SOD policy. Requires role of ORG_ADMIN.
         * @summary Create SOD policy
         * @param {SODPolicyApiCreateSodPolicyRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        createSodPolicy(requestParameters: SODPolicyApiCreateSodPolicyRequest, options?: AxiosRequestConfig): AxiosPromise<SodPolicy> {
            return localVarFp.createSodPolicy(requestParameters.sodPolicy, options).then((request) => request(axios, basePath));
        },
        /**
         * This deletes a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Delete SOD policy by ID
         * @param {SODPolicyApiDeleteSodPolicyRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteSodPolicy(requestParameters: SODPolicyApiDeleteSodPolicyRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSodPolicy(requestParameters.id, requestParameters.logical, options).then((request) => request(axios, basePath));
        },
        /**
         * This deletes schedule for a specified SOD policy by ID.
         * @summary Delete SOD policy schedule
         * @param {SODPolicyApiDeleteSodPolicyScheduleRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteSodPolicySchedule(requestParameters: SODPolicyApiDeleteSodPolicyScheduleRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSodPolicySchedule(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This allows to download a specified named violation report for a given report reference.
         * @summary Download custom violation report
         * @param {SODPolicyApiGetCustomViolationReportRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getCustomViolationReport(requestParameters: SODPolicyApiGetCustomViolationReportRequest, options?: AxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.getCustomViolationReport(requestParameters.reportResultId, requestParameters.fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * This allows to download a violation report for a given report reference.
         * @summary Download violation report
         * @param {SODPolicyApiGetDefaultViolationReportRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getDefaultViolationReport(requestParameters: SODPolicyApiGetDefaultViolationReportRequest, options?: AxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.getDefaultViolationReport(requestParameters.reportResultId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gets the status for a violation report for all policy run.
         * @summary Get multi-report run task status
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getSodAllReportRunStatus(options?: AxiosRequestConfig): AxiosPromise<ReportResultReference> {
            return localVarFp.getSodAllReportRunStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * This gets specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Get SOD policy by ID
         * @param {SODPolicyApiGetSodPolicyRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getSodPolicy(requestParameters: SODPolicyApiGetSodPolicyRequest, options?: AxiosRequestConfig): AxiosPromise<SodPolicy> {
            return localVarFp.getSodPolicy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gets a specified SOD policy\'s schedule.
         * @summary Get SOD policy schedule
         * @param {SODPolicyApiGetSodPolicyScheduleRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getSodPolicySchedule(requestParameters: SODPolicyApiGetSodPolicyScheduleRequest, options?: AxiosRequestConfig): AxiosPromise<SodPolicySchedule> {
            return localVarFp.getSodPolicySchedule(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This gets the status for a violation report run task that has already been invoked.
         * @summary Get violation report run status
         * @param {SODPolicyApiGetSodViolationReportRunStatusRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getSodViolationReportRunStatus(requestParameters: SODPolicyApiGetSodViolationReportRunStatusRequest, options?: AxiosRequestConfig): AxiosPromise<ReportResultReference> {
            return localVarFp.getSodViolationReportRunStatus(requestParameters.reportResultId, options).then((request) => request(axios, basePath));
        },
        /**
         * This gets the status for a violation report run task that has already been invoked.
         * @summary Get SOD violation report status
         * @param {SODPolicyApiGetSodViolationReportStatusRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getSodViolationReportStatus(requestParameters: SODPolicyApiGetSodViolationReportStatusRequest, options?: AxiosRequestConfig): AxiosPromise<ReportResultReference> {
            return localVarFp.getSodViolationReportStatus(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This gets list of all SOD policies. Requires role of ORG_ADMIN
         * @summary List SOD policies
         * @param {SODPolicyApiListSodPoliciesRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listSodPolicies(requestParameters: SODPolicyApiListSodPoliciesRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<SodPolicy>> {
            return localVarFp.listSodPolicies(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows updating SOD Policy fields other than [\"id\",\"created\",\"creatorId\",\"policyQuery\",\"type\"] using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Requires role of ORG_ADMIN. This endpoint can only patch CONFLICTING_ACCESS_BASED type policies. Do not use this endpoint to patch general policies - doing so will build an API exception. 
         * @summary Patch SOD policy by ID
         * @param {SODPolicyApiPatchSodPolicyRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        patchSodPolicy(requestParameters: SODPolicyApiPatchSodPolicyRequest, options?: AxiosRequestConfig): AxiosPromise<SodPolicy> {
            return localVarFp.patchSodPolicy(requestParameters.id, requestParameters.jsonPatchOperation, options).then((request) => request(axios, basePath));
        },
        /**
         * This updates schedule for a specified SOD policy.
         * @summary Update SOD Policy schedule
         * @param {SODPolicyApiPutPolicyScheduleRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        putPolicySchedule(requestParameters: SODPolicyApiPutPolicyScheduleRequest, options?: AxiosRequestConfig): AxiosPromise<SodPolicySchedule> {
            return localVarFp.putPolicySchedule(requestParameters.id, requestParameters.sodPolicySchedule, options).then((request) => request(axios, basePath));
        },
        /**
         * This updates a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Update SOD policy by ID
         * @param {SODPolicyApiPutSodPolicyRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        putSodPolicy(requestParameters: SODPolicyApiPutSodPolicyRequest, options?: AxiosRequestConfig): AxiosPromise<SodPolicy> {
            return localVarFp.putSodPolicy(requestParameters.id, requestParameters.sodPolicy, options).then((request) => request(axios, basePath));
        },
        /**
         * Runs the scheduled report for the policy retrieved by passed policy ID.  The report schedule is fetched from the policy retrieved by ID.
         * @summary Evaluate one policy by ID
         * @param {SODPolicyApiStartEvaluateSodPolicyRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        startEvaluateSodPolicy(requestParameters: SODPolicyApiStartEvaluateSodPolicyRequest, options?: AxiosRequestConfig): AxiosPromise<ReportResultReference> {
            return localVarFp.startEvaluateSodPolicy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Runs multi-policy report for the org. If a policy reports more than 5000 violations, the report mentions that the violation limit was exceeded for that policy. If the request is empty, the report runs for all policies. Otherwise, the report runs for only the filtered policy list provided.
         * @summary Runs all policies for org
         * @param {SODPolicyApiStartSodAllPoliciesForOrgRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        startSodAllPoliciesForOrg(requestParameters: SODPolicyApiStartSodAllPoliciesForOrgRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ReportResultReference> {
            return localVarFp.startSodAllPoliciesForOrg(requestParameters.multiPolicyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This invokes processing of violation report for given SOD policy. If the policy reports more than 5000 violations, the report returns with violation limit exceeded message.
         * @summary Runs SOD policy violation report
         * @param {SODPolicyApiStartSodPolicyRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        startSodPolicy(requestParameters: SODPolicyApiStartSodPolicyRequest, options?: AxiosRequestConfig): AxiosPromise<ReportResultReference> {
            return localVarFp.startSodPolicy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSodPolicy operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiCreateSodPolicyRequest
 */
export interface SODPolicyApiCreateSodPolicyRequest {
    /**
     * 
     * @type {SodPolicy}
     * @memberof SODPolicyApiCreateSodPolicy
     */
    readonly sodPolicy: SodPolicy
}

/**
 * Request parameters for deleteSodPolicy operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiDeleteSodPolicyRequest
 */
export interface SODPolicyApiDeleteSodPolicyRequest {
    /**
     * The ID of the SOD Policy to delete.
     * @type {string}
     * @memberof SODPolicyApiDeleteSodPolicy
     */
    readonly id: string

    /**
     * Indicates whether this is a soft delete (logical true) or a hard delete.  Soft delete marks the policy as deleted and just save it with this status. It could be fully deleted or recovered further.  Hard delete vise versa permanently delete SOD request during this call.
     * @type {boolean}
     * @memberof SODPolicyApiDeleteSodPolicy
     */
    readonly logical?: boolean
}

/**
 * Request parameters for deleteSodPolicySchedule operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiDeleteSodPolicyScheduleRequest
 */
export interface SODPolicyApiDeleteSodPolicyScheduleRequest {
    /**
     * The ID of the SOD policy the schedule must be deleted for.
     * @type {string}
     * @memberof SODPolicyApiDeleteSodPolicySchedule
     */
    readonly id: string
}

/**
 * Request parameters for getCustomViolationReport operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiGetCustomViolationReportRequest
 */
export interface SODPolicyApiGetCustomViolationReportRequest {
    /**
     * The ID of the report reference to download.
     * @type {string}
     * @memberof SODPolicyApiGetCustomViolationReport
     */
    readonly reportResultId: string

    /**
     * Custom Name for the  file.
     * @type {string}
     * @memberof SODPolicyApiGetCustomViolationReport
     */
    readonly fileName: string
}

/**
 * Request parameters for getDefaultViolationReport operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiGetDefaultViolationReportRequest
 */
export interface SODPolicyApiGetDefaultViolationReportRequest {
    /**
     * The ID of the report reference to download.
     * @type {string}
     * @memberof SODPolicyApiGetDefaultViolationReport
     */
    readonly reportResultId: string
}

/**
 * Request parameters for getSodPolicy operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiGetSodPolicyRequest
 */
export interface SODPolicyApiGetSodPolicyRequest {
    /**
     * The ID of the SOD Policy to retrieve.
     * @type {string}
     * @memberof SODPolicyApiGetSodPolicy
     */
    readonly id: string
}

/**
 * Request parameters for getSodPolicySchedule operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiGetSodPolicyScheduleRequest
 */
export interface SODPolicyApiGetSodPolicyScheduleRequest {
    /**
     * The ID of the SOD policy schedule to retrieve.
     * @type {string}
     * @memberof SODPolicyApiGetSodPolicySchedule
     */
    readonly id: string
}

/**
 * Request parameters for getSodViolationReportRunStatus operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiGetSodViolationReportRunStatusRequest
 */
export interface SODPolicyApiGetSodViolationReportRunStatusRequest {
    /**
     * The ID of the report reference to retrieve.
     * @type {string}
     * @memberof SODPolicyApiGetSodViolationReportRunStatus
     */
    readonly reportResultId: string
}

/**
 * Request parameters for getSodViolationReportStatus operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiGetSodViolationReportStatusRequest
 */
export interface SODPolicyApiGetSodViolationReportStatusRequest {
    /**
     * The ID of the violation report to retrieve status for.
     * @type {string}
     * @memberof SODPolicyApiGetSodViolationReportStatus
     */
    readonly id: string
}

/**
 * Request parameters for listSodPolicies operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiListSodPoliciesRequest
 */
export interface SODPolicyApiListSodPoliciesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SODPolicyApiListSodPolicies
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SODPolicyApiListSodPolicies
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SODPolicyApiListSodPolicies
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*  **name**: *eq*  **state**: *eq*
     * @type {string}
     * @memberof SODPolicyApiListSodPolicies
     */
    readonly filters?: string
}

/**
 * Request parameters for patchSodPolicy operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiPatchSodPolicyRequest
 */
export interface SODPolicyApiPatchSodPolicyRequest {
    /**
     * The ID of the SOD policy being modified.
     * @type {string}
     * @memberof SODPolicyApiPatchSodPolicy
     */
    readonly id: string

    /**
     * A list of SOD Policy update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * ownerRef * externalPolicyReference * compensatingControls * correctionAdvice * state * tags * violationOwnerAssignmentConfig * scheduled * conflictingAccessCriteria 
     * @type {Array<JsonPatchOperation>}
     * @memberof SODPolicyApiPatchSodPolicy
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for putPolicySchedule operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiPutPolicyScheduleRequest
 */
export interface SODPolicyApiPutPolicyScheduleRequest {
    /**
     * The ID of the SOD policy to update its schedule.
     * @type {string}
     * @memberof SODPolicyApiPutPolicySchedule
     */
    readonly id: string

    /**
     * 
     * @type {SodPolicySchedule}
     * @memberof SODPolicyApiPutPolicySchedule
     */
    readonly sodPolicySchedule: SodPolicySchedule
}

/**
 * Request parameters for putSodPolicy operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiPutSodPolicyRequest
 */
export interface SODPolicyApiPutSodPolicyRequest {
    /**
     * The ID of the SOD policy to update.
     * @type {string}
     * @memberof SODPolicyApiPutSodPolicy
     */
    readonly id: string

    /**
     * 
     * @type {SodPolicy}
     * @memberof SODPolicyApiPutSodPolicy
     */
    readonly sodPolicy: SodPolicy
}

/**
 * Request parameters for startEvaluateSodPolicy operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiStartEvaluateSodPolicyRequest
 */
export interface SODPolicyApiStartEvaluateSodPolicyRequest {
    /**
     * The SOD policy ID to run.
     * @type {string}
     * @memberof SODPolicyApiStartEvaluateSodPolicy
     */
    readonly id: string
}

/**
 * Request parameters for startSodAllPoliciesForOrg operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiStartSodAllPoliciesForOrgRequest
 */
export interface SODPolicyApiStartSodAllPoliciesForOrgRequest {
    /**
     * 
     * @type {MultiPolicyRequest}
     * @memberof SODPolicyApiStartSodAllPoliciesForOrg
     */
    readonly multiPolicyRequest?: MultiPolicyRequest
}

/**
 * Request parameters for startSodPolicy operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiStartSodPolicyRequest
 */
export interface SODPolicyApiStartSodPolicyRequest {
    /**
     * The SOD policy ID to run.
     * @type {string}
     * @memberof SODPolicyApiStartSodPolicy
     */
    readonly id: string
}

/**
 * SODPolicyApi - object-oriented interface
 * @export
 * @class SODPolicyApi
 * @extends {BaseAPI}
 */
export class SODPolicyApi extends BaseAPI {
    /**
     * This creates both General and Conflicting Access Based policy, with a limit of 50 entitlements for each (left & right) criteria for Conflicting Access Based SOD policy. Requires role of ORG_ADMIN.
     * @summary Create SOD policy
     * @param {SODPolicyApiCreateSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public createSodPolicy(requestParameters: SODPolicyApiCreateSodPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).createSodPolicy(requestParameters.sodPolicy, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes a specified SOD policy. Requires role of ORG_ADMIN.
     * @summary Delete SOD policy by ID
     * @param {SODPolicyApiDeleteSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public deleteSodPolicy(requestParameters: SODPolicyApiDeleteSodPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).deleteSodPolicy(requestParameters.id, requestParameters.logical, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes schedule for a specified SOD policy by ID.
     * @summary Delete SOD policy schedule
     * @param {SODPolicyApiDeleteSodPolicyScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public deleteSodPolicySchedule(requestParameters: SODPolicyApiDeleteSodPolicyScheduleRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).deleteSodPolicySchedule(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This allows to download a specified named violation report for a given report reference.
     * @summary Download custom violation report
     * @param {SODPolicyApiGetCustomViolationReportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public getCustomViolationReport(requestParameters: SODPolicyApiGetCustomViolationReportRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).getCustomViolationReport(requestParameters.reportResultId, requestParameters.fileName, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This allows to download a violation report for a given report reference.
     * @summary Download violation report
     * @param {SODPolicyApiGetDefaultViolationReportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public getDefaultViolationReport(requestParameters: SODPolicyApiGetDefaultViolationReportRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).getDefaultViolationReport(requestParameters.reportResultId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gets the status for a violation report for all policy run.
     * @summary Get multi-report run task status
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public getSodAllReportRunStatus(axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).getSodAllReportRunStatus(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets specified SOD policy. Requires role of ORG_ADMIN.
     * @summary Get SOD policy by ID
     * @param {SODPolicyApiGetSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public getSodPolicy(requestParameters: SODPolicyApiGetSodPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).getSodPolicy(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gets a specified SOD policy\'s schedule.
     * @summary Get SOD policy schedule
     * @param {SODPolicyApiGetSodPolicyScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public getSodPolicySchedule(requestParameters: SODPolicyApiGetSodPolicyScheduleRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).getSodPolicySchedule(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets the status for a violation report run task that has already been invoked.
     * @summary Get violation report run status
     * @param {SODPolicyApiGetSodViolationReportRunStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public getSodViolationReportRunStatus(requestParameters: SODPolicyApiGetSodViolationReportRunStatusRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).getSodViolationReportRunStatus(requestParameters.reportResultId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets the status for a violation report run task that has already been invoked.
     * @summary Get SOD violation report status
     * @param {SODPolicyApiGetSodViolationReportStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public getSodViolationReportStatus(requestParameters: SODPolicyApiGetSodViolationReportStatusRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).getSodViolationReportStatus(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets list of all SOD policies. Requires role of ORG_ADMIN
     * @summary List SOD policies
     * @param {SODPolicyApiListSodPoliciesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public listSodPolicies(requestParameters: SODPolicyApiListSodPoliciesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).listSodPolicies(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows updating SOD Policy fields other than [\"id\",\"created\",\"creatorId\",\"policyQuery\",\"type\"] using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Requires role of ORG_ADMIN. This endpoint can only patch CONFLICTING_ACCESS_BASED type policies. Do not use this endpoint to patch general policies - doing so will build an API exception. 
     * @summary Patch SOD policy by ID
     * @param {SODPolicyApiPatchSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public patchSodPolicy(requestParameters: SODPolicyApiPatchSodPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).patchSodPolicy(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This updates schedule for a specified SOD policy.
     * @summary Update SOD Policy schedule
     * @param {SODPolicyApiPutPolicyScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public putPolicySchedule(requestParameters: SODPolicyApiPutPolicyScheduleRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).putPolicySchedule(requestParameters.id, requestParameters.sodPolicySchedule, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This updates a specified SOD policy. Requires role of ORG_ADMIN.
     * @summary Update SOD policy by ID
     * @param {SODPolicyApiPutSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public putSodPolicy(requestParameters: SODPolicyApiPutSodPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).putSodPolicy(requestParameters.id, requestParameters.sodPolicy, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Runs the scheduled report for the policy retrieved by passed policy ID.  The report schedule is fetched from the policy retrieved by ID.
     * @summary Evaluate one policy by ID
     * @param {SODPolicyApiStartEvaluateSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public startEvaluateSodPolicy(requestParameters: SODPolicyApiStartEvaluateSodPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).startEvaluateSodPolicy(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Runs multi-policy report for the org. If a policy reports more than 5000 violations, the report mentions that the violation limit was exceeded for that policy. If the request is empty, the report runs for all policies. Otherwise, the report runs for only the filtered policy list provided.
     * @summary Runs all policies for org
     * @param {SODPolicyApiStartSodAllPoliciesForOrgRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public startSodAllPoliciesForOrg(requestParameters: SODPolicyApiStartSodAllPoliciesForOrgRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).startSodAllPoliciesForOrg(requestParameters.multiPolicyRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This invokes processing of violation report for given SOD policy. If the policy reports more than 5000 violations, the report returns with violation limit exceeded message.
     * @summary Runs SOD policy violation report
     * @param {SODPolicyApiStartSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public startSodPolicy(requestParameters: SODPolicyApiStartSodPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).startSodPolicy(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SODViolationsApi - axios parameter creator
 * @export
 */
export const SODViolationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API is used to check if granting some additional accesses would cause the subject to be in violation of any SOD policies. Returns the violations that would be caused.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Predict SOD violations for identity.
         * @param {IdentityWithNewAccess} identityWithNewAccess 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startPredictSodViolations: async (identityWithNewAccess: IdentityWithNewAccess, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityWithNewAccess' is not null or undefined
            assertParamExists('startPredictSodViolations', 'identityWithNewAccess', identityWithNewAccess)
            const localVarPath = `/sod-violations/predict`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityWithNewAccess, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API initiates a SOD policy verification asynchronously.  A token with ORG_ADMIN authority is required to call this API.
         * @summary Check SOD violations
         * @param {IdentityWithNewAccess1} identityWithNewAccess1 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startViolationCheck: async (identityWithNewAccess1: IdentityWithNewAccess1, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityWithNewAccess1' is not null or undefined
            assertParamExists('startViolationCheck', 'identityWithNewAccess1', identityWithNewAccess1)
            const localVarPath = `/sod-violations/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityWithNewAccess1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SODViolationsApi - functional programming interface
 * @export
 */
export const SODViolationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SODViolationsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API is used to check if granting some additional accesses would cause the subject to be in violation of any SOD policies. Returns the violations that would be caused.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Predict SOD violations for identity.
         * @param {IdentityWithNewAccess} identityWithNewAccess 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startPredictSodViolations(identityWithNewAccess: IdentityWithNewAccess, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViolationPrediction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startPredictSodViolations(identityWithNewAccess, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SODViolationsApi.startPredictSodViolations']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API initiates a SOD policy verification asynchronously.  A token with ORG_ADMIN authority is required to call this API.
         * @summary Check SOD violations
         * @param {IdentityWithNewAccess1} identityWithNewAccess1 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startViolationCheck(identityWithNewAccess1: IdentityWithNewAccess1, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodViolationCheck>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startViolationCheck(identityWithNewAccess1, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SODViolationsApi.startViolationCheck']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SODViolationsApi - factory interface
 * @export
 */
export const SODViolationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SODViolationsApiFp(configuration)
    return {
        /**
         * This API is used to check if granting some additional accesses would cause the subject to be in violation of any SOD policies. Returns the violations that would be caused.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Predict SOD violations for identity.
         * @param {SODViolationsApiStartPredictSodViolationsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        startPredictSodViolations(requestParameters: SODViolationsApiStartPredictSodViolationsRequest, options?: AxiosRequestConfig): AxiosPromise<ViolationPrediction> {
            return localVarFp.startPredictSodViolations(requestParameters.identityWithNewAccess, options).then((request) => request(axios, basePath));
        },
        /**
         * This API initiates a SOD policy verification asynchronously.  A token with ORG_ADMIN authority is required to call this API.
         * @summary Check SOD violations
         * @param {SODViolationsApiStartViolationCheckRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        startViolationCheck(requestParameters: SODViolationsApiStartViolationCheckRequest, options?: AxiosRequestConfig): AxiosPromise<SodViolationCheck> {
            return localVarFp.startViolationCheck(requestParameters.identityWithNewAccess1, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for startPredictSodViolations operation in SODViolationsApi.
 * @export
 * @interface SODViolationsApiStartPredictSodViolationsRequest
 */
export interface SODViolationsApiStartPredictSodViolationsRequest {
    /**
     * 
     * @type {IdentityWithNewAccess}
     * @memberof SODViolationsApiStartPredictSodViolations
     */
    readonly identityWithNewAccess: IdentityWithNewAccess
}

/**
 * Request parameters for startViolationCheck operation in SODViolationsApi.
 * @export
 * @interface SODViolationsApiStartViolationCheckRequest
 */
export interface SODViolationsApiStartViolationCheckRequest {
    /**
     * 
     * @type {IdentityWithNewAccess1}
     * @memberof SODViolationsApiStartViolationCheck
     */
    readonly identityWithNewAccess1: IdentityWithNewAccess1
}

/**
 * SODViolationsApi - object-oriented interface
 * @export
 * @class SODViolationsApi
 * @extends {BaseAPI}
 */
export class SODViolationsApi extends BaseAPI {
    /**
     * This API is used to check if granting some additional accesses would cause the subject to be in violation of any SOD policies. Returns the violations that would be caused.  A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Predict SOD violations for identity.
     * @param {SODViolationsApiStartPredictSodViolationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODViolationsApi
     */
    public startPredictSodViolations(requestParameters: SODViolationsApiStartPredictSodViolationsRequest, axiosOptions?: AxiosRequestConfig) {
        return SODViolationsApiFp(this.configuration).startPredictSodViolations(requestParameters.identityWithNewAccess, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API initiates a SOD policy verification asynchronously.  A token with ORG_ADMIN authority is required to call this API.
     * @summary Check SOD violations
     * @param {SODViolationsApiStartViolationCheckRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODViolationsApi
     */
    public startViolationCheck(requestParameters: SODViolationsApiStartViolationCheckRequest, axiosOptions?: AxiosRequestConfig) {
        return SODViolationsApiFp(this.configuration).startViolationCheck(requestParameters.identityWithNewAccess1, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SavedSearchApi - axios parameter creator
 * @export
 */
export const SavedSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new saved search. 
         * @summary Create a saved search
         * @param {CreateSavedSearchRequest} createSavedSearchRequest The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSavedSearch: async (createSavedSearchRequest: CreateSavedSearchRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createSavedSearchRequest' is not null or undefined
            assertParamExists('createSavedSearch', 'createSavedSearchRequest', createSavedSearchRequest)
            const localVarPath = `/saved-searches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSavedSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified saved search. 
         * @summary Delete document by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSavedSearch: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSavedSearch', 'id', id)
            const localVarPath = `/saved-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Executes the specified saved search. 
         * @summary Execute a saved search by ID
         * @param {string} id ID of the requested document.
         * @param {SearchArguments} searchArguments When saved search execution is triggered by a scheduled search, *scheduleId* will specify the ID of the triggering scheduled search.  If *scheduleId* is not specified (when execution is triggered by a UI test), the *owner* and *recipients* arguments must be provided. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        executeSavedSearch: async (id: string, searchArguments: SearchArguments, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('executeSavedSearch', 'id', id)
            // verify required parameter 'searchArguments' is not null or undefined
            assertParamExists('executeSavedSearch', 'searchArguments', searchArguments)
            const localVarPath = `/saved-searches/{id}/execute`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchArguments, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified saved search. 
         * @summary Return saved search by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSavedSearch: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSavedSearch', 'id', id)
            const localVarPath = `/saved-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of saved searches. 
         * @summary Return a list of Saved Searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **owner.id**: *eq*  **publiic**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSavedSearches: async (offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/saved-searches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing saved search.   >**NOTE: You cannot update the `owner` of the saved search.** 
         * @summary Updates an existing saved search 
         * @param {string} id ID of the requested document.
         * @param {SavedSearch} savedSearch The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSavedSearch: async (id: string, savedSearch: SavedSearch, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putSavedSearch', 'id', id)
            // verify required parameter 'savedSearch' is not null or undefined
            assertParamExists('putSavedSearch', 'savedSearch', savedSearch)
            const localVarPath = `/saved-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(savedSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SavedSearchApi - functional programming interface
 * @export
 */
export const SavedSearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SavedSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new saved search. 
         * @summary Create a saved search
         * @param {CreateSavedSearchRequest} createSavedSearchRequest The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSavedSearch(createSavedSearchRequest: CreateSavedSearchRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSavedSearch(createSavedSearchRequest, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SavedSearchApi.createSavedSearch']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Deletes the specified saved search. 
         * @summary Delete document by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSavedSearch(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSavedSearch(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SavedSearchApi.deleteSavedSearch']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Executes the specified saved search. 
         * @summary Execute a saved search by ID
         * @param {string} id ID of the requested document.
         * @param {SearchArguments} searchArguments When saved search execution is triggered by a scheduled search, *scheduleId* will specify the ID of the triggering scheduled search.  If *scheduleId* is not specified (when execution is triggered by a UI test), the *owner* and *recipients* arguments must be provided. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async executeSavedSearch(id: string, searchArguments: SearchArguments, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSavedSearch(id, searchArguments, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SavedSearchApi.executeSavedSearch']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns the specified saved search. 
         * @summary Return saved search by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSavedSearch(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSavedSearch(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SavedSearchApi.getSavedSearch']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns a list of saved searches. 
         * @summary Return a list of Saved Searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **owner.id**: *eq*  **publiic**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listSavedSearches(offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SavedSearch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSavedSearches(offset, limit, count, filters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SavedSearchApi.listSavedSearches']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Updates an existing saved search.   >**NOTE: You cannot update the `owner` of the saved search.** 
         * @summary Updates an existing saved search 
         * @param {string} id ID of the requested document.
         * @param {SavedSearch} savedSearch The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putSavedSearch(id: string, savedSearch: SavedSearch, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putSavedSearch(id, savedSearch, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SavedSearchApi.putSavedSearch']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SavedSearchApi - factory interface
 * @export
 */
export const SavedSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SavedSearchApiFp(configuration)
    return {
        /**
         * Creates a new saved search. 
         * @summary Create a saved search
         * @param {SavedSearchApiCreateSavedSearchRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        createSavedSearch(requestParameters: SavedSearchApiCreateSavedSearchRequest, options?: AxiosRequestConfig): AxiosPromise<SavedSearch> {
            return localVarFp.createSavedSearch(requestParameters.createSavedSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified saved search. 
         * @summary Delete document by ID
         * @param {SavedSearchApiDeleteSavedSearchRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteSavedSearch(requestParameters: SavedSearchApiDeleteSavedSearchRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSavedSearch(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Executes the specified saved search. 
         * @summary Execute a saved search by ID
         * @param {SavedSearchApiExecuteSavedSearchRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        executeSavedSearch(requestParameters: SavedSearchApiExecuteSavedSearchRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.executeSavedSearch(requestParameters.id, requestParameters.searchArguments, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified saved search. 
         * @summary Return saved search by ID
         * @param {SavedSearchApiGetSavedSearchRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getSavedSearch(requestParameters: SavedSearchApiGetSavedSearchRequest, options?: AxiosRequestConfig): AxiosPromise<SavedSearch> {
            return localVarFp.getSavedSearch(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of saved searches. 
         * @summary Return a list of Saved Searches
         * @param {SavedSearchApiListSavedSearchesRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listSavedSearches(requestParameters: SavedSearchApiListSavedSearchesRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<SavedSearch>> {
            return localVarFp.listSavedSearches(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.filters, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing saved search.   >**NOTE: You cannot update the `owner` of the saved search.** 
         * @summary Updates an existing saved search 
         * @param {SavedSearchApiPutSavedSearchRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        putSavedSearch(requestParameters: SavedSearchApiPutSavedSearchRequest, options?: AxiosRequestConfig): AxiosPromise<SavedSearch> {
            return localVarFp.putSavedSearch(requestParameters.id, requestParameters.savedSearch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSavedSearch operation in SavedSearchApi.
 * @export
 * @interface SavedSearchApiCreateSavedSearchRequest
 */
export interface SavedSearchApiCreateSavedSearchRequest {
    /**
     * The saved search to persist.
     * @type {CreateSavedSearchRequest}
     * @memberof SavedSearchApiCreateSavedSearch
     */
    readonly createSavedSearchRequest: CreateSavedSearchRequest
}

/**
 * Request parameters for deleteSavedSearch operation in SavedSearchApi.
 * @export
 * @interface SavedSearchApiDeleteSavedSearchRequest
 */
export interface SavedSearchApiDeleteSavedSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof SavedSearchApiDeleteSavedSearch
     */
    readonly id: string
}

/**
 * Request parameters for executeSavedSearch operation in SavedSearchApi.
 * @export
 * @interface SavedSearchApiExecuteSavedSearchRequest
 */
export interface SavedSearchApiExecuteSavedSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof SavedSearchApiExecuteSavedSearch
     */
    readonly id: string

    /**
     * When saved search execution is triggered by a scheduled search, *scheduleId* will specify the ID of the triggering scheduled search.  If *scheduleId* is not specified (when execution is triggered by a UI test), the *owner* and *recipients* arguments must be provided. 
     * @type {SearchArguments}
     * @memberof SavedSearchApiExecuteSavedSearch
     */
    readonly searchArguments: SearchArguments
}

/**
 * Request parameters for getSavedSearch operation in SavedSearchApi.
 * @export
 * @interface SavedSearchApiGetSavedSearchRequest
 */
export interface SavedSearchApiGetSavedSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof SavedSearchApiGetSavedSearch
     */
    readonly id: string
}

/**
 * Request parameters for listSavedSearches operation in SavedSearchApi.
 * @export
 * @interface SavedSearchApiListSavedSearchesRequest
 */
export interface SavedSearchApiListSavedSearchesRequest {
    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SavedSearchApiListSavedSearches
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SavedSearchApiListSavedSearches
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SavedSearchApiListSavedSearches
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **owner.id**: *eq*  **publiic**: *eq*
     * @type {string}
     * @memberof SavedSearchApiListSavedSearches
     */
    readonly filters?: string
}

/**
 * Request parameters for putSavedSearch operation in SavedSearchApi.
 * @export
 * @interface SavedSearchApiPutSavedSearchRequest
 */
export interface SavedSearchApiPutSavedSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof SavedSearchApiPutSavedSearch
     */
    readonly id: string

    /**
     * The saved search to persist.
     * @type {SavedSearch}
     * @memberof SavedSearchApiPutSavedSearch
     */
    readonly savedSearch: SavedSearch
}

/**
 * SavedSearchApi - object-oriented interface
 * @export
 * @class SavedSearchApi
 * @extends {BaseAPI}
 */
export class SavedSearchApi extends BaseAPI {
    /**
     * Creates a new saved search. 
     * @summary Create a saved search
     * @param {SavedSearchApiCreateSavedSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    public createSavedSearch(requestParameters: SavedSearchApiCreateSavedSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return SavedSearchApiFp(this.configuration).createSavedSearch(requestParameters.createSavedSearchRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified saved search. 
     * @summary Delete document by ID
     * @param {SavedSearchApiDeleteSavedSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    public deleteSavedSearch(requestParameters: SavedSearchApiDeleteSavedSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return SavedSearchApiFp(this.configuration).deleteSavedSearch(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Executes the specified saved search. 
     * @summary Execute a saved search by ID
     * @param {SavedSearchApiExecuteSavedSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    public executeSavedSearch(requestParameters: SavedSearchApiExecuteSavedSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return SavedSearchApiFp(this.configuration).executeSavedSearch(requestParameters.id, requestParameters.searchArguments, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified saved search. 
     * @summary Return saved search by ID
     * @param {SavedSearchApiGetSavedSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    public getSavedSearch(requestParameters: SavedSearchApiGetSavedSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return SavedSearchApiFp(this.configuration).getSavedSearch(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of saved searches. 
     * @summary Return a list of Saved Searches
     * @param {SavedSearchApiListSavedSearchesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    public listSavedSearches(requestParameters: SavedSearchApiListSavedSearchesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return SavedSearchApiFp(this.configuration).listSavedSearches(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing saved search.   >**NOTE: You cannot update the `owner` of the saved search.** 
     * @summary Updates an existing saved search 
     * @param {SavedSearchApiPutSavedSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    public putSavedSearch(requestParameters: SavedSearchApiPutSavedSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return SavedSearchApiFp(this.configuration).putSavedSearch(requestParameters.id, requestParameters.savedSearch, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ScheduledSearchApi - axios parameter creator
 * @export
 */
export const ScheduledSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new scheduled search. 
         * @summary Create a new scheduled search
         * @param {CreateScheduledSearchRequest} createScheduledSearchRequest The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createScheduledSearch: async (createScheduledSearchRequest: CreateScheduledSearchRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createScheduledSearchRequest' is not null or undefined
            assertParamExists('createScheduledSearch', 'createScheduledSearchRequest', createScheduledSearchRequest)
            const localVarPath = `/scheduled-searches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createScheduledSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified scheduled search. 
         * @summary Delete a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteScheduledSearch: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteScheduledSearch', 'id', id)
            const localVarPath = `/scheduled-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified scheduled search.
         * @summary Get a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getScheduledSearch: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getScheduledSearch', 'id', id)
            const localVarPath = `/scheduled-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of scheduled searches. 
         * @summary List scheduled searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **owner.id**: *eq*  **savedSearchId**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listScheduledSearch: async (offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/scheduled-searches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Unsubscribes a recipient from the specified scheduled search. 
         * @summary Unsubscribe a recipient from Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {TypedReference} typedReference The recipient to be removed from the scheduled search. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeScheduledSearch: async (id: string, typedReference: TypedReference, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unsubscribeScheduledSearch', 'id', id)
            // verify required parameter 'typedReference' is not null or undefined
            assertParamExists('unsubscribeScheduledSearch', 'typedReference', typedReference)
            const localVarPath = `/scheduled-searches/{id}/unsubscribe`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typedReference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing scheduled search. 
         * @summary Update an existing Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {ScheduledSearch} scheduledSearch The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateScheduledSearch: async (id: string, scheduledSearch: ScheduledSearch, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateScheduledSearch', 'id', id)
            // verify required parameter 'scheduledSearch' is not null or undefined
            assertParamExists('updateScheduledSearch', 'scheduledSearch', scheduledSearch)
            const localVarPath = `/scheduled-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scheduledSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScheduledSearchApi - functional programming interface
 * @export
 */
export const ScheduledSearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScheduledSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new scheduled search. 
         * @summary Create a new scheduled search
         * @param {CreateScheduledSearchRequest} createScheduledSearchRequest The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createScheduledSearch(createScheduledSearchRequest: CreateScheduledSearchRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScheduledSearch(createScheduledSearchRequest, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ScheduledSearchApi.createScheduledSearch']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Deletes the specified scheduled search. 
         * @summary Delete a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScheduledSearch(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScheduledSearch(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ScheduledSearchApi.deleteScheduledSearch']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns the specified scheduled search.
         * @summary Get a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getScheduledSearch(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScheduledSearch(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ScheduledSearchApi.getScheduledSearch']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns a list of scheduled searches. 
         * @summary List scheduled searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **owner.id**: *eq*  **savedSearchId**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listScheduledSearch(offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScheduledSearch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScheduledSearch(offset, limit, count, filters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ScheduledSearchApi.listScheduledSearch']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Unsubscribes a recipient from the specified scheduled search. 
         * @summary Unsubscribe a recipient from Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {TypedReference} typedReference The recipient to be removed from the scheduled search. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async unsubscribeScheduledSearch(id: string, typedReference: TypedReference, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsubscribeScheduledSearch(id, typedReference, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ScheduledSearchApi.unsubscribeScheduledSearch']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Updates an existing scheduled search. 
         * @summary Update an existing Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {ScheduledSearch} scheduledSearch The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateScheduledSearch(id: string, scheduledSearch: ScheduledSearch, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateScheduledSearch(id, scheduledSearch, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ScheduledSearchApi.updateScheduledSearch']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ScheduledSearchApi - factory interface
 * @export
 */
export const ScheduledSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScheduledSearchApiFp(configuration)
    return {
        /**
         * Creates a new scheduled search. 
         * @summary Create a new scheduled search
         * @param {ScheduledSearchApiCreateScheduledSearchRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        createScheduledSearch(requestParameters: ScheduledSearchApiCreateScheduledSearchRequest, options?: AxiosRequestConfig): AxiosPromise<ScheduledSearch> {
            return localVarFp.createScheduledSearch(requestParameters.createScheduledSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified scheduled search. 
         * @summary Delete a Scheduled Search
         * @param {ScheduledSearchApiDeleteScheduledSearchRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteScheduledSearch(requestParameters: ScheduledSearchApiDeleteScheduledSearchRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteScheduledSearch(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified scheduled search.
         * @summary Get a Scheduled Search
         * @param {ScheduledSearchApiGetScheduledSearchRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getScheduledSearch(requestParameters: ScheduledSearchApiGetScheduledSearchRequest, options?: AxiosRequestConfig): AxiosPromise<ScheduledSearch> {
            return localVarFp.getScheduledSearch(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of scheduled searches. 
         * @summary List scheduled searches
         * @param {ScheduledSearchApiListScheduledSearchRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listScheduledSearch(requestParameters: ScheduledSearchApiListScheduledSearchRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<ScheduledSearch>> {
            return localVarFp.listScheduledSearch(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.filters, options).then((request) => request(axios, basePath));
        },
        /**
         * Unsubscribes a recipient from the specified scheduled search. 
         * @summary Unsubscribe a recipient from Scheduled Search
         * @param {ScheduledSearchApiUnsubscribeScheduledSearchRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        unsubscribeScheduledSearch(requestParameters: ScheduledSearchApiUnsubscribeScheduledSearchRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unsubscribeScheduledSearch(requestParameters.id, requestParameters.typedReference, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing scheduled search. 
         * @summary Update an existing Scheduled Search
         * @param {ScheduledSearchApiUpdateScheduledSearchRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        updateScheduledSearch(requestParameters: ScheduledSearchApiUpdateScheduledSearchRequest, options?: AxiosRequestConfig): AxiosPromise<ScheduledSearch> {
            return localVarFp.updateScheduledSearch(requestParameters.id, requestParameters.scheduledSearch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createScheduledSearch operation in ScheduledSearchApi.
 * @export
 * @interface ScheduledSearchApiCreateScheduledSearchRequest
 */
export interface ScheduledSearchApiCreateScheduledSearchRequest {
    /**
     * The scheduled search to persist.
     * @type {CreateScheduledSearchRequest}
     * @memberof ScheduledSearchApiCreateScheduledSearch
     */
    readonly createScheduledSearchRequest: CreateScheduledSearchRequest
}

/**
 * Request parameters for deleteScheduledSearch operation in ScheduledSearchApi.
 * @export
 * @interface ScheduledSearchApiDeleteScheduledSearchRequest
 */
export interface ScheduledSearchApiDeleteScheduledSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof ScheduledSearchApiDeleteScheduledSearch
     */
    readonly id: string
}

/**
 * Request parameters for getScheduledSearch operation in ScheduledSearchApi.
 * @export
 * @interface ScheduledSearchApiGetScheduledSearchRequest
 */
export interface ScheduledSearchApiGetScheduledSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof ScheduledSearchApiGetScheduledSearch
     */
    readonly id: string
}

/**
 * Request parameters for listScheduledSearch operation in ScheduledSearchApi.
 * @export
 * @interface ScheduledSearchApiListScheduledSearchRequest
 */
export interface ScheduledSearchApiListScheduledSearchRequest {
    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ScheduledSearchApiListScheduledSearch
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ScheduledSearchApiListScheduledSearch
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof ScheduledSearchApiListScheduledSearch
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **owner.id**: *eq*  **savedSearchId**: *eq*
     * @type {string}
     * @memberof ScheduledSearchApiListScheduledSearch
     */
    readonly filters?: string
}

/**
 * Request parameters for unsubscribeScheduledSearch operation in ScheduledSearchApi.
 * @export
 * @interface ScheduledSearchApiUnsubscribeScheduledSearchRequest
 */
export interface ScheduledSearchApiUnsubscribeScheduledSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof ScheduledSearchApiUnsubscribeScheduledSearch
     */
    readonly id: string

    /**
     * The recipient to be removed from the scheduled search. 
     * @type {TypedReference}
     * @memberof ScheduledSearchApiUnsubscribeScheduledSearch
     */
    readonly typedReference: TypedReference
}

/**
 * Request parameters for updateScheduledSearch operation in ScheduledSearchApi.
 * @export
 * @interface ScheduledSearchApiUpdateScheduledSearchRequest
 */
export interface ScheduledSearchApiUpdateScheduledSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof ScheduledSearchApiUpdateScheduledSearch
     */
    readonly id: string

    /**
     * The scheduled search to persist.
     * @type {ScheduledSearch}
     * @memberof ScheduledSearchApiUpdateScheduledSearch
     */
    readonly scheduledSearch: ScheduledSearch
}

/**
 * ScheduledSearchApi - object-oriented interface
 * @export
 * @class ScheduledSearchApi
 * @extends {BaseAPI}
 */
export class ScheduledSearchApi extends BaseAPI {
    /**
     * Creates a new scheduled search. 
     * @summary Create a new scheduled search
     * @param {ScheduledSearchApiCreateScheduledSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    public createScheduledSearch(requestParameters: ScheduledSearchApiCreateScheduledSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return ScheduledSearchApiFp(this.configuration).createScheduledSearch(requestParameters.createScheduledSearchRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified scheduled search. 
     * @summary Delete a Scheduled Search
     * @param {ScheduledSearchApiDeleteScheduledSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    public deleteScheduledSearch(requestParameters: ScheduledSearchApiDeleteScheduledSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return ScheduledSearchApiFp(this.configuration).deleteScheduledSearch(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified scheduled search.
     * @summary Get a Scheduled Search
     * @param {ScheduledSearchApiGetScheduledSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    public getScheduledSearch(requestParameters: ScheduledSearchApiGetScheduledSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return ScheduledSearchApiFp(this.configuration).getScheduledSearch(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of scheduled searches. 
     * @summary List scheduled searches
     * @param {ScheduledSearchApiListScheduledSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    public listScheduledSearch(requestParameters: ScheduledSearchApiListScheduledSearchRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return ScheduledSearchApiFp(this.configuration).listScheduledSearch(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unsubscribes a recipient from the specified scheduled search. 
     * @summary Unsubscribe a recipient from Scheduled Search
     * @param {ScheduledSearchApiUnsubscribeScheduledSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    public unsubscribeScheduledSearch(requestParameters: ScheduledSearchApiUnsubscribeScheduledSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return ScheduledSearchApiFp(this.configuration).unsubscribeScheduledSearch(requestParameters.id, requestParameters.typedReference, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing scheduled search. 
     * @summary Update an existing Scheduled Search
     * @param {ScheduledSearchApiUpdateScheduledSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    public updateScheduledSearch(requestParameters: ScheduledSearchApiUpdateScheduledSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return ScheduledSearchApiFp(this.configuration).updateScheduledSearch(requestParameters.id, requestParameters.scheduledSearch, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Performs a search query aggregation and returns the aggregation result. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
         * @summary Perform a Search Query Aggregation
         * @param {Search} search 
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchAggregate: async (search: Search, offset?: number, limit?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'search' is not null or undefined
            assertParamExists('searchAggregate', 'search', search)
            const localVarPath = `/search/aggregate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(search, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Performs a search with a provided query and returns the count of results in the X-Total-Count header.
         * @summary Count Documents Satisfying a Query
         * @param {Search} search 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchCount: async (search: Search, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'search' is not null or undefined
            assertParamExists('searchCount', 'search', search)
            const localVarPath = `/search/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(search, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Fetches a single document from the specified index, using the specified document ID.
         * @summary Get a Document by ID
         * @param {string} index The index from which to fetch the specified document.  The currently supported index names are: *accessprofiles*, *accountactivities*, *entitlements*, *events*, *identities*, and *roles*. 
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchGet: async (index: string, id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'index' is not null or undefined
            assertParamExists('searchGet', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('searchGet', 'id', id)
            const localVarPath = `/search/{index}/{id}`
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Performs a search with the provided query and returns a matching result collection. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
         * @summary Perform Search
         * @param {Search} search 
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchPost: async (search: Search, offset?: number, limit?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'search' is not null or undefined
            assertParamExists('searchPost', 'search', search)
            const localVarPath = `/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(search, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Performs a search query aggregation and returns the aggregation result. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
         * @summary Perform a Search Query Aggregation
         * @param {Search} search 
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async searchAggregate(search: Search, offset?: number, limit?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AggregationResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchAggregate(search, offset, limit, count, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SearchApi.searchAggregate']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Performs a search with a provided query and returns the count of results in the X-Total-Count header.
         * @summary Count Documents Satisfying a Query
         * @param {Search} search 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async searchCount(search: Search, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchCount(search, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SearchApi.searchCount']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Fetches a single document from the specified index, using the specified document ID.
         * @summary Get a Document by ID
         * @param {string} index The index from which to fetch the specified document.  The currently supported index names are: *accessprofiles*, *accountactivities*, *entitlements*, *events*, *identities*, and *roles*. 
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async searchGet(index: string, id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchDocument>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchGet(index, id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SearchApi.searchGet']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Performs a search with the provided query and returns a matching result collection. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
         * @summary Perform Search
         * @param {Search} search 
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async searchPost(search: Search, offset?: number, limit?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SearchDocument>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPost(search, offset, limit, count, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SearchApi.searchPost']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         * Performs a search query aggregation and returns the aggregation result. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
         * @summary Perform a Search Query Aggregation
         * @param {SearchApiSearchAggregateRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        searchAggregate(requestParameters: SearchApiSearchAggregateRequest, options?: AxiosRequestConfig): AxiosPromise<AggregationResult> {
            return localVarFp.searchAggregate(requestParameters.search, requestParameters.offset, requestParameters.limit, requestParameters.count, options).then((request) => request(axios, basePath));
        },
        /**
         * Performs a search with a provided query and returns the count of results in the X-Total-Count header.
         * @summary Count Documents Satisfying a Query
         * @param {SearchApiSearchCountRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        searchCount(requestParameters: SearchApiSearchCountRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.searchCount(requestParameters.search, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a single document from the specified index, using the specified document ID.
         * @summary Get a Document by ID
         * @param {SearchApiSearchGetRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        searchGet(requestParameters: SearchApiSearchGetRequest, options?: AxiosRequestConfig): AxiosPromise<SearchDocument> {
            return localVarFp.searchGet(requestParameters.index, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Performs a search with the provided query and returns a matching result collection. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
         * @summary Perform Search
         * @param {SearchApiSearchPostRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        searchPost(requestParameters: SearchApiSearchPostRequest, options?: AxiosRequestConfig): AxiosPromise<Array<SearchDocument>> {
            return localVarFp.searchPost(requestParameters.search, requestParameters.offset, requestParameters.limit, requestParameters.count, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for searchAggregate operation in SearchApi.
 * @export
 * @interface SearchApiSearchAggregateRequest
 */
export interface SearchApiSearchAggregateRequest {
    /**
     * 
     * @type {Search}
     * @memberof SearchApiSearchAggregate
     */
    readonly search: Search

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SearchApiSearchAggregate
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SearchApiSearchAggregate
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SearchApiSearchAggregate
     */
    readonly count?: boolean
}

/**
 * Request parameters for searchCount operation in SearchApi.
 * @export
 * @interface SearchApiSearchCountRequest
 */
export interface SearchApiSearchCountRequest {
    /**
     * 
     * @type {Search}
     * @memberof SearchApiSearchCount
     */
    readonly search: Search
}

/**
 * Request parameters for searchGet operation in SearchApi.
 * @export
 * @interface SearchApiSearchGetRequest
 */
export interface SearchApiSearchGetRequest {
    /**
     * The index from which to fetch the specified document.  The currently supported index names are: *accessprofiles*, *accountactivities*, *entitlements*, *events*, *identities*, and *roles*. 
     * @type {string}
     * @memberof SearchApiSearchGet
     */
    readonly index: string

    /**
     * ID of the requested document.
     * @type {string}
     * @memberof SearchApiSearchGet
     */
    readonly id: string
}

/**
 * Request parameters for searchPost operation in SearchApi.
 * @export
 * @interface SearchApiSearchPostRequest
 */
export interface SearchApiSearchPostRequest {
    /**
     * 
     * @type {Search}
     * @memberof SearchApiSearchPost
     */
    readonly search: Search

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SearchApiSearchPost
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SearchApiSearchPost
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SearchApiSearchPost
     */
    readonly count?: boolean
}

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * Performs a search query aggregation and returns the aggregation result. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
     * @summary Perform a Search Query Aggregation
     * @param {SearchApiSearchAggregateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchAggregate(requestParameters: SearchApiSearchAggregateRequest, axiosOptions?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchAggregate(requestParameters.search, requestParameters.offset, requestParameters.limit, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs a search with a provided query and returns the count of results in the X-Total-Count header.
     * @summary Count Documents Satisfying a Query
     * @param {SearchApiSearchCountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchCount(requestParameters: SearchApiSearchCountRequest, axiosOptions?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchCount(requestParameters.search, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches a single document from the specified index, using the specified document ID.
     * @summary Get a Document by ID
     * @param {SearchApiSearchGetRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchGet(requestParameters: SearchApiSearchGetRequest, axiosOptions?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchGet(requestParameters.index, requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs a search with the provided query and returns a matching result collection. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
     * @summary Perform Search
     * @param {SearchApiSearchPostRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchPost(requestParameters: SearchApiSearchPostRequest, axiosOptions?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchPost(requestParameters.search, requestParameters.offset, requestParameters.limit, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SegmentsApi - axios parameter creator
 * @export
 */
export const SegmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates a segment.  >**Note:** Segment definitions may take time to propagate to all identities. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Create Segment
         * @param {Segment} segment 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSegment: async (segment: Segment, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'segment' is not null or undefined
            assertParamExists('createSegment', 'segment', segment)
            const localVarPath = `/segments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(segment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API deletes the segment specified by the given ID. >**Note:** that segment deletion may take some time to become effective. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Delete Segment by ID
         * @param {string} id The segment ID to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSegment: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSegment', 'id', id)
            const localVarPath = `/segments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the segment specified by the given ID. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get Segment by ID
         * @param {string} id The segment ID to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSegment: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSegment', 'id', id)
            const localVarPath = `/segments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of all segments.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary List Segments
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSegments: async (limit?: number, offset?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/segments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to update segment fields by using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. >**Note:** Changes to a segment may take some time to propagate to all identities. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Update Segment
         * @param {string} id The segment ID to modify.
         * @param {Array<object>} requestBody A list of segment update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * owner * visibilityCriteria * active 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSegment: async (id: string, requestBody: Array<object>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchSegment', 'id', id)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('patchSegment', 'requestBody', requestBody)
            const localVarPath = `/segments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SegmentsApi - functional programming interface
 * @export
 */
export const SegmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SegmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates a segment.  >**Note:** Segment definitions may take time to propagate to all identities. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Create Segment
         * @param {Segment} segment 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSegment(segment: Segment, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Segment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSegment(segment, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SegmentsApi.createSegment']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API deletes the segment specified by the given ID. >**Note:** that segment deletion may take some time to become effective. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Delete Segment by ID
         * @param {string} id The segment ID to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSegment(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSegment(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SegmentsApi.deleteSegment']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API returns the segment specified by the given ID. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get Segment by ID
         * @param {string} id The segment ID to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSegment(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Segment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSegment(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SegmentsApi.getSegment']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API returns a list of all segments.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary List Segments
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listSegments(limit?: number, offset?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Segment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSegments(limit, offset, count, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SegmentsApi.listSegments']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Use this API to update segment fields by using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. >**Note:** Changes to a segment may take some time to propagate to all identities. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Update Segment
         * @param {string} id The segment ID to modify.
         * @param {Array<object>} requestBody A list of segment update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * owner * visibilityCriteria * active 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchSegment(id: string, requestBody: Array<object>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Segment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchSegment(id, requestBody, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SegmentsApi.patchSegment']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SegmentsApi - factory interface
 * @export
 */
export const SegmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SegmentsApiFp(configuration)
    return {
        /**
         * This API creates a segment.  >**Note:** Segment definitions may take time to propagate to all identities. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Create Segment
         * @param {SegmentsApiCreateSegmentRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        createSegment(requestParameters: SegmentsApiCreateSegmentRequest, options?: AxiosRequestConfig): AxiosPromise<Segment> {
            return localVarFp.createSegment(requestParameters.segment, options).then((request) => request(axios, basePath));
        },
        /**
         * This API deletes the segment specified by the given ID. >**Note:** that segment deletion may take some time to become effective. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Delete Segment by ID
         * @param {SegmentsApiDeleteSegmentRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteSegment(requestParameters: SegmentsApiDeleteSegmentRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSegment(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the segment specified by the given ID. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get Segment by ID
         * @param {SegmentsApiGetSegmentRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getSegment(requestParameters: SegmentsApiGetSegmentRequest, options?: AxiosRequestConfig): AxiosPromise<Segment> {
            return localVarFp.getSegment(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of all segments.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary List Segments
         * @param {SegmentsApiListSegmentsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listSegments(requestParameters: SegmentsApiListSegmentsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<Segment>> {
            return localVarFp.listSegments(requestParameters.limit, requestParameters.offset, requestParameters.count, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to update segment fields by using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. >**Note:** Changes to a segment may take some time to propagate to all identities. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Update Segment
         * @param {SegmentsApiPatchSegmentRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        patchSegment(requestParameters: SegmentsApiPatchSegmentRequest, options?: AxiosRequestConfig): AxiosPromise<Segment> {
            return localVarFp.patchSegment(requestParameters.id, requestParameters.requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSegment operation in SegmentsApi.
 * @export
 * @interface SegmentsApiCreateSegmentRequest
 */
export interface SegmentsApiCreateSegmentRequest {
    /**
     * 
     * @type {Segment}
     * @memberof SegmentsApiCreateSegment
     */
    readonly segment: Segment
}

/**
 * Request parameters for deleteSegment operation in SegmentsApi.
 * @export
 * @interface SegmentsApiDeleteSegmentRequest
 */
export interface SegmentsApiDeleteSegmentRequest {
    /**
     * The segment ID to delete.
     * @type {string}
     * @memberof SegmentsApiDeleteSegment
     */
    readonly id: string
}

/**
 * Request parameters for getSegment operation in SegmentsApi.
 * @export
 * @interface SegmentsApiGetSegmentRequest
 */
export interface SegmentsApiGetSegmentRequest {
    /**
     * The segment ID to retrieve.
     * @type {string}
     * @memberof SegmentsApiGetSegment
     */
    readonly id: string
}

/**
 * Request parameters for listSegments operation in SegmentsApi.
 * @export
 * @interface SegmentsApiListSegmentsRequest
 */
export interface SegmentsApiListSegmentsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SegmentsApiListSegments
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SegmentsApiListSegments
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SegmentsApiListSegments
     */
    readonly count?: boolean
}

/**
 * Request parameters for patchSegment operation in SegmentsApi.
 * @export
 * @interface SegmentsApiPatchSegmentRequest
 */
export interface SegmentsApiPatchSegmentRequest {
    /**
     * The segment ID to modify.
     * @type {string}
     * @memberof SegmentsApiPatchSegment
     */
    readonly id: string

    /**
     * A list of segment update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * owner * visibilityCriteria * active 
     * @type {Array<object>}
     * @memberof SegmentsApiPatchSegment
     */
    readonly requestBody: Array<object>
}

/**
 * SegmentsApi - object-oriented interface
 * @export
 * @class SegmentsApi
 * @extends {BaseAPI}
 */
export class SegmentsApi extends BaseAPI {
    /**
     * This API creates a segment.  >**Note:** Segment definitions may take time to propagate to all identities. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Create Segment
     * @param {SegmentsApiCreateSegmentRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public createSegment(requestParameters: SegmentsApiCreateSegmentRequest, axiosOptions?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).createSegment(requestParameters.segment, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API deletes the segment specified by the given ID. >**Note:** that segment deletion may take some time to become effective. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Delete Segment by ID
     * @param {SegmentsApiDeleteSegmentRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public deleteSegment(requestParameters: SegmentsApiDeleteSegmentRequest, axiosOptions?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).deleteSegment(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the segment specified by the given ID. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Get Segment by ID
     * @param {SegmentsApiGetSegmentRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public getSegment(requestParameters: SegmentsApiGetSegmentRequest, axiosOptions?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).getSegment(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of all segments.  A token with ORG_ADMIN or API authority is required to call this API.
     * @summary List Segments
     * @param {SegmentsApiListSegmentsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public listSegments(requestParameters: SegmentsApiListSegmentsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).listSegments(requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to update segment fields by using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. >**Note:** Changes to a segment may take some time to propagate to all identities. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Update Segment
     * @param {SegmentsApiPatchSegmentRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public patchSegment(requestParameters: SegmentsApiPatchSegmentRequest, axiosOptions?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).patchSegment(requestParameters.id, requestParameters.requestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServiceDeskIntegrationApi - axios parameter creator
 * @export
 */
export const ServiceDeskIntegrationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Create new Service Desk integration
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of a new integration to create
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createServiceDeskIntegration: async (serviceDeskIntegrationDto: ServiceDeskIntegrationDto, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceDeskIntegrationDto' is not null or undefined
            assertParamExists('createServiceDeskIntegration', 'serviceDeskIntegrationDto', serviceDeskIntegrationDto)
            const localVarPath = `/service-desk-integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceDeskIntegrationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Delete a Service Desk integration
         * @param {string} id ID of Service Desk integration to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceDeskIntegration: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteServiceDeskIntegration', 'id', id)
            const localVarPath = `/service-desk-integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get a Service Desk integration
         * @param {string} id ID of the Service Desk integration to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegration: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getServiceDeskIntegration', 'id', id)
            const localVarPath = `/service-desk-integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API endpoint returns an existing Service Desk integration template by scriptName.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk integration template by scriptName.
         * @param {string} scriptName The scriptName value of the Service Desk integration template to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationTemplate: async (scriptName: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptName' is not null or undefined
            assertParamExists('getServiceDeskIntegrationTemplate', 'scriptName', scriptName)
            const localVarPath = `/service-desk-integrations/templates/{scriptName}`
                .replace(`{${"scriptName"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API endpoint returns the current list of supported Service Desk integration types.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk Integration Types List.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationTypes: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/service-desk-integrations/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get a list of ServiceDeskIntegrationDto for existing Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary List existing Service Desk Integrations
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq*  **type**: *eq, in*  **cluster**: *eq, in*
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrations: async (offset?: number, limit?: number, sorters?: string, filters?: string, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/service-desk-integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get the time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getStatusCheckDetails: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/service-desk-integrations/status-check-configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update an existing ServiceDeskIntegration by ID with a PATCH request.
         * @summary Service Desk Integration Update PATCH
         * @param {string} id ID of the Service Desk integration to update
         * @param {JsonPatch} jsonPatch A list of SDIM update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  PATCH can only be applied to the following fields:   * &#x60;beforeProvisioningRule&#x60;   * &#x60;description&#x60;   * &#x60;ownerRef&#x60;  A 403 Forbidden Error indicates that you attempted to PATCH a field that is not allowed. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchServiceDeskIntegration: async (id: string, jsonPatch: JsonPatch, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchServiceDeskIntegration', 'id', id)
            // verify required parameter 'jsonPatch' is not null or undefined
            assertParamExists('patchServiceDeskIntegration', 'jsonPatch', jsonPatch)
            const localVarPath = `/service-desk-integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update an existing Service Desk integration by ID with updated value in JSON form as the request body.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update a Service Desk integration
         * @param {string} id ID of the Service Desk integration to update
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of the integration to update
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putServiceDeskIntegration: async (id: string, serviceDeskIntegrationDto: ServiceDeskIntegrationDto, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putServiceDeskIntegration', 'id', id)
            // verify required parameter 'serviceDeskIntegrationDto' is not null or undefined
            assertParamExists('putServiceDeskIntegration', 'serviceDeskIntegrationDto', serviceDeskIntegrationDto)
            const localVarPath = `/service-desk-integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceDeskIntegrationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update the time check configuration
         * @param {QueuedCheckConfigDetails} queuedCheckConfigDetails the modified time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateStatusCheckDetails: async (queuedCheckConfigDetails: QueuedCheckConfigDetails, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queuedCheckConfigDetails' is not null or undefined
            assertParamExists('updateStatusCheckDetails', 'queuedCheckConfigDetails', queuedCheckConfigDetails)
            const localVarPath = `/service-desk-integrations/status-check-configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queuedCheckConfigDetails, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceDeskIntegrationApi - functional programming interface
 * @export
 */
export const ServiceDeskIntegrationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceDeskIntegrationApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Create new Service Desk integration
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of a new integration to create
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createServiceDeskIntegration(serviceDeskIntegrationDto: ServiceDeskIntegrationDto, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDeskIntegrationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createServiceDeskIntegration(serviceDeskIntegrationDto, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServiceDeskIntegrationApi.createServiceDeskIntegration']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Delete a Service Desk integration
         * @param {string} id ID of Service Desk integration to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteServiceDeskIntegration(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteServiceDeskIntegration(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServiceDeskIntegrationApi.deleteServiceDeskIntegration']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get a Service Desk integration
         * @param {string} id ID of the Service Desk integration to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDeskIntegration(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDeskIntegrationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDeskIntegration(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServiceDeskIntegrationApi.getServiceDeskIntegration']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API endpoint returns an existing Service Desk integration template by scriptName.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk integration template by scriptName.
         * @param {string} scriptName The scriptName value of the Service Desk integration template to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDeskIntegrationTemplate(scriptName: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDeskIntegrationTemplateDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDeskIntegrationTemplate(scriptName, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServiceDeskIntegrationApi.getServiceDeskIntegrationTemplate']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API endpoint returns the current list of supported Service Desk integration types.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk Integration Types List.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDeskIntegrationTypes(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceDeskIntegrationTemplateType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDeskIntegrationTypes(axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServiceDeskIntegrationApi.getServiceDeskIntegrationTypes']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get a list of ServiceDeskIntegrationDto for existing Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary List existing Service Desk Integrations
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq*  **type**: *eq, in*  **cluster**: *eq, in*
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDeskIntegrations(offset?: number, limit?: number, sorters?: string, filters?: string, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceDeskIntegrationDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDeskIntegrations(offset, limit, sorters, filters, count, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServiceDeskIntegrationApi.getServiceDeskIntegrations']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get the time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusCheckDetails(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedCheckConfigDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusCheckDetails(axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServiceDeskIntegrationApi.getStatusCheckDetails']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update an existing ServiceDeskIntegration by ID with a PATCH request.
         * @summary Service Desk Integration Update PATCH
         * @param {string} id ID of the Service Desk integration to update
         * @param {JsonPatch} jsonPatch A list of SDIM update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  PATCH can only be applied to the following fields:   * &#x60;beforeProvisioningRule&#x60;   * &#x60;description&#x60;   * &#x60;ownerRef&#x60;  A 403 Forbidden Error indicates that you attempted to PATCH a field that is not allowed. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchServiceDeskIntegration(id: string, jsonPatch: JsonPatch, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDeskIntegrationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchServiceDeskIntegration(id, jsonPatch, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServiceDeskIntegrationApi.patchServiceDeskIntegration']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update an existing Service Desk integration by ID with updated value in JSON form as the request body.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update a Service Desk integration
         * @param {string} id ID of the Service Desk integration to update
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of the integration to update
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putServiceDeskIntegration(id: string, serviceDeskIntegrationDto: ServiceDeskIntegrationDto, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDeskIntegrationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putServiceDeskIntegration(id, serviceDeskIntegrationDto, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServiceDeskIntegrationApi.putServiceDeskIntegration']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update the time check configuration
         * @param {QueuedCheckConfigDetails} queuedCheckConfigDetails the modified time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateStatusCheckDetails(queuedCheckConfigDetails: QueuedCheckConfigDetails, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedCheckConfigDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStatusCheckDetails(queuedCheckConfigDetails, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServiceDeskIntegrationApi.updateStatusCheckDetails']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ServiceDeskIntegrationApi - factory interface
 * @export
 */
export const ServiceDeskIntegrationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceDeskIntegrationApiFp(configuration)
    return {
        /**
         * Create a new Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Create new Service Desk integration
         * @param {ServiceDeskIntegrationApiCreateServiceDeskIntegrationRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        createServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiCreateServiceDeskIntegrationRequest, options?: AxiosRequestConfig): AxiosPromise<ServiceDeskIntegrationDto> {
            return localVarFp.createServiceDeskIntegration(requestParameters.serviceDeskIntegrationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Delete a Service Desk integration
         * @param {ServiceDeskIntegrationApiDeleteServiceDeskIntegrationRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiDeleteServiceDeskIntegrationRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteServiceDeskIntegration(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get a Service Desk integration
         * @param {ServiceDeskIntegrationApiGetServiceDeskIntegrationRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiGetServiceDeskIntegrationRequest, options?: AxiosRequestConfig): AxiosPromise<ServiceDeskIntegrationDto> {
            return localVarFp.getServiceDeskIntegration(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This API endpoint returns an existing Service Desk integration template by scriptName.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk integration template by scriptName.
         * @param {ServiceDeskIntegrationApiGetServiceDeskIntegrationTemplateRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getServiceDeskIntegrationTemplate(requestParameters: ServiceDeskIntegrationApiGetServiceDeskIntegrationTemplateRequest, options?: AxiosRequestConfig): AxiosPromise<ServiceDeskIntegrationTemplateDto> {
            return localVarFp.getServiceDeskIntegrationTemplate(requestParameters.scriptName, options).then((request) => request(axios, basePath));
        },
        /**
         * This API endpoint returns the current list of supported Service Desk integration types.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk Integration Types List.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getServiceDeskIntegrationTypes(options?: AxiosRequestConfig): AxiosPromise<Array<ServiceDeskIntegrationTemplateType>> {
            return localVarFp.getServiceDeskIntegrationTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of ServiceDeskIntegrationDto for existing Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary List existing Service Desk Integrations
         * @param {ServiceDeskIntegrationApiGetServiceDeskIntegrationsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getServiceDeskIntegrations(requestParameters: ServiceDeskIntegrationApiGetServiceDeskIntegrationsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<ServiceDeskIntegrationDto>> {
            return localVarFp.getServiceDeskIntegrations(requestParameters.offset, requestParameters.limit, requestParameters.sorters, requestParameters.filters, requestParameters.count, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get the time check configuration
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getStatusCheckDetails(options?: AxiosRequestConfig): AxiosPromise<QueuedCheckConfigDetails> {
            return localVarFp.getStatusCheckDetails(options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing ServiceDeskIntegration by ID with a PATCH request.
         * @summary Service Desk Integration Update PATCH
         * @param {ServiceDeskIntegrationApiPatchServiceDeskIntegrationRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        patchServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiPatchServiceDeskIntegrationRequest, options?: AxiosRequestConfig): AxiosPromise<ServiceDeskIntegrationDto> {
            return localVarFp.patchServiceDeskIntegration(requestParameters.id, requestParameters.jsonPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing Service Desk integration by ID with updated value in JSON form as the request body.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update a Service Desk integration
         * @param {ServiceDeskIntegrationApiPutServiceDeskIntegrationRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        putServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiPutServiceDeskIntegrationRequest, options?: AxiosRequestConfig): AxiosPromise<ServiceDeskIntegrationDto> {
            return localVarFp.putServiceDeskIntegration(requestParameters.id, requestParameters.serviceDeskIntegrationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update the time check configuration
         * @param {ServiceDeskIntegrationApiUpdateStatusCheckDetailsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        updateStatusCheckDetails(requestParameters: ServiceDeskIntegrationApiUpdateStatusCheckDetailsRequest, options?: AxiosRequestConfig): AxiosPromise<QueuedCheckConfigDetails> {
            return localVarFp.updateStatusCheckDetails(requestParameters.queuedCheckConfigDetails, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createServiceDeskIntegration operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiCreateServiceDeskIntegrationRequest
 */
export interface ServiceDeskIntegrationApiCreateServiceDeskIntegrationRequest {
    /**
     * The specifics of a new integration to create
     * @type {ServiceDeskIntegrationDto}
     * @memberof ServiceDeskIntegrationApiCreateServiceDeskIntegration
     */
    readonly serviceDeskIntegrationDto: ServiceDeskIntegrationDto
}

/**
 * Request parameters for deleteServiceDeskIntegration operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiDeleteServiceDeskIntegrationRequest
 */
export interface ServiceDeskIntegrationApiDeleteServiceDeskIntegrationRequest {
    /**
     * ID of Service Desk integration to delete
     * @type {string}
     * @memberof ServiceDeskIntegrationApiDeleteServiceDeskIntegration
     */
    readonly id: string
}

/**
 * Request parameters for getServiceDeskIntegration operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiGetServiceDeskIntegrationRequest
 */
export interface ServiceDeskIntegrationApiGetServiceDeskIntegrationRequest {
    /**
     * ID of the Service Desk integration to get
     * @type {string}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegration
     */
    readonly id: string
}

/**
 * Request parameters for getServiceDeskIntegrationTemplate operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiGetServiceDeskIntegrationTemplateRequest
 */
export interface ServiceDeskIntegrationApiGetServiceDeskIntegrationTemplateRequest {
    /**
     * The scriptName value of the Service Desk integration template to get
     * @type {string}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegrationTemplate
     */
    readonly scriptName: string
}

/**
 * Request parameters for getServiceDeskIntegrations operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiGetServiceDeskIntegrationsRequest
 */
export interface ServiceDeskIntegrationApiGetServiceDeskIntegrationsRequest {
    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegrations
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegrations
     */
    readonly limit?: number

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
     * @type {string}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegrations
     */
    readonly sorters?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq*  **type**: *eq, in*  **cluster**: *eq, in*
     * @type {string}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegrations
     */
    readonly filters?: string

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegrations
     */
    readonly count?: boolean
}

/**
 * Request parameters for patchServiceDeskIntegration operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiPatchServiceDeskIntegrationRequest
 */
export interface ServiceDeskIntegrationApiPatchServiceDeskIntegrationRequest {
    /**
     * ID of the Service Desk integration to update
     * @type {string}
     * @memberof ServiceDeskIntegrationApiPatchServiceDeskIntegration
     */
    readonly id: string

    /**
     * A list of SDIM update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  PATCH can only be applied to the following fields:   * &#x60;beforeProvisioningRule&#x60;   * &#x60;description&#x60;   * &#x60;ownerRef&#x60;  A 403 Forbidden Error indicates that you attempted to PATCH a field that is not allowed. 
     * @type {JsonPatch}
     * @memberof ServiceDeskIntegrationApiPatchServiceDeskIntegration
     */
    readonly jsonPatch: JsonPatch
}

/**
 * Request parameters for putServiceDeskIntegration operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiPutServiceDeskIntegrationRequest
 */
export interface ServiceDeskIntegrationApiPutServiceDeskIntegrationRequest {
    /**
     * ID of the Service Desk integration to update
     * @type {string}
     * @memberof ServiceDeskIntegrationApiPutServiceDeskIntegration
     */
    readonly id: string

    /**
     * The specifics of the integration to update
     * @type {ServiceDeskIntegrationDto}
     * @memberof ServiceDeskIntegrationApiPutServiceDeskIntegration
     */
    readonly serviceDeskIntegrationDto: ServiceDeskIntegrationDto
}

/**
 * Request parameters for updateStatusCheckDetails operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiUpdateStatusCheckDetailsRequest
 */
export interface ServiceDeskIntegrationApiUpdateStatusCheckDetailsRequest {
    /**
     * the modified time check configuration
     * @type {QueuedCheckConfigDetails}
     * @memberof ServiceDeskIntegrationApiUpdateStatusCheckDetails
     */
    readonly queuedCheckConfigDetails: QueuedCheckConfigDetails
}

/**
 * ServiceDeskIntegrationApi - object-oriented interface
 * @export
 * @class ServiceDeskIntegrationApi
 * @extends {BaseAPI}
 */
export class ServiceDeskIntegrationApi extends BaseAPI {
    /**
     * Create a new Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Create new Service Desk integration
     * @param {ServiceDeskIntegrationApiCreateServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public createServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiCreateServiceDeskIntegrationRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).createServiceDeskIntegration(requestParameters.serviceDeskIntegrationDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Delete a Service Desk integration
     * @param {ServiceDeskIntegrationApiDeleteServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public deleteServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiDeleteServiceDeskIntegrationRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).deleteServiceDeskIntegration(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Get a Service Desk integration
     * @param {ServiceDeskIntegrationApiGetServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public getServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiGetServiceDeskIntegrationRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).getServiceDeskIntegration(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API endpoint returns an existing Service Desk integration template by scriptName.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Service Desk integration template by scriptName.
     * @param {ServiceDeskIntegrationApiGetServiceDeskIntegrationTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public getServiceDeskIntegrationTemplate(requestParameters: ServiceDeskIntegrationApiGetServiceDeskIntegrationTemplateRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).getServiceDeskIntegrationTemplate(requestParameters.scriptName, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API endpoint returns the current list of supported Service Desk integration types.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Service Desk Integration Types List.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public getServiceDeskIntegrationTypes(axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).getServiceDeskIntegrationTypes(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of ServiceDeskIntegrationDto for existing Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary List existing Service Desk Integrations
     * @param {ServiceDeskIntegrationApiGetServiceDeskIntegrationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public getServiceDeskIntegrations(requestParameters: ServiceDeskIntegrationApiGetServiceDeskIntegrationsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).getServiceDeskIntegrations(requestParameters.offset, requestParameters.limit, requestParameters.sorters, requestParameters.filters, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Get the time check configuration
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public getStatusCheckDetails(axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).getStatusCheckDetails(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing ServiceDeskIntegration by ID with a PATCH request.
     * @summary Service Desk Integration Update PATCH
     * @param {ServiceDeskIntegrationApiPatchServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public patchServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiPatchServiceDeskIntegrationRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).patchServiceDeskIntegration(requestParameters.id, requestParameters.jsonPatch, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing Service Desk integration by ID with updated value in JSON form as the request body.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Update a Service Desk integration
     * @param {ServiceDeskIntegrationApiPutServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public putServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiPutServiceDeskIntegrationRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).putServiceDeskIntegration(requestParameters.id, requestParameters.serviceDeskIntegrationDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Update the time check configuration
     * @param {ServiceDeskIntegrationApiUpdateStatusCheckDetailsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public updateStatusCheckDetails(requestParameters: ServiceDeskIntegrationApiUpdateStatusCheckDetailsRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).updateStatusCheckDetails(requestParameters.queuedCheckConfigDetails, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SourceUsagesApi - axios parameter creator
 * @export
 */
export const SourceUsagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API returns the status of the source usage insights setup by IDN source ID.
         * @summary Finds status of source usage
         * @param {string} sourceId ID of IDN source
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getStatusBySourceId: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getStatusBySourceId', 'sourceId', sourceId)
            const localVarPath = `/source-usages/{sourceId}/status`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a summary of source usage insights for past 12 months.
         * @summary Returns source usage insights
         * @param {string} sourceId ID of IDN source
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **date**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUsagesBySourceId: async (sourceId: string, limit?: number, offset?: number, count?: boolean, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getUsagesBySourceId', 'sourceId', sourceId)
            const localVarPath = `/source-usages/{sourceId}/summaries`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SourceUsagesApi - functional programming interface
 * @export
 */
export const SourceUsagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SourceUsagesApiAxiosParamCreator(configuration)
    return {
        /**
         * This API returns the status of the source usage insights setup by IDN source ID.
         * @summary Finds status of source usage
         * @param {string} sourceId ID of IDN source
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusBySourceId(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceUsageStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusBySourceId(sourceId, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SourceUsagesApi.getStatusBySourceId']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API returns a summary of source usage insights for past 12 months.
         * @summary Returns source usage insights
         * @param {string} sourceId ID of IDN source
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **date**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getUsagesBySourceId(sourceId: string, limit?: number, offset?: number, count?: boolean, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SourceUsage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsagesBySourceId(sourceId, limit, offset, count, sorters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SourceUsagesApi.getUsagesBySourceId']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SourceUsagesApi - factory interface
 * @export
 */
export const SourceUsagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SourceUsagesApiFp(configuration)
    return {
        /**
         * This API returns the status of the source usage insights setup by IDN source ID.
         * @summary Finds status of source usage
         * @param {SourceUsagesApiGetStatusBySourceIdRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getStatusBySourceId(requestParameters: SourceUsagesApiGetStatusBySourceIdRequest, options?: AxiosRequestConfig): AxiosPromise<SourceUsageStatus> {
            return localVarFp.getStatusBySourceId(requestParameters.sourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a summary of source usage insights for past 12 months.
         * @summary Returns source usage insights
         * @param {SourceUsagesApiGetUsagesBySourceIdRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getUsagesBySourceId(requestParameters: SourceUsagesApiGetUsagesBySourceIdRequest, options?: AxiosRequestConfig): AxiosPromise<Array<SourceUsage>> {
            return localVarFp.getUsagesBySourceId(requestParameters.sourceId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getStatusBySourceId operation in SourceUsagesApi.
 * @export
 * @interface SourceUsagesApiGetStatusBySourceIdRequest
 */
export interface SourceUsagesApiGetStatusBySourceIdRequest {
    /**
     * ID of IDN source
     * @type {string}
     * @memberof SourceUsagesApiGetStatusBySourceId
     */
    readonly sourceId: string
}

/**
 * Request parameters for getUsagesBySourceId operation in SourceUsagesApi.
 * @export
 * @interface SourceUsagesApiGetUsagesBySourceIdRequest
 */
export interface SourceUsagesApiGetUsagesBySourceIdRequest {
    /**
     * ID of IDN source
     * @type {string}
     * @memberof SourceUsagesApiGetUsagesBySourceId
     */
    readonly sourceId: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SourceUsagesApiGetUsagesBySourceId
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SourceUsagesApiGetUsagesBySourceId
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SourceUsagesApiGetUsagesBySourceId
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **date**
     * @type {string}
     * @memberof SourceUsagesApiGetUsagesBySourceId
     */
    readonly sorters?: string
}

/**
 * SourceUsagesApi - object-oriented interface
 * @export
 * @class SourceUsagesApi
 * @extends {BaseAPI}
 */
export class SourceUsagesApi extends BaseAPI {
    /**
     * This API returns the status of the source usage insights setup by IDN source ID.
     * @summary Finds status of source usage
     * @param {SourceUsagesApiGetStatusBySourceIdRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceUsagesApi
     */
    public getStatusBySourceId(requestParameters: SourceUsagesApiGetStatusBySourceIdRequest, axiosOptions?: AxiosRequestConfig) {
        return SourceUsagesApiFp(this.configuration).getStatusBySourceId(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a summary of source usage insights for past 12 months.
     * @summary Returns source usage insights
     * @param {SourceUsagesApiGetUsagesBySourceIdRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceUsagesApi
     */
    public getUsagesBySourceId(requestParameters: SourceUsagesApiGetUsagesBySourceIdRequest, axiosOptions?: AxiosRequestConfig) {
        return SourceUsagesApiFp(this.configuration).getUsagesBySourceId(requestParameters.sourceId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SourcesApi - axios parameter creator
 * @export
 */
export const SourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API generates a create policy/template based on field value transforms. This API is intended for use when setting up JDBC Provisioning type sources, but it will also work on other source types. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Provisioning Policy
         * @param {string} sourceId The Source id
         * @param {ProvisioningPolicyDto} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createProvisioningPolicy: async (sourceId: string, provisioningPolicyDto: ProvisioningPolicyDto, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('createProvisioningPolicy', 'sourceId', sourceId)
            // verify required parameter 'provisioningPolicyDto' is not null or undefined
            assertParamExists('createProvisioningPolicy', 'provisioningPolicyDto', provisioningPolicyDto)
            const localVarPath = `/sources/{sourceId}/provisioning-policies`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(provisioningPolicyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This creates a specific source with a full source JSON representation. Any passwords are submitted as plain-text and encrypted upon receipt in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Creates a source in IdentityNow.
         * @param {Source} source 
         * @param {boolean} [provisionAsCsv] If this parameter is &#x60;true&#x60;, it configures the source as a Delimited File (CSV) source. Setting this to &#x60;true&#x60; will automatically set the &#x60;type&#x60; of the source to &#x60;DelimitedFile&#x60;.  You must use this query parameter to create a Delimited File source as you would in the UI.  If you don\&#39;t set this query parameter and you attempt to set the &#x60;type&#x60; attribute directly, the request won\&#39;t correctly generate the source.  
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSource: async (source: Source, provisionAsCsv?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'source' is not null or undefined
            assertParamExists('createSource', 'source', source)
            const localVarPath = `/sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (provisionAsCsv !== undefined) {
                localVarQueryParameter['provisionAsCsv'] = provisionAsCsv;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(source, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Creates a new Schema on the specified Source in IdentityNow. 
         * @summary Create Schema on a Source
         * @param {string} sourceId The Source id.
         * @param {Schema} schema 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSourceSchema: async (sourceId: string, schema: Schema, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('createSourceSchema', 'sourceId', sourceId)
            // verify required parameter 'schema' is not null or undefined
            assertParamExists('createSourceSchema', 'schema', schema)
            const localVarPath = `/sources/{sourceId}/schemas`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes the provisioning policy with the specified usage on an application. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteProvisioningPolicy: async (sourceId: string, usageType: UsageType, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteProvisioningPolicy', 'sourceId', sourceId)
            // verify required parameter 'usageType' is not null or undefined
            assertParamExists('deleteProvisioningPolicy', 'usageType', usageType)
            const localVarPath = `/sources/{sourceId}/provisioning-policies/{usageType}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"usageType"}}`, encodeURIComponent(String(usageType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point deletes a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. All of accounts on the source will be removed first, then the source will be deleted. Actual status of task execution can be retrieved via method GET `/task-status/{id}`
         * @summary Delete Source by ID
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSource', 'id', id)
            const localVarPath = `/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSourceSchema: async (sourceId: string, schemaId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteSourceSchema', 'sourceId', sourceId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('deleteSourceSchema', 'schemaId', schemaId)
            const localVarPath = `/sources/{sourceId}/schemas/{schemaId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"schemaId"}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API downloads the CSV schema that defines the account attributes on a source. >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source accounts schema template
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsSchema: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccountsSchema', 'id', id)
            const localVarPath = `/sources/{id}/schemas/accounts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API downloads the CSV schema that defines the entitlement attributes on a source.  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getEntitlementsSchema: async (id: string, schemaName?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEntitlementsSchema', 'id', id)
            const localVarPath = `/sources/{id}/schemas/entitlements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (schemaName !== undefined) {
                localVarQueryParameter['schemaName'] = schemaName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point retrieves the ProvisioningPolicy with the specified usage on the specified Source in IdentityNow. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getProvisioningPolicy: async (sourceId: string, usageType: UsageType, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getProvisioningPolicy', 'sourceId', sourceId)
            // verify required parameter 'usageType' is not null or undefined
            assertParamExists('getProvisioningPolicy', 'usageType', usageType)
            const localVarPath = `/sources/{sourceId}/provisioning-policies/{usageType}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"usageType"}}`, encodeURIComponent(String(usageType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point gets a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Source by ID
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSource: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSource', 'id', id)
            const localVarPath = `/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint fetches source health by source\'s id
         * @summary Fetches source health by id
         * @param {string} sourceId The Source id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceHealth: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getSourceHealth', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}/source-health`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get the Source Schema by ID in IdentityNow. 
         * @summary Get Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceSchema: async (sourceId: string, schemaId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getSourceSchema', 'sourceId', sourceId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('getSourceSchema', 'schemaId', schemaId)
            const localVarPath = `/sources/{sourceId}/schemas/{schemaId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"schemaId"}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API uploads a source schema template file to configure a source\'s account attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Account Schema** -> **Options** -> **Download Schema**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source accounts schema template
         * @param {string} id The Source id
         * @param {File} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importAccountsSchema: async (id: string, file?: File, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('importAccountsSchema', 'id', id)
            const localVarPath = `/sources/{id}/schemas/accounts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This uploads a supplemental source connector file (like jdbc driver jars) to a source\'s S3 bucket. This also sends ETS and Audit events. A token with ORG_ADMIN authority is required to call this API.
         * @summary Upload connector file to source
         * @param {string} sourceId The Source id.
         * @param {File} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importConnectorFile: async (sourceId: string, file?: File, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('importConnectorFile', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}/upload-connector-file`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API uploads a source schema template file to configure a source\'s entitlement attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Import Entitlements** -> **Download**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {File} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importEntitlementsSchema: async (id: string, schemaName?: string, file?: File, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('importEntitlementsSchema', 'id', id)
            const localVarPath = `/sources/{id}/schemas/entitlements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (schemaName !== undefined) {
                localVarQueryParameter['schemaName'] = schemaName;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point lists all the ProvisioningPolicies in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists ProvisioningPolicies
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listProvisioningPolicies: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('listProvisioningPolicies', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}/provisioning-policies`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Lists the Schemas that exist on the specified Source in IdentityNow. 
         * @summary List Schemas on a Source
         * @param {string} sourceId The Source ID.
         * @param {string} [includeTypes] If set to \&#39;group\&#39;, then the account schema is filtered and only group schemas are returned. Only a value of \&#39;group\&#39; is recognized.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSourceSchemas: async (sourceId: string, includeTypes?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('listSourceSchemas', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}/schemas`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (includeTypes !== undefined) {
                localVarQueryParameter['include-types'] = includeTypes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point lists all the sources in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary Lists all sources in IdentityNow.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **name**: *co, eq, in, sw, ge, gt, ne, isnull*  **type**: *eq, in, ge, gt, ne, isnull, sw*  **owner.id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **features**: *ca, co*  **created**: *eq*  **modified**: *eq*  **managementWorkgroup.id**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **description**: *eq, sw*  **authoritative**: *eq, ne, isnull*  **healthy**: *isnull*  **status**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **connectionType**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **connectorName**: *eq, ge, gt, in, ne, isnull, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified, name, owner.name, healthy, status, id, description, owner.id, accountCorrelationConfig.id, accountCorrelationConfig.name, managerCorrelationRule.type, managerCorrelationRule.id, managerCorrelationRule.name, authoritative, managementWorkgroup.id, connectorName, connectionType**
         * @param {string} [forSubadmin] Filter the returned list of sources for the identity specified by the parameter, which is the id of an identity with the role SOURCE_SUBADMIN. By convention, the value **me** indicates the identity id of the current user. Subadmins may only view Sources which they are able to administer; all other Sources will be filtered out when this parameter is set. If the current user is a SOURCE_SUBADMIN but fails to pass a valid value for this parameter, a 403 Forbidden is returned.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSources: async (limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSubadmin?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (forSubadmin !== undefined) {
                localVarQueryParameter['for-subadmin'] = forSubadmin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point updates the provisioning policy with the specified usage on the specified source in IdentityNow. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Update Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
         * @param {ProvisioningPolicyDto} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putProvisioningPolicy: async (sourceId: string, usageType: UsageType, provisioningPolicyDto: ProvisioningPolicyDto, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('putProvisioningPolicy', 'sourceId', sourceId)
            // verify required parameter 'usageType' is not null or undefined
            assertParamExists('putProvisioningPolicy', 'usageType', usageType)
            // verify required parameter 'provisioningPolicyDto' is not null or undefined
            assertParamExists('putProvisioningPolicy', 'provisioningPolicyDto', provisioningPolicyDto)
            const localVarPath = `/sources/{sourceId}/provisioning-policies/{usageType}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"usageType"}}`, encodeURIComponent(String(usageType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(provisioningPolicyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates a source in IdentityNow, using a full object representation. In other words, the existing Source configuration is completely replaced.  Some fields are immutable and cannot be changed, such as:  * id * type * authoritative * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. 
         * @summary Update Source (Full)
         * @param {string} id The Source id
         * @param {Source} source 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSource: async (id: string, source: Source, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putSource', 'id', id)
            // verify required parameter 'source' is not null or undefined
            assertParamExists('putSource', 'source', source)
            const localVarPath = `/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(source, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API will completely replace an existing Schema with the submitted payload. Some fields of the Schema cannot be updated. These fields are listed below.  * id * name * created * modified  Any attempt to modify these fields will result in an error response with a status code of 400.  > `id` must remain in the request body, but it cannot be changed.  If `id` is omitted from the request body, the result will be a 400 error. 
         * @summary Update Source Schema (Full)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Schema} schema 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSourceSchema: async (sourceId: string, schemaId: string, schema: Schema, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('putSourceSchema', 'sourceId', sourceId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('putSourceSchema', 'schemaId', schemaId)
            // verify required parameter 'schema' is not null or undefined
            assertParamExists('putSourceSchema', 'schema', schema)
            const localVarPath = `/sources/{sourceId}/schemas/{schemaId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"schemaId"}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point updates a list of provisioning policies on the specified source in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Bulk Update Provisioning Policies
         * @param {string} sourceId The Source id.
         * @param {Array<ProvisioningPolicyDto>} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateProvisioningPoliciesInBulk: async (sourceId: string, provisioningPolicyDto: Array<ProvisioningPolicyDto>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('updateProvisioningPoliciesInBulk', 'sourceId', sourceId)
            // verify required parameter 'provisioningPolicyDto' is not null or undefined
            assertParamExists('updateProvisioningPoliciesInBulk', 'provisioningPolicyDto', provisioningPolicyDto)
            const localVarPath = `/sources/{sourceId}/provisioning-policies/bulk-update`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(provisioningPolicyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API selectively updates an existing Provisioning Policy using a JSONPatch payload. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Partial update of Provisioning Policy
         * @param {string} sourceId The Source id.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateProvisioningPolicy: async (sourceId: string, usageType: UsageType, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('updateProvisioningPolicy', 'sourceId', sourceId)
            // verify required parameter 'usageType' is not null or undefined
            assertParamExists('updateProvisioningPolicy', 'usageType', usageType)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateProvisioningPolicy', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/sources/{sourceId}/provisioning-policies/{usageType}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"usageType"}}`, encodeURIComponent(String(usageType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API partially updates a source in IdentityNow, using a list of patch operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Some fields are immutable and cannot be changed, such as:  * id * type * authoritative * created * modified * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or API authority is required to call this API. 
         * @summary Update Source (Partial)
         * @param {string} id The Source id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Any password changes are submitted as plain-text and encrypted upon receipt in IdentityNow.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSource: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSource', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateSource', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to selectively update an existing Schema using a JSONPatch payload.   The following schema fields are immutable and cannot be updated:  - id - name - created - modified   To switch an account attribute to a group entitlement, you need to have the following in place:  - `isEntitlement: true` - Must define a schema for the group and [add it to the source](https://developer.sailpoint.com/idn/api/v3/create-source-schema) before updating the `isGroup` flag.  For example, here is the `group` account attribute referencing a schema that defines the group: ```json {     \"name\": \"groups\",     \"type\": \"STRING\",     \"schema\": {         \"type\": \"CONNECTOR_SCHEMA\",         \"id\": \"2c9180887671ff8c01767b4671fc7d60\",         \"name\": \"group\"     },     \"description\": \"The groups, roles etc. that reference account group objects\",     \"isMulti\": true,     \"isEntitlement\": true,     \"isGroup\": true } ``` 
         * @summary Update Source Schema (Partial)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSourceSchema: async (sourceId: string, schemaId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('updateSourceSchema', 'sourceId', sourceId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('updateSourceSchema', 'schemaId', schemaId)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateSourceSchema', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/sources/{sourceId}/schemas/{schemaId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"schemaId"}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SourcesApi - functional programming interface
 * @export
 */
export const SourcesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * This API generates a create policy/template based on field value transforms. This API is intended for use when setting up JDBC Provisioning type sources, but it will also work on other source types. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Provisioning Policy
         * @param {string} sourceId The Source id
         * @param {ProvisioningPolicyDto} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createProvisioningPolicy(sourceId: string, provisioningPolicyDto: ProvisioningPolicyDto, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisioningPolicyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProvisioningPolicy(sourceId, provisioningPolicyDto, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SourcesApi.createProvisioningPolicy']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This creates a specific source with a full source JSON representation. Any passwords are submitted as plain-text and encrypted upon receipt in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Creates a source in IdentityNow.
         * @param {Source} source 
         * @param {boolean} [provisionAsCsv] If this parameter is &#x60;true&#x60;, it configures the source as a Delimited File (CSV) source. Setting this to &#x60;true&#x60; will automatically set the &#x60;type&#x60; of the source to &#x60;DelimitedFile&#x60;.  You must use this query parameter to create a Delimited File source as you would in the UI.  If you don\&#39;t set this query parameter and you attempt to set the &#x60;type&#x60; attribute directly, the request won\&#39;t correctly generate the source.  
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSource(source: Source, provisionAsCsv?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSource(source, provisionAsCsv, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SourcesApi.createSource']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Creates a new Schema on the specified Source in IdentityNow. 
         * @summary Create Schema on a Source
         * @param {string} sourceId The Source id.
         * @param {Schema} schema 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSourceSchema(sourceId: string, schema: Schema, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSourceSchema(sourceId, schema, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SourcesApi.createSourceSchema']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Deletes the provisioning policy with the specified usage on an application. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProvisioningPolicy(sourceId: string, usageType: UsageType, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProvisioningPolicy(sourceId, usageType, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SourcesApi.deleteProvisioningPolicy']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This end-point deletes a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. All of accounts on the source will be removed first, then the source will be deleted. Actual status of task execution can be retrieved via method GET `/task-status/{id}`
         * @summary Delete Source by ID
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSource(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteSource202Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSource(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SourcesApi.deleteSource']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSourceSchema(sourceId: string, schemaId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSourceSchema(sourceId, schemaId, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SourcesApi.deleteSourceSchema']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API downloads the CSV schema that defines the account attributes on a source. >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source accounts schema template
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountsSchema(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountsSchema(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SourcesApi.getAccountsSchema']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API downloads the CSV schema that defines the entitlement attributes on a source.  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getEntitlementsSchema(id: string, schemaName?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntitlementsSchema(id, schemaName, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SourcesApi.getEntitlementsSchema']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This end-point retrieves the ProvisioningPolicy with the specified usage on the specified Source in IdentityNow. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getProvisioningPolicy(sourceId: string, usageType: UsageType, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisioningPolicyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProvisioningPolicy(sourceId, usageType, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SourcesApi.getProvisioningPolicy']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This end-point gets a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Source by ID
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSource(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSource(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SourcesApi.getSource']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint fetches source health by source\'s id
         * @summary Fetches source health by id
         * @param {string} sourceId The Source id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSourceHealth(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceHealthDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSourceHealth(sourceId, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SourcesApi.getSourceHealth']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get the Source Schema by ID in IdentityNow. 
         * @summary Get Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSourceSchema(sourceId: string, schemaId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSourceSchema(sourceId, schemaId, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SourcesApi.getSourceSchema']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API uploads a source schema template file to configure a source\'s account attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Account Schema** -> **Options** -> **Download Schema**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source accounts schema template
         * @param {string} id The Source id
         * @param {File} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async importAccountsSchema(id: string, file?: File, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importAccountsSchema(id, file, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SourcesApi.importAccountsSchema']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This uploads a supplemental source connector file (like jdbc driver jars) to a source\'s S3 bucket. This also sends ETS and Audit events. A token with ORG_ADMIN authority is required to call this API.
         * @summary Upload connector file to source
         * @param {string} sourceId The Source id.
         * @param {File} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async importConnectorFile(sourceId: string, file?: File, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importConnectorFile(sourceId, file, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SourcesApi.importConnectorFile']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API uploads a source schema template file to configure a source\'s entitlement attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Import Entitlements** -> **Download**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {File} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async importEntitlementsSchema(id: string, schemaName?: string, file?: File, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importEntitlementsSchema(id, schemaName, file, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SourcesApi.importEntitlementsSchema']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This end-point lists all the ProvisioningPolicies in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists ProvisioningPolicies
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listProvisioningPolicies(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProvisioningPolicyDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProvisioningPolicies(sourceId, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SourcesApi.listProvisioningPolicies']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Lists the Schemas that exist on the specified Source in IdentityNow. 
         * @summary List Schemas on a Source
         * @param {string} sourceId The Source ID.
         * @param {string} [includeTypes] If set to \&#39;group\&#39;, then the account schema is filtered and only group schemas are returned. Only a value of \&#39;group\&#39; is recognized.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceSchemas(sourceId: string, includeTypes?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSourceSchemas(sourceId, includeTypes, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SourcesApi.listSourceSchemas']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This end-point lists all the sources in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary Lists all sources in IdentityNow.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **name**: *co, eq, in, sw, ge, gt, ne, isnull*  **type**: *eq, in, ge, gt, ne, isnull, sw*  **owner.id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **features**: *ca, co*  **created**: *eq*  **modified**: *eq*  **managementWorkgroup.id**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **description**: *eq, sw*  **authoritative**: *eq, ne, isnull*  **healthy**: *isnull*  **status**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **connectionType**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **connectorName**: *eq, ge, gt, in, ne, isnull, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified, name, owner.name, healthy, status, id, description, owner.id, accountCorrelationConfig.id, accountCorrelationConfig.name, managerCorrelationRule.type, managerCorrelationRule.id, managerCorrelationRule.name, authoritative, managementWorkgroup.id, connectorName, connectionType**
         * @param {string} [forSubadmin] Filter the returned list of sources for the identity specified by the parameter, which is the id of an identity with the role SOURCE_SUBADMIN. By convention, the value **me** indicates the identity id of the current user. Subadmins may only view Sources which they are able to administer; all other Sources will be filtered out when this parameter is set. If the current user is a SOURCE_SUBADMIN but fails to pass a valid value for this parameter, a 403 Forbidden is returned.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listSources(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSubadmin?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Source>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSources(limit, offset, count, filters, sorters, forSubadmin, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SourcesApi.listSources']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This end-point updates the provisioning policy with the specified usage on the specified source in IdentityNow. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Update Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
         * @param {ProvisioningPolicyDto} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putProvisioningPolicy(sourceId: string, usageType: UsageType, provisioningPolicyDto: ProvisioningPolicyDto, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisioningPolicyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putProvisioningPolicy(sourceId, usageType, provisioningPolicyDto, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SourcesApi.putProvisioningPolicy']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API updates a source in IdentityNow, using a full object representation. In other words, the existing Source configuration is completely replaced.  Some fields are immutable and cannot be changed, such as:  * id * type * authoritative * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. 
         * @summary Update Source (Full)
         * @param {string} id The Source id
         * @param {Source} source 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putSource(id: string, source: Source, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putSource(id, source, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SourcesApi.putSource']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API will completely replace an existing Schema with the submitted payload. Some fields of the Schema cannot be updated. These fields are listed below.  * id * name * created * modified  Any attempt to modify these fields will result in an error response with a status code of 400.  > `id` must remain in the request body, but it cannot be changed.  If `id` is omitted from the request body, the result will be a 400 error. 
         * @summary Update Source Schema (Full)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Schema} schema 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putSourceSchema(sourceId: string, schemaId: string, schema: Schema, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putSourceSchema(sourceId, schemaId, schema, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SourcesApi.putSourceSchema']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This end-point updates a list of provisioning policies on the specified source in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Bulk Update Provisioning Policies
         * @param {string} sourceId The Source id.
         * @param {Array<ProvisioningPolicyDto>} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateProvisioningPoliciesInBulk(sourceId: string, provisioningPolicyDto: Array<ProvisioningPolicyDto>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProvisioningPolicyDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProvisioningPoliciesInBulk(sourceId, provisioningPolicyDto, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SourcesApi.updateProvisioningPoliciesInBulk']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API selectively updates an existing Provisioning Policy using a JSONPatch payload. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Partial update of Provisioning Policy
         * @param {string} sourceId The Source id.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateProvisioningPolicy(sourceId: string, usageType: UsageType, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisioningPolicyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProvisioningPolicy(sourceId, usageType, jsonPatchOperation, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SourcesApi.updateProvisioningPolicy']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API partially updates a source in IdentityNow, using a list of patch operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Some fields are immutable and cannot be changed, such as:  * id * type * authoritative * created * modified * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or API authority is required to call this API. 
         * @summary Update Source (Partial)
         * @param {string} id The Source id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Any password changes are submitted as plain-text and encrypted upon receipt in IdentityNow.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateSource(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSource(id, jsonPatchOperation, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SourcesApi.updateSource']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Use this API to selectively update an existing Schema using a JSONPatch payload.   The following schema fields are immutable and cannot be updated:  - id - name - created - modified   To switch an account attribute to a group entitlement, you need to have the following in place:  - `isEntitlement: true` - Must define a schema for the group and [add it to the source](https://developer.sailpoint.com/idn/api/v3/create-source-schema) before updating the `isGroup` flag.  For example, here is the `group` account attribute referencing a schema that defines the group: ```json {     \"name\": \"groups\",     \"type\": \"STRING\",     \"schema\": {         \"type\": \"CONNECTOR_SCHEMA\",         \"id\": \"2c9180887671ff8c01767b4671fc7d60\",         \"name\": \"group\"     },     \"description\": \"The groups, roles etc. that reference account group objects\",     \"isMulti\": true,     \"isEntitlement\": true,     \"isGroup\": true } ``` 
         * @summary Update Source Schema (Partial)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateSourceSchema(sourceId: string, schemaId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSourceSchema(sourceId, schemaId, jsonPatchOperation, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SourcesApi.updateSourceSchema']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SourcesApi - factory interface
 * @export
 */
export const SourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SourcesApiFp(configuration)
    return {
        /**
         * This API generates a create policy/template based on field value transforms. This API is intended for use when setting up JDBC Provisioning type sources, but it will also work on other source types. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Provisioning Policy
         * @param {SourcesApiCreateProvisioningPolicyRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        createProvisioningPolicy(requestParameters: SourcesApiCreateProvisioningPolicyRequest, options?: AxiosRequestConfig): AxiosPromise<ProvisioningPolicyDto> {
            return localVarFp.createProvisioningPolicy(requestParameters.sourceId, requestParameters.provisioningPolicyDto, options).then((request) => request(axios, basePath));
        },
        /**
         * This creates a specific source with a full source JSON representation. Any passwords are submitted as plain-text and encrypted upon receipt in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Creates a source in IdentityNow.
         * @param {SourcesApiCreateSourceRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        createSource(requestParameters: SourcesApiCreateSourceRequest, options?: AxiosRequestConfig): AxiosPromise<Source> {
            return localVarFp.createSource(requestParameters.source, requestParameters.provisionAsCsv, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new Schema on the specified Source in IdentityNow. 
         * @summary Create Schema on a Source
         * @param {SourcesApiCreateSourceSchemaRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        createSourceSchema(requestParameters: SourcesApiCreateSourceSchemaRequest, options?: AxiosRequestConfig): AxiosPromise<Schema> {
            return localVarFp.createSourceSchema(requestParameters.sourceId, requestParameters.schema, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the provisioning policy with the specified usage on an application. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Provisioning Policy by UsageType
         * @param {SourcesApiDeleteProvisioningPolicyRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteProvisioningPolicy(requestParameters: SourcesApiDeleteProvisioningPolicyRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, options).then((request) => request(axios, basePath));
        },
        /**
         * This end-point deletes a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. All of accounts on the source will be removed first, then the source will be deleted. Actual status of task execution can be retrieved via method GET `/task-status/{id}`
         * @summary Delete Source by ID
         * @param {SourcesApiDeleteSourceRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteSource(requestParameters: SourcesApiDeleteSourceRequest, options?: AxiosRequestConfig): AxiosPromise<DeleteSource202Response> {
            return localVarFp.deleteSource(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Source Schema by ID
         * @param {SourcesApiDeleteSourceSchemaRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteSourceSchema(requestParameters: SourcesApiDeleteSourceSchemaRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSourceSchema(requestParameters.sourceId, requestParameters.schemaId, options).then((request) => request(axios, basePath));
        },
        /**
         * This API downloads the CSV schema that defines the account attributes on a source. >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source accounts schema template
         * @param {SourcesApiGetAccountsSchemaRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getAccountsSchema(requestParameters: SourcesApiGetAccountsSchemaRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getAccountsSchema(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This API downloads the CSV schema that defines the entitlement attributes on a source.  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source entitlements schema template
         * @param {SourcesApiGetEntitlementsSchemaRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getEntitlementsSchema(requestParameters: SourcesApiGetEntitlementsSchemaRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getEntitlementsSchema(requestParameters.id, requestParameters.schemaName, options).then((request) => request(axios, basePath));
        },
        /**
         * This end-point retrieves the ProvisioningPolicy with the specified usage on the specified Source in IdentityNow. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Provisioning Policy by UsageType
         * @param {SourcesApiGetProvisioningPolicyRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getProvisioningPolicy(requestParameters: SourcesApiGetProvisioningPolicyRequest, options?: AxiosRequestConfig): AxiosPromise<ProvisioningPolicyDto> {
            return localVarFp.getProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, options).then((request) => request(axios, basePath));
        },
        /**
         * This end-point gets a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Source by ID
         * @param {SourcesApiGetSourceRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getSource(requestParameters: SourcesApiGetSourceRequest, options?: AxiosRequestConfig): AxiosPromise<Source> {
            return localVarFp.getSource(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint fetches source health by source\'s id
         * @summary Fetches source health by id
         * @param {SourcesApiGetSourceHealthRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getSourceHealth(requestParameters: SourcesApiGetSourceHealthRequest, options?: AxiosRequestConfig): AxiosPromise<SourceHealthDto> {
            return localVarFp.getSourceHealth(requestParameters.sourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the Source Schema by ID in IdentityNow. 
         * @summary Get Source Schema by ID
         * @param {SourcesApiGetSourceSchemaRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getSourceSchema(requestParameters: SourcesApiGetSourceSchemaRequest, options?: AxiosRequestConfig): AxiosPromise<Schema> {
            return localVarFp.getSourceSchema(requestParameters.sourceId, requestParameters.schemaId, options).then((request) => request(axios, basePath));
        },
        /**
         * This API uploads a source schema template file to configure a source\'s account attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Account Schema** -> **Options** -> **Download Schema**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source accounts schema template
         * @param {SourcesApiImportAccountsSchemaRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        importAccountsSchema(requestParameters: SourcesApiImportAccountsSchemaRequest, options?: AxiosRequestConfig): AxiosPromise<Schema> {
            return localVarFp.importAccountsSchema(requestParameters.id, requestParameters.file, options).then((request) => request(axios, basePath));
        },
        /**
         * This uploads a supplemental source connector file (like jdbc driver jars) to a source\'s S3 bucket. This also sends ETS and Audit events. A token with ORG_ADMIN authority is required to call this API.
         * @summary Upload connector file to source
         * @param {SourcesApiImportConnectorFileRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        importConnectorFile(requestParameters: SourcesApiImportConnectorFileRequest, options?: AxiosRequestConfig): AxiosPromise<Source> {
            return localVarFp.importConnectorFile(requestParameters.sourceId, requestParameters.file, options).then((request) => request(axios, basePath));
        },
        /**
         * This API uploads a source schema template file to configure a source\'s entitlement attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Import Entitlements** -> **Download**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source entitlements schema template
         * @param {SourcesApiImportEntitlementsSchemaRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        importEntitlementsSchema(requestParameters: SourcesApiImportEntitlementsSchemaRequest, options?: AxiosRequestConfig): AxiosPromise<Schema> {
            return localVarFp.importEntitlementsSchema(requestParameters.id, requestParameters.schemaName, requestParameters.file, options).then((request) => request(axios, basePath));
        },
        /**
         * This end-point lists all the ProvisioningPolicies in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists ProvisioningPolicies
         * @param {SourcesApiListProvisioningPoliciesRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listProvisioningPolicies(requestParameters: SourcesApiListProvisioningPoliciesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ProvisioningPolicyDto>> {
            return localVarFp.listProvisioningPolicies(requestParameters.sourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the Schemas that exist on the specified Source in IdentityNow. 
         * @summary List Schemas on a Source
         * @param {SourcesApiListSourceSchemasRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listSourceSchemas(requestParameters: SourcesApiListSourceSchemasRequest, options?: AxiosRequestConfig): AxiosPromise<Array<Schema>> {
            return localVarFp.listSourceSchemas(requestParameters.sourceId, requestParameters.includeTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * This end-point lists all the sources in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary Lists all sources in IdentityNow.
         * @param {SourcesApiListSourcesRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listSources(requestParameters: SourcesApiListSourcesRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<Source>> {
            return localVarFp.listSources(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.forSubadmin, options).then((request) => request(axios, basePath));
        },
        /**
         * This end-point updates the provisioning policy with the specified usage on the specified source in IdentityNow. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Update Provisioning Policy by UsageType
         * @param {SourcesApiPutProvisioningPolicyRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        putProvisioningPolicy(requestParameters: SourcesApiPutProvisioningPolicyRequest, options?: AxiosRequestConfig): AxiosPromise<ProvisioningPolicyDto> {
            return localVarFp.putProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, requestParameters.provisioningPolicyDto, options).then((request) => request(axios, basePath));
        },
        /**
         * This API updates a source in IdentityNow, using a full object representation. In other words, the existing Source configuration is completely replaced.  Some fields are immutable and cannot be changed, such as:  * id * type * authoritative * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. 
         * @summary Update Source (Full)
         * @param {SourcesApiPutSourceRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        putSource(requestParameters: SourcesApiPutSourceRequest, options?: AxiosRequestConfig): AxiosPromise<Source> {
            return localVarFp.putSource(requestParameters.id, requestParameters.source, options).then((request) => request(axios, basePath));
        },
        /**
         * This API will completely replace an existing Schema with the submitted payload. Some fields of the Schema cannot be updated. These fields are listed below.  * id * name * created * modified  Any attempt to modify these fields will result in an error response with a status code of 400.  > `id` must remain in the request body, but it cannot be changed.  If `id` is omitted from the request body, the result will be a 400 error. 
         * @summary Update Source Schema (Full)
         * @param {SourcesApiPutSourceSchemaRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        putSourceSchema(requestParameters: SourcesApiPutSourceSchemaRequest, options?: AxiosRequestConfig): AxiosPromise<Schema> {
            return localVarFp.putSourceSchema(requestParameters.sourceId, requestParameters.schemaId, requestParameters.schema, options).then((request) => request(axios, basePath));
        },
        /**
         * This end-point updates a list of provisioning policies on the specified source in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Bulk Update Provisioning Policies
         * @param {SourcesApiUpdateProvisioningPoliciesInBulkRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        updateProvisioningPoliciesInBulk(requestParameters: SourcesApiUpdateProvisioningPoliciesInBulkRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ProvisioningPolicyDto>> {
            return localVarFp.updateProvisioningPoliciesInBulk(requestParameters.sourceId, requestParameters.provisioningPolicyDto, options).then((request) => request(axios, basePath));
        },
        /**
         * This API selectively updates an existing Provisioning Policy using a JSONPatch payload. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Partial update of Provisioning Policy
         * @param {SourcesApiUpdateProvisioningPolicyRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        updateProvisioningPolicy(requestParameters: SourcesApiUpdateProvisioningPolicyRequest, options?: AxiosRequestConfig): AxiosPromise<ProvisioningPolicyDto> {
            return localVarFp.updateProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, requestParameters.jsonPatchOperation, options).then((request) => request(axios, basePath));
        },
        /**
         * This API partially updates a source in IdentityNow, using a list of patch operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Some fields are immutable and cannot be changed, such as:  * id * type * authoritative * created * modified * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or API authority is required to call this API. 
         * @summary Update Source (Partial)
         * @param {SourcesApiUpdateSourceRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        updateSource(requestParameters: SourcesApiUpdateSourceRequest, options?: AxiosRequestConfig): AxiosPromise<Source> {
            return localVarFp.updateSource(requestParameters.id, requestParameters.jsonPatchOperation, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to selectively update an existing Schema using a JSONPatch payload.   The following schema fields are immutable and cannot be updated:  - id - name - created - modified   To switch an account attribute to a group entitlement, you need to have the following in place:  - `isEntitlement: true` - Must define a schema for the group and [add it to the source](https://developer.sailpoint.com/idn/api/v3/create-source-schema) before updating the `isGroup` flag.  For example, here is the `group` account attribute referencing a schema that defines the group: ```json {     \"name\": \"groups\",     \"type\": \"STRING\",     \"schema\": {         \"type\": \"CONNECTOR_SCHEMA\",         \"id\": \"2c9180887671ff8c01767b4671fc7d60\",         \"name\": \"group\"     },     \"description\": \"The groups, roles etc. that reference account group objects\",     \"isMulti\": true,     \"isEntitlement\": true,     \"isGroup\": true } ``` 
         * @summary Update Source Schema (Partial)
         * @param {SourcesApiUpdateSourceSchemaRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        updateSourceSchema(requestParameters: SourcesApiUpdateSourceSchemaRequest, options?: AxiosRequestConfig): AxiosPromise<Schema> {
            return localVarFp.updateSourceSchema(requestParameters.sourceId, requestParameters.schemaId, requestParameters.jsonPatchOperation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createProvisioningPolicy operation in SourcesApi.
 * @export
 * @interface SourcesApiCreateProvisioningPolicyRequest
 */
export interface SourcesApiCreateProvisioningPolicyRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiCreateProvisioningPolicy
     */
    readonly sourceId: string

    /**
     * 
     * @type {ProvisioningPolicyDto}
     * @memberof SourcesApiCreateProvisioningPolicy
     */
    readonly provisioningPolicyDto: ProvisioningPolicyDto
}

/**
 * Request parameters for createSource operation in SourcesApi.
 * @export
 * @interface SourcesApiCreateSourceRequest
 */
export interface SourcesApiCreateSourceRequest {
    /**
     * 
     * @type {Source}
     * @memberof SourcesApiCreateSource
     */
    readonly source: Source

    /**
     * If this parameter is &#x60;true&#x60;, it configures the source as a Delimited File (CSV) source. Setting this to &#x60;true&#x60; will automatically set the &#x60;type&#x60; of the source to &#x60;DelimitedFile&#x60;.  You must use this query parameter to create a Delimited File source as you would in the UI.  If you don\&#39;t set this query parameter and you attempt to set the &#x60;type&#x60; attribute directly, the request won\&#39;t correctly generate the source.  
     * @type {boolean}
     * @memberof SourcesApiCreateSource
     */
    readonly provisionAsCsv?: boolean
}

/**
 * Request parameters for createSourceSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiCreateSourceSchemaRequest
 */
export interface SourcesApiCreateSourceSchemaRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiCreateSourceSchema
     */
    readonly sourceId: string

    /**
     * 
     * @type {Schema}
     * @memberof SourcesApiCreateSourceSchema
     */
    readonly schema: Schema
}

/**
 * Request parameters for deleteProvisioningPolicy operation in SourcesApi.
 * @export
 * @interface SourcesApiDeleteProvisioningPolicyRequest
 */
export interface SourcesApiDeleteProvisioningPolicyRequest {
    /**
     * The Source ID.
     * @type {string}
     * @memberof SourcesApiDeleteProvisioningPolicy
     */
    readonly sourceId: string

    /**
     * The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
     * @type {UsageType}
     * @memberof SourcesApiDeleteProvisioningPolicy
     */
    readonly usageType: UsageType
}

/**
 * Request parameters for deleteSource operation in SourcesApi.
 * @export
 * @interface SourcesApiDeleteSourceRequest
 */
export interface SourcesApiDeleteSourceRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiDeleteSource
     */
    readonly id: string
}

/**
 * Request parameters for deleteSourceSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiDeleteSourceSchemaRequest
 */
export interface SourcesApiDeleteSourceSchemaRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiDeleteSourceSchema
     */
    readonly sourceId: string

    /**
     * The Schema id.
     * @type {string}
     * @memberof SourcesApiDeleteSourceSchema
     */
    readonly schemaId: string
}

/**
 * Request parameters for getAccountsSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiGetAccountsSchemaRequest
 */
export interface SourcesApiGetAccountsSchemaRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiGetAccountsSchema
     */
    readonly id: string
}

/**
 * Request parameters for getEntitlementsSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiGetEntitlementsSchemaRequest
 */
export interface SourcesApiGetEntitlementsSchemaRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiGetEntitlementsSchema
     */
    readonly id: string

    /**
     * Name of entitlement schema
     * @type {string}
     * @memberof SourcesApiGetEntitlementsSchema
     */
    readonly schemaName?: string
}

/**
 * Request parameters for getProvisioningPolicy operation in SourcesApi.
 * @export
 * @interface SourcesApiGetProvisioningPolicyRequest
 */
export interface SourcesApiGetProvisioningPolicyRequest {
    /**
     * The Source ID.
     * @type {string}
     * @memberof SourcesApiGetProvisioningPolicy
     */
    readonly sourceId: string

    /**
     * The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
     * @type {UsageType}
     * @memberof SourcesApiGetProvisioningPolicy
     */
    readonly usageType: UsageType
}

/**
 * Request parameters for getSource operation in SourcesApi.
 * @export
 * @interface SourcesApiGetSourceRequest
 */
export interface SourcesApiGetSourceRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiGetSource
     */
    readonly id: string
}

/**
 * Request parameters for getSourceHealth operation in SourcesApi.
 * @export
 * @interface SourcesApiGetSourceHealthRequest
 */
export interface SourcesApiGetSourceHealthRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiGetSourceHealth
     */
    readonly sourceId: string
}

/**
 * Request parameters for getSourceSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiGetSourceSchemaRequest
 */
export interface SourcesApiGetSourceSchemaRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiGetSourceSchema
     */
    readonly sourceId: string

    /**
     * The Schema id.
     * @type {string}
     * @memberof SourcesApiGetSourceSchema
     */
    readonly schemaId: string
}

/**
 * Request parameters for importAccountsSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiImportAccountsSchemaRequest
 */
export interface SourcesApiImportAccountsSchemaRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiImportAccountsSchema
     */
    readonly id: string

    /**
     * 
     * @type {File}
     * @memberof SourcesApiImportAccountsSchema
     */
    readonly file?: File
}

/**
 * Request parameters for importConnectorFile operation in SourcesApi.
 * @export
 * @interface SourcesApiImportConnectorFileRequest
 */
export interface SourcesApiImportConnectorFileRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiImportConnectorFile
     */
    readonly sourceId: string

    /**
     * 
     * @type {File}
     * @memberof SourcesApiImportConnectorFile
     */
    readonly file?: File
}

/**
 * Request parameters for importEntitlementsSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiImportEntitlementsSchemaRequest
 */
export interface SourcesApiImportEntitlementsSchemaRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiImportEntitlementsSchema
     */
    readonly id: string

    /**
     * Name of entitlement schema
     * @type {string}
     * @memberof SourcesApiImportEntitlementsSchema
     */
    readonly schemaName?: string

    /**
     * 
     * @type {File}
     * @memberof SourcesApiImportEntitlementsSchema
     */
    readonly file?: File
}

/**
 * Request parameters for listProvisioningPolicies operation in SourcesApi.
 * @export
 * @interface SourcesApiListProvisioningPoliciesRequest
 */
export interface SourcesApiListProvisioningPoliciesRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiListProvisioningPolicies
     */
    readonly sourceId: string
}

/**
 * Request parameters for listSourceSchemas operation in SourcesApi.
 * @export
 * @interface SourcesApiListSourceSchemasRequest
 */
export interface SourcesApiListSourceSchemasRequest {
    /**
     * The Source ID.
     * @type {string}
     * @memberof SourcesApiListSourceSchemas
     */
    readonly sourceId: string

    /**
     * If set to \&#39;group\&#39;, then the account schema is filtered and only group schemas are returned. Only a value of \&#39;group\&#39; is recognized.
     * @type {string}
     * @memberof SourcesApiListSourceSchemas
     */
    readonly includeTypes?: string
}

/**
 * Request parameters for listSources operation in SourcesApi.
 * @export
 * @interface SourcesApiListSourcesRequest
 */
export interface SourcesApiListSourcesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SourcesApiListSources
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SourcesApiListSources
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SourcesApiListSources
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **name**: *co, eq, in, sw, ge, gt, ne, isnull*  **type**: *eq, in, ge, gt, ne, isnull, sw*  **owner.id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **features**: *ca, co*  **created**: *eq*  **modified**: *eq*  **managementWorkgroup.id**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **description**: *eq, sw*  **authoritative**: *eq, ne, isnull*  **healthy**: *isnull*  **status**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **connectionType**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **connectorName**: *eq, ge, gt, in, ne, isnull, sw*
     * @type {string}
     * @memberof SourcesApiListSources
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified, name, owner.name, healthy, status, id, description, owner.id, accountCorrelationConfig.id, accountCorrelationConfig.name, managerCorrelationRule.type, managerCorrelationRule.id, managerCorrelationRule.name, authoritative, managementWorkgroup.id, connectorName, connectionType**
     * @type {string}
     * @memberof SourcesApiListSources
     */
    readonly sorters?: string

    /**
     * Filter the returned list of sources for the identity specified by the parameter, which is the id of an identity with the role SOURCE_SUBADMIN. By convention, the value **me** indicates the identity id of the current user. Subadmins may only view Sources which they are able to administer; all other Sources will be filtered out when this parameter is set. If the current user is a SOURCE_SUBADMIN but fails to pass a valid value for this parameter, a 403 Forbidden is returned.
     * @type {string}
     * @memberof SourcesApiListSources
     */
    readonly forSubadmin?: string
}

/**
 * Request parameters for putProvisioningPolicy operation in SourcesApi.
 * @export
 * @interface SourcesApiPutProvisioningPolicyRequest
 */
export interface SourcesApiPutProvisioningPolicyRequest {
    /**
     * The Source ID.
     * @type {string}
     * @memberof SourcesApiPutProvisioningPolicy
     */
    readonly sourceId: string

    /**
     * The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
     * @type {UsageType}
     * @memberof SourcesApiPutProvisioningPolicy
     */
    readonly usageType: UsageType

    /**
     * 
     * @type {ProvisioningPolicyDto}
     * @memberof SourcesApiPutProvisioningPolicy
     */
    readonly provisioningPolicyDto: ProvisioningPolicyDto
}

/**
 * Request parameters for putSource operation in SourcesApi.
 * @export
 * @interface SourcesApiPutSourceRequest
 */
export interface SourcesApiPutSourceRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiPutSource
     */
    readonly id: string

    /**
     * 
     * @type {Source}
     * @memberof SourcesApiPutSource
     */
    readonly source: Source
}

/**
 * Request parameters for putSourceSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiPutSourceSchemaRequest
 */
export interface SourcesApiPutSourceSchemaRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiPutSourceSchema
     */
    readonly sourceId: string

    /**
     * The Schema id.
     * @type {string}
     * @memberof SourcesApiPutSourceSchema
     */
    readonly schemaId: string

    /**
     * 
     * @type {Schema}
     * @memberof SourcesApiPutSourceSchema
     */
    readonly schema: Schema
}

/**
 * Request parameters for updateProvisioningPoliciesInBulk operation in SourcesApi.
 * @export
 * @interface SourcesApiUpdateProvisioningPoliciesInBulkRequest
 */
export interface SourcesApiUpdateProvisioningPoliciesInBulkRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiUpdateProvisioningPoliciesInBulk
     */
    readonly sourceId: string

    /**
     * 
     * @type {Array<ProvisioningPolicyDto>}
     * @memberof SourcesApiUpdateProvisioningPoliciesInBulk
     */
    readonly provisioningPolicyDto: Array<ProvisioningPolicyDto>
}

/**
 * Request parameters for updateProvisioningPolicy operation in SourcesApi.
 * @export
 * @interface SourcesApiUpdateProvisioningPolicyRequest
 */
export interface SourcesApiUpdateProvisioningPolicyRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiUpdateProvisioningPolicy
     */
    readonly sourceId: string

    /**
     * The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
     * @type {UsageType}
     * @memberof SourcesApiUpdateProvisioningPolicy
     */
    readonly usageType: UsageType

    /**
     * The JSONPatch payload used to update the schema.
     * @type {Array<JsonPatchOperation>}
     * @memberof SourcesApiUpdateProvisioningPolicy
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for updateSource operation in SourcesApi.
 * @export
 * @interface SourcesApiUpdateSourceRequest
 */
export interface SourcesApiUpdateSourceRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiUpdateSource
     */
    readonly id: string

    /**
     * A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Any password changes are submitted as plain-text and encrypted upon receipt in IdentityNow.
     * @type {Array<JsonPatchOperation>}
     * @memberof SourcesApiUpdateSource
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for updateSourceSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiUpdateSourceSchemaRequest
 */
export interface SourcesApiUpdateSourceSchemaRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiUpdateSourceSchema
     */
    readonly sourceId: string

    /**
     * The Schema id.
     * @type {string}
     * @memberof SourcesApiUpdateSourceSchema
     */
    readonly schemaId: string

    /**
     * The JSONPatch payload used to update the schema.
     * @type {Array<JsonPatchOperation>}
     * @memberof SourcesApiUpdateSourceSchema
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * SourcesApi - object-oriented interface
 * @export
 * @class SourcesApi
 * @extends {BaseAPI}
 */
export class SourcesApi extends BaseAPI {
    /**
     * This API generates a create policy/template based on field value transforms. This API is intended for use when setting up JDBC Provisioning type sources, but it will also work on other source types. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with ORG_ADMIN authority is required to call this API.
     * @summary Create Provisioning Policy
     * @param {SourcesApiCreateProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public createProvisioningPolicy(requestParameters: SourcesApiCreateProvisioningPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).createProvisioningPolicy(requestParameters.sourceId, requestParameters.provisioningPolicyDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This creates a specific source with a full source JSON representation. Any passwords are submitted as plain-text and encrypted upon receipt in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Creates a source in IdentityNow.
     * @param {SourcesApiCreateSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public createSource(requestParameters: SourcesApiCreateSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).createSource(requestParameters.source, requestParameters.provisionAsCsv, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new Schema on the specified Source in IdentityNow. 
     * @summary Create Schema on a Source
     * @param {SourcesApiCreateSourceSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public createSourceSchema(requestParameters: SourcesApiCreateSourceSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).createSourceSchema(requestParameters.sourceId, requestParameters.schema, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the provisioning policy with the specified usage on an application. A token with API, or ORG_ADMIN authority is required to call this API.
     * @summary Delete Provisioning Policy by UsageType
     * @param {SourcesApiDeleteProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public deleteProvisioningPolicy(requestParameters: SourcesApiDeleteProvisioningPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).deleteProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point deletes a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. All of accounts on the source will be removed first, then the source will be deleted. Actual status of task execution can be retrieved via method GET `/task-status/{id}`
     * @summary Delete Source by ID
     * @param {SourcesApiDeleteSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public deleteSource(requestParameters: SourcesApiDeleteSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).deleteSource(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Source Schema by ID
     * @param {SourcesApiDeleteSourceSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public deleteSourceSchema(requestParameters: SourcesApiDeleteSourceSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).deleteSourceSchema(requestParameters.sourceId, requestParameters.schemaId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API downloads the CSV schema that defines the account attributes on a source. >**NOTE: This API is designated only for Delimited File sources.**
     * @summary Downloads source accounts schema template
     * @param {SourcesApiGetAccountsSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getAccountsSchema(requestParameters: SourcesApiGetAccountsSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).getAccountsSchema(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API downloads the CSV schema that defines the entitlement attributes on a source.  >**NOTE: This API is designated only for Delimited File sources.**
     * @summary Downloads source entitlements schema template
     * @param {SourcesApiGetEntitlementsSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getEntitlementsSchema(requestParameters: SourcesApiGetEntitlementsSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).getEntitlementsSchema(requestParameters.id, requestParameters.schemaName, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point retrieves the ProvisioningPolicy with the specified usage on the specified Source in IdentityNow. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Get Provisioning Policy by UsageType
     * @param {SourcesApiGetProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getProvisioningPolicy(requestParameters: SourcesApiGetProvisioningPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).getProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point gets a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Get Source by ID
     * @param {SourcesApiGetSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getSource(requestParameters: SourcesApiGetSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).getSource(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint fetches source health by source\'s id
     * @summary Fetches source health by id
     * @param {SourcesApiGetSourceHealthRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getSourceHealth(requestParameters: SourcesApiGetSourceHealthRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).getSourceHealth(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the Source Schema by ID in IdentityNow. 
     * @summary Get Source Schema by ID
     * @param {SourcesApiGetSourceSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getSourceSchema(requestParameters: SourcesApiGetSourceSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).getSourceSchema(requestParameters.sourceId, requestParameters.schemaId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API uploads a source schema template file to configure a source\'s account attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Account Schema** -> **Options** -> **Download Schema**  >**NOTE: This API is designated only for Delimited File sources.**
     * @summary Uploads source accounts schema template
     * @param {SourcesApiImportAccountsSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public importAccountsSchema(requestParameters: SourcesApiImportAccountsSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).importAccountsSchema(requestParameters.id, requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This uploads a supplemental source connector file (like jdbc driver jars) to a source\'s S3 bucket. This also sends ETS and Audit events. A token with ORG_ADMIN authority is required to call this API.
     * @summary Upload connector file to source
     * @param {SourcesApiImportConnectorFileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public importConnectorFile(requestParameters: SourcesApiImportConnectorFileRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).importConnectorFile(requestParameters.sourceId, requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API uploads a source schema template file to configure a source\'s entitlement attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Import Entitlements** -> **Download**  >**NOTE: This API is designated only for Delimited File sources.**
     * @summary Uploads source entitlements schema template
     * @param {SourcesApiImportEntitlementsSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public importEntitlementsSchema(requestParameters: SourcesApiImportEntitlementsSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).importEntitlementsSchema(requestParameters.id, requestParameters.schemaName, requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point lists all the ProvisioningPolicies in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
     * @summary Lists ProvisioningPolicies
     * @param {SourcesApiListProvisioningPoliciesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public listProvisioningPolicies(requestParameters: SourcesApiListProvisioningPoliciesRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).listProvisioningPolicies(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the Schemas that exist on the specified Source in IdentityNow. 
     * @summary List Schemas on a Source
     * @param {SourcesApiListSourceSchemasRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public listSourceSchemas(requestParameters: SourcesApiListSourceSchemasRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).listSourceSchemas(requestParameters.sourceId, requestParameters.includeTypes, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point lists all the sources in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or ROLE_SUBADMIN authority is required to call this API.
     * @summary Lists all sources in IdentityNow.
     * @param {SourcesApiListSourcesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public listSources(requestParameters: SourcesApiListSourcesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).listSources(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.forSubadmin, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point updates the provisioning policy with the specified usage on the specified source in IdentityNow. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Update Provisioning Policy by UsageType
     * @param {SourcesApiPutProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public putProvisioningPolicy(requestParameters: SourcesApiPutProvisioningPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).putProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, requestParameters.provisioningPolicyDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates a source in IdentityNow, using a full object representation. In other words, the existing Source configuration is completely replaced.  Some fields are immutable and cannot be changed, such as:  * id * type * authoritative * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. 
     * @summary Update Source (Full)
     * @param {SourcesApiPutSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public putSource(requestParameters: SourcesApiPutSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).putSource(requestParameters.id, requestParameters.source, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API will completely replace an existing Schema with the submitted payload. Some fields of the Schema cannot be updated. These fields are listed below.  * id * name * created * modified  Any attempt to modify these fields will result in an error response with a status code of 400.  > `id` must remain in the request body, but it cannot be changed.  If `id` is omitted from the request body, the result will be a 400 error. 
     * @summary Update Source Schema (Full)
     * @param {SourcesApiPutSourceSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public putSourceSchema(requestParameters: SourcesApiPutSourceSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).putSourceSchema(requestParameters.sourceId, requestParameters.schemaId, requestParameters.schema, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point updates a list of provisioning policies on the specified source in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
     * @summary Bulk Update Provisioning Policies
     * @param {SourcesApiUpdateProvisioningPoliciesInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public updateProvisioningPoliciesInBulk(requestParameters: SourcesApiUpdateProvisioningPoliciesInBulkRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).updateProvisioningPoliciesInBulk(requestParameters.sourceId, requestParameters.provisioningPolicyDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API selectively updates an existing Provisioning Policy using a JSONPatch payload. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Partial update of Provisioning Policy
     * @param {SourcesApiUpdateProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public updateProvisioningPolicy(requestParameters: SourcesApiUpdateProvisioningPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).updateProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API partially updates a source in IdentityNow, using a list of patch operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Some fields are immutable and cannot be changed, such as:  * id * type * authoritative * created * modified * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or API authority is required to call this API. 
     * @summary Update Source (Partial)
     * @param {SourcesApiUpdateSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public updateSource(requestParameters: SourcesApiUpdateSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).updateSource(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to selectively update an existing Schema using a JSONPatch payload.   The following schema fields are immutable and cannot be updated:  - id - name - created - modified   To switch an account attribute to a group entitlement, you need to have the following in place:  - `isEntitlement: true` - Must define a schema for the group and [add it to the source](https://developer.sailpoint.com/idn/api/v3/create-source-schema) before updating the `isGroup` flag.  For example, here is the `group` account attribute referencing a schema that defines the group: ```json {     \"name\": \"groups\",     \"type\": \"STRING\",     \"schema\": {         \"type\": \"CONNECTOR_SCHEMA\",         \"id\": \"2c9180887671ff8c01767b4671fc7d60\",         \"name\": \"group\"     },     \"description\": \"The groups, roles etc. that reference account group objects\",     \"isMulti\": true,     \"isEntitlement\": true,     \"isGroup\": true } ``` 
     * @summary Update Source Schema (Partial)
     * @param {SourcesApiUpdateSourceSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public updateSourceSchema(requestParameters: SourcesApiUpdateSourceSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).updateSourceSchema(requestParameters.sourceId, requestParameters.schemaId, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TaggedObjectsApi - axios parameter creator
 * @export
 */
export const TaggedObjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This deletes a tagged object for the specified type.
         * @summary Delete Tagged Object
         * @param {DeleteTaggedObjectTypeEnum} type The type of tagged object to delete.
         * @param {string} id The ID of the object reference to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaggedObject: async (type: 'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE', id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('deleteTaggedObject', 'type', type)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTaggedObject', 'id', id)
            const localVarPath = `/tagged-objects/{type}/{id}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API removes tags from multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Remove Tags from Multiple Objects
         * @param {BulkTaggedObject} bulkTaggedObject Supported object types are ACCESS_PROFILE, APPLICATION, CAMPAIGN, ENTITLEMENT, IDENTITY, ROLE, SOD_POLICY, SOURCE.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagsToManyObject: async (bulkTaggedObject: BulkTaggedObject, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkTaggedObject' is not null or undefined
            assertParamExists('deleteTagsToManyObject', 'bulkTaggedObject', bulkTaggedObject)
            const localVarPath = `/tagged-objects/bulk-remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkTaggedObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a tagged object for the specified type.
         * @summary Get Tagged Object
         * @param {GetTaggedObjectTypeEnum} type The type of tagged object to retrieve.
         * @param {string} id The ID of the object reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTaggedObject: async (type: 'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE', id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getTaggedObject', 'type', type)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTaggedObject', 'id', id)
            const localVarPath = `/tagged-objects/{type}/{id}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of all tagged objects.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq, in*  **objectRef.type**: *eq, in*  **tagName**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTaggedObjects: async (limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tagged-objects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of all tagged objects by type.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects
         * @param {ListTaggedObjectsByTypeTypeEnum} type The type of tagged object to retrieve.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq*  **objectRef.type**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTaggedObjectsByType: async (type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY', limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('listTaggedObjectsByType', 'type', type)
            const localVarPath = `/tagged-objects/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This updates a tagged object for the specified type.
         * @summary Update Tagged Object
         * @param {PutTaggedObjectTypeEnum} type The type of tagged object to update.
         * @param {string} id The ID of the object reference to update.
         * @param {TaggedObject} taggedObject 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putTaggedObject: async (type: 'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE', id: string, taggedObject: TaggedObject, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('putTaggedObject', 'type', type)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putTaggedObject', 'id', id)
            // verify required parameter 'taggedObject' is not null or undefined
            assertParamExists('putTaggedObject', 'taggedObject', taggedObject)
            const localVarPath = `/tagged-objects/{type}/{id}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taggedObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This adds a tag to an object.  Any authenticated token may be used to call this API.
         * @summary Add Tag to Object
         * @param {TaggedObject} taggedObject 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setTagToObject: async (taggedObject: TaggedObject, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taggedObject' is not null or undefined
            assertParamExists('setTagToObject', 'taggedObject', taggedObject)
            const localVarPath = `/tagged-objects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taggedObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API adds tags to multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Tag Multiple Objects
         * @param {BulkTaggedObject} bulkTaggedObject Supported object types are ACCESS_PROFILE, APPLICATION, CAMPAIGN, ENTITLEMENT, IDENTITY, ROLE, SOD_POLICY, SOURCE.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setTagsToManyObjects: async (bulkTaggedObject: BulkTaggedObject, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkTaggedObject' is not null or undefined
            assertParamExists('setTagsToManyObjects', 'bulkTaggedObject', bulkTaggedObject)
            const localVarPath = `/tagged-objects/bulk-add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkTaggedObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaggedObjectsApi - functional programming interface
 * @export
 */
export const TaggedObjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaggedObjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * This deletes a tagged object for the specified type.
         * @summary Delete Tagged Object
         * @param {DeleteTaggedObjectTypeEnum} type The type of tagged object to delete.
         * @param {string} id The ID of the object reference to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTaggedObject(type: DeleteTaggedObjectTypeEnum, id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTaggedObject(type, id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TaggedObjectsApi.deleteTaggedObject']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API removes tags from multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Remove Tags from Multiple Objects
         * @param {BulkTaggedObject} bulkTaggedObject Supported object types are ACCESS_PROFILE, APPLICATION, CAMPAIGN, ENTITLEMENT, IDENTITY, ROLE, SOD_POLICY, SOURCE.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTagsToManyObject(bulkTaggedObject: BulkTaggedObject, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTagsToManyObject(bulkTaggedObject, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TaggedObjectsApi.deleteTagsToManyObject']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This gets a tagged object for the specified type.
         * @summary Get Tagged Object
         * @param {GetTaggedObjectTypeEnum} type The type of tagged object to retrieve.
         * @param {string} id The ID of the object reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getTaggedObject(type: GetTaggedObjectTypeEnum, id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaggedObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaggedObject(type, id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TaggedObjectsApi.getTaggedObject']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API returns a list of all tagged objects.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq, in*  **objectRef.type**: *eq, in*  **tagName**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listTaggedObjects(limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaggedObject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTaggedObjects(limit, offset, count, filters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TaggedObjectsApi.listTaggedObjects']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API returns a list of all tagged objects by type.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects
         * @param {ListTaggedObjectsByTypeTypeEnum} type The type of tagged object to retrieve.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq*  **objectRef.type**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listTaggedObjectsByType(type: ListTaggedObjectsByTypeTypeEnum, limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaggedObject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTaggedObjectsByType(type, limit, offset, count, filters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TaggedObjectsApi.listTaggedObjectsByType']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This updates a tagged object for the specified type.
         * @summary Update Tagged Object
         * @param {PutTaggedObjectTypeEnum} type The type of tagged object to update.
         * @param {string} id The ID of the object reference to update.
         * @param {TaggedObject} taggedObject 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putTaggedObject(type: PutTaggedObjectTypeEnum, id: string, taggedObject: TaggedObject, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaggedObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putTaggedObject(type, id, taggedObject, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TaggedObjectsApi.putTaggedObject']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This adds a tag to an object.  Any authenticated token may be used to call this API.
         * @summary Add Tag to Object
         * @param {TaggedObject} taggedObject 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setTagToObject(taggedObject: TaggedObject, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTagToObject(taggedObject, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TaggedObjectsApi.setTagToObject']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API adds tags to multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Tag Multiple Objects
         * @param {BulkTaggedObject} bulkTaggedObject Supported object types are ACCESS_PROFILE, APPLICATION, CAMPAIGN, ENTITLEMENT, IDENTITY, ROLE, SOD_POLICY, SOURCE.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setTagsToManyObjects(bulkTaggedObject: BulkTaggedObject, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkTaggedObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTagsToManyObjects(bulkTaggedObject, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TaggedObjectsApi.setTagsToManyObjects']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TaggedObjectsApi - factory interface
 * @export
 */
export const TaggedObjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaggedObjectsApiFp(configuration)
    return {
        /**
         * This deletes a tagged object for the specified type.
         * @summary Delete Tagged Object
         * @param {TaggedObjectsApiDeleteTaggedObjectRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteTaggedObject(requestParameters: TaggedObjectsApiDeleteTaggedObjectRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTaggedObject(requestParameters.type, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This API removes tags from multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Remove Tags from Multiple Objects
         * @param {TaggedObjectsApiDeleteTagsToManyObjectRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteTagsToManyObject(requestParameters: TaggedObjectsApiDeleteTagsToManyObjectRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTagsToManyObject(requestParameters.bulkTaggedObject, options).then((request) => request(axios, basePath));
        },
        /**
         * This gets a tagged object for the specified type.
         * @summary Get Tagged Object
         * @param {TaggedObjectsApiGetTaggedObjectRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getTaggedObject(requestParameters: TaggedObjectsApiGetTaggedObjectRequest, options?: AxiosRequestConfig): AxiosPromise<TaggedObject> {
            return localVarFp.getTaggedObject(requestParameters.type, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of all tagged objects.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects
         * @param {TaggedObjectsApiListTaggedObjectsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listTaggedObjects(requestParameters: TaggedObjectsApiListTaggedObjectsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<TaggedObject>> {
            return localVarFp.listTaggedObjects(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, options).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of all tagged objects by type.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects
         * @param {TaggedObjectsApiListTaggedObjectsByTypeRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listTaggedObjectsByType(requestParameters: TaggedObjectsApiListTaggedObjectsByTypeRequest, options?: AxiosRequestConfig): AxiosPromise<Array<TaggedObject>> {
            return localVarFp.listTaggedObjectsByType(requestParameters.type, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, options).then((request) => request(axios, basePath));
        },
        /**
         * This updates a tagged object for the specified type.
         * @summary Update Tagged Object
         * @param {TaggedObjectsApiPutTaggedObjectRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        putTaggedObject(requestParameters: TaggedObjectsApiPutTaggedObjectRequest, options?: AxiosRequestConfig): AxiosPromise<TaggedObject> {
            return localVarFp.putTaggedObject(requestParameters.type, requestParameters.id, requestParameters.taggedObject, options).then((request) => request(axios, basePath));
        },
        /**
         * This adds a tag to an object.  Any authenticated token may be used to call this API.
         * @summary Add Tag to Object
         * @param {TaggedObjectsApiSetTagToObjectRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        setTagToObject(requestParameters: TaggedObjectsApiSetTagToObjectRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setTagToObject(requestParameters.taggedObject, options).then((request) => request(axios, basePath));
        },
        /**
         * This API adds tags to multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Tag Multiple Objects
         * @param {TaggedObjectsApiSetTagsToManyObjectsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        setTagsToManyObjects(requestParameters: TaggedObjectsApiSetTagsToManyObjectsRequest, options?: AxiosRequestConfig): AxiosPromise<BulkTaggedObject> {
            return localVarFp.setTagsToManyObjects(requestParameters.bulkTaggedObject, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteTaggedObject operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiDeleteTaggedObjectRequest
 */
export interface TaggedObjectsApiDeleteTaggedObjectRequest {
    /**
     * The type of tagged object to delete.
     * @type {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'}
     * @memberof TaggedObjectsApiDeleteTaggedObject
     */
    readonly type: DeleteTaggedObjectTypeEnum

    /**
     * The ID of the object reference to delete.
     * @type {string}
     * @memberof TaggedObjectsApiDeleteTaggedObject
     */
    readonly id: string
}

/**
 * Request parameters for deleteTagsToManyObject operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiDeleteTagsToManyObjectRequest
 */
export interface TaggedObjectsApiDeleteTagsToManyObjectRequest {
    /**
     * Supported object types are ACCESS_PROFILE, APPLICATION, CAMPAIGN, ENTITLEMENT, IDENTITY, ROLE, SOD_POLICY, SOURCE.
     * @type {BulkTaggedObject}
     * @memberof TaggedObjectsApiDeleteTagsToManyObject
     */
    readonly bulkTaggedObject: BulkTaggedObject
}

/**
 * Request parameters for getTaggedObject operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiGetTaggedObjectRequest
 */
export interface TaggedObjectsApiGetTaggedObjectRequest {
    /**
     * The type of tagged object to retrieve.
     * @type {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'}
     * @memberof TaggedObjectsApiGetTaggedObject
     */
    readonly type: GetTaggedObjectTypeEnum

    /**
     * The ID of the object reference to retrieve.
     * @type {string}
     * @memberof TaggedObjectsApiGetTaggedObject
     */
    readonly id: string
}

/**
 * Request parameters for listTaggedObjects operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiListTaggedObjectsRequest
 */
export interface TaggedObjectsApiListTaggedObjectsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TaggedObjectsApiListTaggedObjects
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TaggedObjectsApiListTaggedObjects
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof TaggedObjectsApiListTaggedObjects
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq, in*  **objectRef.type**: *eq, in*  **tagName**: *eq, in*
     * @type {string}
     * @memberof TaggedObjectsApiListTaggedObjects
     */
    readonly filters?: string
}

/**
 * Request parameters for listTaggedObjectsByType operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiListTaggedObjectsByTypeRequest
 */
export interface TaggedObjectsApiListTaggedObjectsByTypeRequest {
    /**
     * The type of tagged object to retrieve.
     * @type {'ROLE' | 'IDENTITY' | 'SOD_POLICY'}
     * @memberof TaggedObjectsApiListTaggedObjectsByType
     */
    readonly type: ListTaggedObjectsByTypeTypeEnum

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TaggedObjectsApiListTaggedObjectsByType
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TaggedObjectsApiListTaggedObjectsByType
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof TaggedObjectsApiListTaggedObjectsByType
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq*  **objectRef.type**: *eq*
     * @type {string}
     * @memberof TaggedObjectsApiListTaggedObjectsByType
     */
    readonly filters?: string
}

/**
 * Request parameters for putTaggedObject operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiPutTaggedObjectRequest
 */
export interface TaggedObjectsApiPutTaggedObjectRequest {
    /**
     * The type of tagged object to update.
     * @type {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'}
     * @memberof TaggedObjectsApiPutTaggedObject
     */
    readonly type: PutTaggedObjectTypeEnum

    /**
     * The ID of the object reference to update.
     * @type {string}
     * @memberof TaggedObjectsApiPutTaggedObject
     */
    readonly id: string

    /**
     * 
     * @type {TaggedObject}
     * @memberof TaggedObjectsApiPutTaggedObject
     */
    readonly taggedObject: TaggedObject
}

/**
 * Request parameters for setTagToObject operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiSetTagToObjectRequest
 */
export interface TaggedObjectsApiSetTagToObjectRequest {
    /**
     * 
     * @type {TaggedObject}
     * @memberof TaggedObjectsApiSetTagToObject
     */
    readonly taggedObject: TaggedObject
}

/**
 * Request parameters for setTagsToManyObjects operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiSetTagsToManyObjectsRequest
 */
export interface TaggedObjectsApiSetTagsToManyObjectsRequest {
    /**
     * Supported object types are ACCESS_PROFILE, APPLICATION, CAMPAIGN, ENTITLEMENT, IDENTITY, ROLE, SOD_POLICY, SOURCE.
     * @type {BulkTaggedObject}
     * @memberof TaggedObjectsApiSetTagsToManyObjects
     */
    readonly bulkTaggedObject: BulkTaggedObject
}

/**
 * TaggedObjectsApi - object-oriented interface
 * @export
 * @class TaggedObjectsApi
 * @extends {BaseAPI}
 */
export class TaggedObjectsApi extends BaseAPI {
    /**
     * This deletes a tagged object for the specified type.
     * @summary Delete Tagged Object
     * @param {TaggedObjectsApiDeleteTaggedObjectRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public deleteTaggedObject(requestParameters: TaggedObjectsApiDeleteTaggedObjectRequest, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).deleteTaggedObject(requestParameters.type, requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API removes tags from multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Remove Tags from Multiple Objects
     * @param {TaggedObjectsApiDeleteTagsToManyObjectRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public deleteTagsToManyObject(requestParameters: TaggedObjectsApiDeleteTagsToManyObjectRequest, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).deleteTagsToManyObject(requestParameters.bulkTaggedObject, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a tagged object for the specified type.
     * @summary Get Tagged Object
     * @param {TaggedObjectsApiGetTaggedObjectRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public getTaggedObject(requestParameters: TaggedObjectsApiGetTaggedObjectRequest, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).getTaggedObject(requestParameters.type, requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of all tagged objects.  Any authenticated token may be used to call this API.
     * @summary List Tagged Objects
     * @param {TaggedObjectsApiListTaggedObjectsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public listTaggedObjects(requestParameters: TaggedObjectsApiListTaggedObjectsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).listTaggedObjects(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of all tagged objects by type.  Any authenticated token may be used to call this API.
     * @summary List Tagged Objects
     * @param {TaggedObjectsApiListTaggedObjectsByTypeRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public listTaggedObjectsByType(requestParameters: TaggedObjectsApiListTaggedObjectsByTypeRequest, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).listTaggedObjectsByType(requestParameters.type, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This updates a tagged object for the specified type.
     * @summary Update Tagged Object
     * @param {TaggedObjectsApiPutTaggedObjectRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public putTaggedObject(requestParameters: TaggedObjectsApiPutTaggedObjectRequest, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).putTaggedObject(requestParameters.type, requestParameters.id, requestParameters.taggedObject, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This adds a tag to an object.  Any authenticated token may be used to call this API.
     * @summary Add Tag to Object
     * @param {TaggedObjectsApiSetTagToObjectRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public setTagToObject(requestParameters: TaggedObjectsApiSetTagToObjectRequest, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).setTagToObject(requestParameters.taggedObject, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API adds tags to multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Tag Multiple Objects
     * @param {TaggedObjectsApiSetTagsToManyObjectsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public setTagsToManyObjects(requestParameters: TaggedObjectsApiSetTagsToManyObjectsRequest, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).setTagsToManyObjects(requestParameters.bulkTaggedObject, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeleteTaggedObjectTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    Application: 'APPLICATION',
    Campaign: 'CAMPAIGN',
    Entitlement: 'ENTITLEMENT',
    Identity: 'IDENTITY',
    Role: 'ROLE',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE'
} as const;
export type DeleteTaggedObjectTypeEnum = typeof DeleteTaggedObjectTypeEnum[keyof typeof DeleteTaggedObjectTypeEnum];
/**
 * @export
 */
export const GetTaggedObjectTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    Application: 'APPLICATION',
    Campaign: 'CAMPAIGN',
    Entitlement: 'ENTITLEMENT',
    Identity: 'IDENTITY',
    Role: 'ROLE',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE'
} as const;
export type GetTaggedObjectTypeEnum = typeof GetTaggedObjectTypeEnum[keyof typeof GetTaggedObjectTypeEnum];
/**
 * @export
 */
export const ListTaggedObjectsByTypeTypeEnum = {
    Role: 'ROLE',
    Identity: 'IDENTITY',
    SodPolicy: 'SOD_POLICY'
} as const;
export type ListTaggedObjectsByTypeTypeEnum = typeof ListTaggedObjectsByTypeTypeEnum[keyof typeof ListTaggedObjectsByTypeTypeEnum];
/**
 * @export
 */
export const PutTaggedObjectTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    Application: 'APPLICATION',
    Campaign: 'CAMPAIGN',
    Entitlement: 'ENTITLEMENT',
    Identity: 'IDENTITY',
    Role: 'ROLE',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE'
} as const;
export type PutTaggedObjectTypeEnum = typeof PutTaggedObjectTypeEnum[keyof typeof PutTaggedObjectTypeEnum];


/**
 * TransformsApi - axios parameter creator
 * @export
 */
export const TransformsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new transform object immediately. By default, the internal flag is set to false to indicate that this is a custom transform. Only SailPoint employees have the ability to create a transform with internal set to true. Newly created Transforms can be used in the Identity Profile mappings within the UI. A token with transform write authority is required to call this API.
         * @summary Create transform
         * @param {Transform} transform The transform to be created.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createTransform: async (transform: Transform, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transform' is not null or undefined
            assertParamExists('createTransform', 'transform', transform)
            const localVarPath = `/transforms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transform, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes the transform specified by the given ID. Attempting to delete a transform that is used in one or more Identity Profile mappings will result in an error. If this occurs, you must first remove the transform from all mappings before deleting the transform. A token with transform delete authority is required to call this API.
         * @summary Delete a transform
         * @param {string} id ID of the transform to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransform: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTransform', 'id', id)
            const localVarPath = `/transforms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the transform specified by the given ID. A token with transform read authority is required to call this API.
         * @summary Transform by ID
         * @param {string} id ID of the transform to retrieve
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTransform: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTransform', 'id', id)
            const localVarPath = `/transforms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of all saved transform objects. A token with transforms-list read authority is required to call this API.
         * @summary List transforms
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [name] Name of the transform to retrieve from the list.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **internal**: *eq*  **name**: *eq, sw*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTransforms: async (offset?: number, limit?: number, count?: boolean, name?: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transforms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Replaces the transform specified by the given ID with the transform provided in the request body. Only the \"attributes\" field is mutable. Attempting to change other properties (ex. \"name\" and \"type\") will result in an error. A token with transform write authority is required to call this API.
         * @summary Update a transform
         * @param {string} id ID of the transform to update
         * @param {Transform} [transform] The updated transform object. Must include \&quot;name\&quot;, \&quot;type\&quot;, and \&quot;attributes\&quot; fields, but \&quot;name\&quot; and \&quot;type\&quot; must not be modified.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateTransform: async (id: string, transform?: Transform, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTransform', 'id', id)
            const localVarPath = `/transforms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transform, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransformsApi - functional programming interface
 * @export
 */
export const TransformsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransformsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new transform object immediately. By default, the internal flag is set to false to indicate that this is a custom transform. Only SailPoint employees have the ability to create a transform with internal set to true. Newly created Transforms can be used in the Identity Profile mappings within the UI. A token with transform write authority is required to call this API.
         * @summary Create transform
         * @param {Transform} transform The transform to be created.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createTransform(transform: Transform, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransformRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransform(transform, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransformsApi.createTransform']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Deletes the transform specified by the given ID. Attempting to delete a transform that is used in one or more Identity Profile mappings will result in an error. If this occurs, you must first remove the transform from all mappings before deleting the transform. A token with transform delete authority is required to call this API.
         * @summary Delete a transform
         * @param {string} id ID of the transform to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTransform(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTransform(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransformsApi.deleteTransform']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API returns the transform specified by the given ID. A token with transform read authority is required to call this API.
         * @summary Transform by ID
         * @param {string} id ID of the transform to retrieve
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getTransform(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransformRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransform(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransformsApi.getTransform']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Gets a list of all saved transform objects. A token with transforms-list read authority is required to call this API.
         * @summary List transforms
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [name] Name of the transform to retrieve from the list.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **internal**: *eq*  **name**: *eq, sw*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listTransforms(offset?: number, limit?: number, count?: boolean, name?: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransformRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransforms(offset, limit, count, name, filters, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransformsApi.listTransforms']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Replaces the transform specified by the given ID with the transform provided in the request body. Only the \"attributes\" field is mutable. Attempting to change other properties (ex. \"name\" and \"type\") will result in an error. A token with transform write authority is required to call this API.
         * @summary Update a transform
         * @param {string} id ID of the transform to update
         * @param {Transform} [transform] The updated transform object. Must include \&quot;name\&quot;, \&quot;type\&quot;, and \&quot;attributes\&quot; fields, but \&quot;name\&quot; and \&quot;type\&quot; must not be modified.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateTransform(id: string, transform?: Transform, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransformRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTransform(id, transform, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransformsApi.updateTransform']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TransformsApi - factory interface
 * @export
 */
export const TransformsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransformsApiFp(configuration)
    return {
        /**
         * Creates a new transform object immediately. By default, the internal flag is set to false to indicate that this is a custom transform. Only SailPoint employees have the ability to create a transform with internal set to true. Newly created Transforms can be used in the Identity Profile mappings within the UI. A token with transform write authority is required to call this API.
         * @summary Create transform
         * @param {TransformsApiCreateTransformRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        createTransform(requestParameters: TransformsApiCreateTransformRequest, options?: AxiosRequestConfig): AxiosPromise<TransformRead> {
            return localVarFp.createTransform(requestParameters.transform, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the transform specified by the given ID. Attempting to delete a transform that is used in one or more Identity Profile mappings will result in an error. If this occurs, you must first remove the transform from all mappings before deleting the transform. A token with transform delete authority is required to call this API.
         * @summary Delete a transform
         * @param {TransformsApiDeleteTransformRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteTransform(requestParameters: TransformsApiDeleteTransformRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTransform(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the transform specified by the given ID. A token with transform read authority is required to call this API.
         * @summary Transform by ID
         * @param {TransformsApiGetTransformRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getTransform(requestParameters: TransformsApiGetTransformRequest, options?: AxiosRequestConfig): AxiosPromise<TransformRead> {
            return localVarFp.getTransform(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of all saved transform objects. A token with transforms-list read authority is required to call this API.
         * @summary List transforms
         * @param {TransformsApiListTransformsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listTransforms(requestParameters: TransformsApiListTransformsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<TransformRead>> {
            return localVarFp.listTransforms(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.name, requestParameters.filters, options).then((request) => request(axios, basePath));
        },
        /**
         * Replaces the transform specified by the given ID with the transform provided in the request body. Only the \"attributes\" field is mutable. Attempting to change other properties (ex. \"name\" and \"type\") will result in an error. A token with transform write authority is required to call this API.
         * @summary Update a transform
         * @param {TransformsApiUpdateTransformRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        updateTransform(requestParameters: TransformsApiUpdateTransformRequest, options?: AxiosRequestConfig): AxiosPromise<TransformRead> {
            return localVarFp.updateTransform(requestParameters.id, requestParameters.transform, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createTransform operation in TransformsApi.
 * @export
 * @interface TransformsApiCreateTransformRequest
 */
export interface TransformsApiCreateTransformRequest {
    /**
     * The transform to be created.
     * @type {Transform}
     * @memberof TransformsApiCreateTransform
     */
    readonly transform: Transform
}

/**
 * Request parameters for deleteTransform operation in TransformsApi.
 * @export
 * @interface TransformsApiDeleteTransformRequest
 */
export interface TransformsApiDeleteTransformRequest {
    /**
     * ID of the transform to delete
     * @type {string}
     * @memberof TransformsApiDeleteTransform
     */
    readonly id: string
}

/**
 * Request parameters for getTransform operation in TransformsApi.
 * @export
 * @interface TransformsApiGetTransformRequest
 */
export interface TransformsApiGetTransformRequest {
    /**
     * ID of the transform to retrieve
     * @type {string}
     * @memberof TransformsApiGetTransform
     */
    readonly id: string
}

/**
 * Request parameters for listTransforms operation in TransformsApi.
 * @export
 * @interface TransformsApiListTransformsRequest
 */
export interface TransformsApiListTransformsRequest {
    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TransformsApiListTransforms
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TransformsApiListTransforms
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof TransformsApiListTransforms
     */
    readonly count?: boolean

    /**
     * Name of the transform to retrieve from the list.
     * @type {string}
     * @memberof TransformsApiListTransforms
     */
    readonly name?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **internal**: *eq*  **name**: *eq, sw*
     * @type {string}
     * @memberof TransformsApiListTransforms
     */
    readonly filters?: string
}

/**
 * Request parameters for updateTransform operation in TransformsApi.
 * @export
 * @interface TransformsApiUpdateTransformRequest
 */
export interface TransformsApiUpdateTransformRequest {
    /**
     * ID of the transform to update
     * @type {string}
     * @memberof TransformsApiUpdateTransform
     */
    readonly id: string

    /**
     * The updated transform object. Must include \&quot;name\&quot;, \&quot;type\&quot;, and \&quot;attributes\&quot; fields, but \&quot;name\&quot; and \&quot;type\&quot; must not be modified.
     * @type {Transform}
     * @memberof TransformsApiUpdateTransform
     */
    readonly transform?: Transform
}

/**
 * TransformsApi - object-oriented interface
 * @export
 * @class TransformsApi
 * @extends {BaseAPI}
 */
export class TransformsApi extends BaseAPI {
    /**
     * Creates a new transform object immediately. By default, the internal flag is set to false to indicate that this is a custom transform. Only SailPoint employees have the ability to create a transform with internal set to true. Newly created Transforms can be used in the Identity Profile mappings within the UI. A token with transform write authority is required to call this API.
     * @summary Create transform
     * @param {TransformsApiCreateTransformRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsApi
     */
    public createTransform(requestParameters: TransformsApiCreateTransformRequest, axiosOptions?: AxiosRequestConfig) {
        return TransformsApiFp(this.configuration).createTransform(requestParameters.transform, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the transform specified by the given ID. Attempting to delete a transform that is used in one or more Identity Profile mappings will result in an error. If this occurs, you must first remove the transform from all mappings before deleting the transform. A token with transform delete authority is required to call this API.
     * @summary Delete a transform
     * @param {TransformsApiDeleteTransformRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsApi
     */
    public deleteTransform(requestParameters: TransformsApiDeleteTransformRequest, axiosOptions?: AxiosRequestConfig) {
        return TransformsApiFp(this.configuration).deleteTransform(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the transform specified by the given ID. A token with transform read authority is required to call this API.
     * @summary Transform by ID
     * @param {TransformsApiGetTransformRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsApi
     */
    public getTransform(requestParameters: TransformsApiGetTransformRequest, axiosOptions?: AxiosRequestConfig) {
        return TransformsApiFp(this.configuration).getTransform(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of all saved transform objects. A token with transforms-list read authority is required to call this API.
     * @summary List transforms
     * @param {TransformsApiListTransformsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsApi
     */
    public listTransforms(requestParameters: TransformsApiListTransformsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return TransformsApiFp(this.configuration).listTransforms(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.name, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replaces the transform specified by the given ID with the transform provided in the request body. Only the \"attributes\" field is mutable. Attempting to change other properties (ex. \"name\" and \"type\") will result in an error. A token with transform write authority is required to call this API.
     * @summary Update a transform
     * @param {TransformsApiUpdateTransformRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsApi
     */
    public updateTransform(requestParameters: TransformsApiUpdateTransformRequest, axiosOptions?: AxiosRequestConfig) {
        return TransformsApiFp(this.configuration).updateTransform(requestParameters.id, requestParameters.transform, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkItemsApi - axios parameter creator
 * @export
 */
export const WorkItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API approves an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Approve an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveApprovalItem: async (id: string, approvalItemId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('approveApprovalItem', 'id', id)
            // verify required parameter 'approvalItemId' is not null or undefined
            assertParamExists('approveApprovalItem', 'approvalItemId', approvalItemId)
            const localVarPath = `/work-items/{id}/approve/{approvalItemId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"approvalItemId"}}`, encodeURIComponent(String(approvalItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API bulk approves Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk approve Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveApprovalItemsInBulk: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('approveApprovalItemsInBulk', 'id', id)
            const localVarPath = `/work-items/bulk-approve/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API completes a work item. Either an admin, or the owning/current user must make this request.
         * @summary Complete a Work Item
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        completeWorkItem: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('completeWorkItem', 'id', id)
            const localVarPath = `/work-items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a collection of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Completed Work Items
         * @param {string} [ownerId] The id of the owner of the work item list being requested.  Either an admin, or the owning/current user must make this request.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCompletedWorkItems: async (ownerId?: string, limit?: number, offset?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work-items/completed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a count of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Completed Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCountCompletedWorkItems: async (ownerId?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work-items/completed/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a count of work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCountWorkItems: async (ownerId?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work-items/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets the details of a Work Item belonging to either the specified user(admin required), or the current user.
         * @summary Get a Work Item
         * @param {string} id ID of the work item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItem: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWorkItem', 'id', id)
            const localVarPath = `/work-items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a summary of work items belonging to either the specified user(admin required), or the current user.
         * @summary Work Items Summary
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItemsSummary: async (ownerId?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work-items/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a collection of work items belonging to either the specified user(admin required), or the current user.
         * @summary List Work Items
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkItems: async (limit?: number, offset?: number, count?: boolean, ownerId?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work-items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API rejects an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Reject an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectApprovalItem: async (id: string, approvalItemId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rejectApprovalItem', 'id', id)
            // verify required parameter 'approvalItemId' is not null or undefined
            assertParamExists('rejectApprovalItem', 'approvalItemId', approvalItemId)
            const localVarPath = `/work-items/{id}/reject/{approvalItemId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"approvalItemId"}}`, encodeURIComponent(String(approvalItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API bulk rejects Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk reject Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectApprovalItemsInBulk: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rejectApprovalItemsInBulk', 'id', id)
            const localVarPath = `/work-items/bulk-reject/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits account selections. Either an admin, or the owning/current user must make this request.
         * @summary Submit Account Selections
         * @param {string} id The ID of the work item
         * @param {{ [key: string]: any; }} requestBody Account Selection Data map, keyed on fieldName
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        submitAccountSelection: async (id: string, requestBody: { [key: string]: any; }, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submitAccountSelection', 'id', id)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('submitAccountSelection', 'requestBody', requestBody)
            const localVarPath = `/work-items/{id}/submit-account-selection`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkItemsApi - functional programming interface
 * @export
 */
export const WorkItemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkItemsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API approves an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Approve an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async approveApprovalItem(id: string, approvalItemId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveApprovalItem(id, approvalItemId, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WorkItemsApi.approveApprovalItem']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API bulk approves Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk approve Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async approveApprovalItemsInBulk(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveApprovalItemsInBulk(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WorkItemsApi.approveApprovalItemsInBulk']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API completes a work item. Either an admin, or the owning/current user must make this request.
         * @summary Complete a Work Item
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async completeWorkItem(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeWorkItem(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WorkItemsApi.completeWorkItem']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This gets a collection of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Completed Work Items
         * @param {string} [ownerId] The id of the owner of the work item list being requested.  Either an admin, or the owning/current user must make this request.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCompletedWorkItems(ownerId?: string, limit?: number, offset?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkItems>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompletedWorkItems(ownerId, limit, offset, count, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WorkItemsApi.getCompletedWorkItems']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This gets a count of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Completed Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCountCompletedWorkItems(ownerId?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItemsCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCountCompletedWorkItems(ownerId, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WorkItemsApi.getCountCompletedWorkItems']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This gets a count of work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCountWorkItems(ownerId?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItemsCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCountWorkItems(ownerId, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WorkItemsApi.getCountWorkItems']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This gets the details of a Work Item belonging to either the specified user(admin required), or the current user.
         * @summary Get a Work Item
         * @param {string} id ID of the work item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkItem(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkItem(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WorkItemsApi.getWorkItem']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This gets a summary of work items belonging to either the specified user(admin required), or the current user.
         * @summary Work Items Summary
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkItemsSummary(ownerId?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItemsSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkItemsSummary(ownerId, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WorkItemsApi.getWorkItemsSummary']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This gets a collection of work items belonging to either the specified user(admin required), or the current user.
         * @summary List Work Items
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkItems(limit?: number, offset?: number, count?: boolean, ownerId?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkItems>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkItems(limit, offset, count, ownerId, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WorkItemsApi.listWorkItems']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API rejects an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Reject an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async rejectApprovalItem(id: string, approvalItemId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectApprovalItem(id, approvalItemId, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WorkItemsApi.rejectApprovalItem']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API bulk rejects Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk reject Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async rejectApprovalItemsInBulk(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectApprovalItemsInBulk(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WorkItemsApi.rejectApprovalItemsInBulk']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This API submits account selections. Either an admin, or the owning/current user must make this request.
         * @summary Submit Account Selections
         * @param {string} id The ID of the work item
         * @param {{ [key: string]: any; }} requestBody Account Selection Data map, keyed on fieldName
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async submitAccountSelection(id: string, requestBody: { [key: string]: any; }, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitAccountSelection(id, requestBody, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WorkItemsApi.submitAccountSelection']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * WorkItemsApi - factory interface
 * @export
 */
export const WorkItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkItemsApiFp(configuration)
    return {
        /**
         * This API approves an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Approve an Approval Item
         * @param {WorkItemsApiApproveApprovalItemRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        approveApprovalItem(requestParameters: WorkItemsApiApproveApprovalItemRequest, options?: AxiosRequestConfig): AxiosPromise<WorkItems> {
            return localVarFp.approveApprovalItem(requestParameters.id, requestParameters.approvalItemId, options).then((request) => request(axios, basePath));
        },
        /**
         * This API bulk approves Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk approve Approval Items
         * @param {WorkItemsApiApproveApprovalItemsInBulkRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        approveApprovalItemsInBulk(requestParameters: WorkItemsApiApproveApprovalItemsInBulkRequest, options?: AxiosRequestConfig): AxiosPromise<WorkItems> {
            return localVarFp.approveApprovalItemsInBulk(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This API completes a work item. Either an admin, or the owning/current user must make this request.
         * @summary Complete a Work Item
         * @param {WorkItemsApiCompleteWorkItemRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        completeWorkItem(requestParameters: WorkItemsApiCompleteWorkItemRequest, options?: AxiosRequestConfig): AxiosPromise<WorkItems> {
            return localVarFp.completeWorkItem(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This gets a collection of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Completed Work Items
         * @param {WorkItemsApiGetCompletedWorkItemsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getCompletedWorkItems(requestParameters: WorkItemsApiGetCompletedWorkItemsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<WorkItems>> {
            return localVarFp.getCompletedWorkItems(requestParameters.ownerId, requestParameters.limit, requestParameters.offset, requestParameters.count, options).then((request) => request(axios, basePath));
        },
        /**
         * This gets a count of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Completed Work Items
         * @param {WorkItemsApiGetCountCompletedWorkItemsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getCountCompletedWorkItems(requestParameters: WorkItemsApiGetCountCompletedWorkItemsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<WorkItemsCount> {
            return localVarFp.getCountCompletedWorkItems(requestParameters.ownerId, options).then((request) => request(axios, basePath));
        },
        /**
         * This gets a count of work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Work Items
         * @param {WorkItemsApiGetCountWorkItemsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getCountWorkItems(requestParameters: WorkItemsApiGetCountWorkItemsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<WorkItemsCount> {
            return localVarFp.getCountWorkItems(requestParameters.ownerId, options).then((request) => request(axios, basePath));
        },
        /**
         * This gets the details of a Work Item belonging to either the specified user(admin required), or the current user.
         * @summary Get a Work Item
         * @param {WorkItemsApiGetWorkItemRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getWorkItem(requestParameters: WorkItemsApiGetWorkItemRequest, options?: AxiosRequestConfig): AxiosPromise<WorkItems> {
            return localVarFp.getWorkItem(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This gets a summary of work items belonging to either the specified user(admin required), or the current user.
         * @summary Work Items Summary
         * @param {WorkItemsApiGetWorkItemsSummaryRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getWorkItemsSummary(requestParameters: WorkItemsApiGetWorkItemsSummaryRequest = {}, options?: AxiosRequestConfig): AxiosPromise<WorkItemsSummary> {
            return localVarFp.getWorkItemsSummary(requestParameters.ownerId, options).then((request) => request(axios, basePath));
        },
        /**
         * This gets a collection of work items belonging to either the specified user(admin required), or the current user.
         * @summary List Work Items
         * @param {WorkItemsApiListWorkItemsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listWorkItems(requestParameters: WorkItemsApiListWorkItemsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<WorkItems>> {
            return localVarFp.listWorkItems(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.ownerId, options).then((request) => request(axios, basePath));
        },
        /**
         * This API rejects an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Reject an Approval Item
         * @param {WorkItemsApiRejectApprovalItemRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        rejectApprovalItem(requestParameters: WorkItemsApiRejectApprovalItemRequest, options?: AxiosRequestConfig): AxiosPromise<WorkItems> {
            return localVarFp.rejectApprovalItem(requestParameters.id, requestParameters.approvalItemId, options).then((request) => request(axios, basePath));
        },
        /**
         * This API bulk rejects Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk reject Approval Items
         * @param {WorkItemsApiRejectApprovalItemsInBulkRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        rejectApprovalItemsInBulk(requestParameters: WorkItemsApiRejectApprovalItemsInBulkRequest, options?: AxiosRequestConfig): AxiosPromise<WorkItems> {
            return localVarFp.rejectApprovalItemsInBulk(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This API submits account selections. Either an admin, or the owning/current user must make this request.
         * @summary Submit Account Selections
         * @param {WorkItemsApiSubmitAccountSelectionRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        submitAccountSelection(requestParameters: WorkItemsApiSubmitAccountSelectionRequest, options?: AxiosRequestConfig): AxiosPromise<WorkItems> {
            return localVarFp.submitAccountSelection(requestParameters.id, requestParameters.requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for approveApprovalItem operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiApproveApprovalItemRequest
 */
export interface WorkItemsApiApproveApprovalItemRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsApiApproveApprovalItem
     */
    readonly id: string

    /**
     * The ID of the approval item.
     * @type {string}
     * @memberof WorkItemsApiApproveApprovalItem
     */
    readonly approvalItemId: string
}

/**
 * Request parameters for approveApprovalItemsInBulk operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiApproveApprovalItemsInBulkRequest
 */
export interface WorkItemsApiApproveApprovalItemsInBulkRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsApiApproveApprovalItemsInBulk
     */
    readonly id: string
}

/**
 * Request parameters for completeWorkItem operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiCompleteWorkItemRequest
 */
export interface WorkItemsApiCompleteWorkItemRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsApiCompleteWorkItem
     */
    readonly id: string
}

/**
 * Request parameters for getCompletedWorkItems operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiGetCompletedWorkItemsRequest
 */
export interface WorkItemsApiGetCompletedWorkItemsRequest {
    /**
     * The id of the owner of the work item list being requested.  Either an admin, or the owning/current user must make this request.
     * @type {string}
     * @memberof WorkItemsApiGetCompletedWorkItems
     */
    readonly ownerId?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkItemsApiGetCompletedWorkItems
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkItemsApiGetCompletedWorkItems
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof WorkItemsApiGetCompletedWorkItems
     */
    readonly count?: boolean
}

/**
 * Request parameters for getCountCompletedWorkItems operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiGetCountCompletedWorkItemsRequest
 */
export interface WorkItemsApiGetCountCompletedWorkItemsRequest {
    /**
     * ID of the work item owner.
     * @type {string}
     * @memberof WorkItemsApiGetCountCompletedWorkItems
     */
    readonly ownerId?: string
}

/**
 * Request parameters for getCountWorkItems operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiGetCountWorkItemsRequest
 */
export interface WorkItemsApiGetCountWorkItemsRequest {
    /**
     * ID of the work item owner.
     * @type {string}
     * @memberof WorkItemsApiGetCountWorkItems
     */
    readonly ownerId?: string
}

/**
 * Request parameters for getWorkItem operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiGetWorkItemRequest
 */
export interface WorkItemsApiGetWorkItemRequest {
    /**
     * ID of the work item.
     * @type {string}
     * @memberof WorkItemsApiGetWorkItem
     */
    readonly id: string
}

/**
 * Request parameters for getWorkItemsSummary operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiGetWorkItemsSummaryRequest
 */
export interface WorkItemsApiGetWorkItemsSummaryRequest {
    /**
     * ID of the work item owner.
     * @type {string}
     * @memberof WorkItemsApiGetWorkItemsSummary
     */
    readonly ownerId?: string
}

/**
 * Request parameters for listWorkItems operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiListWorkItemsRequest
 */
export interface WorkItemsApiListWorkItemsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkItemsApiListWorkItems
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkItemsApiListWorkItems
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof WorkItemsApiListWorkItems
     */
    readonly count?: boolean

    /**
     * ID of the work item owner.
     * @type {string}
     * @memberof WorkItemsApiListWorkItems
     */
    readonly ownerId?: string
}

/**
 * Request parameters for rejectApprovalItem operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiRejectApprovalItemRequest
 */
export interface WorkItemsApiRejectApprovalItemRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsApiRejectApprovalItem
     */
    readonly id: string

    /**
     * The ID of the approval item.
     * @type {string}
     * @memberof WorkItemsApiRejectApprovalItem
     */
    readonly approvalItemId: string
}

/**
 * Request parameters for rejectApprovalItemsInBulk operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiRejectApprovalItemsInBulkRequest
 */
export interface WorkItemsApiRejectApprovalItemsInBulkRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsApiRejectApprovalItemsInBulk
     */
    readonly id: string
}

/**
 * Request parameters for submitAccountSelection operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiSubmitAccountSelectionRequest
 */
export interface WorkItemsApiSubmitAccountSelectionRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsApiSubmitAccountSelection
     */
    readonly id: string

    /**
     * Account Selection Data map, keyed on fieldName
     * @type {{ [key: string]: any; }}
     * @memberof WorkItemsApiSubmitAccountSelection
     */
    readonly requestBody: { [key: string]: any; }
}

/**
 * WorkItemsApi - object-oriented interface
 * @export
 * @class WorkItemsApi
 * @extends {BaseAPI}
 */
export class WorkItemsApi extends BaseAPI {
    /**
     * This API approves an Approval Item. Either an admin, or the owning/current user must make this request.
     * @summary Approve an Approval Item
     * @param {WorkItemsApiApproveApprovalItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public approveApprovalItem(requestParameters: WorkItemsApiApproveApprovalItemRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).approveApprovalItem(requestParameters.id, requestParameters.approvalItemId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API bulk approves Approval Items. Either an admin, or the owning/current user must make this request.
     * @summary Bulk approve Approval Items
     * @param {WorkItemsApiApproveApprovalItemsInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public approveApprovalItemsInBulk(requestParameters: WorkItemsApiApproveApprovalItemsInBulkRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).approveApprovalItemsInBulk(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API completes a work item. Either an admin, or the owning/current user must make this request.
     * @summary Complete a Work Item
     * @param {WorkItemsApiCompleteWorkItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public completeWorkItem(requestParameters: WorkItemsApiCompleteWorkItemRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).completeWorkItem(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a collection of completed work items belonging to either the specified user(admin required), or the current user.
     * @summary Completed Work Items
     * @param {WorkItemsApiGetCompletedWorkItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public getCompletedWorkItems(requestParameters: WorkItemsApiGetCompletedWorkItemsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).getCompletedWorkItems(requestParameters.ownerId, requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a count of completed work items belonging to either the specified user(admin required), or the current user.
     * @summary Count Completed Work Items
     * @param {WorkItemsApiGetCountCompletedWorkItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public getCountCompletedWorkItems(requestParameters: WorkItemsApiGetCountCompletedWorkItemsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).getCountCompletedWorkItems(requestParameters.ownerId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a count of work items belonging to either the specified user(admin required), or the current user.
     * @summary Count Work Items
     * @param {WorkItemsApiGetCountWorkItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public getCountWorkItems(requestParameters: WorkItemsApiGetCountWorkItemsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).getCountWorkItems(requestParameters.ownerId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets the details of a Work Item belonging to either the specified user(admin required), or the current user.
     * @summary Get a Work Item
     * @param {WorkItemsApiGetWorkItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public getWorkItem(requestParameters: WorkItemsApiGetWorkItemRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).getWorkItem(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a summary of work items belonging to either the specified user(admin required), or the current user.
     * @summary Work Items Summary
     * @param {WorkItemsApiGetWorkItemsSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public getWorkItemsSummary(requestParameters: WorkItemsApiGetWorkItemsSummaryRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).getWorkItemsSummary(requestParameters.ownerId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a collection of work items belonging to either the specified user(admin required), or the current user.
     * @summary List Work Items
     * @param {WorkItemsApiListWorkItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public listWorkItems(requestParameters: WorkItemsApiListWorkItemsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).listWorkItems(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.ownerId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API rejects an Approval Item. Either an admin, or the owning/current user must make this request.
     * @summary Reject an Approval Item
     * @param {WorkItemsApiRejectApprovalItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public rejectApprovalItem(requestParameters: WorkItemsApiRejectApprovalItemRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).rejectApprovalItem(requestParameters.id, requestParameters.approvalItemId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API bulk rejects Approval Items. Either an admin, or the owning/current user must make this request.
     * @summary Bulk reject Approval Items
     * @param {WorkItemsApiRejectApprovalItemsInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public rejectApprovalItemsInBulk(requestParameters: WorkItemsApiRejectApprovalItemsInBulkRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).rejectApprovalItemsInBulk(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits account selections. Either an admin, or the owning/current user must make this request.
     * @summary Submit Account Selections
     * @param {WorkItemsApiSubmitAccountSelectionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public submitAccountSelection(requestParameters: WorkItemsApiSubmitAccountSelectionRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).submitAccountSelection(requestParameters.id, requestParameters.requestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



