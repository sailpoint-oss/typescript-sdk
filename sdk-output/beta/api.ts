/* tslint:disable */
/* eslint-disable */
/**
 * IdentityNow Beta API
 * Use these APIs to interact with the IdentityNow platform to achieve repeatable, automated processes with greater scalability. These APIs are in beta and are subject to change. We encourage you to join the SailPoint Developer Community forum at https://developer.sailpoint.com/discuss to connect with other developers using our APIs.
 *
 * The version of the OpenAPI document: 3.1.0-beta
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from '../configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccessConstraintBeta
 */
export interface AccessConstraintBeta {
    /**
     * Type of Access
     * @type {string}
     * @memberof AccessConstraintBeta
     */
    'type': AccessConstraintBetaTypeEnum;
    /**
     * Must be set only if operator is SELECTED.
     * @type {Array<string>}
     * @memberof AccessConstraintBeta
     */
    'ids'?: Array<string>;
    /**
     * Used to determine whether the scope of the campaign should be reduced for selected ids or all.
     * @type {string}
     * @memberof AccessConstraintBeta
     */
    'operator': AccessConstraintBetaOperatorEnum;
}

export const AccessConstraintBetaTypeEnum = {
    Entitlement: 'ENTITLEMENT',
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE'
} as const;

export type AccessConstraintBetaTypeEnum = typeof AccessConstraintBetaTypeEnum[keyof typeof AccessConstraintBetaTypeEnum];
export const AccessConstraintBetaOperatorEnum = {
    All: 'ALL',
    Selected: 'SELECTED'
} as const;

export type AccessConstraintBetaOperatorEnum = typeof AccessConstraintBetaOperatorEnum[keyof typeof AccessConstraintBetaOperatorEnum];

/**
 * 
 * @export
 * @interface AccessCriteriaBeta
 */
export interface AccessCriteriaBeta {
    /**
     * Business name for the access construct list
     * @type {string}
     * @memberof AccessCriteriaBeta
     */
    'name'?: string;
    /**
     * List of criteria.  There is a min of 1 and max of 50 items in the list.
     * @type {Array<AccessCriteriaCriteriaListInnerBeta>}
     * @memberof AccessCriteriaBeta
     */
    'criteriaList'?: Array<AccessCriteriaCriteriaListInnerBeta>;
}
/**
 * 
 * @export
 * @interface AccessCriteriaCriteriaListInnerBeta
 */
export interface AccessCriteriaCriteriaListInnerBeta {
    /**
     * DTO type
     * @type {string}
     * @memberof AccessCriteriaCriteriaListInnerBeta
     */
    'type'?: AccessCriteriaCriteriaListInnerBetaTypeEnum;
    /**
     * ID of the object to which this reference applies to
     * @type {string}
     * @memberof AccessCriteriaCriteriaListInnerBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies to
     * @type {string}
     * @memberof AccessCriteriaCriteriaListInnerBeta
     */
    'name'?: string;
}

export const AccessCriteriaCriteriaListInnerBetaTypeEnum = {
    Entitlement: 'ENTITLEMENT'
} as const;

export type AccessCriteriaCriteriaListInnerBetaTypeEnum = typeof AccessCriteriaCriteriaListInnerBetaTypeEnum[keyof typeof AccessCriteriaCriteriaListInnerBetaTypeEnum];

/**
 * 
 * @export
 * @interface AccessItemAccessProfileResponseBeta
 */
export interface AccessItemAccessProfileResponseBeta {
    /**
     * the access item type. accessProfile in this case
     * @type {string}
     * @memberof AccessItemAccessProfileResponseBeta
     */
    'accessType'?: string;
    /**
     * the access item id
     * @type {string}
     * @memberof AccessItemAccessProfileResponseBeta
     */
    'id'?: string;
    /**
     * the access profile name
     * @type {string}
     * @memberof AccessItemAccessProfileResponseBeta
     */
    'name'?: string;
    /**
     * the name of the source
     * @type {string}
     * @memberof AccessItemAccessProfileResponseBeta
     */
    'sourceName'?: string;
    /**
     * the id of the source
     * @type {string}
     * @memberof AccessItemAccessProfileResponseBeta
     */
    'sourceId'?: string;
    /**
     * the description for the access profile
     * @type {string}
     * @memberof AccessItemAccessProfileResponseBeta
     */
    'description'?: string;
    /**
     * the display name of the identity
     * @type {string}
     * @memberof AccessItemAccessProfileResponseBeta
     */
    'displayName'?: string;
    /**
     * the number of entitlements the access profile will create
     * @type {string}
     * @memberof AccessItemAccessProfileResponseBeta
     */
    'entitlementCount'?: string;
    /**
     * the name of app
     * @type {string}
     * @memberof AccessItemAccessProfileResponseBeta
     */
    'appDisplayName'?: string;
}
/**
 * 
 * @export
 * @interface AccessItemAccountResponseBeta
 */
export interface AccessItemAccountResponseBeta {
    /**
     * the access item type. account in this case
     * @type {string}
     * @memberof AccessItemAccountResponseBeta
     */
    'accessType'?: string;
    /**
     * the access item id
     * @type {string}
     * @memberof AccessItemAccountResponseBeta
     */
    'id'?: string;
    /**
     * the native identifier used to uniquely identify an acccount
     * @type {string}
     * @memberof AccessItemAccountResponseBeta
     */
    'nativeIdentity'?: string;
    /**
     * the name of the source
     * @type {string}
     * @memberof AccessItemAccountResponseBeta
     */
    'sourceName'?: string;
    /**
     * the id of the source
     * @type {string}
     * @memberof AccessItemAccountResponseBeta
     */
    'sourceId'?: string;
    /**
     * the number of entitlements the account will create
     * @type {string}
     * @memberof AccessItemAccountResponseBeta
     */
    'entitlementCount'?: string;
    /**
     * the display name of the identity
     * @type {string}
     * @memberof AccessItemAccountResponseBeta
     */
    'displayName'?: string;
}
/**
 * 
 * @export
 * @interface AccessItemAppResponseBeta
 */
export interface AccessItemAppResponseBeta {
    /**
     * the access item type. entitlement in this case
     * @type {string}
     * @memberof AccessItemAppResponseBeta
     */
    'accessType'?: string;
    /**
     * the access item id
     * @type {string}
     * @memberof AccessItemAppResponseBeta
     */
    'id'?: string;
    /**
     * the access profile display name
     * @type {string}
     * @memberof AccessItemAppResponseBeta
     */
    'displayName'?: string;
    /**
     * the associated source name if it exists
     * @type {string}
     * @memberof AccessItemAppResponseBeta
     */
    'sourceName'?: string;
}
/**
 * @type AccessItemAssociatedAccessItemBeta
 * @export
 */
export type AccessItemAssociatedAccessItemBeta = AccessItemAccessProfileResponseBeta | AccessItemAccountResponseBeta | AccessItemAppResponseBeta | AccessItemEntitlementResponseBeta | AccessItemRoleResponseBeta;

/**
 * 
 * @export
 * @interface AccessItemAssociatedBeta
 */
export interface AccessItemAssociatedBeta {
    /**
     * 
     * @type {AccessItemAssociatedAccessItemBeta}
     * @memberof AccessItemAssociatedBeta
     */
    'accessItem'?: AccessItemAssociatedAccessItemBeta;
    /**
     * the identity id
     * @type {string}
     * @memberof AccessItemAssociatedBeta
     */
    'identityId'?: string;
    /**
     * the event type
     * @type {string}
     * @memberof AccessItemAssociatedBeta
     */
    'eventType'?: string;
    /**
     * the date of event
     * @type {string}
     * @memberof AccessItemAssociatedBeta
     */
    'dt'?: string;
    /**
     * 
     * @type {CorrelatedGovernanceEventBeta}
     * @memberof AccessItemAssociatedBeta
     */
    'governanceEvent'?: CorrelatedGovernanceEventBeta;
}
/**
 * 
 * @export
 * @interface AccessItemDiffBeta
 */
export interface AccessItemDiffBeta {
    /**
     * the id of the access item
     * @type {string}
     * @memberof AccessItemDiffBeta
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessItemDiffBeta
     */
    'eventType'?: AccessItemDiffBetaEventTypeEnum;
    /**
     * the display name of the access item
     * @type {string}
     * @memberof AccessItemDiffBeta
     */
    'displayName'?: string;
    /**
     * the source name of the access item
     * @type {string}
     * @memberof AccessItemDiffBeta
     */
    'sourceName'?: string;
}

export const AccessItemDiffBetaEventTypeEnum = {
    Add: 'ADD',
    Remove: 'REMOVE'
} as const;

export type AccessItemDiffBetaEventTypeEnum = typeof AccessItemDiffBetaEventTypeEnum[keyof typeof AccessItemDiffBetaEventTypeEnum];

/**
 * 
 * @export
 * @interface AccessItemEntitlementResponseBeta
 */
export interface AccessItemEntitlementResponseBeta {
    /**
     * the access item type. entitlement in this case
     * @type {string}
     * @memberof AccessItemEntitlementResponseBeta
     */
    'accessType'?: string;
    /**
     * the access item id
     * @type {string}
     * @memberof AccessItemEntitlementResponseBeta
     */
    'id'?: string;
    /**
     * the entitlement attribute
     * @type {string}
     * @memberof AccessItemEntitlementResponseBeta
     */
    'attribute'?: string;
    /**
     * the associated value
     * @type {string}
     * @memberof AccessItemEntitlementResponseBeta
     */
    'value'?: string;
    /**
     * the type of entitlement
     * @type {string}
     * @memberof AccessItemEntitlementResponseBeta
     */
    'entitlementType'?: string;
    /**
     * the name of the source
     * @type {string}
     * @memberof AccessItemEntitlementResponseBeta
     */
    'sourceName'?: string;
    /**
     * the id of the source
     * @type {string}
     * @memberof AccessItemEntitlementResponseBeta
     */
    'sourceId'?: string;
    /**
     * the description for the entitlment
     * @type {string}
     * @memberof AccessItemEntitlementResponseBeta
     */
    'description'?: string;
    /**
     * the display name of the identity
     * @type {string}
     * @memberof AccessItemEntitlementResponseBeta
     */
    'displayName'?: string;
}
/**
 * 
 * @export
 * @interface AccessItemRefBeta
 */
export interface AccessItemRefBeta {
    /**
     * The ID of the access item for which to retrieve the recommendation
     * @type {string}
     * @memberof AccessItemRefBeta
     */
    'id'?: string;
    /**
     * The type of the access item.
     * @type {string}
     * @memberof AccessItemRefBeta
     */
    'type'?: AccessItemRefBetaTypeEnum;
}

export const AccessItemRefBetaTypeEnum = {
    Entitlement: 'ENTITLEMENT',
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE'
} as const;

export type AccessItemRefBetaTypeEnum = typeof AccessItemRefBetaTypeEnum[keyof typeof AccessItemRefBetaTypeEnum];

/**
 * 
 * @export
 * @interface AccessItemRemovedBeta
 */
export interface AccessItemRemovedBeta {
    /**
     * 
     * @type {AccessItemAssociatedAccessItemBeta}
     * @memberof AccessItemRemovedBeta
     */
    'accessItem'?: AccessItemAssociatedAccessItemBeta;
    /**
     * the identity id
     * @type {string}
     * @memberof AccessItemRemovedBeta
     */
    'identityId'?: string;
    /**
     * the event type
     * @type {string}
     * @memberof AccessItemRemovedBeta
     */
    'eventType'?: string;
    /**
     * the date of event
     * @type {string}
     * @memberof AccessItemRemovedBeta
     */
    'dt'?: string;
    /**
     * 
     * @type {CorrelatedGovernanceEventBeta}
     * @memberof AccessItemRemovedBeta
     */
    'governanceEvent'?: CorrelatedGovernanceEventBeta;
}
/**
 * 
 * @export
 * @interface AccessItemRoleResponseBeta
 */
export interface AccessItemRoleResponseBeta {
    /**
     * the access item type. role in this case
     * @type {string}
     * @memberof AccessItemRoleResponseBeta
     */
    'accessType'?: string;
    /**
     * the access item id
     * @type {string}
     * @memberof AccessItemRoleResponseBeta
     */
    'id'?: string;
    /**
     * the role display name
     * @type {string}
     * @memberof AccessItemRoleResponseBeta
     */
    'displayName'?: string;
    /**
     * the description for the role
     * @type {string}
     * @memberof AccessItemRoleResponseBeta
     */
    'description'?: string;
    /**
     * the associated source name if it exists
     * @type {string}
     * @memberof AccessItemRoleResponseBeta
     */
    'sourceName'?: string;
}
/**
 * 
 * @export
 * @interface AccessProfileApprovalSchemeBeta
 */
export interface AccessProfileApprovalSchemeBeta {
    /**
     * Describes the individual or group that is responsible for an approval step. Values are as follows. **APP_OWNER**: The owner of the Application  **OWNER**: Owner of the associated Access Profile or Role  **SOURCE_OWNER**: Owner of the Source associated with an Access Profile  **MANAGER**: Manager of the Identity making the request  **GOVERNANCE_GROUP**: A Governance Group, the ID of which is specified by the **approverId** field
     * @type {string}
     * @memberof AccessProfileApprovalSchemeBeta
     */
    'approverType'?: AccessProfileApprovalSchemeBetaApproverTypeEnum;
    /**
     * Id of the specific approver, used only when approverType is GOVERNANCE_GROUP
     * @type {string}
     * @memberof AccessProfileApprovalSchemeBeta
     */
    'approverId'?: string | null;
}

export const AccessProfileApprovalSchemeBetaApproverTypeEnum = {
    AppOwner: 'APP_OWNER',
    Owner: 'OWNER',
    SourceOwner: 'SOURCE_OWNER',
    Manager: 'MANAGER',
    GovernanceGroup: 'GOVERNANCE_GROUP'
} as const;

export type AccessProfileApprovalSchemeBetaApproverTypeEnum = typeof AccessProfileApprovalSchemeBetaApproverTypeEnum[keyof typeof AccessProfileApprovalSchemeBetaApproverTypeEnum];

/**
 * 
 * @export
 * @interface AccessProfileBeta
 */
export interface AccessProfileBeta {
    /**
     * The ID of the Access Profile
     * @type {string}
     * @memberof AccessProfileBeta
     */
    'id'?: string;
    /**
     * Name of the Access Profile
     * @type {string}
     * @memberof AccessProfileBeta
     */
    'name': string;
    /**
     * Information about the Access Profile
     * @type {string}
     * @memberof AccessProfileBeta
     */
    'description'?: string | null;
    /**
     * Date the Access Profile was created
     * @type {string}
     * @memberof AccessProfileBeta
     */
    'created'?: string;
    /**
     * Date the Access Profile was last modified.
     * @type {string}
     * @memberof AccessProfileBeta
     */
    'modified'?: string;
    /**
     * Whether the Access Profile is enabled. If the Access Profile is enabled then you must include at least one Entitlement.
     * @type {boolean}
     * @memberof AccessProfileBeta
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {OwnerReferenceBeta}
     * @memberof AccessProfileBeta
     */
    'owner': OwnerReferenceBeta | null;
    /**
     * 
     * @type {AccessProfileSourceRefBeta}
     * @memberof AccessProfileBeta
     */
    'source': AccessProfileSourceRefBeta;
    /**
     * A list of entitlements associated with the Access Profile. If enabled is false this is allowed to be empty otherwise it needs to contain at least one Entitlement.
     * @type {Array<EntitlementRefBeta>}
     * @memberof AccessProfileBeta
     */
    'entitlements'?: Array<EntitlementRefBeta>;
    /**
     * Whether the Access Profile is requestable via access request. Currently, making an Access Profile non-requestable is only supported  for customers enabled with the new Request Center. Otherwise, attempting to create an Access Profile with a value  **false** in this field results in a 400 error.
     * @type {boolean}
     * @memberof AccessProfileBeta
     */
    'requestable'?: boolean;
    /**
     * 
     * @type {RequestabilityBeta}
     * @memberof AccessProfileBeta
     */
    'accessRequestConfig'?: RequestabilityBeta;
    /**
     * 
     * @type {RevocabilityBeta}
     * @memberof AccessProfileBeta
     */
    'revocationRequestConfig'?: RevocabilityBeta;
    /**
     * List of IDs of segments, if any, to which this Access Profile is assigned.
     * @type {Array<string>}
     * @memberof AccessProfileBeta
     */
    'segments'?: Array<string> | null;
    /**
     * 
     * @type {ProvisioningCriteriaLevel1Beta}
     * @memberof AccessProfileBeta
     */
    'provisioningCriteria'?: ProvisioningCriteriaLevel1Beta | null;
}
/**
 * 
 * @export
 * @interface AccessProfileBulkDeleteRequestBeta
 */
export interface AccessProfileBulkDeleteRequestBeta {
    /**
     * List of IDs of Access Profiles to be deleted.
     * @type {Array<string>}
     * @memberof AccessProfileBulkDeleteRequestBeta
     */
    'accessProfileIds'?: Array<string>;
    /**
     * If **true**, silently skip over any of the specified Access Profiles if they cannot be deleted because they are in use. If **false**, no deletions will be attempted if any of the Access Profiles are in use.
     * @type {boolean}
     * @memberof AccessProfileBulkDeleteRequestBeta
     */
    'bestEffortOnly'?: boolean;
}
/**
 * 
 * @export
 * @interface AccessProfileBulkDeleteResponseBeta
 */
export interface AccessProfileBulkDeleteResponseBeta {
    /**
     * ID of the task which is executing the bulk deletion. This can be passed to the **_/task-status** API to track status.
     * @type {string}
     * @memberof AccessProfileBulkDeleteResponseBeta
     */
    'taskId'?: string;
    /**
     * List of IDs of Access Profiles which are pending deletion.
     * @type {Array<string>}
     * @memberof AccessProfileBulkDeleteResponseBeta
     */
    'pending'?: Array<string>;
    /**
     * List of usages of Access Profiles targeted for deletion.
     * @type {Array<AccessProfileUsageBeta>}
     * @memberof AccessProfileBulkDeleteResponseBeta
     */
    'inUse'?: Array<AccessProfileUsageBeta>;
}
/**
 * 
 * @export
 * @interface AccessProfileRefBeta
 */
export interface AccessProfileRefBeta {
    /**
     * ID of the Access Profile
     * @type {string}
     * @memberof AccessProfileRefBeta
     */
    'id'?: string;
    /**
     * Type of requested object. This field must be either left null or set to \'ACCESS_PROFILE\' when creating an Access Profile, otherwise a 400 Bad Request error will result.
     * @type {string}
     * @memberof AccessProfileRefBeta
     */
    'type'?: AccessProfileRefBetaTypeEnum;
    /**
     * Human-readable display name of the Access Profile. This field is ignored on input.
     * @type {string}
     * @memberof AccessProfileRefBeta
     */
    'name'?: string;
}

export const AccessProfileRefBetaTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE'
} as const;

export type AccessProfileRefBetaTypeEnum = typeof AccessProfileRefBetaTypeEnum[keyof typeof AccessProfileRefBetaTypeEnum];

/**
 * 
 * @export
 * @interface AccessProfileSourceRefBeta
 */
export interface AccessProfileSourceRefBeta {
    /**
     * The ID of the Source with with which the Access Profile is associated
     * @type {string}
     * @memberof AccessProfileSourceRefBeta
     */
    'id'?: string;
    /**
     * The type of the Source, will always be SOURCE
     * @type {string}
     * @memberof AccessProfileSourceRefBeta
     */
    'type'?: AccessProfileSourceRefBetaTypeEnum;
    /**
     * The display name of the associated Source
     * @type {string}
     * @memberof AccessProfileSourceRefBeta
     */
    'name'?: string;
}

export const AccessProfileSourceRefBetaTypeEnum = {
    Source: 'SOURCE'
} as const;

export type AccessProfileSourceRefBetaTypeEnum = typeof AccessProfileSourceRefBetaTypeEnum[keyof typeof AccessProfileSourceRefBetaTypeEnum];

/**
 * 
 * @export
 * @interface AccessProfileUsageBeta
 */
export interface AccessProfileUsageBeta {
    /**
     * ID of the Access Profile that is in use
     * @type {string}
     * @memberof AccessProfileUsageBeta
     */
    'accessProfileId'?: string;
    /**
     * List of references to objects which are using the indicated Access Profile
     * @type {Array<BaseReferenceDto1Beta>}
     * @memberof AccessProfileUsageBeta
     */
    'usedBy'?: Array<BaseReferenceDto1Beta>;
}
/**
 * 
 * @export
 * @interface AccessRecommendationMessageBeta
 */
export interface AccessRecommendationMessageBeta {
    /**
     * Information about why the access item was recommended.
     * @type {string}
     * @memberof AccessRecommendationMessageBeta
     */
    'interpretation'?: string;
}
/**
 * 
 * @export
 * @interface AccessRequestBeta
 */
export interface AccessRequestBeta {
    /**
     * A list of Identity IDs for whom the Access is requested. If it\'s a Revoke request, there can only be one Identity ID.
     * @type {Array<string>}
     * @memberof AccessRequestBeta
     */
    'requestedFor': Array<string>;
    /**
     * 
     * @type {AccessRequestTypeBeta}
     * @memberof AccessRequestBeta
     */
    'requestType'?: AccessRequestTypeBeta;
    /**
     * 
     * @type {Array<AccessRequestItemBeta>}
     * @memberof AccessRequestBeta
     */
    'requestedItems': Array<AccessRequestItemBeta>;
    /**
     * Arbitrary key-value pairs. They will never be processed by the IdentityNow system but will be returned on associated APIs such as /account-activities.
     * @type {{ [key: string]: string; }}
     * @memberof AccessRequestBeta
     */
    'clientMetadata'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface AccessRequestConfigBeta
 */
export interface AccessRequestConfigBeta {
    /**
     * If true, then approvals must be processed by external system.
     * @type {boolean}
     * @memberof AccessRequestConfigBeta
     */
    'approvalsMustBeExternal'?: boolean;
    /**
     * If true and requester and reviewer are the same, then automatically approve the approval.
     * @type {boolean}
     * @memberof AccessRequestConfigBeta
     */
    'autoApprovalEnabled'?: boolean;
    /**
     * 
     * @type {RequestOnBehalfOfConfigBeta}
     * @memberof AccessRequestConfigBeta
     */
    'requestOnBehalfOfConfig'?: RequestOnBehalfOfConfigBeta;
    /**
     * 
     * @type {ApprovalReminderAndEscalationConfigBeta}
     * @memberof AccessRequestConfigBeta
     */
    'approvalReminderAndEscalationConfig'?: ApprovalReminderAndEscalationConfigBeta;
    /**
     * 
     * @type {EntitlementRequestConfig1Beta}
     * @memberof AccessRequestConfigBeta
     */
    'entitlementRequestConfig'?: EntitlementRequestConfig1Beta;
}
/**
 * 
 * @export
 * @interface AccessRequestDynamicApprover1Beta
 */
export interface AccessRequestDynamicApprover1Beta {
    /**
     * The unique ID of the identity to add to the approver list for the access request.
     * @type {string}
     * @memberof AccessRequestDynamicApprover1Beta
     */
    'id': string;
    /**
     * The name of the identity to add to the approver list for the access request.
     * @type {string}
     * @memberof AccessRequestDynamicApprover1Beta
     */
    'name': string;
    /**
     * The type of object being referenced.
     * @type {object}
     * @memberof AccessRequestDynamicApprover1Beta
     */
    'type': AccessRequestDynamicApprover1BetaTypeEnum;
}

export const AccessRequestDynamicApprover1BetaTypeEnum = {
    Identity: 'IDENTITY',
    GovernanceGroup: 'GOVERNANCE_GROUP'
} as const;

export type AccessRequestDynamicApprover1BetaTypeEnum = typeof AccessRequestDynamicApprover1BetaTypeEnum[keyof typeof AccessRequestDynamicApprover1BetaTypeEnum];

/**
 * 
 * @export
 * @interface AccessRequestDynamicApproverBeta
 */
export interface AccessRequestDynamicApproverBeta {
    /**
     * The unique ID of the access request object. Can be used with the [access request status endpoint](https://developer.sailpoint.com/idn/api/beta/list-access-request-status) to get the status of the request. 
     * @type {string}
     * @memberof AccessRequestDynamicApproverBeta
     */
    'accessRequestId': string;
    /**
     * 
     * @type {AccessRequestDynamicApproverRequestedForBeta}
     * @memberof AccessRequestDynamicApproverBeta
     */
    'requestedFor': AccessRequestDynamicApproverRequestedForBeta;
    /**
     * The access items that are being requested.
     * @type {Array<AccessRequestDynamicApproverRequestedItemsInnerBeta>}
     * @memberof AccessRequestDynamicApproverBeta
     */
    'requestedItems': Array<AccessRequestDynamicApproverRequestedItemsInnerBeta>;
    /**
     * 
     * @type {AccessRequestDynamicApproverRequestedByBeta}
     * @memberof AccessRequestDynamicApproverBeta
     */
    'requestedBy': AccessRequestDynamicApproverRequestedByBeta;
}
/**
 * The identity that initiated the access request.
 * @export
 * @interface AccessRequestDynamicApproverRequestedByBeta
 */
export interface AccessRequestDynamicApproverRequestedByBeta {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof AccessRequestDynamicApproverRequestedByBeta
     */
    'type'?: AccessRequestDynamicApproverRequestedByBetaTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof AccessRequestDynamicApproverRequestedByBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof AccessRequestDynamicApproverRequestedByBeta
     */
    'name'?: string;
}

export const AccessRequestDynamicApproverRequestedByBetaTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type AccessRequestDynamicApproverRequestedByBetaTypeEnum = typeof AccessRequestDynamicApproverRequestedByBetaTypeEnum[keyof typeof AccessRequestDynamicApproverRequestedByBetaTypeEnum];

/**
 * The identity for whom the access is requested for.
 * @export
 * @interface AccessRequestDynamicApproverRequestedForBeta
 */
export interface AccessRequestDynamicApproverRequestedForBeta {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof AccessRequestDynamicApproverRequestedForBeta
     */
    'type'?: AccessRequestDynamicApproverRequestedForBetaTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof AccessRequestDynamicApproverRequestedForBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof AccessRequestDynamicApproverRequestedForBeta
     */
    'name'?: string;
}

export const AccessRequestDynamicApproverRequestedForBetaTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type AccessRequestDynamicApproverRequestedForBetaTypeEnum = typeof AccessRequestDynamicApproverRequestedForBetaTypeEnum[keyof typeof AccessRequestDynamicApproverRequestedForBetaTypeEnum];

/**
 * 
 * @export
 * @interface AccessRequestDynamicApproverRequestedItemsInnerBeta
 */
export interface AccessRequestDynamicApproverRequestedItemsInnerBeta {
    /**
     * The unique ID of the access item.
     * @type {string}
     * @memberof AccessRequestDynamicApproverRequestedItemsInnerBeta
     */
    'id': string;
    /**
     * Human friendly name of the access item.
     * @type {string}
     * @memberof AccessRequestDynamicApproverRequestedItemsInnerBeta
     */
    'name': string;
    /**
     * Extended description of the access item.
     * @type {string}
     * @memberof AccessRequestDynamicApproverRequestedItemsInnerBeta
     */
    'description'?: string | null;
    /**
     * The type of access item being requested.
     * @type {object}
     * @memberof AccessRequestDynamicApproverRequestedItemsInnerBeta
     */
    'type': AccessRequestDynamicApproverRequestedItemsInnerBetaTypeEnum;
    /**
     * Grant or revoke the access item
     * @type {object}
     * @memberof AccessRequestDynamicApproverRequestedItemsInnerBeta
     */
    'operation': AccessRequestDynamicApproverRequestedItemsInnerBetaOperationEnum;
    /**
     * A comment from the requestor on why the access is needed.
     * @type {string}
     * @memberof AccessRequestDynamicApproverRequestedItemsInnerBeta
     */
    'comment'?: string | null;
}

export const AccessRequestDynamicApproverRequestedItemsInnerBetaTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE',
    Entitlement: 'ENTITLEMENT'
} as const;

export type AccessRequestDynamicApproverRequestedItemsInnerBetaTypeEnum = typeof AccessRequestDynamicApproverRequestedItemsInnerBetaTypeEnum[keyof typeof AccessRequestDynamicApproverRequestedItemsInnerBetaTypeEnum];
export const AccessRequestDynamicApproverRequestedItemsInnerBetaOperationEnum = {
    Add: 'Add',
    Remove: 'Remove'
} as const;

export type AccessRequestDynamicApproverRequestedItemsInnerBetaOperationEnum = typeof AccessRequestDynamicApproverRequestedItemsInnerBetaOperationEnum[keyof typeof AccessRequestDynamicApproverRequestedItemsInnerBetaOperationEnum];

/**
 * 
 * @export
 * @interface AccessRequestItemBeta
 */
export interface AccessRequestItemBeta {
    /**
     * The type of the item being requested.
     * @type {string}
     * @memberof AccessRequestItemBeta
     */
    'type': AccessRequestItemBetaTypeEnum;
    /**
     * ID of Role, Access Profile or Entitlement being requested.
     * @type {string}
     * @memberof AccessRequestItemBeta
     */
    'id': string;
    /**
     * Comment provided by requester. * Comment is required when the request is of type Revoke Access. 
     * @type {string}
     * @memberof AccessRequestItemBeta
     */
    'comment'?: string;
    /**
     * Arbitrary key-value pairs. They will never be processed by the IdentityNow system but will be returned on associated APIs such as /account-activities and /access-request-status.
     * @type {{ [key: string]: string; }}
     * @memberof AccessRequestItemBeta
     */
    'clientMetadata'?: { [key: string]: string; };
    /**
     * The date the role or access profile is no longer assigned to the specified identity. * Specify a date in the future. * The current SLA for the deprovisioning is 24 hours. * This date can be modified to either extend or decrease the duration of access item assignments for the specified identity. * Currently it is not supported for entitlements. 
     * @type {string}
     * @memberof AccessRequestItemBeta
     */
    'removeDate'?: string;
}

export const AccessRequestItemBetaTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE',
    Entitlement: 'ENTITLEMENT'
} as const;

export type AccessRequestItemBetaTypeEnum = typeof AccessRequestItemBetaTypeEnum[keyof typeof AccessRequestItemBetaTypeEnum];

/**
 * 
 * @export
 * @interface AccessRequestItemResponseBeta
 */
export interface AccessRequestItemResponseBeta {
    /**
     * the access request item operation
     * @type {string}
     * @memberof AccessRequestItemResponseBeta
     */
    'operation'?: string;
    /**
     * the access item type
     * @type {string}
     * @memberof AccessRequestItemResponseBeta
     */
    'accessItemType'?: string;
    /**
     * the name of access request item
     * @type {string}
     * @memberof AccessRequestItemResponseBeta
     */
    'name'?: string;
    /**
     * the final decision for the access request
     * @type {string}
     * @memberof AccessRequestItemResponseBeta
     */
    'decision'?: AccessRequestItemResponseBetaDecisionEnum;
    /**
     * the description of access request item
     * @type {string}
     * @memberof AccessRequestItemResponseBeta
     */
    'description'?: string;
    /**
     * the source id
     * @type {string}
     * @memberof AccessRequestItemResponseBeta
     */
    'sourceId'?: string;
    /**
     * the source Name
     * @type {string}
     * @memberof AccessRequestItemResponseBeta
     */
    'sourceName'?: string;
    /**
     * 
     * @type {Array<ApprovalInfoResponseBeta>}
     * @memberof AccessRequestItemResponseBeta
     */
    'approvalInfos'?: Array<ApprovalInfoResponseBeta>;
}

export const AccessRequestItemResponseBetaDecisionEnum = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED'
} as const;

export type AccessRequestItemResponseBetaDecisionEnum = typeof AccessRequestItemResponseBetaDecisionEnum[keyof typeof AccessRequestItemResponseBetaDecisionEnum];

/**
 * Provides additional details about this access request phase.
 * @export
 * @interface AccessRequestPhasesBeta
 */
export interface AccessRequestPhasesBeta {
    /**
     * The time that this phase started.
     * @type {string}
     * @memberof AccessRequestPhasesBeta
     */
    'started'?: string;
    /**
     * The time that this phase finished.
     * @type {string}
     * @memberof AccessRequestPhasesBeta
     */
    'finished'?: string;
    /**
     * The name of this phase.
     * @type {string}
     * @memberof AccessRequestPhasesBeta
     */
    'name'?: string;
    /**
     * The state of this phase.
     * @type {string}
     * @memberof AccessRequestPhasesBeta
     */
    'state'?: AccessRequestPhasesBetaStateEnum;
    /**
     * The state of this phase.
     * @type {string}
     * @memberof AccessRequestPhasesBeta
     */
    'result'?: AccessRequestPhasesBetaResultEnum;
    /**
     * A reference to another object on the RequestedItemStatus that contains more details about the phase. Note that for the Provisioning phase, this will be empty if there are no manual work items.
     * @type {string}
     * @memberof AccessRequestPhasesBeta
     */
    'phaseReference'?: string;
}

export const AccessRequestPhasesBetaStateEnum = {
    Pending: 'PENDING',
    Executing: 'EXECUTING',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED'
} as const;

export type AccessRequestPhasesBetaStateEnum = typeof AccessRequestPhasesBetaStateEnum[keyof typeof AccessRequestPhasesBetaStateEnum];
export const AccessRequestPhasesBetaResultEnum = {
    Successful: 'SUCCESSFUL',
    Failed: 'FAILED'
} as const;

export type AccessRequestPhasesBetaResultEnum = typeof AccessRequestPhasesBetaResultEnum[keyof typeof AccessRequestPhasesBetaResultEnum];

/**
 * 
 * @export
 * @interface AccessRequestPostApprovalBeta
 */
export interface AccessRequestPostApprovalBeta {
    /**
     * The unique ID of the access request.
     * @type {string}
     * @memberof AccessRequestPostApprovalBeta
     */
    'accessRequestId': string;
    /**
     * 
     * @type {AccessRequestPostApprovalRequestedForBeta}
     * @memberof AccessRequestPostApprovalBeta
     */
    'requestedFor': AccessRequestPostApprovalRequestedForBeta;
    /**
     * Details on the outcome of each access item.
     * @type {Array<AccessRequestPostApprovalRequestedItemsStatusInnerBeta>}
     * @memberof AccessRequestPostApprovalBeta
     */
    'requestedItemsStatus': Array<AccessRequestPostApprovalRequestedItemsStatusInnerBeta>;
    /**
     * 
     * @type {AccessRequestPostApprovalRequestedByBeta}
     * @memberof AccessRequestPostApprovalBeta
     */
    'requestedBy': AccessRequestPostApprovalRequestedByBeta;
}
/**
 * The identity that initiated the access request.
 * @export
 * @interface AccessRequestPostApprovalRequestedByBeta
 */
export interface AccessRequestPostApprovalRequestedByBeta {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof AccessRequestPostApprovalRequestedByBeta
     */
    'type': AccessRequestPostApprovalRequestedByBetaTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof AccessRequestPostApprovalRequestedByBeta
     */
    'id': string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof AccessRequestPostApprovalRequestedByBeta
     */
    'name': string;
}

export const AccessRequestPostApprovalRequestedByBetaTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type AccessRequestPostApprovalRequestedByBetaTypeEnum = typeof AccessRequestPostApprovalRequestedByBetaTypeEnum[keyof typeof AccessRequestPostApprovalRequestedByBetaTypeEnum];

/**
 * The identity who the access request is for.
 * @export
 * @interface AccessRequestPostApprovalRequestedForBeta
 */
export interface AccessRequestPostApprovalRequestedForBeta {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof AccessRequestPostApprovalRequestedForBeta
     */
    'type': AccessRequestPostApprovalRequestedForBetaTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof AccessRequestPostApprovalRequestedForBeta
     */
    'id': string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof AccessRequestPostApprovalRequestedForBeta
     */
    'name': string;
}

export const AccessRequestPostApprovalRequestedForBetaTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type AccessRequestPostApprovalRequestedForBetaTypeEnum = typeof AccessRequestPostApprovalRequestedForBetaTypeEnum[keyof typeof AccessRequestPostApprovalRequestedForBetaTypeEnum];

/**
 * The identity of the approver.
 * @export
 * @interface AccessRequestPostApprovalRequestedItemsStatusInnerApprovalInfoInnerApproverBeta
 */
export interface AccessRequestPostApprovalRequestedItemsStatusInnerApprovalInfoInnerApproverBeta {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof AccessRequestPostApprovalRequestedItemsStatusInnerApprovalInfoInnerApproverBeta
     */
    'type': AccessRequestPostApprovalRequestedItemsStatusInnerApprovalInfoInnerApproverBetaTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof AccessRequestPostApprovalRequestedItemsStatusInnerApprovalInfoInnerApproverBeta
     */
    'id': string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof AccessRequestPostApprovalRequestedItemsStatusInnerApprovalInfoInnerApproverBeta
     */
    'name': string;
}

export const AccessRequestPostApprovalRequestedItemsStatusInnerApprovalInfoInnerApproverBetaTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type AccessRequestPostApprovalRequestedItemsStatusInnerApprovalInfoInnerApproverBetaTypeEnum = typeof AccessRequestPostApprovalRequestedItemsStatusInnerApprovalInfoInnerApproverBetaTypeEnum[keyof typeof AccessRequestPostApprovalRequestedItemsStatusInnerApprovalInfoInnerApproverBetaTypeEnum];

/**
 * 
 * @export
 * @interface AccessRequestPostApprovalRequestedItemsStatusInnerApprovalInfoInnerBeta
 */
export interface AccessRequestPostApprovalRequestedItemsStatusInnerApprovalInfoInnerBeta {
    /**
     * A comment left by the approver.
     * @type {string}
     * @memberof AccessRequestPostApprovalRequestedItemsStatusInnerApprovalInfoInnerBeta
     */
    'approvalComment'?: string | null;
    /**
     * The final decision of the approver.
     * @type {object}
     * @memberof AccessRequestPostApprovalRequestedItemsStatusInnerApprovalInfoInnerBeta
     */
    'approvalDecision': AccessRequestPostApprovalRequestedItemsStatusInnerApprovalInfoInnerBetaApprovalDecisionEnum;
    /**
     * The name of the approver
     * @type {string}
     * @memberof AccessRequestPostApprovalRequestedItemsStatusInnerApprovalInfoInnerBeta
     */
    'approverName': string;
    /**
     * 
     * @type {AccessRequestPostApprovalRequestedItemsStatusInnerApprovalInfoInnerApproverBeta}
     * @memberof AccessRequestPostApprovalRequestedItemsStatusInnerApprovalInfoInnerBeta
     */
    'approver': AccessRequestPostApprovalRequestedItemsStatusInnerApprovalInfoInnerApproverBeta;
}

export const AccessRequestPostApprovalRequestedItemsStatusInnerApprovalInfoInnerBetaApprovalDecisionEnum = {
    Approved: 'APPROVED',
    Denied: 'DENIED'
} as const;

export type AccessRequestPostApprovalRequestedItemsStatusInnerApprovalInfoInnerBetaApprovalDecisionEnum = typeof AccessRequestPostApprovalRequestedItemsStatusInnerApprovalInfoInnerBetaApprovalDecisionEnum[keyof typeof AccessRequestPostApprovalRequestedItemsStatusInnerApprovalInfoInnerBetaApprovalDecisionEnum];

/**
 * 
 * @export
 * @interface AccessRequestPostApprovalRequestedItemsStatusInnerBeta
 */
export interface AccessRequestPostApprovalRequestedItemsStatusInnerBeta {
    /**
     * The unique ID of the access item being requested.
     * @type {string}
     * @memberof AccessRequestPostApprovalRequestedItemsStatusInnerBeta
     */
    'id': string;
    /**
     * The human friendly name of the access item.
     * @type {string}
     * @memberof AccessRequestPostApprovalRequestedItemsStatusInnerBeta
     */
    'name': string;
    /**
     * Detailed description of the access item.
     * @type {string}
     * @memberof AccessRequestPostApprovalRequestedItemsStatusInnerBeta
     */
    'description'?: string | null;
    /**
     * The type of access item.
     * @type {object}
     * @memberof AccessRequestPostApprovalRequestedItemsStatusInnerBeta
     */
    'type': AccessRequestPostApprovalRequestedItemsStatusInnerBetaTypeEnum;
    /**
     * The action to perform on the access item.
     * @type {object}
     * @memberof AccessRequestPostApprovalRequestedItemsStatusInnerBeta
     */
    'operation': AccessRequestPostApprovalRequestedItemsStatusInnerBetaOperationEnum;
    /**
     * A comment from the identity requesting the access.
     * @type {string}
     * @memberof AccessRequestPostApprovalRequestedItemsStatusInnerBeta
     */
    'comment'?: string | null;
    /**
     * Additional customer defined metadata about the access item.
     * @type {{ [key: string]: any; }}
     * @memberof AccessRequestPostApprovalRequestedItemsStatusInnerBeta
     */
    'clientMetadata'?: { [key: string]: any; } | null;
    /**
     * A list of one or more approvers for the access request.
     * @type {Array<AccessRequestPostApprovalRequestedItemsStatusInnerApprovalInfoInnerBeta>}
     * @memberof AccessRequestPostApprovalRequestedItemsStatusInnerBeta
     */
    'approvalInfo': Array<AccessRequestPostApprovalRequestedItemsStatusInnerApprovalInfoInnerBeta>;
}

export const AccessRequestPostApprovalRequestedItemsStatusInnerBetaTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE',
    Entitlement: 'ENTITLEMENT'
} as const;

export type AccessRequestPostApprovalRequestedItemsStatusInnerBetaTypeEnum = typeof AccessRequestPostApprovalRequestedItemsStatusInnerBetaTypeEnum[keyof typeof AccessRequestPostApprovalRequestedItemsStatusInnerBetaTypeEnum];
export const AccessRequestPostApprovalRequestedItemsStatusInnerBetaOperationEnum = {
    Add: 'Add',
    Remove: 'Remove'
} as const;

export type AccessRequestPostApprovalRequestedItemsStatusInnerBetaOperationEnum = typeof AccessRequestPostApprovalRequestedItemsStatusInnerBetaOperationEnum[keyof typeof AccessRequestPostApprovalRequestedItemsStatusInnerBetaOperationEnum];

/**
 * 
 * @export
 * @interface AccessRequestPreApproval1Beta
 */
export interface AccessRequestPreApproval1Beta {
    /**
     * Whether or not to approve the access request.
     * @type {boolean}
     * @memberof AccessRequestPreApproval1Beta
     */
    'approved': boolean;
    /**
     * A comment about the decision to approve or deny the request.
     * @type {string}
     * @memberof AccessRequestPreApproval1Beta
     */
    'comment': string;
    /**
     * The name of the entity that approved or denied the request.
     * @type {string}
     * @memberof AccessRequestPreApproval1Beta
     */
    'approver': string;
}
/**
 * 
 * @export
 * @interface AccessRequestPreApprovalBeta
 */
export interface AccessRequestPreApprovalBeta {
    /**
     * The unique ID of the access request.
     * @type {string}
     * @memberof AccessRequestPreApprovalBeta
     */
    'accessRequestId': string;
    /**
     * 
     * @type {AccessRequestPostApprovalRequestedForBeta}
     * @memberof AccessRequestPreApprovalBeta
     */
    'requestedFor': AccessRequestPostApprovalRequestedForBeta;
    /**
     * Details of the access items being requested.
     * @type {Array<AccessRequestPreApprovalRequestedItemsInnerBeta>}
     * @memberof AccessRequestPreApprovalBeta
     */
    'requestedItems': Array<AccessRequestPreApprovalRequestedItemsInnerBeta>;
    /**
     * 
     * @type {AccessRequestPostApprovalRequestedByBeta}
     * @memberof AccessRequestPreApprovalBeta
     */
    'requestedBy': AccessRequestPostApprovalRequestedByBeta;
}
/**
 * 
 * @export
 * @interface AccessRequestPreApprovalRequestedItemsInnerBeta
 */
export interface AccessRequestPreApprovalRequestedItemsInnerBeta {
    /**
     * The unique ID of the access item being requested.
     * @type {string}
     * @memberof AccessRequestPreApprovalRequestedItemsInnerBeta
     */
    'id': string;
    /**
     * The human friendly name of the access item.
     * @type {string}
     * @memberof AccessRequestPreApprovalRequestedItemsInnerBeta
     */
    'name': string;
    /**
     * Detailed description of the access item.
     * @type {string}
     * @memberof AccessRequestPreApprovalRequestedItemsInnerBeta
     */
    'description'?: string | null;
    /**
     * The type of access item.
     * @type {object}
     * @memberof AccessRequestPreApprovalRequestedItemsInnerBeta
     */
    'type': AccessRequestPreApprovalRequestedItemsInnerBetaTypeEnum;
    /**
     * The action to perform on the access item.
     * @type {object}
     * @memberof AccessRequestPreApprovalRequestedItemsInnerBeta
     */
    'operation': AccessRequestPreApprovalRequestedItemsInnerBetaOperationEnum;
    /**
     * A comment from the identity requesting the access.
     * @type {string}
     * @memberof AccessRequestPreApprovalRequestedItemsInnerBeta
     */
    'comment'?: string | null;
}

export const AccessRequestPreApprovalRequestedItemsInnerBetaTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE',
    Entitlement: 'ENTITLEMENT'
} as const;

export type AccessRequestPreApprovalRequestedItemsInnerBetaTypeEnum = typeof AccessRequestPreApprovalRequestedItemsInnerBetaTypeEnum[keyof typeof AccessRequestPreApprovalRequestedItemsInnerBetaTypeEnum];
export const AccessRequestPreApprovalRequestedItemsInnerBetaOperationEnum = {
    Add: 'Add',
    Remove: 'Remove'
} as const;

export type AccessRequestPreApprovalRequestedItemsInnerBetaOperationEnum = typeof AccessRequestPreApprovalRequestedItemsInnerBetaOperationEnum[keyof typeof AccessRequestPreApprovalRequestedItemsInnerBetaOperationEnum];

/**
 * 
 * @export
 * @interface AccessRequestRecommendationActionItemDtoBeta
 */
export interface AccessRequestRecommendationActionItemDtoBeta {
    /**
     * The identity ID taking the action.
     * @type {string}
     * @memberof AccessRequestRecommendationActionItemDtoBeta
     */
    'identityId': string;
    /**
     * 
     * @type {AccessRequestRecommendationItemBeta}
     * @memberof AccessRequestRecommendationActionItemDtoBeta
     */
    'access': AccessRequestRecommendationItemBeta;
}
/**
 * 
 * @export
 * @interface AccessRequestRecommendationActionItemResponseDtoBeta
 */
export interface AccessRequestRecommendationActionItemResponseDtoBeta {
    /**
     * The identity ID taking the action.
     * @type {string}
     * @memberof AccessRequestRecommendationActionItemResponseDtoBeta
     */
    'identityId'?: string;
    /**
     * 
     * @type {AccessRequestRecommendationItemBeta}
     * @memberof AccessRequestRecommendationActionItemResponseDtoBeta
     */
    'access'?: AccessRequestRecommendationItemBeta;
    /**
     * 
     * @type {string}
     * @memberof AccessRequestRecommendationActionItemResponseDtoBeta
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface AccessRequestRecommendationItemBeta
 */
export interface AccessRequestRecommendationItemBeta {
    /**
     * ID of access item being recommended.
     * @type {string}
     * @memberof AccessRequestRecommendationItemBeta
     */
    'id'?: string;
    /**
     * 
     * @type {AccessRequestRecommendationItemTypeBeta}
     * @memberof AccessRequestRecommendationItemBeta
     */
    'type'?: AccessRequestRecommendationItemTypeBeta;
}
/**
 * 
 * @export
 * @interface AccessRequestRecommendationItemDetailAccessBeta
 */
export interface AccessRequestRecommendationItemDetailAccessBeta {
    /**
     * ID of access item being recommended.
     * @type {string}
     * @memberof AccessRequestRecommendationItemDetailAccessBeta
     */
    'id'?: string;
    /**
     * 
     * @type {AccessRequestRecommendationItemTypeBeta}
     * @memberof AccessRequestRecommendationItemDetailAccessBeta
     */
    'type'?: AccessRequestRecommendationItemTypeBeta;
    /**
     * Name of the access item
     * @type {string}
     * @memberof AccessRequestRecommendationItemDetailAccessBeta
     */
    'name'?: string;
    /**
     * Description of the access item
     * @type {string}
     * @memberof AccessRequestRecommendationItemDetailAccessBeta
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface AccessRequestRecommendationItemDetailBeta
 */
export interface AccessRequestRecommendationItemDetailBeta {
    /**
     * Identity ID for the recommendation
     * @type {string}
     * @memberof AccessRequestRecommendationItemDetailBeta
     */
    'identityId'?: string;
    /**
     * 
     * @type {AccessRequestRecommendationItemDetailAccessBeta}
     * @memberof AccessRequestRecommendationItemDetailBeta
     */
    'access'?: AccessRequestRecommendationItemDetailAccessBeta;
    /**
     * Whether or not the identity has already chosen to ignore this recommendation.
     * @type {boolean}
     * @memberof AccessRequestRecommendationItemDetailBeta
     */
    'ignored'?: boolean;
    /**
     * Whether or not the identity has already chosen to request this recommendation.
     * @type {boolean}
     * @memberof AccessRequestRecommendationItemDetailBeta
     */
    'requested'?: boolean;
    /**
     * Whether or not the identity reportedly viewed this recommendation.
     * @type {boolean}
     * @memberof AccessRequestRecommendationItemDetailBeta
     */
    'viewed'?: boolean;
    /**
     * 
     * @type {Array<AccessRecommendationMessageBeta>}
     * @memberof AccessRequestRecommendationItemDetailBeta
     */
    'messages'?: Array<AccessRecommendationMessageBeta>;
    /**
     * The list of translation messages
     * @type {Array<TranslationMessageBeta>}
     * @memberof AccessRequestRecommendationItemDetailBeta
     */
    'translationMessages'?: Array<TranslationMessageBeta>;
}
/**
 * The type of access item.
 * @export
 * @enum {string}
 */

export const AccessRequestRecommendationItemTypeBeta = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE'
} as const;

export type AccessRequestRecommendationItemTypeBeta = typeof AccessRequestRecommendationItemTypeBeta[keyof typeof AccessRequestRecommendationItemTypeBeta];


/**
 * 
 * @export
 * @interface AccessRequestResponseBeta
 */
export interface AccessRequestResponseBeta {
    /**
     * the requester Id
     * @type {string}
     * @memberof AccessRequestResponseBeta
     */
    'requesterId'?: string;
    /**
     * the requesterName
     * @type {string}
     * @memberof AccessRequestResponseBeta
     */
    'requesterName'?: string;
    /**
     * 
     * @type {Array<AccessRequestItemResponseBeta>}
     * @memberof AccessRequestResponseBeta
     */
    'items'?: Array<AccessRequestItemResponseBeta>;
}
/**
 * Access request type. Defaults to GRANT_ACCESS. REVOKE_ACCESS type can only have a single Identity ID in the requestedFor field.
 * @export
 * @enum {string}
 */

export const AccessRequestTypeBeta = {
    GrantAccess: 'GRANT_ACCESS',
    RevokeAccess: 'REVOKE_ACCESS'
} as const;

export type AccessRequestTypeBeta = typeof AccessRequestTypeBeta[keyof typeof AccessRequestTypeBeta];


/**
 * 
 * @export
 * @interface AccessRequestedBeta
 */
export interface AccessRequestedBeta {
    /**
     * 
     * @type {AccessRequestResponseBeta}
     * @memberof AccessRequestedBeta
     */
    'accessRequest'?: AccessRequestResponseBeta;
    /**
     * the identity id
     * @type {string}
     * @memberof AccessRequestedBeta
     */
    'identityId'?: string;
    /**
     * the event type
     * @type {string}
     * @memberof AccessRequestedBeta
     */
    'eventType'?: string;
    /**
     * the date of event
     * @type {string}
     * @memberof AccessRequestedBeta
     */
    'dt'?: string;
}
/**
 * Access type of API Client indicating online or offline use
 * @export
 * @enum {string}
 */

export const AccessTypeBeta = {
    Online: 'ONLINE',
    Offline: 'OFFLINE'
} as const;

export type AccessTypeBeta = typeof AccessTypeBeta[keyof typeof AccessTypeBeta];


/**
 * 
 * @export
 * @interface AccountActionBeta
 */
export interface AccountActionBeta {
    /**
     * Describes if action will be enabled or disabled
     * @type {string}
     * @memberof AccountActionBeta
     */
    'action'?: AccountActionBetaActionEnum;
    /**
     * List of source IDs. The sources must have the ENABLE feature or flat file source. See \"/sources\" endpoint for source features.
     * @type {Array<string>}
     * @memberof AccountActionBeta
     */
    'sourceIds'?: Array<string>;
}

export const AccountActionBetaActionEnum = {
    Enable: 'ENABLE',
    Disable: 'DISABLE'
} as const;

export type AccountActionBetaActionEnum = typeof AccountActionBetaActionEnum[keyof typeof AccountActionBetaActionEnum];

/**
 * 
 * @export
 * @interface AccountActivityItemBeta
 */
export interface AccountActivityItemBeta {
    /**
     * Item id
     * @type {string}
     * @memberof AccountActivityItemBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of item
     * @type {string}
     * @memberof AccountActivityItemBeta
     */
    'name'?: string;
    /**
     * Date and time item was requested
     * @type {string}
     * @memberof AccountActivityItemBeta
     */
    'requested'?: string;
    /**
     * 
     * @type {WorkItemStateBeta}
     * @memberof AccountActivityItemBeta
     */
    'approvalStatus'?: WorkItemStateBeta;
    /**
     * 
     * @type {ProvisioningStateBeta}
     * @memberof AccountActivityItemBeta
     */
    'provisioningStatus'?: ProvisioningStateBeta;
    /**
     * 
     * @type {CommentBeta}
     * @memberof AccountActivityItemBeta
     */
    'requesterComment'?: CommentBeta | null;
    /**
     * 
     * @type {IdentitySummaryBeta}
     * @memberof AccountActivityItemBeta
     */
    'reviewerIdentitySummary'?: IdentitySummaryBeta | null;
    /**
     * 
     * @type {CommentBeta}
     * @memberof AccountActivityItemBeta
     */
    'reviewerComment'?: CommentBeta | null;
    /**
     * 
     * @type {AccountActivityItemOperationBeta}
     * @memberof AccountActivityItemBeta
     */
    'operation'?: AccountActivityItemOperationBeta;
    /**
     * Attribute to which account activity applies
     * @type {string}
     * @memberof AccountActivityItemBeta
     */
    'attribute'?: string | null;
    /**
     * Value of attribute
     * @type {string}
     * @memberof AccountActivityItemBeta
     */
    'value'?: string | null;
    /**
     * Native identity in the target system to which the account activity applies
     * @type {string}
     * @memberof AccountActivityItemBeta
     */
    'nativeIdentity'?: string | null;
    /**
     * Id of Source to which account activity applies
     * @type {string}
     * @memberof AccountActivityItemBeta
     */
    'sourceId'?: string;
    /**
     * 
     * @type {AccountRequestInfoBeta}
     * @memberof AccountActivityItemBeta
     */
    'accountRequestInfo'?: AccountRequestInfoBeta | null;
    /**
     * Arbitrary key-value pairs, if any were included in the corresponding access request item
     * @type {{ [key: string]: string; }}
     * @memberof AccountActivityItemBeta
     */
    'clientMetadata'?: { [key: string]: string; } | null;
    /**
     * The date the role or access profile is no longer assigned to the specified identity.
     * @type {string}
     * @memberof AccountActivityItemBeta
     */
    'removeDate'?: string | null;
}
/**
 * Represents an operation in an account activity item
 * @export
 * @enum {string}
 */

export const AccountActivityItemOperationBeta = {
    Add: 'ADD',
    Create: 'CREATE',
    Modify: 'MODIFY',
    Delete: 'DELETE',
    Disable: 'DISABLE',
    Enable: 'ENABLE',
    Unlock: 'UNLOCK',
    Lock: 'LOCK',
    Remove: 'REMOVE'
} as const;

export type AccountActivityItemOperationBeta = typeof AccountActivityItemOperationBeta[keyof typeof AccountActivityItemOperationBeta];


/**
 * 
 * @export
 * @interface AccountAggregationBeta
 */
export interface AccountAggregationBeta {
    /**
     * When the aggregation started.
     * @type {string}
     * @memberof AccountAggregationBeta
     */
    'start'?: string;
    /**
     * STARTED - Aggregation started, but source account iteration has not completed.  ACCOUNTS_COLLECTED - Source account iteration completed, but all accounts have not yet been processed.  COMPLETED - Aggregation completed (*possibly with errors*).  CANCELLED - Aggregation cancelled by user.  RETRIED - Aggregation retried because of connectivity issues with the Virtual Appliance.  TERMINATED - Aggregation marked as failed after 3 tries after connectivity issues with the Virtual Appliance. 
     * @type {string}
     * @memberof AccountAggregationBeta
     */
    'status'?: AccountAggregationBetaStatusEnum;
    /**
     * The total number of *NEW, CHANGED and DELETED* accounts that need to be processed for this aggregation. This does not include accounts that were unchanged since the previous aggregation. This can be zero if there were no new, changed or deleted accounts since the previous aggregation. *Only available when status is ACCOUNTS_COLLECTED or COMPLETED.*
     * @type {number}
     * @memberof AccountAggregationBeta
     */
    'totalAccounts'?: number;
    /**
     * The number of *NEW, CHANGED and DELETED* accounts that have been processed so far. This reflects the number of accounts that have been processed at the time of the API call, and may increase on subsequent API calls while the status is ACCOUNTS_COLLECTED. *Only available when status is ACCOUNTS_COLLECTED or COMPLETED.*
     * @type {number}
     * @memberof AccountAggregationBeta
     */
    'processedAccounts'?: number;
}

export const AccountAggregationBetaStatusEnum = {
    Started: 'STARTED',
    AccountsCollected: 'ACCOUNTS_COLLECTED',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED',
    Retried: 'RETRIED',
    Terminated: 'TERMINATED'
} as const;

export type AccountAggregationBetaStatusEnum = typeof AccountAggregationBetaStatusEnum[keyof typeof AccountAggregationBetaStatusEnum];

/**
 * 
 * @export
 * @interface AccountAggregationCompletedBeta
 */
export interface AccountAggregationCompletedBeta {
    /**
     * 
     * @type {AccountAggregationCompletedSourceBeta}
     * @memberof AccountAggregationCompletedBeta
     */
    'source': AccountAggregationCompletedSourceBeta;
    /**
     * The overall status of the aggregation.
     * @type {object}
     * @memberof AccountAggregationCompletedBeta
     */
    'status': AccountAggregationCompletedBetaStatusEnum;
    /**
     * The date and time when the account aggregation started.
     * @type {string}
     * @memberof AccountAggregationCompletedBeta
     */
    'started': string;
    /**
     * The date and time when the account aggregation finished.
     * @type {string}
     * @memberof AccountAggregationCompletedBeta
     */
    'completed': string;
    /**
     * A list of errors that occurred during the aggregation.
     * @type {Array<string>}
     * @memberof AccountAggregationCompletedBeta
     */
    'errors': Array<string> | null;
    /**
     * A list of warnings that occurred during the aggregation.
     * @type {Array<string>}
     * @memberof AccountAggregationCompletedBeta
     */
    'warnings': Array<string> | null;
    /**
     * 
     * @type {AccountAggregationCompletedStatsBeta}
     * @memberof AccountAggregationCompletedBeta
     */
    'stats': AccountAggregationCompletedStatsBeta;
}

export const AccountAggregationCompletedBetaStatusEnum = {
    Success: 'Success',
    Failed: 'Failed',
    Terminated: 'Terminated'
} as const;

export type AccountAggregationCompletedBetaStatusEnum = typeof AccountAggregationCompletedBetaStatusEnum[keyof typeof AccountAggregationCompletedBetaStatusEnum];

/**
 * The source from which the accounts were aggregated.
 * @export
 * @interface AccountAggregationCompletedSourceBeta
 */
export interface AccountAggregationCompletedSourceBeta {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof AccountAggregationCompletedSourceBeta
     */
    'type': AccountAggregationCompletedSourceBetaTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof AccountAggregationCompletedSourceBeta
     */
    'id': string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof AccountAggregationCompletedSourceBeta
     */
    'name': string;
}

export const AccountAggregationCompletedSourceBetaTypeEnum = {
    Source: 'SOURCE'
} as const;

export type AccountAggregationCompletedSourceBetaTypeEnum = typeof AccountAggregationCompletedSourceBetaTypeEnum[keyof typeof AccountAggregationCompletedSourceBetaTypeEnum];

/**
 * Overall statistics about the account aggregation.
 * @export
 * @interface AccountAggregationCompletedStatsBeta
 */
export interface AccountAggregationCompletedStatsBeta {
    /**
     * The number of accounts which were scanned / iterated over.
     * @type {number}
     * @memberof AccountAggregationCompletedStatsBeta
     */
    'scanned': number;
    /**
     * The number of accounts which existed before, but had no changes.
     * @type {number}
     * @memberof AccountAggregationCompletedStatsBeta
     */
    'unchanged': number;
    /**
     * The number of accounts which existed before, but had changes.
     * @type {number}
     * @memberof AccountAggregationCompletedStatsBeta
     */
    'changed': number;
    /**
     * The number of accounts which are new - have not existed before.
     * @type {number}
     * @memberof AccountAggregationCompletedStatsBeta
     */
    'added': number;
    /**
     * The number accounts which existed before, but no longer exist (thus getting removed).
     * @type {number}
     * @memberof AccountAggregationCompletedStatsBeta
     */
    'removed': number;
}
/**
 * 
 * @export
 * @interface AccountAggregationStatusBeta
 */
export interface AccountAggregationStatusBeta {
    /**
     * When the aggregation started.
     * @type {string}
     * @memberof AccountAggregationStatusBeta
     */
    'start'?: string;
    /**
     * STARTED - Aggregation started, but source account iteration has not completed.  ACCOUNTS_COLLECTED - Source account iteration completed, but all accounts have not yet been processed.  COMPLETED - Aggregation completed (*possibly with errors*).  CANCELLED - Aggregation cancelled by user.  RETRIED - Aggregation retried because of connectivity issues with the Virtual Appliance.  TERMINATED - Aggregation marked as failed after 3 tries after connectivity issues with the Virtual Appliance. 
     * @type {string}
     * @memberof AccountAggregationStatusBeta
     */
    'status'?: AccountAggregationStatusBetaStatusEnum;
    /**
     * The total number of *NEW, CHANGED and DELETED* accounts that need to be processed for this aggregation. This does not include accounts that were unchanged since the previous aggregation. This can be zero if there were no new, changed or deleted accounts since the previous aggregation. *Only available when status is ACCOUNTS_COLLECTED or COMPLETED.*
     * @type {number}
     * @memberof AccountAggregationStatusBeta
     */
    'totalAccounts'?: number;
    /**
     * The number of *NEW, CHANGED and DELETED* accounts that have been processed so far. This reflects the number of accounts that have been processed at the time of the API call, and may increase on subsequent API calls while the status is ACCOUNTS_COLLECTED. *Only available when status is ACCOUNTS_COLLECTED or COMPLETED.*
     * @type {number}
     * @memberof AccountAggregationStatusBeta
     */
    'processedAccounts'?: number;
}

export const AccountAggregationStatusBetaStatusEnum = {
    Started: 'STARTED',
    AccountsCollected: 'ACCOUNTS_COLLECTED',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED',
    Retried: 'RETRIED',
    Terminated: 'TERMINATED'
} as const;

export type AccountAggregationStatusBetaStatusEnum = typeof AccountAggregationStatusBetaStatusEnum[keyof typeof AccountAggregationStatusBetaStatusEnum];

/**
 * 
 * @export
 * @interface AccountAllOfBeta
 */
export interface AccountAllOfBeta {
    /**
     * The unique ID of the source this account belongs to
     * @type {string}
     * @memberof AccountAllOfBeta
     */
    'sourceId': string;
    /**
     * The display name of the source this account belongs to
     * @type {string}
     * @memberof AccountAllOfBeta
     */
    'sourceName': string;
    /**
     * The unique ID of the identity this account is correlated to
     * @type {string}
     * @memberof AccountAllOfBeta
     */
    'identityId'?: string;
    /**
     * The account attributes that are aggregated
     * @type {{ [key: string]: any; }}
     * @memberof AccountAllOfBeta
     */
    'attributes': { [key: string]: any; };
    /**
     * Indicates if this account is from an authoritative source
     * @type {boolean}
     * @memberof AccountAllOfBeta
     */
    'authoritative': boolean;
    /**
     * A description of the account
     * @type {string}
     * @memberof AccountAllOfBeta
     */
    'description'?: string | null;
    /**
     * Indicates if the account is currently disabled
     * @type {boolean}
     * @memberof AccountAllOfBeta
     */
    'disabled': boolean;
    /**
     * Indicates if the account is currently locked
     * @type {boolean}
     * @memberof AccountAllOfBeta
     */
    'locked': boolean;
    /**
     * The unique ID of the account generated by the source system
     * @type {string}
     * @memberof AccountAllOfBeta
     */
    'nativeIdentity': string;
    /**
     * If true, this is a user account within IdentityNow.  If false, this is an account from a source system.
     * @type {boolean}
     * @memberof AccountAllOfBeta
     */
    'systemAccount': boolean;
    /**
     * Indicates if this account is not correlated to an identity
     * @type {boolean}
     * @memberof AccountAllOfBeta
     */
    'uncorrelated': boolean;
    /**
     * The unique ID of the account as determined by the account schema
     * @type {string}
     * @memberof AccountAllOfBeta
     */
    'uuid'?: string | null;
    /**
     * Indicates if the account has been manually correlated to an identity
     * @type {boolean}
     * @memberof AccountAllOfBeta
     */
    'manuallyCorrelated': boolean;
    /**
     * Indicates if the account has entitlements
     * @type {boolean}
     * @memberof AccountAllOfBeta
     */
    'hasEntitlements': boolean;
}
/**
 * 
 * @export
 * @interface AccountAttributesBeta
 */
export interface AccountAttributesBeta {
    /**
     * The schema attribute values for the account
     * @type {object}
     * @memberof AccountAttributesBeta
     */
    'attributes': object;
}
/**
 * Details of the account where the attributes changed.
 * @export
 * @interface AccountAttributesChangedAccountBeta
 */
export interface AccountAttributesChangedAccountBeta {
    /**
     * SailPoint generated unique identifier.
     * @type {string}
     * @memberof AccountAttributesChangedAccountBeta
     */
    'id': string;
    /**
     * The source\'s unique identifier for the account. UUID is generated by the source system.
     * @type {string}
     * @memberof AccountAttributesChangedAccountBeta
     */
    'uuid': string | null;
    /**
     * Name of the account.
     * @type {string}
     * @memberof AccountAttributesChangedAccountBeta
     */
    'name': string;
    /**
     * Unique ID of the account on the source.
     * @type {string}
     * @memberof AccountAttributesChangedAccountBeta
     */
    'nativeIdentity': string;
    /**
     * The type of the account
     * @type {object}
     * @memberof AccountAttributesChangedAccountBeta
     */
    'type': AccountAttributesChangedAccountBetaTypeEnum;
}

export const AccountAttributesChangedAccountBetaTypeEnum = {
    Account: 'ACCOUNT'
} as const;

export type AccountAttributesChangedAccountBetaTypeEnum = typeof AccountAttributesChangedAccountBetaTypeEnum[keyof typeof AccountAttributesChangedAccountBetaTypeEnum];

/**
 * 
 * @export
 * @interface AccountAttributesChangedBeta
 */
export interface AccountAttributesChangedBeta {
    /**
     * 
     * @type {AccountAttributesChangedIdentityBeta}
     * @memberof AccountAttributesChangedBeta
     */
    'identity': AccountAttributesChangedIdentityBeta;
    /**
     * 
     * @type {AccountAttributesChangedSourceBeta}
     * @memberof AccountAttributesChangedBeta
     */
    'source': AccountAttributesChangedSourceBeta;
    /**
     * 
     * @type {AccountAttributesChangedAccountBeta}
     * @memberof AccountAttributesChangedBeta
     */
    'account': AccountAttributesChangedAccountBeta;
    /**
     * A list of attributes that changed.
     * @type {Array<AccountAttributesChangedChangesInnerBeta>}
     * @memberof AccountAttributesChangedBeta
     */
    'changes': Array<AccountAttributesChangedChangesInnerBeta>;
}
/**
 * 
 * @export
 * @interface AccountAttributesChangedChangesInnerBeta
 */
export interface AccountAttributesChangedChangesInnerBeta {
    /**
     * The name of the attribute.
     * @type {string}
     * @memberof AccountAttributesChangedChangesInnerBeta
     */
    'attribute': string;
    /**
     * 
     * @type {AccountAttributesChangedChangesInnerOldValueBeta}
     * @memberof AccountAttributesChangedChangesInnerBeta
     */
    'oldValue': AccountAttributesChangedChangesInnerOldValueBeta | null;
    /**
     * 
     * @type {AccountAttributesChangedChangesInnerNewValueBeta}
     * @memberof AccountAttributesChangedChangesInnerBeta
     */
    'newValue': AccountAttributesChangedChangesInnerNewValueBeta | null;
}
/**
 * @type AccountAttributesChangedChangesInnerNewValueBeta
 * The new value of the attribute.
 * @export
 */
export type AccountAttributesChangedChangesInnerNewValueBeta = Array<string> | boolean | string;

/**
 * @type AccountAttributesChangedChangesInnerOldValueBeta
 * The previous value of the attribute.
 * @export
 */
export type AccountAttributesChangedChangesInnerOldValueBeta = Array<string> | boolean | string;

/**
 * The identity whose account attributes changed.
 * @export
 * @interface AccountAttributesChangedIdentityBeta
 */
export interface AccountAttributesChangedIdentityBeta {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof AccountAttributesChangedIdentityBeta
     */
    'type': AccountAttributesChangedIdentityBetaTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof AccountAttributesChangedIdentityBeta
     */
    'id': string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof AccountAttributesChangedIdentityBeta
     */
    'name': string;
}

export const AccountAttributesChangedIdentityBetaTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type AccountAttributesChangedIdentityBetaTypeEnum = typeof AccountAttributesChangedIdentityBetaTypeEnum[keyof typeof AccountAttributesChangedIdentityBetaTypeEnum];

/**
 * The source that contains the account.
 * @export
 * @interface AccountAttributesChangedSourceBeta
 */
export interface AccountAttributesChangedSourceBeta {
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof AccountAttributesChangedSourceBeta
     */
    'id': string;
    /**
     * The type of object that is referenced
     * @type {string}
     * @memberof AccountAttributesChangedSourceBeta
     */
    'type': AccountAttributesChangedSourceBetaTypeEnum;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof AccountAttributesChangedSourceBeta
     */
    'name': string;
}

export const AccountAttributesChangedSourceBetaTypeEnum = {
    Source: 'SOURCE'
} as const;

export type AccountAttributesChangedSourceBetaTypeEnum = typeof AccountAttributesChangedSourceBetaTypeEnum[keyof typeof AccountAttributesChangedSourceBetaTypeEnum];

/**
 * The schema attribute values for the account
 * @export
 * @interface AccountAttributesCreateAttributesBeta
 */
export interface AccountAttributesCreateAttributesBeta {
    [key: string]: string | any;

    /**
     * Target source to create an account
     * @type {string}
     * @memberof AccountAttributesCreateAttributesBeta
     */
    'sourceId': string;
}
/**
 * 
 * @export
 * @interface AccountAttributesCreateBeta
 */
export interface AccountAttributesCreateBeta {
    /**
     * 
     * @type {AccountAttributesCreateAttributesBeta}
     * @memberof AccountAttributesCreateBeta
     */
    'attributes': AccountAttributesCreateAttributesBeta;
}
/**
 * 
 * @export
 * @interface AccountBeta
 */
export interface AccountBeta {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof AccountBeta
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof AccountBeta
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof AccountBeta
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof AccountBeta
     */
    'modified'?: string;
    /**
     * The unique ID of the source this account belongs to
     * @type {string}
     * @memberof AccountBeta
     */
    'sourceId': string;
    /**
     * The display name of the source this account belongs to
     * @type {string}
     * @memberof AccountBeta
     */
    'sourceName': string;
    /**
     * The unique ID of the identity this account is correlated to
     * @type {string}
     * @memberof AccountBeta
     */
    'identityId'?: string;
    /**
     * The account attributes that are aggregated
     * @type {{ [key: string]: any; }}
     * @memberof AccountBeta
     */
    'attributes': { [key: string]: any; };
    /**
     * Indicates if this account is from an authoritative source
     * @type {boolean}
     * @memberof AccountBeta
     */
    'authoritative': boolean;
    /**
     * A description of the account
     * @type {string}
     * @memberof AccountBeta
     */
    'description'?: string | null;
    /**
     * Indicates if the account is currently disabled
     * @type {boolean}
     * @memberof AccountBeta
     */
    'disabled': boolean;
    /**
     * Indicates if the account is currently locked
     * @type {boolean}
     * @memberof AccountBeta
     */
    'locked': boolean;
    /**
     * The unique ID of the account generated by the source system
     * @type {string}
     * @memberof AccountBeta
     */
    'nativeIdentity': string;
    /**
     * If true, this is a user account within IdentityNow.  If false, this is an account from a source system.
     * @type {boolean}
     * @memberof AccountBeta
     */
    'systemAccount': boolean;
    /**
     * Indicates if this account is not correlated to an identity
     * @type {boolean}
     * @memberof AccountBeta
     */
    'uncorrelated': boolean;
    /**
     * The unique ID of the account as determined by the account schema
     * @type {string}
     * @memberof AccountBeta
     */
    'uuid'?: string | null;
    /**
     * Indicates if the account has been manually correlated to an identity
     * @type {boolean}
     * @memberof AccountBeta
     */
    'manuallyCorrelated': boolean;
    /**
     * Indicates if the account has entitlements
     * @type {boolean}
     * @memberof AccountBeta
     */
    'hasEntitlements': boolean;
}
/**
 * The account that was correlated.
 * @export
 * @interface AccountCorrelatedAccountBeta
 */
export interface AccountCorrelatedAccountBeta {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof AccountCorrelatedAccountBeta
     */
    'type': AccountCorrelatedAccountBetaTypeEnum;
    /**
     * Unique ID of the account on the source.
     * @type {string}
     * @memberof AccountCorrelatedAccountBeta
     */
    'nativeIdentity': string;
    /**
     * The source\'s unique identifier for the account. UUID is generated by the source system.
     * @type {string}
     * @memberof AccountCorrelatedAccountBeta
     */
    'uuid'?: string | null;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof AccountCorrelatedAccountBeta
     */
    'id': string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof AccountCorrelatedAccountBeta
     */
    'name': string;
}

export const AccountCorrelatedAccountBetaTypeEnum = {
    Account: 'ACCOUNT'
} as const;

export type AccountCorrelatedAccountBetaTypeEnum = typeof AccountCorrelatedAccountBetaTypeEnum[keyof typeof AccountCorrelatedAccountBetaTypeEnum];

/**
 * 
 * @export
 * @interface AccountCorrelatedBeta
 */
export interface AccountCorrelatedBeta {
    /**
     * 
     * @type {AccountCorrelatedIdentityBeta}
     * @memberof AccountCorrelatedBeta
     */
    'identity': AccountCorrelatedIdentityBeta;
    /**
     * 
     * @type {AccountCorrelatedSourceBeta}
     * @memberof AccountCorrelatedBeta
     */
    'source': AccountCorrelatedSourceBeta;
    /**
     * 
     * @type {AccountCorrelatedAccountBeta}
     * @memberof AccountCorrelatedBeta
     */
    'account': AccountCorrelatedAccountBeta;
    /**
     * The attributes associated with the account.  Attributes are unique per source.
     * @type {{ [key: string]: any; }}
     * @memberof AccountCorrelatedBeta
     */
    'attributes': { [key: string]: any; };
    /**
     * The number of entitlements associated with this account.
     * @type {number}
     * @memberof AccountCorrelatedBeta
     */
    'entitlementCount'?: number;
}
/**
 * The identity that the account correlated with.
 * @export
 * @interface AccountCorrelatedIdentityBeta
 */
export interface AccountCorrelatedIdentityBeta {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof AccountCorrelatedIdentityBeta
     */
    'type': AccountCorrelatedIdentityBetaTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof AccountCorrelatedIdentityBeta
     */
    'id': string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof AccountCorrelatedIdentityBeta
     */
    'name': string;
}

export const AccountCorrelatedIdentityBetaTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type AccountCorrelatedIdentityBetaTypeEnum = typeof AccountCorrelatedIdentityBetaTypeEnum[keyof typeof AccountCorrelatedIdentityBetaTypeEnum];

/**
 * The source from which the account came from.
 * @export
 * @interface AccountCorrelatedSourceBeta
 */
export interface AccountCorrelatedSourceBeta {
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof AccountCorrelatedSourceBeta
     */
    'id': string;
    /**
     * The type of object that is referenced
     * @type {string}
     * @memberof AccountCorrelatedSourceBeta
     */
    'type': AccountCorrelatedSourceBetaTypeEnum;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof AccountCorrelatedSourceBeta
     */
    'name': string;
}

export const AccountCorrelatedSourceBetaTypeEnum = {
    Source: 'SOURCE'
} as const;

export type AccountCorrelatedSourceBetaTypeEnum = typeof AccountCorrelatedSourceBetaTypeEnum[keyof typeof AccountCorrelatedSourceBetaTypeEnum];

/**
 * If an account activity item is associated with an access request, captures details of that request.
 * @export
 * @interface AccountRequestInfoBeta
 */
export interface AccountRequestInfoBeta {
    /**
     * Id of requested object
     * @type {string}
     * @memberof AccountRequestInfoBeta
     */
    'requestedObjectId'?: string;
    /**
     * Human-readable name of requested object
     * @type {string}
     * @memberof AccountRequestInfoBeta
     */
    'requestedObjectName'?: string;
    /**
     * 
     * @type {RequestableObjectTypeBeta}
     * @memberof AccountRequestInfoBeta
     */
    'requestedObjectType'?: RequestableObjectTypeBeta;
}
/**
 * 
 * @export
 * @interface AccountStatusChangedAccountBeta
 */
export interface AccountStatusChangedAccountBeta {
    /**
     * the ID of the account in the database
     * @type {string}
     * @memberof AccountStatusChangedAccountBeta
     */
    'id'?: string;
    /**
     * the native identifier of the account
     * @type {string}
     * @memberof AccountStatusChangedAccountBeta
     */
    'nativeIdentity'?: string;
    /**
     * the display name of the account
     * @type {string}
     * @memberof AccountStatusChangedAccountBeta
     */
    'displayName'?: string;
    /**
     * the ID of the source for this account
     * @type {string}
     * @memberof AccountStatusChangedAccountBeta
     */
    'sourceId'?: string;
    /**
     * the name of the source for this account
     * @type {string}
     * @memberof AccountStatusChangedAccountBeta
     */
    'sourceName'?: string;
    /**
     * the number of entitlements on this account
     * @type {number}
     * @memberof AccountStatusChangedAccountBeta
     */
    'entitlementCount'?: number;
    /**
     * this value is always \"account\"
     * @type {string}
     * @memberof AccountStatusChangedAccountBeta
     */
    'accessType'?: string;
}
/**
 * 
 * @export
 * @interface AccountStatusChangedBeta
 */
export interface AccountStatusChangedBeta {
    /**
     * the event type
     * @type {string}
     * @memberof AccountStatusChangedBeta
     */
    'eventType'?: string;
    /**
     * the identity id
     * @type {string}
     * @memberof AccountStatusChangedBeta
     */
    'identityId'?: string;
    /**
     * the date of event
     * @type {string}
     * @memberof AccountStatusChangedBeta
     */
    'dt'?: string;
    /**
     * 
     * @type {AccountStatusChangedAccountBeta}
     * @memberof AccountStatusChangedBeta
     */
    'account'?: AccountStatusChangedAccountBeta;
    /**
     * 
     * @type {AccountStatusChangedStatusChangeBeta}
     * @memberof AccountStatusChangedBeta
     */
    'statusChange'?: AccountStatusChangedStatusChangeBeta;
}
/**
 * 
 * @export
 * @interface AccountStatusChangedStatusChangeBeta
 */
export interface AccountStatusChangedStatusChangeBeta {
    /**
     * the previous status of the account
     * @type {string}
     * @memberof AccountStatusChangedStatusChangeBeta
     */
    'previousStatus'?: AccountStatusChangedStatusChangeBetaPreviousStatusEnum;
    /**
     * the new status of the account
     * @type {string}
     * @memberof AccountStatusChangedStatusChangeBeta
     */
    'newStatus'?: AccountStatusChangedStatusChangeBetaNewStatusEnum;
}

export const AccountStatusChangedStatusChangeBetaPreviousStatusEnum = {
    Enabled: 'enabled',
    Disabled: 'disabled',
    Locked: 'locked'
} as const;

export type AccountStatusChangedStatusChangeBetaPreviousStatusEnum = typeof AccountStatusChangedStatusChangeBetaPreviousStatusEnum[keyof typeof AccountStatusChangedStatusChangeBetaPreviousStatusEnum];
export const AccountStatusChangedStatusChangeBetaNewStatusEnum = {
    Enabled: 'enabled',
    Disabled: 'disabled',
    Locked: 'locked'
} as const;

export type AccountStatusChangedStatusChangeBetaNewStatusEnum = typeof AccountStatusChangedStatusChangeBetaNewStatusEnum[keyof typeof AccountStatusChangedStatusChangeBetaNewStatusEnum];

/**
 * Request used for account enable/disable
 * @export
 * @interface AccountToggleRequestBeta
 */
export interface AccountToggleRequestBeta {
    /**
     * If set, an external process validates that the user wants to proceed with this request.
     * @type {string}
     * @memberof AccountToggleRequestBeta
     */
    'externalVerificationId'?: string;
    /**
     * If set, provisioning updates the account attribute at the source.   This option is used when the account is not synced to ensure the attribute is updated.
     * @type {boolean}
     * @memberof AccountToggleRequestBeta
     */
    'forceProvisioning'?: boolean;
}
/**
 * The account that was uncorrelated.
 * @export
 * @interface AccountUncorrelatedAccountBeta
 */
export interface AccountUncorrelatedAccountBeta {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof AccountUncorrelatedAccountBeta
     */
    'type': AccountUncorrelatedAccountBetaTypeEnum;
    /**
     * Unique ID of the account on the source.
     * @type {string}
     * @memberof AccountUncorrelatedAccountBeta
     */
    'nativeIdentity': string;
    /**
     * The source\'s unique identifier for the account. UUID is generated by the source system.
     * @type {string}
     * @memberof AccountUncorrelatedAccountBeta
     */
    'uuid'?: string | null;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof AccountUncorrelatedAccountBeta
     */
    'id': string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof AccountUncorrelatedAccountBeta
     */
    'name': string;
}

export const AccountUncorrelatedAccountBetaTypeEnum = {
    Account: 'ACCOUNT'
} as const;

export type AccountUncorrelatedAccountBetaTypeEnum = typeof AccountUncorrelatedAccountBetaTypeEnum[keyof typeof AccountUncorrelatedAccountBetaTypeEnum];

/**
 * 
 * @export
 * @interface AccountUncorrelatedBeta
 */
export interface AccountUncorrelatedBeta {
    /**
     * 
     * @type {AccountUncorrelatedIdentityBeta}
     * @memberof AccountUncorrelatedBeta
     */
    'identity': AccountUncorrelatedIdentityBeta;
    /**
     * 
     * @type {AccountUncorrelatedSourceBeta}
     * @memberof AccountUncorrelatedBeta
     */
    'source': AccountUncorrelatedSourceBeta;
    /**
     * 
     * @type {AccountUncorrelatedAccountBeta}
     * @memberof AccountUncorrelatedBeta
     */
    'account': AccountUncorrelatedAccountBeta;
    /**
     * The number of entitlements associated with this account.
     * @type {number}
     * @memberof AccountUncorrelatedBeta
     */
    'entitlementCount'?: number;
}
/**
 * The identity that the account uncorrelated with.
 * @export
 * @interface AccountUncorrelatedIdentityBeta
 */
export interface AccountUncorrelatedIdentityBeta {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof AccountUncorrelatedIdentityBeta
     */
    'type': AccountUncorrelatedIdentityBetaTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof AccountUncorrelatedIdentityBeta
     */
    'id': string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof AccountUncorrelatedIdentityBeta
     */
    'name': string;
}

export const AccountUncorrelatedIdentityBetaTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type AccountUncorrelatedIdentityBetaTypeEnum = typeof AccountUncorrelatedIdentityBetaTypeEnum[keyof typeof AccountUncorrelatedIdentityBetaTypeEnum];

/**
 * The source from which the account came from.
 * @export
 * @interface AccountUncorrelatedSourceBeta
 */
export interface AccountUncorrelatedSourceBeta {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof AccountUncorrelatedSourceBeta
     */
    'type': AccountUncorrelatedSourceBetaTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof AccountUncorrelatedSourceBeta
     */
    'id': string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof AccountUncorrelatedSourceBeta
     */
    'name': string;
}

export const AccountUncorrelatedSourceBetaTypeEnum = {
    Source: 'SOURCE'
} as const;

export type AccountUncorrelatedSourceBetaTypeEnum = typeof AccountUncorrelatedSourceBetaTypeEnum[keyof typeof AccountUncorrelatedSourceBetaTypeEnum];

/**
 * Request used for account unlock
 * @export
 * @interface AccountUnlockRequestBeta
 */
export interface AccountUnlockRequestBeta {
    /**
     * If set, an external process validates that the user wants to proceed with this request.
     * @type {string}
     * @memberof AccountUnlockRequestBeta
     */
    'externalVerificationId'?: string;
    /**
     * If set, the IDN account is unlocked after the workflow completes.
     * @type {boolean}
     * @memberof AccountUnlockRequestBeta
     */
    'unlockIDNAccount'?: boolean;
    /**
     * If set, provisioning updates the account attribute at the source.   This option is used when the account is not synced to ensure the attribute is updated.
     * @type {boolean}
     * @memberof AccountUnlockRequestBeta
     */
    'forceProvisioning'?: boolean;
}
/**
 * Accounts async response containing details on started async process
 * @export
 * @interface AccountsAsyncResultBeta
 */
export interface AccountsAsyncResultBeta {
    /**
     * id of the task
     * @type {string}
     * @memberof AccountsAsyncResultBeta
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface AccountsCollectedForAggregationBeta
 */
export interface AccountsCollectedForAggregationBeta {
    /**
     * 
     * @type {AccountsCollectedForAggregationSourceBeta}
     * @memberof AccountsCollectedForAggregationBeta
     */
    'source': AccountsCollectedForAggregationSourceBeta;
    /**
     * The overall status of the collection.
     * @type {object}
     * @memberof AccountsCollectedForAggregationBeta
     */
    'status': AccountsCollectedForAggregationBetaStatusEnum;
    /**
     * The date and time when the account collection started.
     * @type {string}
     * @memberof AccountsCollectedForAggregationBeta
     */
    'started': string;
    /**
     * The date and time when the account collection finished.
     * @type {string}
     * @memberof AccountsCollectedForAggregationBeta
     */
    'completed': string;
    /**
     * A list of errors that occurred during the collection.
     * @type {Array<string>}
     * @memberof AccountsCollectedForAggregationBeta
     */
    'errors': Array<string> | null;
    /**
     * A list of warnings that occurred during the collection.
     * @type {Array<string>}
     * @memberof AccountsCollectedForAggregationBeta
     */
    'warnings': Array<string> | null;
    /**
     * 
     * @type {AccountsCollectedForAggregationStatsBeta}
     * @memberof AccountsCollectedForAggregationBeta
     */
    'stats': AccountsCollectedForAggregationStatsBeta;
}

export const AccountsCollectedForAggregationBetaStatusEnum = {
    Success: 'Success',
    Failed: 'Failed',
    Terminated: 'Terminated'
} as const;

export type AccountsCollectedForAggregationBetaStatusEnum = typeof AccountsCollectedForAggregationBetaStatusEnum[keyof typeof AccountsCollectedForAggregationBetaStatusEnum];

/**
 * Reference to the source that has been aggregated.
 * @export
 * @interface AccountsCollectedForAggregationSourceBeta
 */
export interface AccountsCollectedForAggregationSourceBeta {
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof AccountsCollectedForAggregationSourceBeta
     */
    'id': string;
    /**
     * The type of object that is referenced
     * @type {string}
     * @memberof AccountsCollectedForAggregationSourceBeta
     */
    'type': AccountsCollectedForAggregationSourceBetaTypeEnum;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof AccountsCollectedForAggregationSourceBeta
     */
    'name': string;
}

export const AccountsCollectedForAggregationSourceBetaTypeEnum = {
    Source: 'SOURCE'
} as const;

export type AccountsCollectedForAggregationSourceBetaTypeEnum = typeof AccountsCollectedForAggregationSourceBetaTypeEnum[keyof typeof AccountsCollectedForAggregationSourceBetaTypeEnum];

/**
 * Overall statistics about the account collection.
 * @export
 * @interface AccountsCollectedForAggregationStatsBeta
 */
export interface AccountsCollectedForAggregationStatsBeta {
    /**
     * The number of accounts which were scanned / iterated over.
     * @type {number}
     * @memberof AccountsCollectedForAggregationStatsBeta
     */
    'scanned': number;
    /**
     * The number of accounts which existed before, but had no changes.
     * @type {number}
     * @memberof AccountsCollectedForAggregationStatsBeta
     */
    'unchanged': number;
    /**
     * The number of accounts which existed before, but had changes.
     * @type {number}
     * @memberof AccountsCollectedForAggregationStatsBeta
     */
    'changed': number;
    /**
     * The number of accounts which are new - have not existed before.
     * @type {number}
     * @memberof AccountsCollectedForAggregationStatsBeta
     */
    'added': number;
    /**
     * The number accounts which existed before, but no longer exist (thus getting removed).
     * @type {number}
     * @memberof AccountsCollectedForAggregationStatsBeta
     */
    'removed': number;
}
/**
 * 
 * @export
 * @interface ActivateCampaignOptionsBeta
 */
export interface ActivateCampaignOptionsBeta {
    /**
     * The timezone must be in a valid ISO 8601 format. Timezones in ISO 8601 are represented as UTC (represented as \'Z\') or as an offset from UTC. The offset format can be +/-hh:mm, +/-hhmm, or +/-hh.
     * @type {string}
     * @memberof ActivateCampaignOptionsBeta
     */
    'timeZone'?: string;
}
/**
 * 
 * @export
 * @interface AdminReviewReassignBeta
 */
export interface AdminReviewReassignBeta {
    /**
     * List of certification IDs to reassign
     * @type {Array<string>}
     * @memberof AdminReviewReassignBeta
     */
    'certificationIds'?: Array<string>;
    /**
     * 
     * @type {AdminReviewReassignReassignToBeta}
     * @memberof AdminReviewReassignBeta
     */
    'reassignTo'?: AdminReviewReassignReassignToBeta;
    /**
     * Comment to explain why the certification was reassigned
     * @type {string}
     * @memberof AdminReviewReassignBeta
     */
    'reason'?: string;
}
/**
 * 
 * @export
 * @interface AdminReviewReassignReassignToBeta
 */
export interface AdminReviewReassignReassignToBeta {
    /**
     * The identity ID to which the review is being assigned.
     * @type {string}
     * @memberof AdminReviewReassignReassignToBeta
     */
    'id'?: string;
    /**
     * The type of the ID provided.
     * @type {string}
     * @memberof AdminReviewReassignReassignToBeta
     */
    'type'?: AdminReviewReassignReassignToBetaTypeEnum;
}

export const AdminReviewReassignReassignToBetaTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type AdminReviewReassignReassignToBetaTypeEnum = typeof AdminReviewReassignReassignToBetaTypeEnum[keyof typeof AdminReviewReassignReassignToBetaTypeEnum];

/**
 * 
 * @export
 * @interface ApprovalForwardHistoryBeta
 */
export interface ApprovalForwardHistoryBeta {
    /**
     * Display name of approver from whom the approval was forwarded.
     * @type {string}
     * @memberof ApprovalForwardHistoryBeta
     */
    'oldApproverName'?: string;
    /**
     * Display name of approver to whom the approval was forwarded.
     * @type {string}
     * @memberof ApprovalForwardHistoryBeta
     */
    'newApproverName'?: string;
    /**
     * Comment made while forwarding.
     * @type {string}
     * @memberof ApprovalForwardHistoryBeta
     */
    'comment'?: string | null;
    /**
     * Time at which approval was forwarded.
     * @type {string}
     * @memberof ApprovalForwardHistoryBeta
     */
    'modified'?: string;
    /**
     * Display name of forwarder who forwarded the approval.
     * @type {string}
     * @memberof ApprovalForwardHistoryBeta
     */
    'forwarderName'?: string | null;
    /**
     * 
     * @type {ReassignmentTypeBeta}
     * @memberof ApprovalForwardHistoryBeta
     */
    'reassignmentType'?: ReassignmentTypeBeta;
}
/**
 * 
 * @export
 * @interface ApprovalInfoResponseBeta
 */
export interface ApprovalInfoResponseBeta {
    /**
     * the id of approver
     * @type {string}
     * @memberof ApprovalInfoResponseBeta
     */
    'id'?: string;
    /**
     * the name of approver
     * @type {string}
     * @memberof ApprovalInfoResponseBeta
     */
    'name'?: string;
    /**
     * the status of the approval request
     * @type {string}
     * @memberof ApprovalInfoResponseBeta
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ApprovalItemDetailsBeta
 */
export interface ApprovalItemDetailsBeta {
    /**
     * The approval item\'s ID
     * @type {string}
     * @memberof ApprovalItemDetailsBeta
     */
    'id'?: string;
    /**
     * The account referenced by the approval item
     * @type {string}
     * @memberof ApprovalItemDetailsBeta
     */
    'account'?: string;
    /**
     * The name of the application/source
     * @type {string}
     * @memberof ApprovalItemDetailsBeta
     */
    'application'?: string;
    /**
     * The attribute\'s name
     * @type {string}
     * @memberof ApprovalItemDetailsBeta
     */
    'name'?: string;
    /**
     * The attribute\'s operation
     * @type {string}
     * @memberof ApprovalItemDetailsBeta
     */
    'operation'?: string;
    /**
     * The attribute\'s value
     * @type {string}
     * @memberof ApprovalItemDetailsBeta
     */
    'value'?: string;
    /**
     * 
     * @type {WorkItemStateBeta}
     * @memberof ApprovalItemDetailsBeta
     */
    'state'?: WorkItemStateBeta;
}
/**
 * 
 * @export
 * @interface ApprovalItemsBeta
 */
export interface ApprovalItemsBeta {
    /**
     * The approval item\'s ID
     * @type {string}
     * @memberof ApprovalItemsBeta
     */
    'id'?: string;
    /**
     * The account referenced by the approval item
     * @type {string}
     * @memberof ApprovalItemsBeta
     */
    'account'?: string;
    /**
     * The name of the application/source
     * @type {string}
     * @memberof ApprovalItemsBeta
     */
    'application'?: string;
    /**
     * The attribute\'s name
     * @type {string}
     * @memberof ApprovalItemsBeta
     */
    'name'?: string;
    /**
     * The attribute\'s operation
     * @type {string}
     * @memberof ApprovalItemsBeta
     */
    'operation'?: string;
    /**
     * The attribute\'s value
     * @type {string}
     * @memberof ApprovalItemsBeta
     */
    'value'?: string;
    /**
     * 
     * @type {WorkItemStateBeta}
     * @memberof ApprovalItemsBeta
     */
    'state'?: WorkItemStateBeta;
}
/**
 * 
 * @export
 * @interface ApprovalReminderAndEscalationConfigBeta
 */
export interface ApprovalReminderAndEscalationConfigBeta {
    /**
     * Number of days to wait before the first reminder. If no reminders are configured, then this is the number of days to wait before escalation.
     * @type {number}
     * @memberof ApprovalReminderAndEscalationConfigBeta
     */
    'daysUntilEscalation'?: number;
    /**
     * Number of days to wait between reminder notifications.
     * @type {number}
     * @memberof ApprovalReminderAndEscalationConfigBeta
     */
    'daysBetweenReminders'?: number;
    /**
     * Maximum number of reminder notification to send to the reviewer before approval escalation. This will only be a positive number.
     * @type {number}
     * @memberof ApprovalReminderAndEscalationConfigBeta
     */
    'maxReminders'?: number;
    /**
     * 
     * @type {IdentityReferenceWithNameAndEmailBeta}
     * @memberof ApprovalReminderAndEscalationConfigBeta
     */
    'fallbackApproverRef'?: IdentityReferenceWithNameAndEmailBeta | null;
}
/**
 * Describes the individual or group that is responsible for an approval step.
 * @export
 * @enum {string}
 */

export const ApprovalSchemeBeta = {
    AppOwner: 'APP_OWNER',
    SourceOwner: 'SOURCE_OWNER',
    Manager: 'MANAGER',
    RoleOwner: 'ROLE_OWNER',
    AccessProfileOwner: 'ACCESS_PROFILE_OWNER',
    EntitlementOwner: 'ENTITLEMENT_OWNER',
    GovernanceGroup: 'GOVERNANCE_GROUP'
} as const;

export type ApprovalSchemeBeta = typeof ApprovalSchemeBeta[keyof typeof ApprovalSchemeBeta];


/**
 * 
 * @export
 * @interface ApprovalSchemeForRoleBeta
 */
export interface ApprovalSchemeForRoleBeta {
    /**
     * Describes the individual or group that is responsible for an approval step. Values are as follows.  **OWNER**: Owner of the associated Role  **MANAGER**: Manager of the Identity making the request  **GOVERNANCE_GROUP**: A Governance Group, the ID of which is specified by the **approverId** field
     * @type {string}
     * @memberof ApprovalSchemeForRoleBeta
     */
    'approverType'?: ApprovalSchemeForRoleBetaApproverTypeEnum;
    /**
     * Id of the specific approver, used only when approverType is GOVERNANCE_GROUP
     * @type {string}
     * @memberof ApprovalSchemeForRoleBeta
     */
    'approverId'?: string | null;
}

export const ApprovalSchemeForRoleBetaApproverTypeEnum = {
    Owner: 'OWNER',
    Manager: 'MANAGER',
    GovernanceGroup: 'GOVERNANCE_GROUP'
} as const;

export type ApprovalSchemeForRoleBetaApproverTypeEnum = typeof ApprovalSchemeForRoleBetaApproverTypeEnum[keyof typeof ApprovalSchemeForRoleBetaApproverTypeEnum];

/**
 * Enum representing the non-employee request approval status
 * @export
 * @enum {string}
 */

export const ApprovalStatusBeta = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    Pending: 'PENDING',
    NotReady: 'NOT_READY',
    Cancelled: 'CANCELLED'
} as const;

export type ApprovalStatusBeta = typeof ApprovalStatusBeta[keyof typeof ApprovalStatusBeta];


/**
 * 
 * @export
 * @interface ApprovalStatusDtoBeta
 */
export interface ApprovalStatusDtoBeta {
    /**
     * True if the request for this item was forwarded from one owner to another.
     * @type {boolean}
     * @memberof ApprovalStatusDtoBeta
     */
    'forwarded'?: boolean;
    /**
     * 
     * @type {BaseReferenceDto1Beta}
     * @memberof ApprovalStatusDtoBeta
     */
    'originalOwner'?: BaseReferenceDto1Beta;
    /**
     * 
     * @type {BaseReferenceDto1Beta}
     * @memberof ApprovalStatusDtoBeta
     */
    'currentOwner'?: BaseReferenceDto1Beta;
    /**
     * 
     * @type {BaseReferenceDto1Beta}
     * @memberof ApprovalStatusDtoBeta
     */
    'reviewedBy'?: BaseReferenceDto1Beta;
    /**
     * Time at which item was modified.
     * @type {string}
     * @memberof ApprovalStatusDtoBeta
     */
    'modified'?: string;
    /**
     * 
     * @type {ManualWorkItemStateBeta}
     * @memberof ApprovalStatusDtoBeta
     */
    'status'?: ManualWorkItemStateBeta;
    /**
     * 
     * @type {ApprovalSchemeBeta}
     * @memberof ApprovalStatusDtoBeta
     */
    'scheme'?: ApprovalSchemeBeta;
    /**
     * If the request failed, includes any error messages that were generated.
     * @type {Array<ErrorMessageDtoBeta>}
     * @memberof ApprovalStatusDtoBeta
     */
    'errorMessages'?: Array<ErrorMessageDtoBeta>;
    /**
     * Comment, if any, provided by the approver.
     * @type {string}
     * @memberof ApprovalStatusDtoBeta
     */
    'comment'?: string;
    /**
     * The date the role or access profile is no longer assigned to the specified identity.
     * @type {string}
     * @memberof ApprovalStatusDtoBeta
     */
    'removeDate'?: string;
}
/**
 * 
 * @export
 * @interface ApprovalSummaryBeta
 */
export interface ApprovalSummaryBeta {
    /**
     * The number of pending access requests approvals.
     * @type {number}
     * @memberof ApprovalSummaryBeta
     */
    'pending'?: number;
    /**
     * The number of approved access requests approvals.
     * @type {number}
     * @memberof ApprovalSummaryBeta
     */
    'approved'?: number;
    /**
     * The number of rejected access requests approvals.
     * @type {number}
     * @memberof ApprovalSummaryBeta
     */
    'rejected'?: number;
}
/**
 * 
 * @export
 * @interface ArgumentBeta
 */
export interface ArgumentBeta {
    /**
     * the name of the argument
     * @type {string}
     * @memberof ArgumentBeta
     */
    'name': string;
    /**
     * the description of the argument
     * @type {string}
     * @memberof ArgumentBeta
     */
    'description'?: string;
    /**
     * the programmatic type of the argument
     * @type {string}
     * @memberof ArgumentBeta
     */
    'type'?: string | null;
}
/**
 * Specification of source attribute sync mapping configuration for an identity attribute
 * @export
 * @interface AttrSyncSourceAttributeConfigBeta
 */
export interface AttrSyncSourceAttributeConfigBeta {
    /**
     * Name of the identity attribute
     * @type {string}
     * @memberof AttrSyncSourceAttributeConfigBeta
     */
    'name': string;
    /**
     * Display name of the identity attribute
     * @type {string}
     * @memberof AttrSyncSourceAttributeConfigBeta
     */
    'displayName': string;
    /**
     * Determines whether or not the attribute is enabled for synchronization
     * @type {boolean}
     * @memberof AttrSyncSourceAttributeConfigBeta
     */
    'enabled': boolean;
    /**
     * Name of the source account attribute to which the identity attribute value will be synchronized if enabled
     * @type {string}
     * @memberof AttrSyncSourceAttributeConfigBeta
     */
    'target': string;
}
/**
 * Specification of attribute sync configuration for a source
 * @export
 * @interface AttrSyncSourceConfigBeta
 */
export interface AttrSyncSourceConfigBeta {
    /**
     * 
     * @type {BaseReferenceDto1Beta}
     * @memberof AttrSyncSourceConfigBeta
     */
    'source': BaseReferenceDto1Beta;
    /**
     * Attribute synchronization configuration for specific identity attributes in the context of a source
     * @type {Array<AttrSyncSourceAttributeConfigBeta>}
     * @memberof AttrSyncSourceConfigBeta
     */
    'attributes': Array<AttrSyncSourceAttributeConfigBeta>;
}
/**
 * 
 * @export
 * @interface AttributeChangeBeta
 */
export interface AttributeChangeBeta {
    /**
     * the attribute name
     * @type {string}
     * @memberof AttributeChangeBeta
     */
    'name'?: string;
    /**
     * the old value of attribute
     * @type {string}
     * @memberof AttributeChangeBeta
     */
    'previousValue'?: string;
    /**
     * the new value of attribute
     * @type {string}
     * @memberof AttributeChangeBeta
     */
    'newValue'?: string;
}
/**
 * 
 * @export
 * @interface AttributeDefinitionBeta
 */
export interface AttributeDefinitionBeta {
    /**
     * The name of the attribute.
     * @type {string}
     * @memberof AttributeDefinitionBeta
     */
    'name'?: string;
    /**
     * 
     * @type {AttributeDefinitionTypeBeta}
     * @memberof AttributeDefinitionBeta
     */
    'type'?: AttributeDefinitionTypeBeta;
    /**
     * 
     * @type {AttributeDefinitionSchemaBeta}
     * @memberof AttributeDefinitionBeta
     */
    'schema'?: AttributeDefinitionSchemaBeta;
    /**
     * A human-readable description of the attribute.
     * @type {string}
     * @memberof AttributeDefinitionBeta
     */
    'description'?: string;
    /**
     * Flag indicating whether or not the attribute is multi-valued.
     * @type {boolean}
     * @memberof AttributeDefinitionBeta
     */
    'isMulti'?: boolean;
    /**
     * Flag indicating whether or not the attribute is an entitlement.
     * @type {boolean}
     * @memberof AttributeDefinitionBeta
     */
    'isEntitlement'?: boolean;
    /**
     * Flag indicating whether or not the attribute represents a group. This can only be `true` if `isEntitlement` is also `true` **and** there is a schema defined for the attribute. 
     * @type {boolean}
     * @memberof AttributeDefinitionBeta
     */
    'isGroup'?: boolean;
}
/**
 * A reference to the schema on the source to the attribute values map to.
 * @export
 * @interface AttributeDefinitionSchemaBeta
 */
export interface AttributeDefinitionSchemaBeta {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof AttributeDefinitionSchemaBeta
     */
    'type'?: AttributeDefinitionSchemaBetaTypeEnum;
    /**
     * The object ID this reference applies to.
     * @type {string}
     * @memberof AttributeDefinitionSchemaBeta
     */
    'id'?: string;
    /**
     * The human-readable display name of the object.
     * @type {string}
     * @memberof AttributeDefinitionSchemaBeta
     */
    'name'?: string;
}

export const AttributeDefinitionSchemaBetaTypeEnum = {
    ConnectorSchema: 'CONNECTOR_SCHEMA'
} as const;

export type AttributeDefinitionSchemaBetaTypeEnum = typeof AttributeDefinitionSchemaBetaTypeEnum[keyof typeof AttributeDefinitionSchemaBetaTypeEnum];

/**
 * The underlying type of the value which an AttributeDefinition represents.
 * @export
 * @enum {string}
 */

export const AttributeDefinitionTypeBeta = {
    String: 'STRING',
    Long: 'LONG',
    Int: 'INT',
    Boolean: 'BOOLEAN'
} as const;

export type AttributeDefinitionTypeBeta = typeof AttributeDefinitionTypeBeta[keyof typeof AttributeDefinitionTypeBeta];


/**
 * 
 * @export
 * @interface AttributesChangedBeta
 */
export interface AttributesChangedBeta {
    /**
     * 
     * @type {Array<AttributeChangeBeta>}
     * @memberof AttributesChangedBeta
     */
    'changes'?: Array<AttributeChangeBeta>;
    /**
     * the event type
     * @type {string}
     * @memberof AttributesChangedBeta
     */
    'eventType'?: string;
    /**
     * the identity id
     * @type {string}
     * @memberof AttributesChangedBeta
     */
    'identityId'?: string;
    /**
     * the date of event
     * @type {string}
     * @memberof AttributesChangedBeta
     */
    'dt'?: string;
}
/**
 * Audit details for the reassignment configuration of an identity
 * @export
 * @interface AuditDetailsBeta
 */
export interface AuditDetailsBeta {
    /**
     * Initial date and time when the record was created
     * @type {string}
     * @memberof AuditDetailsBeta
     */
    'created'?: string;
    /**
     * 
     * @type {Identity1Beta}
     * @memberof AuditDetailsBeta
     */
    'createdBy'?: Identity1Beta;
    /**
     * Last modified date and time for the record
     * @type {string}
     * @memberof AuditDetailsBeta
     */
    'modified'?: string;
    /**
     * 
     * @type {Identity1Beta}
     * @memberof AuditDetailsBeta
     */
    'modifiedBy'?: Identity1Beta;
}
/**
 * 
 * @export
 * @interface BaseCommonDto1Beta
 */
export interface BaseCommonDto1Beta {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof BaseCommonDto1Beta
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof BaseCommonDto1Beta
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof BaseCommonDto1Beta
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof BaseCommonDto1Beta
     */
    'modified'?: string;
}
/**
 * 
 * @export
 * @interface BaseCommonDtoBeta
 */
export interface BaseCommonDtoBeta {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof BaseCommonDtoBeta
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof BaseCommonDtoBeta
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof BaseCommonDtoBeta
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof BaseCommonDtoBeta
     */
    'modified'?: string;
}
/**
 * 
 * @export
 * @interface BaseReferenceDto1Beta
 */
export interface BaseReferenceDto1Beta {
    /**
     * 
     * @type {DtoTypeBeta}
     * @memberof BaseReferenceDto1Beta
     */
    'type'?: DtoTypeBeta;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof BaseReferenceDto1Beta
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof BaseReferenceDto1Beta
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface BaseReferenceDtoBeta
 */
export interface BaseReferenceDtoBeta {
    /**
     * the application ID
     * @type {string}
     * @memberof BaseReferenceDtoBeta
     */
    'id'?: string;
    /**
     * the application name
     * @type {string}
     * @memberof BaseReferenceDtoBeta
     */
    'name'?: string;
}
/**
 * Config required if BASIC_AUTH is used.
 * @export
 * @interface BasicAuthConfigBeta
 */
export interface BasicAuthConfigBeta {
    /**
     * The username to authenticate.
     * @type {string}
     * @memberof BasicAuthConfigBeta
     */
    'userName'?: string;
    /**
     * The password to authenticate. On response, this field is set to null as to not return secrets.
     * @type {string}
     * @memberof BasicAuthConfigBeta
     */
    'password'?: string | null;
}
/**
 * Config required if BEARER_TOKEN authentication is used. On response, this field is set to null as to not return secrets.
 * @export
 * @interface BearerTokenAuthConfigBeta
 */
export interface BearerTokenAuthConfigBeta {
    /**
     * Bearer token
     * @type {string}
     * @memberof BearerTokenAuthConfigBeta
     */
    'bearerToken'?: string | null;
}
/**
 * Bulk response object.
 * @export
 * @interface BulkIdentitiesAccountsResponseBeta
 */
export interface BulkIdentitiesAccountsResponseBeta {
    /**
     * Identifier of bulk request item.
     * @type {string}
     * @memberof BulkIdentitiesAccountsResponseBeta
     */
    'id'?: string;
    /**
     * Response status value.
     * @type {number}
     * @memberof BulkIdentitiesAccountsResponseBeta
     */
    'statusCode'?: number;
    /**
     * Status containing additional context information about failures.
     * @type {string}
     * @memberof BulkIdentitiesAccountsResponseBeta
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface BulkTaggedObjectBeta
 */
export interface BulkTaggedObjectBeta {
    /**
     * 
     * @type {Array<BaseReferenceDto1Beta>}
     * @memberof BulkTaggedObjectBeta
     */
    'objectRefs'?: Array<BaseReferenceDto1Beta>;
    /**
     * Label to be applied to an Object
     * @type {Array<string>}
     * @memberof BulkTaggedObjectBeta
     */
    'tags'?: Array<string>;
    /**
     * If APPEND, tags are appended to the list of tags for the object. A 400 error is returned if this would add duplicate tags to the object.  If MERGE, tags are merged with the existing tags. Duplicate tags are silently ignored.
     * @type {string}
     * @memberof BulkTaggedObjectBeta
     */
    'operation'?: BulkTaggedObjectBetaOperationEnum;
}

export const BulkTaggedObjectBetaOperationEnum = {
    Append: 'APPEND',
    Merge: 'MERGE'
} as const;

export type BulkTaggedObjectBetaOperationEnum = typeof BulkTaggedObjectBetaOperationEnum[keyof typeof BulkTaggedObjectBetaOperationEnum];

/**
 * 
 * @export
 * @interface CampaignActivatedBeta
 */
export interface CampaignActivatedBeta {
    /**
     * 
     * @type {CampaignActivatedCampaignBeta}
     * @memberof CampaignActivatedBeta
     */
    'campaign': CampaignActivatedCampaignBeta;
}
/**
 * Details about the certification campaign that was activated.
 * @export
 * @interface CampaignActivatedCampaignBeta
 */
export interface CampaignActivatedCampaignBeta {
    /**
     * Unique ID for the campaign.
     * @type {string}
     * @memberof CampaignActivatedCampaignBeta
     */
    'id': string;
    /**
     * The human friendly name of the campaign.
     * @type {string}
     * @memberof CampaignActivatedCampaignBeta
     */
    'name': string;
    /**
     * Extended description of the campaign.
     * @type {string}
     * @memberof CampaignActivatedCampaignBeta
     */
    'description': string;
    /**
     * The date and time the campaign was created.
     * @type {string}
     * @memberof CampaignActivatedCampaignBeta
     */
    'created': string;
    /**
     * The date and time the campaign was last modified.
     * @type {string}
     * @memberof CampaignActivatedCampaignBeta
     */
    'modified'?: string | null;
    /**
     * The date and time the campaign is due.
     * @type {string}
     * @memberof CampaignActivatedCampaignBeta
     */
    'deadline': string;
    /**
     * The type of campaign.
     * @type {object}
     * @memberof CampaignActivatedCampaignBeta
     */
    'type': CampaignActivatedCampaignBetaTypeEnum;
    /**
     * 
     * @type {CampaignActivatedCampaignCampaignOwnerBeta}
     * @memberof CampaignActivatedCampaignBeta
     */
    'campaignOwner': CampaignActivatedCampaignCampaignOwnerBeta;
    /**
     * The current status of the campaign.
     * @type {object}
     * @memberof CampaignActivatedCampaignBeta
     */
    'status': CampaignActivatedCampaignBetaStatusEnum;
}

export const CampaignActivatedCampaignBetaTypeEnum = {
    Manager: 'MANAGER',
    SourceOwner: 'SOURCE_OWNER',
    Search: 'SEARCH',
    RoleComposition: 'ROLE_COMPOSITION'
} as const;

export type CampaignActivatedCampaignBetaTypeEnum = typeof CampaignActivatedCampaignBetaTypeEnum[keyof typeof CampaignActivatedCampaignBetaTypeEnum];
export const CampaignActivatedCampaignBetaStatusEnum = {
    Active: 'ACTIVE'
} as const;

export type CampaignActivatedCampaignBetaStatusEnum = typeof CampaignActivatedCampaignBetaStatusEnum[keyof typeof CampaignActivatedCampaignBetaStatusEnum];

/**
 * Details of the identity that owns the campaign.
 * @export
 * @interface CampaignActivatedCampaignCampaignOwnerBeta
 */
export interface CampaignActivatedCampaignCampaignOwnerBeta {
    /**
     * The unique ID of the identity.
     * @type {string}
     * @memberof CampaignActivatedCampaignCampaignOwnerBeta
     */
    'id': string;
    /**
     * The human friendly name of the identity.
     * @type {string}
     * @memberof CampaignActivatedCampaignCampaignOwnerBeta
     */
    'displayName': string;
    /**
     * The primary email address of the identity.
     * @type {string}
     * @memberof CampaignActivatedCampaignCampaignOwnerBeta
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface CampaignAlertBeta
 */
export interface CampaignAlertBeta {
    /**
     * Denotes the level of the message
     * @type {string}
     * @memberof CampaignAlertBeta
     */
    'level'?: CampaignAlertBetaLevelEnum;
    /**
     * 
     * @type {Array<ErrorMessageDtoBeta>}
     * @memberof CampaignAlertBeta
     */
    'localizations'?: Array<ErrorMessageDtoBeta>;
}

export const CampaignAlertBetaLevelEnum = {
    Error: 'ERROR',
    Warn: 'WARN',
    Info: 'INFO'
} as const;

export type CampaignAlertBetaLevelEnum = typeof CampaignAlertBetaLevelEnum[keyof typeof CampaignAlertBetaLevelEnum];

/**
 * 
 * @export
 * @interface CampaignBeta
 */
export interface CampaignBeta {
    /**
     * Id of the campaign
     * @type {string}
     * @memberof CampaignBeta
     */
    'id'?: string;
    /**
     * The campaign name. If this object is part of a template, special formatting applies; see the `/campaign-templates/{id}/generate` endpoint documentation for details.
     * @type {string}
     * @memberof CampaignBeta
     */
    'name': string;
    /**
     * The campaign description. If this object is part of a template, special formatting applies; see the `/campaign-templates/{id}/generate` endpoint documentation for details.
     * @type {string}
     * @memberof CampaignBeta
     */
    'description': string;
    /**
     * The campaign\'s completion deadline.
     * @type {string}
     * @memberof CampaignBeta
     */
    'deadline'?: string;
    /**
     * The type of campaign. Could be extended in the future.
     * @type {string}
     * @memberof CampaignBeta
     */
    'type': CampaignBetaTypeEnum;
    /**
     * Enables email notification for this campaign
     * @type {boolean}
     * @memberof CampaignBeta
     */
    'emailNotificationEnabled'?: boolean;
    /**
     * Allows auto revoke for this campaign
     * @type {boolean}
     * @memberof CampaignBeta
     */
    'autoRevokeAllowed'?: boolean;
    /**
     * Enables IAI for this campaign. Accepts true even if the IAI product feature is off. If IAI is turned off then campaigns generated from this template will indicate false. The real value will then be returned if IAI is ever enabled for the org in the future.
     * @type {boolean}
     * @memberof CampaignBeta
     */
    'recommendationsEnabled'?: boolean;
    /**
     * The campaign\'s current status.
     * @type {string}
     * @memberof CampaignBeta
     */
    'status'?: CampaignBetaStatusEnum;
    /**
     * The correlatedStatus of the campaign. Only SOURCE_OWNER campaigns can be Uncorrelated. An Uncorrelated certification campaign only includes Uncorrelated identities (An identity is uncorrelated if it has no accounts on an authoritative source).
     * @type {object}
     * @memberof CampaignBeta
     */
    'correlatedStatus'?: CampaignBetaCorrelatedStatusEnum;
    /**
     * Created time of the campaign
     * @type {string}
     * @memberof CampaignBeta
     */
    'created'?: string;
    /**
     * Modified time of the campaign
     * @type {string}
     * @memberof CampaignBeta
     */
    'modified'?: string;
    /**
     * 
     * @type {FullcampaignAllOfFilterBeta}
     * @memberof CampaignBeta
     */
    'filter'?: FullcampaignAllOfFilterBeta;
    /**
     * Determines if comments on sunset date changes are required.
     * @type {boolean}
     * @memberof CampaignBeta
     */
    'sunsetCommentsRequired'?: boolean;
    /**
     * 
     * @type {FullcampaignAllOfSourceOwnerCampaignInfoBeta}
     * @memberof CampaignBeta
     */
    'sourceOwnerCampaignInfo'?: FullcampaignAllOfSourceOwnerCampaignInfoBeta;
    /**
     * 
     * @type {FullcampaignAllOfSearchCampaignInfoBeta}
     * @memberof CampaignBeta
     */
    'searchCampaignInfo'?: FullcampaignAllOfSearchCampaignInfoBeta;
    /**
     * 
     * @type {FullcampaignAllOfRoleCompositionCampaignInfoBeta}
     * @memberof CampaignBeta
     */
    'roleCompositionCampaignInfo'?: FullcampaignAllOfRoleCompositionCampaignInfoBeta;
    /**
     * A list of errors and warnings that have accumulated.
     * @type {Array<CampaignAlertBeta>}
     * @memberof CampaignBeta
     */
    'alerts'?: Array<CampaignAlertBeta>;
    /**
     * The total number of certifications in this campaign.
     * @type {number}
     * @memberof CampaignBeta
     */
    'totalCertifications'?: number;
    /**
     * The number of completed certifications in this campaign.
     * @type {number}
     * @memberof CampaignBeta
     */
    'completedCertifications'?: number;
    /**
     * A list of sources in the campaign that contain \\\"orphan entitlements\\\" (entitlements without a corresponding Managed Attribute). An empty list indicates the campaign has no orphan entitlements. Null indicates there may be unknown orphan entitlements in the campaign (the campaign was created before this feature was implemented).
     * @type {Array<FullcampaignAllOfSourcesWithOrphanEntitlementsBeta>}
     * @memberof CampaignBeta
     */
    'sourcesWithOrphanEntitlements'?: Array<FullcampaignAllOfSourcesWithOrphanEntitlementsBeta>;
    /**
     * Determines whether comments are required for decisions during certification reviews. You can require comments for all decisions, revoke-only decisions, or no decisions. By default, comments are not required for decisions.
     * @type {string}
     * @memberof CampaignBeta
     */
    'mandatoryCommentRequirement'?: CampaignBetaMandatoryCommentRequirementEnum;
}

export const CampaignBetaTypeEnum = {
    Manager: 'MANAGER',
    SourceOwner: 'SOURCE_OWNER',
    Search: 'SEARCH',
    RoleComposition: 'ROLE_COMPOSITION'
} as const;

export type CampaignBetaTypeEnum = typeof CampaignBetaTypeEnum[keyof typeof CampaignBetaTypeEnum];
export const CampaignBetaStatusEnum = {
    Pending: 'PENDING',
    Staged: 'STAGED',
    Canceling: 'CANCELING',
    Activating: 'ACTIVATING',
    Active: 'ACTIVE',
    Completing: 'COMPLETING',
    Completed: 'COMPLETED',
    Error: 'ERROR',
    Archived: 'ARCHIVED'
} as const;

export type CampaignBetaStatusEnum = typeof CampaignBetaStatusEnum[keyof typeof CampaignBetaStatusEnum];
export const CampaignBetaCorrelatedStatusEnum = {
    Correlated: 'CORRELATED',
    Uncorrelated: 'UNCORRELATED'
} as const;

export type CampaignBetaCorrelatedStatusEnum = typeof CampaignBetaCorrelatedStatusEnum[keyof typeof CampaignBetaCorrelatedStatusEnum];
export const CampaignBetaMandatoryCommentRequirementEnum = {
    AllDecisions: 'ALL_DECISIONS',
    RevokeOnlyDecisions: 'REVOKE_ONLY_DECISIONS',
    NoDecisions: 'NO_DECISIONS'
} as const;

export type CampaignBetaMandatoryCommentRequirementEnum = typeof CampaignBetaMandatoryCommentRequirementEnum[keyof typeof CampaignBetaMandatoryCommentRequirementEnum];

/**
 * 
 * @export
 * @interface CampaignEndedBeta
 */
export interface CampaignEndedBeta {
    /**
     * 
     * @type {CampaignEndedCampaignBeta}
     * @memberof CampaignEndedBeta
     */
    'campaign': CampaignEndedCampaignBeta;
}
/**
 * Details about the certification campaign that ended.
 * @export
 * @interface CampaignEndedCampaignBeta
 */
export interface CampaignEndedCampaignBeta {
    /**
     * Unique ID for the campaign.
     * @type {string}
     * @memberof CampaignEndedCampaignBeta
     */
    'id': string;
    /**
     * The human friendly name of the campaign.
     * @type {string}
     * @memberof CampaignEndedCampaignBeta
     */
    'name': string;
    /**
     * Extended description of the campaign.
     * @type {string}
     * @memberof CampaignEndedCampaignBeta
     */
    'description': string;
    /**
     * The date and time the campaign was created.
     * @type {string}
     * @memberof CampaignEndedCampaignBeta
     */
    'created': string;
    /**
     * The date and time the campaign was last modified.
     * @type {string}
     * @memberof CampaignEndedCampaignBeta
     */
    'modified'?: string | null;
    /**
     * The date and time the campaign is due.
     * @type {string}
     * @memberof CampaignEndedCampaignBeta
     */
    'deadline': string;
    /**
     * The type of campaign.
     * @type {object}
     * @memberof CampaignEndedCampaignBeta
     */
    'type': CampaignEndedCampaignBetaTypeEnum;
    /**
     * 
     * @type {CampaignActivatedCampaignCampaignOwnerBeta}
     * @memberof CampaignEndedCampaignBeta
     */
    'campaignOwner': CampaignActivatedCampaignCampaignOwnerBeta;
    /**
     * The current status of the campaign.
     * @type {object}
     * @memberof CampaignEndedCampaignBeta
     */
    'status': CampaignEndedCampaignBetaStatusEnum;
}

export const CampaignEndedCampaignBetaTypeEnum = {
    Manager: 'MANAGER',
    SourceOwner: 'SOURCE_OWNER',
    Search: 'SEARCH',
    RoleComposition: 'ROLE_COMPOSITION'
} as const;

export type CampaignEndedCampaignBetaTypeEnum = typeof CampaignEndedCampaignBetaTypeEnum[keyof typeof CampaignEndedCampaignBetaTypeEnum];
export const CampaignEndedCampaignBetaStatusEnum = {
    Completed: 'COMPLETED'
} as const;

export type CampaignEndedCampaignBetaStatusEnum = typeof CampaignEndedCampaignBetaStatusEnum[keyof typeof CampaignEndedCampaignBetaStatusEnum];

/**
 * 
 * @export
 * @interface CampaignGeneratedBeta
 */
export interface CampaignGeneratedBeta {
    /**
     * 
     * @type {CampaignGeneratedCampaignBeta}
     * @memberof CampaignGeneratedBeta
     */
    'campaign': CampaignGeneratedCampaignBeta;
}
/**
 * Details about the campaign that was generated.
 * @export
 * @interface CampaignGeneratedCampaignBeta
 */
export interface CampaignGeneratedCampaignBeta {
    /**
     * The unique ID of the campaign.
     * @type {string}
     * @memberof CampaignGeneratedCampaignBeta
     */
    'id': string;
    /**
     * Human friendly name of the campaign.
     * @type {string}
     * @memberof CampaignGeneratedCampaignBeta
     */
    'name': string;
    /**
     * Extended description of the campaign.
     * @type {string}
     * @memberof CampaignGeneratedCampaignBeta
     */
    'description': string;
    /**
     * The date and time the campaign was created.
     * @type {string}
     * @memberof CampaignGeneratedCampaignBeta
     */
    'created': string;
    /**
     * The date and time the campaign was last modified.
     * @type {string}
     * @memberof CampaignGeneratedCampaignBeta
     */
    'modified'?: string | null;
    /**
     * The date and time when the campaign must be finished by.
     * @type {string}
     * @memberof CampaignGeneratedCampaignBeta
     */
    'deadline'?: string | null;
    /**
     * The type of campaign that was generated.
     * @type {object}
     * @memberof CampaignGeneratedCampaignBeta
     */
    'type': CampaignGeneratedCampaignBetaTypeEnum;
    /**
     * 
     * @type {CampaignGeneratedCampaignCampaignOwnerBeta}
     * @memberof CampaignGeneratedCampaignBeta
     */
    'campaignOwner': CampaignGeneratedCampaignCampaignOwnerBeta;
    /**
     * The current status of the campaign.
     * @type {object}
     * @memberof CampaignGeneratedCampaignBeta
     */
    'status': CampaignGeneratedCampaignBetaStatusEnum;
}

export const CampaignGeneratedCampaignBetaTypeEnum = {
    Manager: 'MANAGER',
    SourceOwner: 'SOURCE_OWNER',
    Search: 'SEARCH',
    RoleComposition: 'ROLE_COMPOSITION'
} as const;

export type CampaignGeneratedCampaignBetaTypeEnum = typeof CampaignGeneratedCampaignBetaTypeEnum[keyof typeof CampaignGeneratedCampaignBetaTypeEnum];
export const CampaignGeneratedCampaignBetaStatusEnum = {
    Staged: 'STAGED',
    Activating: 'ACTIVATING',
    Active: 'ACTIVE'
} as const;

export type CampaignGeneratedCampaignBetaStatusEnum = typeof CampaignGeneratedCampaignBetaStatusEnum[keyof typeof CampaignGeneratedCampaignBetaStatusEnum];

/**
 * The identity that owns the campaign.
 * @export
 * @interface CampaignGeneratedCampaignCampaignOwnerBeta
 */
export interface CampaignGeneratedCampaignCampaignOwnerBeta {
    /**
     * The unique ID of the identity.
     * @type {string}
     * @memberof CampaignGeneratedCampaignCampaignOwnerBeta
     */
    'id': string;
    /**
     * The display name of the identity.
     * @type {string}
     * @memberof CampaignGeneratedCampaignCampaignOwnerBeta
     */
    'displayName': string;
    /**
     * The primary email address of the identity.
     * @type {string}
     * @memberof CampaignGeneratedCampaignCampaignOwnerBeta
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface CampaignReferenceBeta
 */
export interface CampaignReferenceBeta {
    /**
     * The unique ID of the campaign.
     * @type {string}
     * @memberof CampaignReferenceBeta
     */
    'id': string;
    /**
     * The name of the campaign.
     * @type {string}
     * @memberof CampaignReferenceBeta
     */
    'name': string;
    /**
     * The type of object that is being referenced.
     * @type {string}
     * @memberof CampaignReferenceBeta
     */
    'type': CampaignReferenceBetaTypeEnum;
    /**
     * The type of the campaign.
     * @type {string}
     * @memberof CampaignReferenceBeta
     */
    'campaignType': CampaignReferenceBetaCampaignTypeEnum;
    /**
     * The description of the campaign set by the admin who created it.
     * @type {string}
     * @memberof CampaignReferenceBeta
     */
    'description': string | null;
    /**
     * The correlatedStatus of the campaign. Only SOURCE_OWNER campaigns can be Uncorrelated. An Uncorrelated certification campaign only includes Uncorrelated identities (An identity is uncorrelated if it has no accounts on an authoritative source).
     * @type {object}
     * @memberof CampaignReferenceBeta
     */
    'correlatedStatus': CampaignReferenceBetaCorrelatedStatusEnum;
    /**
     * Determines whether comments are required for decisions during certification reviews. You can require comments for all decisions, revoke-only decisions, or no decisions. By default, comments are not required for decisions.
     * @type {string}
     * @memberof CampaignReferenceBeta
     */
    'mandatoryCommentRequirement': CampaignReferenceBetaMandatoryCommentRequirementEnum;
}

export const CampaignReferenceBetaTypeEnum = {
    Campaign: 'CAMPAIGN'
} as const;

export type CampaignReferenceBetaTypeEnum = typeof CampaignReferenceBetaTypeEnum[keyof typeof CampaignReferenceBetaTypeEnum];
export const CampaignReferenceBetaCampaignTypeEnum = {
    Manager: 'MANAGER',
    SourceOwner: 'SOURCE_OWNER',
    Search: 'SEARCH'
} as const;

export type CampaignReferenceBetaCampaignTypeEnum = typeof CampaignReferenceBetaCampaignTypeEnum[keyof typeof CampaignReferenceBetaCampaignTypeEnum];
export const CampaignReferenceBetaCorrelatedStatusEnum = {
    Correlated: 'CORRELATED',
    Uncorrelated: 'UNCORRELATED'
} as const;

export type CampaignReferenceBetaCorrelatedStatusEnum = typeof CampaignReferenceBetaCorrelatedStatusEnum[keyof typeof CampaignReferenceBetaCorrelatedStatusEnum];
export const CampaignReferenceBetaMandatoryCommentRequirementEnum = {
    AllDecisions: 'ALL_DECISIONS',
    RevokeOnlyDecisions: 'REVOKE_ONLY_DECISIONS',
    NoDecisions: 'NO_DECISIONS'
} as const;

export type CampaignReferenceBetaMandatoryCommentRequirementEnum = typeof CampaignReferenceBetaMandatoryCommentRequirementEnum[keyof typeof CampaignReferenceBetaMandatoryCommentRequirementEnum];

/**
 * 
 * @export
 * @interface CampaignReportAllOfBeta
 */
export interface CampaignReportAllOfBeta {
    /**
     * 
     * @type {ReportTypeBeta}
     * @memberof CampaignReportAllOfBeta
     */
    'reportType'?: ReportTypeBeta;
    /**
     * The most recent date and time this report was run
     * @type {string}
     * @memberof CampaignReportAllOfBeta
     */
    'lastRunAt'?: string;
}
/**
 * 
 * @export
 * @interface CampaignReportBeta
 */
export interface CampaignReportBeta {
    /**
     * 
     * @type {DtoTypeBeta}
     * @memberof CampaignReportBeta
     */
    'type'?: DtoTypeBeta;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof CampaignReportBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof CampaignReportBeta
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CampaignReportBeta
     */
    'status'?: CampaignReportBetaStatusEnum;
    /**
     * 
     * @type {ReportTypeBeta}
     * @memberof CampaignReportBeta
     */
    'reportType': ReportTypeBeta;
    /**
     * The most recent date and time this report was run
     * @type {string}
     * @memberof CampaignReportBeta
     */
    'lastRunAt'?: string;
}

export const CampaignReportBetaStatusEnum = {
    Success: 'SUCCESS',
    Warning: 'WARNING',
    Error: 'ERROR',
    Terminated: 'TERMINATED',
    TempError: 'TEMP_ERROR',
    Pending: 'PENDING'
} as const;

export type CampaignReportBetaStatusEnum = typeof CampaignReportBetaStatusEnum[keyof typeof CampaignReportBetaStatusEnum];

/**
 * 
 * @export
 * @interface CampaignReportsConfigBeta
 */
export interface CampaignReportsConfigBeta {
    /**
     * 
     * @type {Array<string>}
     * @memberof CampaignReportsConfigBeta
     */
    'identityAttributeColumns'?: Array<string>;
}
/**
 * Campaign Template
 * @export
 * @interface CampaignTemplateBeta
 */
export interface CampaignTemplateBeta {
    /**
     * Id of the campaign template
     * @type {string}
     * @memberof CampaignTemplateBeta
     */
    'id'?: string;
    /**
     * This template\'s name. Has no bearing on generated campaigns\' names.
     * @type {string}
     * @memberof CampaignTemplateBeta
     */
    'name': string;
    /**
     * This template\'s description. Has no bearing on generated campaigns\' descriptions.
     * @type {string}
     * @memberof CampaignTemplateBeta
     */
    'description': string;
    /**
     * Creation date of Campaign Template
     * @type {string}
     * @memberof CampaignTemplateBeta
     */
    'created': string;
    /**
     * Modification date of Campaign Template
     * @type {string}
     * @memberof CampaignTemplateBeta
     */
    'modified': string;
    /**
     * Indicates if this campaign template has been scheduled.
     * @type {boolean}
     * @memberof CampaignTemplateBeta
     */
    'scheduled'?: boolean;
    /**
     * 
     * @type {CampaignTemplateOwnerRefBeta}
     * @memberof CampaignTemplateBeta
     */
    'ownerRef'?: CampaignTemplateOwnerRefBeta;
    /**
     * The time period during which the campaign should be completed, formatted as an ISO-8601 Duration. When this template generates a campaign, the campaign\'s deadline will be the current date plus this duration. For example, if generation occurred on 2020-01-01 and this field was \"P2W\" (two weeks), the resulting campaign\'s deadline would be 2020-01-15 (the current date plus 14 days).
     * @type {string}
     * @memberof CampaignTemplateBeta
     */
    'deadlineDuration'?: string;
    /**
     * 
     * @type {CampaignBeta}
     * @memberof CampaignTemplateBeta
     */
    'campaign': CampaignBeta;
}
/**
 * The owner of this template, and the owner of campaigns generated from this template via a schedule. This field is automatically populated at creation time with the current user.
 * @export
 * @interface CampaignTemplateOwnerRefBeta
 */
export interface CampaignTemplateOwnerRefBeta {
    /**
     * Id of the owner
     * @type {string}
     * @memberof CampaignTemplateOwnerRefBeta
     */
    'id'?: string;
    /**
     * Type of the owner
     * @type {string}
     * @memberof CampaignTemplateOwnerRefBeta
     */
    'type'?: CampaignTemplateOwnerRefBetaTypeEnum;
    /**
     * Name of the owner
     * @type {string}
     * @memberof CampaignTemplateOwnerRefBeta
     */
    'name'?: string;
    /**
     * Email of the owner
     * @type {string}
     * @memberof CampaignTemplateOwnerRefBeta
     */
    'email'?: string;
}

export const CampaignTemplateOwnerRefBetaTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type CampaignTemplateOwnerRefBetaTypeEnum = typeof CampaignTemplateOwnerRefBetaTypeEnum[keyof typeof CampaignTemplateOwnerRefBetaTypeEnum];

/**
 * Request body payload for cancel access request endpoint.
 * @export
 * @interface CancelAccessRequestBeta
 */
export interface CancelAccessRequestBeta {
    /**
     * This refers to the identityRequestId. To successfully cancel an access request, you must provide the identityRequestId.
     * @type {string}
     * @memberof CancelAccessRequestBeta
     */
    'accountActivityId': string;
    /**
     * Reason for cancelling the pending access request.
     * @type {string}
     * @memberof CancelAccessRequestBeta
     */
    'comment': string;
}
/**
 * 
 * @export
 * @interface CancelableAccountActivityBeta
 */
export interface CancelableAccountActivityBeta {
    /**
     * ID of the account activity itself
     * @type {string}
     * @memberof CancelableAccountActivityBeta
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CancelableAccountActivityBeta
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CancelableAccountActivityBeta
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof CancelableAccountActivityBeta
     */
    'modified'?: string;
    /**
     * 
     * @type {string}
     * @memberof CancelableAccountActivityBeta
     */
    'completed'?: string;
    /**
     * 
     * @type {CompletionStatusBeta}
     * @memberof CancelableAccountActivityBeta
     */
    'completionStatus'?: CompletionStatusBeta | null;
    /**
     * 
     * @type {string}
     * @memberof CancelableAccountActivityBeta
     */
    'type'?: string;
    /**
     * 
     * @type {IdentitySummaryBeta}
     * @memberof CancelableAccountActivityBeta
     */
    'requesterIdentitySummary'?: IdentitySummaryBeta | null;
    /**
     * 
     * @type {IdentitySummaryBeta}
     * @memberof CancelableAccountActivityBeta
     */
    'targetIdentitySummary'?: IdentitySummaryBeta | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CancelableAccountActivityBeta
     */
    'errors'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CancelableAccountActivityBeta
     */
    'warnings'?: Array<string>;
    /**
     * 
     * @type {Array<AccountActivityItemBeta>}
     * @memberof CancelableAccountActivityBeta
     */
    'items'?: Array<AccountActivityItemBeta>;
    /**
     * 
     * @type {ExecutionStatusBeta}
     * @memberof CancelableAccountActivityBeta
     */
    'executionStatus'?: ExecutionStatusBeta;
    /**
     * Arbitrary key-value pairs, if any were included in the corresponding access request
     * @type {{ [key: string]: string; }}
     * @memberof CancelableAccountActivityBeta
     */
    'clientMetadata'?: { [key: string]: string; };
    /**
     * Whether the account activity can be canceled before completion
     * @type {boolean}
     * @memberof CancelableAccountActivityBeta
     */
    'cancelable'?: boolean;
    /**
     * 
     * @type {CommentBeta}
     * @memberof CancelableAccountActivityBeta
     */
    'cancelComment'?: CommentBeta | null;
}
/**
 * Provides additional details for a request that has been cancelled.
 * @export
 * @interface CancelledRequestDetailsBeta
 */
export interface CancelledRequestDetailsBeta {
    /**
     * Comment made by the owner when cancelling the associated request.
     * @type {string}
     * @memberof CancelledRequestDetailsBeta
     */
    'comment'?: string;
    /**
     * 
     * @type {BaseReferenceDto1Beta}
     * @memberof CancelledRequestDetailsBeta
     */
    'owner'?: BaseReferenceDto1Beta;
    /**
     * Date comment was added by the owner when cancelling the associated request
     * @type {string}
     * @memberof CancelledRequestDetailsBeta
     */
    'modified'?: string;
}
/**
 * 
 * @export
 * @interface CertificationDtoBeta
 */
export interface CertificationDtoBeta {
    /**
     * 
     * @type {CampaignReferenceBeta}
     * @memberof CertificationDtoBeta
     */
    'campaignRef': CampaignReferenceBeta;
    /**
     * 
     * @type {CertificationPhaseBeta}
     * @memberof CertificationDtoBeta
     */
    'phase': CertificationPhaseBeta;
    /**
     * The due date of the certification.
     * @type {string}
     * @memberof CertificationDtoBeta
     */
    'due': string;
    /**
     * The date the reviewer signed off on the certification.
     * @type {string}
     * @memberof CertificationDtoBeta
     */
    'signed': string;
    /**
     * 
     * @type {ReviewerBeta}
     * @memberof CertificationDtoBeta
     */
    'reviewer': ReviewerBeta;
    /**
     * 
     * @type {ReassignmentBeta}
     * @memberof CertificationDtoBeta
     */
    'reassignment'?: ReassignmentBeta;
    /**
     * Indicates it the certification has any errors.
     * @type {boolean}
     * @memberof CertificationDtoBeta
     */
    'hasErrors': boolean;
    /**
     * A message indicating what the error is.
     * @type {string}
     * @memberof CertificationDtoBeta
     */
    'errorMessage'?: string | null;
    /**
     * Indicates if all certification decisions have been made.
     * @type {boolean}
     * @memberof CertificationDtoBeta
     */
    'completed': boolean;
    /**
     * The number of approve/revoke/acknowledge decisions that have been made by the reviewer.
     * @type {number}
     * @memberof CertificationDtoBeta
     */
    'decisionsMade': number;
    /**
     * The total number of approve/revoke/acknowledge decisions for the certification.
     * @type {number}
     * @memberof CertificationDtoBeta
     */
    'decisionsTotal': number;
    /**
     * The number of entities (identities, access profiles, roles, etc.) for which all decisions have been made and are complete.
     * @type {number}
     * @memberof CertificationDtoBeta
     */
    'entitiesCompleted': number;
    /**
     * The total number of entities (identities, access profiles, roles, etc.) in the certification, both complete and incomplete.
     * @type {number}
     * @memberof CertificationDtoBeta
     */
    'entitiesTotal': number;
}
/**
 * The current phase of the campaign. * `STAGED`: The campaign is waiting to be activated. * `ACTIVE`: The campaign is active. * `SIGNED`: The reviewer has signed off on the campaign, and it is considered complete. 
 * @export
 * @enum {string}
 */

export const CertificationPhaseBeta = {
    Staged: 'STAGED',
    Active: 'ACTIVE',
    Signed: 'SIGNED'
} as const;

export type CertificationPhaseBeta = typeof CertificationPhaseBeta[keyof typeof CertificationPhaseBeta];


/**
 * 
 * @export
 * @interface CertificationReferenceAllOfBeta
 */
export interface CertificationReferenceAllOfBeta {
    /**
     * 
     * @type {ReviewerBeta}
     * @memberof CertificationReferenceAllOfBeta
     */
    'reviewer'?: ReviewerBeta;
}
/**
 * The previous certification
 * @export
 * @interface CertificationReferenceBeta
 */
export interface CertificationReferenceBeta {
    /**
     * The type of object that the reviewer is.
     * @type {object}
     * @memberof CertificationReferenceBeta
     */
    'type'?: CertificationReferenceBetaTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof CertificationReferenceBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof CertificationReferenceBeta
     */
    'name'?: string;
    /**
     * 
     * @type {ReviewerBeta}
     * @memberof CertificationReferenceBeta
     */
    'reviewer'?: ReviewerBeta;
}

export const CertificationReferenceBetaTypeEnum = {
    Certification: 'CERTIFICATION'
} as const;

export type CertificationReferenceBetaTypeEnum = typeof CertificationReferenceBetaTypeEnum[keyof typeof CertificationReferenceBetaTypeEnum];

/**
 * 
 * @export
 * @interface CertificationSignedOffBeta
 */
export interface CertificationSignedOffBeta {
    /**
     * 
     * @type {CertificationSignedOffCertificationBeta}
     * @memberof CertificationSignedOffBeta
     */
    'certification': CertificationSignedOffCertificationBeta;
}
/**
 * The certification campaign that was signed off on.
 * @export
 * @interface CertificationSignedOffCertificationBeta
 */
export interface CertificationSignedOffCertificationBeta {
    /**
     * Unique ID of the certification.
     * @type {string}
     * @memberof CertificationSignedOffCertificationBeta
     */
    'id': string;
    /**
     * The name of the certification.
     * @type {string}
     * @memberof CertificationSignedOffCertificationBeta
     */
    'name': string;
    /**
     * The date and time the certification was created.
     * @type {string}
     * @memberof CertificationSignedOffCertificationBeta
     */
    'created': string;
    /**
     * The date and time the certification was last modified.
     * @type {string}
     * @memberof CertificationSignedOffCertificationBeta
     */
    'modified'?: string | null;
    /**
     * 
     * @type {CampaignReferenceBeta}
     * @memberof CertificationSignedOffCertificationBeta
     */
    'campaignRef': CampaignReferenceBeta;
    /**
     * 
     * @type {CertificationPhaseBeta}
     * @memberof CertificationSignedOffCertificationBeta
     */
    'phase': CertificationPhaseBeta;
    /**
     * The due date of the certification.
     * @type {string}
     * @memberof CertificationSignedOffCertificationBeta
     */
    'due': string;
    /**
     * The date the reviewer signed off on the certification.
     * @type {string}
     * @memberof CertificationSignedOffCertificationBeta
     */
    'signed': string;
    /**
     * 
     * @type {ReviewerBeta}
     * @memberof CertificationSignedOffCertificationBeta
     */
    'reviewer': ReviewerBeta;
    /**
     * 
     * @type {ReassignmentBeta}
     * @memberof CertificationSignedOffCertificationBeta
     */
    'reassignment'?: ReassignmentBeta;
    /**
     * Indicates it the certification has any errors.
     * @type {boolean}
     * @memberof CertificationSignedOffCertificationBeta
     */
    'hasErrors': boolean;
    /**
     * A message indicating what the error is.
     * @type {string}
     * @memberof CertificationSignedOffCertificationBeta
     */
    'errorMessage'?: string | null;
    /**
     * Indicates if all certification decisions have been made.
     * @type {boolean}
     * @memberof CertificationSignedOffCertificationBeta
     */
    'completed': boolean;
    /**
     * The number of approve/revoke/acknowledge decisions that have been made by the reviewer.
     * @type {number}
     * @memberof CertificationSignedOffCertificationBeta
     */
    'decisionsMade': number;
    /**
     * The total number of approve/revoke/acknowledge decisions for the certification.
     * @type {number}
     * @memberof CertificationSignedOffCertificationBeta
     */
    'decisionsTotal': number;
    /**
     * The number of entities (identities, access profiles, roles, etc.) for which all decisions have been made and are complete.
     * @type {number}
     * @memberof CertificationSignedOffCertificationBeta
     */
    'entitiesCompleted': number;
    /**
     * The total number of entities (identities, access profiles, roles, etc.) in the certification, both complete and incomplete.
     * @type {number}
     * @memberof CertificationSignedOffCertificationBeta
     */
    'entitiesTotal': number;
}
/**
 * 
 * @export
 * @interface CertificationTaskBeta
 */
export interface CertificationTaskBeta {
    /**
     * The ID of the certification task.
     * @type {string}
     * @memberof CertificationTaskBeta
     */
    'id'?: string;
    /**
     * The type of the certification task. More values may be added in the future.
     * @type {string}
     * @memberof CertificationTaskBeta
     */
    'type'?: CertificationTaskBetaTypeEnum;
    /**
     * The type of item that is being operated on by this task whose ID is stored in the targetId field.
     * @type {string}
     * @memberof CertificationTaskBeta
     */
    'targetType'?: CertificationTaskBetaTargetTypeEnum;
    /**
     * The ID of the item being operated on by this task.
     * @type {string}
     * @memberof CertificationTaskBeta
     */
    'targetId'?: string;
    /**
     * The status of the task.
     * @type {string}
     * @memberof CertificationTaskBeta
     */
    'status'?: CertificationTaskBetaStatusEnum;
    /**
     * 
     * @type {Array<ErrorMessageDtoBeta>}
     * @memberof CertificationTaskBeta
     */
    'errors'?: Array<ErrorMessageDtoBeta>;
    /**
     * The date and time on which this task was created.
     * @type {string}
     * @memberof CertificationTaskBeta
     */
    'created'?: string;
}

export const CertificationTaskBetaTypeEnum = {
    Reassign: 'REASSIGN',
    AdminReassign: 'ADMIN_REASSIGN',
    CompleteCertification: 'COMPLETE_CERTIFICATION',
    FinishCertification: 'FINISH_CERTIFICATION',
    CompleteCampaign: 'COMPLETE_CAMPAIGN',
    ActivateCampaign: 'ACTIVATE_CAMPAIGN',
    CampaignCreate: 'CAMPAIGN_CREATE',
    CampaignDelete: 'CAMPAIGN_DELETE'
} as const;

export type CertificationTaskBetaTypeEnum = typeof CertificationTaskBetaTypeEnum[keyof typeof CertificationTaskBetaTypeEnum];
export const CertificationTaskBetaTargetTypeEnum = {
    Certification: 'CERTIFICATION',
    Campaign: 'CAMPAIGN'
} as const;

export type CertificationTaskBetaTargetTypeEnum = typeof CertificationTaskBetaTargetTypeEnum[keyof typeof CertificationTaskBetaTargetTypeEnum];
export const CertificationTaskBetaStatusEnum = {
    Queued: 'QUEUED',
    InProgress: 'IN_PROGRESS',
    Success: 'SUCCESS',
    Error: 'ERROR'
} as const;

export type CertificationTaskBetaStatusEnum = typeof CertificationTaskBetaStatusEnum[keyof typeof CertificationTaskBetaStatusEnum];

/**
 * 
 * @export
 * @interface CertifierResponseBeta
 */
export interface CertifierResponseBeta {
    /**
     * the id of the certifier
     * @type {string}
     * @memberof CertifierResponseBeta
     */
    'id'?: string;
    /**
     * the name of the certifier
     * @type {string}
     * @memberof CertifierResponseBeta
     */
    'displayName'?: string;
}
/**
 * Client Runtime Logging Configuration
 * @export
 * @interface ClientLogConfigurationBeta
 */
export interface ClientLogConfigurationBeta {
    /**
     * Log configuration\'s client ID
     * @type {string}
     * @memberof ClientLogConfigurationBeta
     */
    'clientId'?: string;
    /**
     * Duration in minutes for log configuration to remain in effect before resetting to defaults
     * @type {number}
     * @memberof ClientLogConfigurationBeta
     */
    'durationMinutes': number;
    /**
     * Expiration date-time of the log configuration request
     * @type {string}
     * @memberof ClientLogConfigurationBeta
     */
    'expiration'?: string;
    /**
     * 
     * @type {StandardLevelBeta}
     * @memberof ClientLogConfigurationBeta
     */
    'rootLevel': StandardLevelBeta;
    /**
     * Mapping of identifiers to Standard Log Level values
     * @type {{ [key: string]: StandardLevelBeta; }}
     * @memberof ClientLogConfigurationBeta
     */
    'logLevels'?: { [key: string]: StandardLevelBeta; };
}
/**
 * Type of an API Client indicating public or confidentials use
 * @export
 * @enum {string}
 */

export const ClientTypeBeta = {
    Confidential: 'CONFIDENTIAL',
    Public: 'PUBLIC'
} as const;

export type ClientTypeBeta = typeof ClientTypeBeta[keyof typeof ClientTypeBeta];


/**
 * Request body payload for close access requests endpoint.
 * @export
 * @interface CloseAccessRequestBeta
 */
export interface CloseAccessRequestBeta {
    /**
     * Access Request IDs for the requests to be closed. Accepts 1-500 Identity Request IDs per request.
     * @type {Array<string>}
     * @memberof CloseAccessRequestBeta
     */
    'accessRequestIds': Array<string>;
    /**
     * Reason for closing the access request. Displayed under Warnings in IdentityNow.
     * @type {string}
     * @memberof CloseAccessRequestBeta
     */
    'message'?: string;
    /**
     * The request\'s provisioning status. Displayed as Stage in IdentityNow.
     * @type {string}
     * @memberof CloseAccessRequestBeta
     */
    'executionStatus'?: CloseAccessRequestBetaExecutionStatusEnum;
    /**
     * The request\'s overall status. Displayed as Status in IdentityNow.
     * @type {string}
     * @memberof CloseAccessRequestBeta
     */
    'completionStatus'?: CloseAccessRequestBetaCompletionStatusEnum;
}

export const CloseAccessRequestBetaExecutionStatusEnum = {
    Terminated: 'Terminated',
    Completed: 'Completed'
} as const;

export type CloseAccessRequestBetaExecutionStatusEnum = typeof CloseAccessRequestBetaExecutionStatusEnum[keyof typeof CloseAccessRequestBetaExecutionStatusEnum];
export const CloseAccessRequestBetaCompletionStatusEnum = {
    Success: 'Success',
    Incomplete: 'Incomplete',
    Failure: 'Failure'
} as const;

export type CloseAccessRequestBetaCompletionStatusEnum = typeof CloseAccessRequestBetaCompletionStatusEnum[keyof typeof CloseAccessRequestBetaCompletionStatusEnum];

/**
 * 
 * @export
 * @interface CommentBeta
 */
export interface CommentBeta {
    /**
     * Id of the identity making the comment
     * @type {string}
     * @memberof CommentBeta
     */
    'commenterId'?: string;
    /**
     * Human-readable display name of the identity making the comment
     * @type {string}
     * @memberof CommentBeta
     */
    'commenterName'?: string;
    /**
     * Content of the comment
     * @type {string}
     * @memberof CommentBeta
     */
    'body'?: string;
    /**
     * Date and time comment was made
     * @type {string}
     * @memberof CommentBeta
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface CommentDto1AuthorBeta
 */
export interface CommentDto1AuthorBeta {
    /**
     * 
     * @type {DtoTypeBeta}
     * @memberof CommentDto1AuthorBeta
     */
    'type'?: DtoTypeBeta;
    /**
     * ID of the author
     * @type {string}
     * @memberof CommentDto1AuthorBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of the identity making the comment
     * @type {string}
     * @memberof CommentDto1AuthorBeta
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface CommentDto1Beta
 */
export interface CommentDto1Beta {
    /**
     * Content of the comment
     * @type {string}
     * @memberof CommentDto1Beta
     */
    'comment'?: string;
    /**
     * 
     * @type {CommentDto1AuthorBeta}
     * @memberof CommentDto1Beta
     */
    'author'?: CommentDto1AuthorBeta;
    /**
     * Date and time comment was created
     * @type {string}
     * @memberof CommentDto1Beta
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface CommentDtoBeta
 */
export interface CommentDtoBeta {
    /**
     * 
     * @type {string}
     * @memberof CommentDtoBeta
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface CommonAccessIDStatusBeta
 */
export interface CommonAccessIDStatusBeta {
    /**
     * List of confirmed common access ids.
     * @type {Array<string>}
     * @memberof CommonAccessIDStatusBeta
     */
    'confirmedIds'?: Array<string>;
    /**
     * List of denied common access ids.
     * @type {Array<string>}
     * @memberof CommonAccessIDStatusBeta
     */
    'deniedIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CommonAccessItemAccessBeta
 */
export interface CommonAccessItemAccessBeta {
    /**
     * Common access ID
     * @type {string}
     * @memberof CommonAccessItemAccessBeta
     */
    'id'?: string;
    /**
     * 
     * @type {CommonAccessTypeBeta}
     * @memberof CommonAccessItemAccessBeta
     */
    'type'?: CommonAccessTypeBeta;
    /**
     * Common access name
     * @type {string}
     * @memberof CommonAccessItemAccessBeta
     */
    'name'?: string;
    /**
     * Common access description
     * @type {string}
     * @memberof CommonAccessItemAccessBeta
     */
    'description'?: string;
    /**
     * Common access owner name
     * @type {string}
     * @memberof CommonAccessItemAccessBeta
     */
    'ownerName'?: string;
    /**
     * Common access owner ID
     * @type {string}
     * @memberof CommonAccessItemAccessBeta
     */
    'ownerId'?: string;
}
/**
 * 
 * @export
 * @interface CommonAccessItemRequestBeta
 */
export interface CommonAccessItemRequestBeta {
    /**
     * 
     * @type {CommonAccessItemAccessBeta}
     * @memberof CommonAccessItemRequestBeta
     */
    'access'?: CommonAccessItemAccessBeta;
    /**
     * 
     * @type {CommonAccessItemStateBeta}
     * @memberof CommonAccessItemRequestBeta
     */
    'status'?: CommonAccessItemStateBeta;
}
/**
 * 
 * @export
 * @interface CommonAccessItemResponseBeta
 */
export interface CommonAccessItemResponseBeta {
    /**
     * Common Access Item ID
     * @type {string}
     * @memberof CommonAccessItemResponseBeta
     */
    'id'?: string;
    /**
     * 
     * @type {CommonAccessItemAccessBeta}
     * @memberof CommonAccessItemResponseBeta
     */
    'access'?: CommonAccessItemAccessBeta;
    /**
     * 
     * @type {CommonAccessItemStateBeta}
     * @memberof CommonAccessItemResponseBeta
     */
    'status'?: CommonAccessItemStateBeta;
    /**
     * 
     * @type {string}
     * @memberof CommonAccessItemResponseBeta
     */
    'lastUpdated'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CommonAccessItemResponseBeta
     */
    'reviewedByUser'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CommonAccessItemResponseBeta
     */
    'lastReviewed'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonAccessItemResponseBeta
     */
    'createdByUser'?: string;
}
/**
 * State of common access item.
 * @export
 * @enum {string}
 */

export const CommonAccessItemStateBeta = {
    Confirmed: 'CONFIRMED',
    Denied: 'DENIED'
} as const;

export type CommonAccessItemStateBeta = typeof CommonAccessItemStateBeta[keyof typeof CommonAccessItemStateBeta];


/**
 * 
 * @export
 * @interface CommonAccessResponseBeta
 */
export interface CommonAccessResponseBeta {
    /**
     * 
     * @type {CommonAccessItemAccessBeta}
     * @memberof CommonAccessResponseBeta
     */
    'access'?: CommonAccessItemAccessBeta;
    /**
     * CONFIRMED or DENIED
     * @type {string}
     * @memberof CommonAccessResponseBeta
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonAccessResponseBeta
     */
    'lastUpdated'?: string;
    /**
     * true if user has confirmed or denied status
     * @type {boolean}
     * @memberof CommonAccessResponseBeta
     */
    'reviewedByUser'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CommonAccessResponseBeta
     */
    'lastReviewed'?: string;
}
/**
 * The type of access item.
 * @export
 * @enum {string}
 */

export const CommonAccessTypeBeta = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE'
} as const;

export type CommonAccessTypeBeta = typeof CommonAccessTypeBeta[keyof typeof CommonAccessTypeBeta];


/**
 * 
 * @export
 * @interface CompleteCampaignOptionsBeta
 */
export interface CompleteCampaignOptionsBeta {
    /**
     * Determines whether to auto-approve(APPROVE) or auto-revoke(REVOKE) upon campaign completion.
     * @type {string}
     * @memberof CompleteCampaignOptionsBeta
     */
    'autoCompleteAction'?: CompleteCampaignOptionsBetaAutoCompleteActionEnum;
}

export const CompleteCampaignOptionsBetaAutoCompleteActionEnum = {
    Approve: 'APPROVE',
    Revoke: 'REVOKE'
} as const;

export type CompleteCampaignOptionsBetaAutoCompleteActionEnum = typeof CompleteCampaignOptionsBetaAutoCompleteActionEnum[keyof typeof CompleteCampaignOptionsBetaAutoCompleteActionEnum];

/**
 * 
 * @export
 * @interface CompleteInvocationBeta
 */
export interface CompleteInvocationBeta {
    /**
     * Unique invocation secret that was generated when the invocation was created. Required to authenticate to the endpoint.
     * @type {string}
     * @memberof CompleteInvocationBeta
     */
    'secret': string;
    /**
     * The error message to indicate a failed invocation or error if any.
     * @type {string}
     * @memberof CompleteInvocationBeta
     */
    'error'?: string;
    /**
     * Trigger output to complete the invocation. Its schema is defined in the trigger definition.
     * @type {object}
     * @memberof CompleteInvocationBeta
     */
    'output': object;
}
/**
 * 
 * @export
 * @interface CompleteInvocationInputBeta
 */
export interface CompleteInvocationInputBeta {
    /**
     * 
     * @type {LocalizedMessageBeta}
     * @memberof CompleteInvocationInputBeta
     */
    'localizedError'?: LocalizedMessageBeta;
    /**
     * Trigger output that completed the invocation. Its schema is defined in the trigger definition.
     * @type {object}
     * @memberof CompleteInvocationInputBeta
     */
    'output'?: object;
}
/**
 * 
 * @export
 * @interface CompletedApprovalBeta
 */
export interface CompletedApprovalBeta {
    /**
     * The approval id.
     * @type {string}
     * @memberof CompletedApprovalBeta
     */
    'id'?: string;
    /**
     * The name of the approval.
     * @type {string}
     * @memberof CompletedApprovalBeta
     */
    'name'?: string;
    /**
     * When the approval was created.
     * @type {string}
     * @memberof CompletedApprovalBeta
     */
    'created'?: string;
    /**
     * When the approval was modified last time.
     * @type {string}
     * @memberof CompletedApprovalBeta
     */
    'modified'?: string;
    /**
     * When the access-request was created.
     * @type {string}
     * @memberof CompletedApprovalBeta
     */
    'requestCreated'?: string;
    /**
     * 
     * @type {AccessRequestTypeBeta}
     * @memberof CompletedApprovalBeta
     */
    'requestType'?: AccessRequestTypeBeta;
    /**
     * 
     * @type {BaseReferenceDto1Beta}
     * @memberof CompletedApprovalBeta
     */
    'requester'?: BaseReferenceDto1Beta;
    /**
     * 
     * @type {BaseReferenceDto1Beta}
     * @memberof CompletedApprovalBeta
     */
    'requestedFor'?: BaseReferenceDto1Beta;
    /**
     * 
     * @type {BaseReferenceDto1Beta}
     * @memberof CompletedApprovalBeta
     */
    'reviewedBy'?: BaseReferenceDto1Beta;
    /**
     * 
     * @type {BaseReferenceDto1Beta}
     * @memberof CompletedApprovalBeta
     */
    'owner'?: BaseReferenceDto1Beta;
    /**
     * 
     * @type {RequestableObjectReferenceBeta}
     * @memberof CompletedApprovalBeta
     */
    'requestedObject'?: RequestableObjectReferenceBeta;
    /**
     * 
     * @type {CommentDto1Beta}
     * @memberof CompletedApprovalBeta
     */
    'requesterComment'?: CommentDto1Beta;
    /**
     * 
     * @type {CommentDto1Beta}
     * @memberof CompletedApprovalBeta
     */
    'reviewerComment'?: CommentDto1Beta;
    /**
     * The history of the previous reviewers comments.
     * @type {Array<CommentDto1Beta>}
     * @memberof CompletedApprovalBeta
     */
    'previousReviewersComments'?: Array<CommentDto1Beta>;
    /**
     * The history of approval forward action.
     * @type {Array<ApprovalForwardHistoryBeta>}
     * @memberof CompletedApprovalBeta
     */
    'forwardHistory'?: Array<ApprovalForwardHistoryBeta>;
    /**
     * When true the rejector has to provide comments when rejecting
     * @type {boolean}
     * @memberof CompletedApprovalBeta
     */
    'commentRequiredWhenRejected'?: boolean;
    /**
     * 
     * @type {CompletedApprovalStateBeta}
     * @memberof CompletedApprovalBeta
     */
    'state'?: CompletedApprovalStateBeta;
    /**
     * The date the role or access profile is no longer assigned to the specified identity.
     * @type {string}
     * @memberof CompletedApprovalBeta
     */
    'removeDate'?: string;
    /**
     * If true, then the request was to change the remove date or sunset date.
     * @type {boolean}
     * @memberof CompletedApprovalBeta
     */
    'removeDateUpdateRequested'?: boolean;
    /**
     * The remove date or sunset date that was assigned at the time of the request.
     * @type {string}
     * @memberof CompletedApprovalBeta
     */
    'currentRemoveDate'?: string;
    /**
     * 
     * @type {SodViolationContextCheckCompleted1Beta}
     * @memberof CompletedApprovalBeta
     */
    'sodViolationContext'?: SodViolationContextCheckCompleted1Beta;
}
/**
 * Enum represents completed approval object\'s state.
 * @export
 * @enum {string}
 */

export const CompletedApprovalStateBeta = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED'
} as const;

export type CompletedApprovalStateBeta = typeof CompletedApprovalStateBeta[keyof typeof CompletedApprovalStateBeta];


/**
 * The status after completion.
 * @export
 * @enum {string}
 */

export const CompletionStatusBeta = {
    Success: 'SUCCESS',
    Failure: 'FAILURE',
    Incomplete: 'INCOMPLETE',
    Pending: 'PENDING'
} as const;

export type CompletionStatusBeta = typeof CompletionStatusBeta[keyof typeof CompletionStatusBeta];


/**
 * ConditionEffect is the effect produced by a condition
 * @export
 * @interface ConditionEffectBeta
 */
export interface ConditionEffectBeta {
    /**
     * Config is a arbitrary map that holds a configuration based on EffectType
     * @type {{ [key: string]: object; }}
     * @memberof ConditionEffectBeta
     */
    'config'?: { [key: string]: object; };
    /**
     * EffectType is the type of effect to perform when the conditions are evaluated for this logic block HIDE ConditionEffectTypeHide  ConditionEffectTypeHide disables validations SHOW ConditionEffectTypeShow  ConditionEffectTypeShow enables validations DISABLE ConditionEffectTypeDisable  ConditionEffectTypeDisable disables validations ENABLE ConditionEffectTypeEnable  ConditionEffectTypeEnable enables validations REQUIRE ConditionEffectTypeRequire OPTIONAL ConditionEffectTypeOptional SUBMIT_MESSAGE ConditionEffectTypeSubmitMessage SUBMIT_NOTIFICATION ConditionEffectTypeSubmitNotification SET_DEFAULT_VALUE ConditionEffectTypeSetDefaultValue  ConditionEffectTypeSetDefaultValue is ignored on purpose
     * @type {string}
     * @memberof ConditionEffectBeta
     */
    'effectType'?: ConditionEffectBetaEffectTypeEnum;
}

export const ConditionEffectBetaEffectTypeEnum = {
    Hide: 'HIDE',
    Show: 'SHOW',
    Disable: 'DISABLE',
    Enable: 'ENABLE',
    Require: 'REQUIRE',
    Optional: 'OPTIONAL',
    SubmitMessage: 'SUBMIT_MESSAGE',
    SubmitNotification: 'SUBMIT_NOTIFICATION',
    SetDefaultValue: 'SET_DEFAULT_VALUE'
} as const;

export type ConditionEffectBetaEffectTypeEnum = typeof ConditionEffectBetaEffectTypeEnum[keyof typeof ConditionEffectBetaEffectTypeEnum];

/**
 * 
 * @export
 * @interface ConditionRuleBeta
 */
export interface ConditionRuleBeta {
    /**
     * Operator is a ConditionRuleComparisonOperatorType value EQ ConditionRuleComparisonOperatorTypeEquals  ConditionRuleComparisonOperatorTypeEquals is a comparison operator, the source and target are compared for equality NE ConditionRuleComparisonOperatorTypeNotEquals  ConditionRuleComparisonOperatorTypeNotEquals is a comparison operator, the source and target are compared for the opposite of equality CO ConditionRuleComparisonOperatorTypeContains  ConditionRuleComparisonOperatorTypeContains is a comparison operator, the source is searched to see if it contains the value NOT_CO ConditionRuleComparisonOperatorTypeNotContains IN ConditionRuleComparisonOperatorTypeIncludes  ConditionRuleComparisonOperatorTypeIncludes is a comparison operator, the source will be searched if it equals any of the values NOT_IN ConditionRuleComparisonOperatorTypeNotIncludes EM ConditionRuleComparisonOperatorTypeEmpty NOT_EM ConditionRuleComparisonOperatorTypeNotEmpty SW ConditionRuleComparisonOperatorTypeStartsWith  ConditionRuleComparisonOperatorTypeStartsWith checks if a string starts with another substring of the same string, this operator is case-sensitive NOT_SW ConditionRuleComparisonOperatorTypeNotStartsWith EW ConditionRuleComparisonOperatorTypeEndsWith  ConditionRuleComparisonOperatorTypeEndsWith checks if a string ends with another substring of the same string, this operator is case-sensitive NOT_EW ConditionRuleComparisonOperatorTypeNotEndsWith
     * @type {string}
     * @memberof ConditionRuleBeta
     */
    'operator'?: ConditionRuleBetaOperatorEnum;
    /**
     * Source, if the sourceType is ConditionRuleSourceTypeInput then the source type is the name of the form input to accept. While if the sourceType is ConditionRuleSourceTypeElement then source is the name of a technical key of an element to retrieve its value
     * @type {string}
     * @memberof ConditionRuleBeta
     */
    'source'?: string;
    /**
     * SourceType defines what type of object is being selected. Either a reference to a form input (by input name), or a form element (by technical key) INPUT ConditionRuleSourceTypeInput ELEMENT ConditionRuleSourceTypeElement
     * @type {string}
     * @memberof ConditionRuleBeta
     */
    'sourceType'?: ConditionRuleBetaSourceTypeEnum;
    /**
     * Value is the value based on the ValueType
     * @type {object}
     * @memberof ConditionRuleBeta
     */
    'value'?: object;
    /**
     * ValueType is a ConditionRuleValueType type STRING ConditionRuleValueTypeString  ConditionRuleValueTypeString the value field is a static string STRING_LIST ConditionRuleValueTypeStringList  ConditionRuleValueTypeStringList the value field is an array of string values INPUT ConditionRuleValueTypeInput  ConditionRuleValueTypeInput the value field is a reference to a form input by ELEMENT ConditionRuleValueTypeElement  ConditionRuleValueTypeElement the value field is a reference to form element (by technical key) LIST ConditionRuleValueTypeList BOOLEAN ConditionRuleValueTypeBoolean
     * @type {string}
     * @memberof ConditionRuleBeta
     */
    'valueType'?: ConditionRuleBetaValueTypeEnum;
}

export const ConditionRuleBetaOperatorEnum = {
    Eq: 'EQ',
    Ne: 'NE',
    Co: 'CO',
    NotCo: 'NOT_CO',
    In: 'IN',
    NotIn: 'NOT_IN',
    Em: 'EM',
    NotEm: 'NOT_EM',
    Sw: 'SW',
    NotSw: 'NOT_SW',
    Ew: 'EW',
    NotEw: 'NOT_EW'
} as const;

export type ConditionRuleBetaOperatorEnum = typeof ConditionRuleBetaOperatorEnum[keyof typeof ConditionRuleBetaOperatorEnum];
export const ConditionRuleBetaSourceTypeEnum = {
    Input: 'INPUT',
    Element: 'ELEMENT'
} as const;

export type ConditionRuleBetaSourceTypeEnum = typeof ConditionRuleBetaSourceTypeEnum[keyof typeof ConditionRuleBetaSourceTypeEnum];
export const ConditionRuleBetaValueTypeEnum = {
    String: 'STRING',
    StringList: 'STRING_LIST',
    Input: 'INPUT',
    Element: 'ELEMENT',
    List: 'LIST',
    Boolean: 'BOOLEAN'
} as const;

export type ConditionRuleBetaValueTypeEnum = typeof ConditionRuleBetaValueTypeEnum[keyof typeof ConditionRuleBetaValueTypeEnum];

/**
 * Config export and import format for individual object configurations.
 * @export
 * @interface ConfigObjectBeta
 */
export interface ConfigObjectBeta {
    /**
     * Current version of configuration object.
     * @type {number}
     * @memberof ConfigObjectBeta
     */
    'version'?: number;
    /**
     * 
     * @type {BaseReferenceDto1Beta}
     * @memberof ConfigObjectBeta
     */
    'self'?: BaseReferenceDto1Beta;
    /**
     * Object details. Format dependant on the object type.
     * @type {{ [key: string]: any; }}
     * @memberof ConfigObjectBeta
     */
    'object'?: { [key: string]: any; };
}
/**
 * Type of Reassignment Configuration.
 * @export
 * @interface ConfigTypeBeta
 */
export interface ConfigTypeBeta {
    /**
     * 
     * @type {ConfigTypeEnumBeta}
     * @memberof ConfigTypeBeta
     */
    'internalName'?: ConfigTypeEnumBeta;
    /**
     * Human readable display name of the type to be shown on UI
     * @type {string}
     * @memberof ConfigTypeBeta
     */
    'displayName'?: string;
    /**
     * Description of the type of work to be reassigned, displayed by the UI.
     * @type {string}
     * @memberof ConfigTypeBeta
     */
    'description'?: string;
}
/**
 * Enum list of valid work types that can be selected for a Reassignment Configuration
 * @export
 * @enum {string}
 */

export const ConfigTypeEnumBeta = {
    AccessRequests: 'ACCESS_REQUESTS',
    Certifications: 'CERTIFICATIONS',
    ManualTasks: 'MANUAL_TASKS'
} as const;

export type ConfigTypeEnumBeta = typeof ConfigTypeEnumBeta[keyof typeof ConfigTypeEnumBeta];


/**
 * The request body of Reassignment Configuration Details for a specific identity and config type
 * @export
 * @interface ConfigurationDetailsResponseBeta
 */
export interface ConfigurationDetailsResponseBeta {
    /**
     * 
     * @type {ConfigTypeEnumBeta}
     * @memberof ConfigurationDetailsResponseBeta
     */
    'configType'?: ConfigTypeEnumBeta;
    /**
     * 
     * @type {Identity1Beta}
     * @memberof ConfigurationDetailsResponseBeta
     */
    'targetIdentity'?: Identity1Beta;
    /**
     * The date from which to start reassigning work items
     * @type {string}
     * @memberof ConfigurationDetailsResponseBeta
     */
    'startDate'?: string;
    /**
     * The date from which to stop reassigning work items.  If this is an empty string it indicates a permanent reassignment.
     * @type {string}
     * @memberof ConfigurationDetailsResponseBeta
     */
    'endDate'?: string;
    /**
     * 
     * @type {AuditDetailsBeta}
     * @memberof ConfigurationDetailsResponseBeta
     */
    'auditDetails'?: AuditDetailsBeta;
}
/**
 * The request body for creation or update of a Reassignment Configuration for a single identity and work type
 * @export
 * @interface ConfigurationItemRequestBeta
 */
export interface ConfigurationItemRequestBeta {
    /**
     * The identity id to reassign an item from
     * @type {string}
     * @memberof ConfigurationItemRequestBeta
     */
    'reassignedFromId'?: string;
    /**
     * The identity id to reassign an item to
     * @type {string}
     * @memberof ConfigurationItemRequestBeta
     */
    'reassignedToId'?: string;
    /**
     * 
     * @type {ConfigTypeEnumBeta}
     * @memberof ConfigurationItemRequestBeta
     */
    'configType'?: ConfigTypeEnumBeta;
    /**
     * The date from which to start reassigning work items
     * @type {string}
     * @memberof ConfigurationItemRequestBeta
     */
    'startDate'?: string;
    /**
     * The date from which to stop reassigning work items.  If this is an null string it indicates a permanent reassignment.
     * @type {string}
     * @memberof ConfigurationItemRequestBeta
     */
    'endDate'?: string | null;
}
/**
 * The response body of a Reassignment Configuration for a single identity
 * @export
 * @interface ConfigurationItemResponseBeta
 */
export interface ConfigurationItemResponseBeta {
    /**
     * 
     * @type {Identity1Beta}
     * @memberof ConfigurationItemResponseBeta
     */
    'identity'?: Identity1Beta;
    /**
     * Details of how work should be reassigned for an Identity
     * @type {Array<ConfigurationDetailsResponseBeta>}
     * @memberof ConfigurationItemResponseBeta
     */
    'configDetails'?: Array<ConfigurationDetailsResponseBeta>;
}
/**
 * The response body of a Reassignment Configuration for a single identity
 * @export
 * @interface ConfigurationResponseBeta
 */
export interface ConfigurationResponseBeta {
    /**
     * 
     * @type {Identity1Beta}
     * @memberof ConfigurationResponseBeta
     */
    'identity'?: Identity1Beta;
    /**
     * Details of how work should be reassigned for an Identity
     * @type {Array<ConfigurationDetailsResponseBeta>}
     * @memberof ConfigurationResponseBeta
     */
    'configDetails'?: Array<ConfigurationDetailsResponseBeta>;
}
/**
 * 
 * @export
 * @interface ConflictingAccessCriteriaBeta
 */
export interface ConflictingAccessCriteriaBeta {
    /**
     * 
     * @type {AccessCriteriaBeta}
     * @memberof ConflictingAccessCriteriaBeta
     */
    'leftCriteria'?: AccessCriteriaBeta;
    /**
     * 
     * @type {AccessCriteriaBeta}
     * @memberof ConflictingAccessCriteriaBeta
     */
    'rightCriteria'?: AccessCriteriaBeta;
}
/**
 * 
 * @export
 * @interface ConnectorDetailBeta
 */
export interface ConnectorDetailBeta {
    /**
     * The connector name
     * @type {string}
     * @memberof ConnectorDetailBeta
     */
    'name'?: string;
    /**
     * XML representation of the source config data
     * @type {string}
     * @memberof ConnectorDetailBeta
     */
    'sourceConfigXml'?: string;
    /**
     * JSON representation of the source config data
     * @type {string}
     * @memberof ConnectorDetailBeta
     */
    'sourceConfig'?: string;
    /**
     * true if the source is a direct connect source
     * @type {boolean}
     * @memberof ConnectorDetailBeta
     */
    'directConnect'?: boolean;
    /**
     * Connector config\'s file upload attribute, false if not there
     * @type {boolean}
     * @memberof ConnectorDetailBeta
     */
    'fileUpload'?: boolean;
    /**
     * List of uploaded file strings for the connector
     * @type {string}
     * @memberof ConnectorDetailBeta
     */
    'uploadedFiles'?: string;
    /**
     * Object containing metadata pertinent to the UI to be used
     * @type {object}
     * @memberof ConnectorDetailBeta
     */
    'connectorMetadata'?: object;
}
/**
 * ConnectorRuleCreateRequest
 * @export
 * @interface ConnectorRuleCreateRequestBeta
 */
export interface ConnectorRuleCreateRequestBeta {
    /**
     * the name of the rule
     * @type {string}
     * @memberof ConnectorRuleCreateRequestBeta
     */
    'name': string;
    /**
     * a description of the rule\'s purpose
     * @type {string}
     * @memberof ConnectorRuleCreateRequestBeta
     */
    'description'?: string;
    /**
     * the type of rule
     * @type {string}
     * @memberof ConnectorRuleCreateRequestBeta
     */
    'type': ConnectorRuleCreateRequestBetaTypeEnum;
    /**
     * 
     * @type {ConnectorRuleCreateRequestSignatureBeta}
     * @memberof ConnectorRuleCreateRequestBeta
     */
    'signature'?: ConnectorRuleCreateRequestSignatureBeta;
    /**
     * 
     * @type {SourceCodeBeta}
     * @memberof ConnectorRuleCreateRequestBeta
     */
    'sourceCode': SourceCodeBeta;
    /**
     * a map of string to objects
     * @type {object}
     * @memberof ConnectorRuleCreateRequestBeta
     */
    'attributes'?: object | null;
}

export const ConnectorRuleCreateRequestBetaTypeEnum = {
    BuildMap: 'BuildMap',
    ConnectorAfterCreate: 'ConnectorAfterCreate',
    ConnectorAfterDelete: 'ConnectorAfterDelete',
    ConnectorAfterModify: 'ConnectorAfterModify',
    ConnectorBeforeCreate: 'ConnectorBeforeCreate',
    ConnectorBeforeDelete: 'ConnectorBeforeDelete',
    ConnectorBeforeModify: 'ConnectorBeforeModify',
    JdbcBuildMap: 'JDBCBuildMap',
    JdbcOperationProvisioning: 'JDBCOperationProvisioning',
    JdbcProvision: 'JDBCProvision',
    PeopleSoftHrmsBuildMap: 'PeopleSoftHRMSBuildMap',
    PeopleSoftHrmsOperationProvisioning: 'PeopleSoftHRMSOperationProvisioning',
    PeopleSoftHrmsProvision: 'PeopleSoftHRMSProvision',
    RacfPermissionCustomization: 'RACFPermissionCustomization',
    SapBuildMap: 'SAPBuildMap',
    SapHrManagerRule: 'SapHrManagerRule',
    SapHrOperationProvisioning: 'SapHrOperationProvisioning',
    SapHrProvision: 'SapHrProvision',
    SuccessFactorsOperationProvisioning: 'SuccessFactorsOperationProvisioning',
    WebServiceAfterOperationRule: 'WebServiceAfterOperationRule',
    WebServiceBeforeOperationRule: 'WebServiceBeforeOperationRule'
} as const;

export type ConnectorRuleCreateRequestBetaTypeEnum = typeof ConnectorRuleCreateRequestBetaTypeEnum[keyof typeof ConnectorRuleCreateRequestBetaTypeEnum];

/**
 * The rule\'s function signature. Describes the rule\'s input arguments and output (if any)
 * @export
 * @interface ConnectorRuleCreateRequestSignatureBeta
 */
export interface ConnectorRuleCreateRequestSignatureBeta {
    /**
     * 
     * @type {Array<ArgumentBeta>}
     * @memberof ConnectorRuleCreateRequestSignatureBeta
     */
    'input': Array<ArgumentBeta>;
    /**
     * 
     * @type {ArgumentBeta}
     * @memberof ConnectorRuleCreateRequestSignatureBeta
     */
    'output'?: ArgumentBeta | null;
}
/**
 * 
 * @export
 * @interface ConnectorRuleResponseAllOfBeta
 */
export interface ConnectorRuleResponseAllOfBeta {
    /**
     * the ID of the rule
     * @type {string}
     * @memberof ConnectorRuleResponseAllOfBeta
     */
    'id': string;
    /**
     * an ISO 8601 UTC timestamp when this rule was created
     * @type {string}
     * @memberof ConnectorRuleResponseAllOfBeta
     */
    'created': string;
    /**
     * an ISO 8601 UTC timestamp when this rule was last modified
     * @type {string}
     * @memberof ConnectorRuleResponseAllOfBeta
     */
    'modified'?: string | null;
}
/**
 * ConnectorRuleResponse
 * @export
 * @interface ConnectorRuleResponseBeta
 */
export interface ConnectorRuleResponseBeta {
    /**
     * the name of the rule
     * @type {string}
     * @memberof ConnectorRuleResponseBeta
     */
    'name': string;
    /**
     * a description of the rule\'s purpose
     * @type {string}
     * @memberof ConnectorRuleResponseBeta
     */
    'description'?: string;
    /**
     * the type of rule
     * @type {string}
     * @memberof ConnectorRuleResponseBeta
     */
    'type': ConnectorRuleResponseBetaTypeEnum;
    /**
     * 
     * @type {ConnectorRuleCreateRequestSignatureBeta}
     * @memberof ConnectorRuleResponseBeta
     */
    'signature'?: ConnectorRuleCreateRequestSignatureBeta;
    /**
     * 
     * @type {SourceCodeBeta}
     * @memberof ConnectorRuleResponseBeta
     */
    'sourceCode': SourceCodeBeta;
    /**
     * a map of string to objects
     * @type {object}
     * @memberof ConnectorRuleResponseBeta
     */
    'attributes'?: object | null;
    /**
     * the ID of the rule
     * @type {string}
     * @memberof ConnectorRuleResponseBeta
     */
    'id': string;
    /**
     * an ISO 8601 UTC timestamp when this rule was created
     * @type {string}
     * @memberof ConnectorRuleResponseBeta
     */
    'created': string;
    /**
     * an ISO 8601 UTC timestamp when this rule was last modified
     * @type {string}
     * @memberof ConnectorRuleResponseBeta
     */
    'modified'?: string | null;
}

export const ConnectorRuleResponseBetaTypeEnum = {
    BuildMap: 'BuildMap',
    ConnectorAfterCreate: 'ConnectorAfterCreate',
    ConnectorAfterDelete: 'ConnectorAfterDelete',
    ConnectorAfterModify: 'ConnectorAfterModify',
    ConnectorBeforeCreate: 'ConnectorBeforeCreate',
    ConnectorBeforeDelete: 'ConnectorBeforeDelete',
    ConnectorBeforeModify: 'ConnectorBeforeModify',
    JdbcBuildMap: 'JDBCBuildMap',
    JdbcOperationProvisioning: 'JDBCOperationProvisioning',
    JdbcProvision: 'JDBCProvision',
    PeopleSoftHrmsBuildMap: 'PeopleSoftHRMSBuildMap',
    PeopleSoftHrmsOperationProvisioning: 'PeopleSoftHRMSOperationProvisioning',
    PeopleSoftHrmsProvision: 'PeopleSoftHRMSProvision',
    RacfPermissionCustomization: 'RACFPermissionCustomization',
    SapBuildMap: 'SAPBuildMap',
    SapHrManagerRule: 'SapHrManagerRule',
    SapHrOperationProvisioning: 'SapHrOperationProvisioning',
    SapHrProvision: 'SapHrProvision',
    SuccessFactorsOperationProvisioning: 'SuccessFactorsOperationProvisioning',
    WebServiceAfterOperationRule: 'WebServiceAfterOperationRule',
    WebServiceBeforeOperationRule: 'WebServiceBeforeOperationRule'
} as const;

export type ConnectorRuleResponseBetaTypeEnum = typeof ConnectorRuleResponseBetaTypeEnum[keyof typeof ConnectorRuleResponseBetaTypeEnum];

/**
 * 
 * @export
 * @interface ConnectorRuleUpdateRequestAllOfBeta
 */
export interface ConnectorRuleUpdateRequestAllOfBeta {
    /**
     * the ID of the rule to update
     * @type {string}
     * @memberof ConnectorRuleUpdateRequestAllOfBeta
     */
    'id': string;
}
/**
 * ConnectorRuleUpdateRequest
 * @export
 * @interface ConnectorRuleUpdateRequestBeta
 */
export interface ConnectorRuleUpdateRequestBeta {
    /**
     * the ID of the rule to update
     * @type {string}
     * @memberof ConnectorRuleUpdateRequestBeta
     */
    'id': string;
    /**
     * the name of the rule
     * @type {string}
     * @memberof ConnectorRuleUpdateRequestBeta
     */
    'name': string;
    /**
     * a description of the rule\'s purpose
     * @type {string}
     * @memberof ConnectorRuleUpdateRequestBeta
     */
    'description'?: string;
    /**
     * the type of rule
     * @type {string}
     * @memberof ConnectorRuleUpdateRequestBeta
     */
    'type': ConnectorRuleUpdateRequestBetaTypeEnum;
    /**
     * 
     * @type {ConnectorRuleCreateRequestSignatureBeta}
     * @memberof ConnectorRuleUpdateRequestBeta
     */
    'signature'?: ConnectorRuleCreateRequestSignatureBeta;
    /**
     * 
     * @type {SourceCodeBeta}
     * @memberof ConnectorRuleUpdateRequestBeta
     */
    'sourceCode': SourceCodeBeta;
    /**
     * a map of string to objects
     * @type {object}
     * @memberof ConnectorRuleUpdateRequestBeta
     */
    'attributes'?: object | null;
}

export const ConnectorRuleUpdateRequestBetaTypeEnum = {
    BuildMap: 'BuildMap',
    ConnectorAfterCreate: 'ConnectorAfterCreate',
    ConnectorAfterDelete: 'ConnectorAfterDelete',
    ConnectorAfterModify: 'ConnectorAfterModify',
    ConnectorBeforeCreate: 'ConnectorBeforeCreate',
    ConnectorBeforeDelete: 'ConnectorBeforeDelete',
    ConnectorBeforeModify: 'ConnectorBeforeModify',
    JdbcBuildMap: 'JDBCBuildMap',
    JdbcOperationProvisioning: 'JDBCOperationProvisioning',
    JdbcProvision: 'JDBCProvision',
    PeopleSoftHrmsBuildMap: 'PeopleSoftHRMSBuildMap',
    PeopleSoftHrmsOperationProvisioning: 'PeopleSoftHRMSOperationProvisioning',
    PeopleSoftHrmsProvision: 'PeopleSoftHRMSProvision',
    RacfPermissionCustomization: 'RACFPermissionCustomization',
    SapBuildMap: 'SAPBuildMap',
    SapHrManagerRule: 'SapHrManagerRule',
    SapHrOperationProvisioning: 'SapHrOperationProvisioning',
    SapHrProvision: 'SapHrProvision',
    SuccessFactorsOperationProvisioning: 'SuccessFactorsOperationProvisioning',
    WebServiceAfterOperationRule: 'WebServiceAfterOperationRule',
    WebServiceBeforeOperationRule: 'WebServiceBeforeOperationRule'
} as const;

export type ConnectorRuleUpdateRequestBetaTypeEnum = typeof ConnectorRuleUpdateRequestBetaTypeEnum[keyof typeof ConnectorRuleUpdateRequestBetaTypeEnum];

/**
 * ConnectorRuleValidationResponse
 * @export
 * @interface ConnectorRuleValidationResponseBeta
 */
export interface ConnectorRuleValidationResponseBeta {
    /**
     * 
     * @type {string}
     * @memberof ConnectorRuleValidationResponseBeta
     */
    'state': ConnectorRuleValidationResponseBetaStateEnum;
    /**
     * 
     * @type {Array<ConnectorRuleValidationResponseDetailsInnerBeta>}
     * @memberof ConnectorRuleValidationResponseBeta
     */
    'details': Array<ConnectorRuleValidationResponseDetailsInnerBeta>;
}

export const ConnectorRuleValidationResponseBetaStateEnum = {
    Ok: 'OK',
    Error: 'ERROR'
} as const;

export type ConnectorRuleValidationResponseBetaStateEnum = typeof ConnectorRuleValidationResponseBetaStateEnum[keyof typeof ConnectorRuleValidationResponseBetaStateEnum];

/**
 * CodeErrorDetail
 * @export
 * @interface ConnectorRuleValidationResponseDetailsInnerBeta
 */
export interface ConnectorRuleValidationResponseDetailsInnerBeta {
    /**
     * The line number where the issue occurred
     * @type {number}
     * @memberof ConnectorRuleValidationResponseDetailsInnerBeta
     */
    'line': number;
    /**
     * the column number where the issue occurred
     * @type {number}
     * @memberof ConnectorRuleValidationResponseDetailsInnerBeta
     */
    'column': number;
    /**
     * a description of the issue in the code
     * @type {string}
     * @memberof ConnectorRuleValidationResponseDetailsInnerBeta
     */
    'messsage'?: string;
}
/**
 * 
 * @export
 * @interface CorrelatedGovernanceEventBeta
 */
export interface CorrelatedGovernanceEventBeta {
    /**
     * The name of the governance event, such as the certification name or access request ID.
     * @type {string}
     * @memberof CorrelatedGovernanceEventBeta
     */
    'name'?: string;
    /**
     * The date that the certification or access request was completed.
     * @type {string}
     * @memberof CorrelatedGovernanceEventBeta
     */
    'dt'?: string;
    /**
     * The type of governance event.
     * @type {string}
     * @memberof CorrelatedGovernanceEventBeta
     */
    'type'?: CorrelatedGovernanceEventBetaTypeEnum;
    /**
     * The ID of the instance that caused the event - either the certification ID or access request ID.
     * @type {string}
     * @memberof CorrelatedGovernanceEventBeta
     */
    'governanceId'?: string;
    /**
     * The owners of the governance event (the certifiers or approvers)
     * @type {Array<CertifierResponseBeta>}
     * @memberof CorrelatedGovernanceEventBeta
     */
    'owners'?: Array<CertifierResponseBeta>;
    /**
     * The owners of the governance event (the certifiers or approvers), this field should be preferred over owners
     * @type {Array<CertifierResponseBeta>}
     * @memberof CorrelatedGovernanceEventBeta
     */
    'reviewers'?: Array<CertifierResponseBeta>;
    /**
     * 
     * @type {CertifierResponseBeta}
     * @memberof CorrelatedGovernanceEventBeta
     */
    'decisionMaker'?: CertifierResponseBeta;
}

export const CorrelatedGovernanceEventBetaTypeEnum = {
    Certification: 'certification',
    AccessRequest: 'accessRequest'
} as const;

export type CorrelatedGovernanceEventBetaTypeEnum = typeof CorrelatedGovernanceEventBetaTypeEnum[keyof typeof CorrelatedGovernanceEventBetaTypeEnum];

/**
 * 
 * @export
 * @interface CreateDomainDkim405ResponseBeta
 */
export interface CreateDomainDkim405ResponseBeta {
    /**
     * A message describing the error
     * @type {object}
     * @memberof CreateDomainDkim405ResponseBeta
     */
    'errorName'?: object;
    /**
     * Description of the error
     * @type {object}
     * @memberof CreateDomainDkim405ResponseBeta
     */
    'errorMessage'?: object;
    /**
     * Unique tracking id for the error.
     * @type {string}
     * @memberof CreateDomainDkim405ResponseBeta
     */
    'trackingId'?: string;
}
/**
 * 
 * @export
 * @interface CreateFormDefinitionRequestBeta
 */
export interface CreateFormDefinitionRequestBeta {
    /**
     * Description is the form definition description
     * @type {string}
     * @memberof CreateFormDefinitionRequestBeta
     */
    'description'?: string;
    /**
     * FormConditions is the conditional logic that modify the form dynamically modify the form as the recipient is interacting out the form
     * @type {Array<FormConditionBeta>}
     * @memberof CreateFormDefinitionRequestBeta
     */
    'formConditions'?: Array<FormConditionBeta>;
    /**
     * FormElements is a list of nested form elements
     * @type {Array<FormElementBeta>}
     * @memberof CreateFormDefinitionRequestBeta
     */
    'formElements'?: Array<FormElementBeta>;
    /**
     * FormInput is a list of form inputs that are required when creating a form-instance object
     * @type {Array<FormDefinitionInputBeta>}
     * @memberof CreateFormDefinitionRequestBeta
     */
    'formInput'?: Array<FormDefinitionInputBeta>;
    /**
     * Name is the form definition name
     * @type {string}
     * @memberof CreateFormDefinitionRequestBeta
     */
    'name': string;
    /**
     * 
     * @type {FormOwnerBeta}
     * @memberof CreateFormDefinitionRequestBeta
     */
    'owner': FormOwnerBeta;
    /**
     * UsedBy is a list of objects where when any system uses a particular form it reaches out to the form service to record it is currently being used
     * @type {Array<FormUsedByBeta>}
     * @memberof CreateFormDefinitionRequestBeta
     */
    'usedBy'?: Array<FormUsedByBeta>;
}
/**
 * 
 * @export
 * @interface CreateFormInstanceRequestBeta
 */
export interface CreateFormInstanceRequestBeta {
    /**
     * 
     * @type {FormInstanceCreatedByBeta}
     * @memberof CreateFormInstanceRequestBeta
     */
    'createdBy': FormInstanceCreatedByBeta;
    /**
     * Expire is required
     * @type {string}
     * @memberof CreateFormInstanceRequestBeta
     */
    'expire': string;
    /**
     * FormDefinitionID is the id of the form definition that created this form
     * @type {string}
     * @memberof CreateFormInstanceRequestBeta
     */
    'formDefinitionId': string;
    /**
     * FormInput is an object of form input labels to value
     * @type {{ [key: string]: object; }}
     * @memberof CreateFormInstanceRequestBeta
     */
    'formInput'?: { [key: string]: object; };
    /**
     * Recipients is required
     * @type {Array<FormInstanceRecipientBeta>}
     * @memberof CreateFormInstanceRequestBeta
     */
    'recipients': Array<FormInstanceRecipientBeta>;
    /**
     * StandAloneForm is a boolean flag to indicate if this form should be available for users to complete via the standalone form UI or should this only be available to be completed by as an embedded form
     * @type {boolean}
     * @memberof CreateFormInstanceRequestBeta
     */
    'standAloneForm'?: boolean;
    /**
     * State is required, if not present initial state is FormInstanceStateAssigned ASSIGNED FormInstanceStateAssigned IN_PROGRESS FormInstanceStateInProgress SUBMITTED FormInstanceStateSubmitted COMPLETED FormInstanceStateCompleted CANCELLED FormInstanceStateCancelled
     * @type {string}
     * @memberof CreateFormInstanceRequestBeta
     */
    'state'?: CreateFormInstanceRequestBetaStateEnum;
    /**
     * TTL an epoch timestamp in seconds, it most be in seconds or dynamodb will ignore it SEE: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/time-to-live-ttl-before-you-start.html
     * @type {number}
     * @memberof CreateFormInstanceRequestBeta
     */
    'ttl'?: number;
}

export const CreateFormInstanceRequestBetaStateEnum = {
    Assigned: 'ASSIGNED',
    InProgress: 'IN_PROGRESS',
    Submitted: 'SUBMITTED',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED'
} as const;

export type CreateFormInstanceRequestBetaStateEnum = typeof CreateFormInstanceRequestBetaStateEnum[keyof typeof CreateFormInstanceRequestBetaStateEnum];

/**
 * 
 * @export
 * @interface CreateOAuthClientRequestBeta
 */
export interface CreateOAuthClientRequestBeta {
    /**
     * The name of the business the API Client should belong to
     * @type {string}
     * @memberof CreateOAuthClientRequestBeta
     */
    'businessName'?: string | null;
    /**
     * The homepage URL associated with the owner of the API Client
     * @type {string}
     * @memberof CreateOAuthClientRequestBeta
     */
    'homepageUrl'?: string | null;
    /**
     * A human-readable name for the API Client
     * @type {string}
     * @memberof CreateOAuthClientRequestBeta
     */
    'name': string | null;
    /**
     * A description of the API Client
     * @type {string}
     * @memberof CreateOAuthClientRequestBeta
     */
    'description': string | null;
    /**
     * The number of seconds an access token generated for this API Client is valid for
     * @type {number}
     * @memberof CreateOAuthClientRequestBeta
     */
    'accessTokenValiditySeconds': number;
    /**
     * The number of seconds a refresh token generated for this API Client is valid for
     * @type {number}
     * @memberof CreateOAuthClientRequestBeta
     */
    'refreshTokenValiditySeconds'?: number;
    /**
     * A list of the approved redirect URIs. Provide one or more URIs when assigning the AUTHORIZATION_CODE grant type to a new OAuth Client.
     * @type {Array<string>}
     * @memberof CreateOAuthClientRequestBeta
     */
    'redirectUris'?: Array<string> | null;
    /**
     * A list of OAuth 2.0 grant types this API Client can be used with
     * @type {Array<GrantTypeBeta>}
     * @memberof CreateOAuthClientRequestBeta
     */
    'grantTypes': Array<GrantTypeBeta> | null;
    /**
     * 
     * @type {AccessTypeBeta}
     * @memberof CreateOAuthClientRequestBeta
     */
    'accessType': AccessTypeBeta;
    /**
     * 
     * @type {ClientTypeBeta}
     * @memberof CreateOAuthClientRequestBeta
     */
    'type'?: ClientTypeBeta;
    /**
     * An indicator of whether the API Client can be used for requests internal within the product.
     * @type {boolean}
     * @memberof CreateOAuthClientRequestBeta
     */
    'internal'?: boolean;
    /**
     * An indicator of whether the API Client is enabled for use
     * @type {boolean}
     * @memberof CreateOAuthClientRequestBeta
     */
    'enabled': boolean;
    /**
     * An indicator of whether the API Client supports strong authentication
     * @type {boolean}
     * @memberof CreateOAuthClientRequestBeta
     */
    'strongAuthSupported'?: boolean;
    /**
     * An indicator of whether the API Client supports the serialization of SAML claims when used with the authorization_code flow
     * @type {boolean}
     * @memberof CreateOAuthClientRequestBeta
     */
    'claimsSupported'?: boolean;
    /**
     * Scopes of the API Client. If no scope is specified, the client will be created with the default scope \"sp:scopes:all\". This means the API Client will have all the rights of the owner who created it.
     * @type {Array<string>}
     * @memberof CreateOAuthClientRequestBeta
     */
    'scope'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface CreateOAuthClientResponseBeta
 */
export interface CreateOAuthClientResponseBeta {
    /**
     * ID of the OAuth client
     * @type {string}
     * @memberof CreateOAuthClientResponseBeta
     */
    'id': string;
    /**
     * Secret of the OAuth client (This field is only returned on the intial create call.)
     * @type {string}
     * @memberof CreateOAuthClientResponseBeta
     */
    'secret': string;
    /**
     * The name of the business the API Client should belong to
     * @type {string}
     * @memberof CreateOAuthClientResponseBeta
     */
    'businessName': string;
    /**
     * The homepage URL associated with the owner of the API Client
     * @type {string}
     * @memberof CreateOAuthClientResponseBeta
     */
    'homepageUrl': string;
    /**
     * A human-readable name for the API Client
     * @type {string}
     * @memberof CreateOAuthClientResponseBeta
     */
    'name': string;
    /**
     * A description of the API Client
     * @type {string}
     * @memberof CreateOAuthClientResponseBeta
     */
    'description': string;
    /**
     * The number of seconds an access token generated for this API Client is valid for
     * @type {number}
     * @memberof CreateOAuthClientResponseBeta
     */
    'accessTokenValiditySeconds': number;
    /**
     * The number of seconds a refresh token generated for this API Client is valid for
     * @type {number}
     * @memberof CreateOAuthClientResponseBeta
     */
    'refreshTokenValiditySeconds': number;
    /**
     * A list of the approved redirect URIs used with the authorization_code flow
     * @type {Array<string>}
     * @memberof CreateOAuthClientResponseBeta
     */
    'redirectUris': Array<string>;
    /**
     * A list of OAuth 2.0 grant types this API Client can be used with
     * @type {Array<GrantTypeBeta>}
     * @memberof CreateOAuthClientResponseBeta
     */
    'grantTypes': Array<GrantTypeBeta>;
    /**
     * 
     * @type {AccessTypeBeta}
     * @memberof CreateOAuthClientResponseBeta
     */
    'accessType': AccessTypeBeta;
    /**
     * 
     * @type {ClientTypeBeta}
     * @memberof CreateOAuthClientResponseBeta
     */
    'type': ClientTypeBeta;
    /**
     * An indicator of whether the API Client can be used for requests internal to IDN
     * @type {boolean}
     * @memberof CreateOAuthClientResponseBeta
     */
    'internal': boolean;
    /**
     * An indicator of whether the API Client is enabled for use
     * @type {boolean}
     * @memberof CreateOAuthClientResponseBeta
     */
    'enabled': boolean;
    /**
     * An indicator of whether the API Client supports strong authentication
     * @type {boolean}
     * @memberof CreateOAuthClientResponseBeta
     */
    'strongAuthSupported': boolean;
    /**
     * An indicator of whether the API Client supports the serialization of SAML claims when used with the authorization_code flow
     * @type {boolean}
     * @memberof CreateOAuthClientResponseBeta
     */
    'claimsSupported': boolean;
    /**
     * The date and time, down to the millisecond, when the API Client was created
     * @type {string}
     * @memberof CreateOAuthClientResponseBeta
     */
    'created': string;
    /**
     * The date and time, down to the millisecond, when the API Client was last updated
     * @type {string}
     * @memberof CreateOAuthClientResponseBeta
     */
    'modified': string;
    /**
     * Scopes of the API Client.
     * @type {Array<string>}
     * @memberof CreateOAuthClientResponseBeta
     */
    'scope': Array<string> | null;
}
/**
 * Object for specifying the name of a personal access token to create
 * @export
 * @interface CreatePersonalAccessTokenRequestBeta
 */
export interface CreatePersonalAccessTokenRequestBeta {
    /**
     * The name of the personal access token (PAT) to be created. Cannot be the same as another PAT owned by the user for whom this PAT is being created.
     * @type {string}
     * @memberof CreatePersonalAccessTokenRequestBeta
     */
    'name': string;
    /**
     * Scopes of the personal access token. If no scope is specified, the token will be created with the default scope \"sp:scopes:all\". This means the personal access token will have all the rights of the owner who created it.
     * @type {Array<string>}
     * @memberof CreatePersonalAccessTokenRequestBeta
     */
    'scope'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface CreatePersonalAccessTokenResponseBeta
 */
export interface CreatePersonalAccessTokenResponseBeta {
    /**
     * The ID of the personal access token (to be used as the username for Basic Auth).
     * @type {string}
     * @memberof CreatePersonalAccessTokenResponseBeta
     */
    'id': string;
    /**
     * The secret of the personal access token (to be used as the password for Basic Auth).
     * @type {string}
     * @memberof CreatePersonalAccessTokenResponseBeta
     */
    'secret': string;
    /**
     * Scopes of the personal  access token.
     * @type {Array<string>}
     * @memberof CreatePersonalAccessTokenResponseBeta
     */
    'scope': Array<string> | null;
    /**
     * The name of the personal access token. Cannot be the same as other personal access tokens owned by a user.
     * @type {string}
     * @memberof CreatePersonalAccessTokenResponseBeta
     */
    'name': string;
    /**
     * 
     * @type {BaseReferenceDto1Beta}
     * @memberof CreatePersonalAccessTokenResponseBeta
     */
    'owner': BaseReferenceDto1Beta;
    /**
     * The date and time, down to the millisecond, when this personal access token was created.
     * @type {string}
     * @memberof CreatePersonalAccessTokenResponseBeta
     */
    'created': string;
}
/**
 * 
 * @export
 * @interface CreateWorkflowRequestBeta
 */
export interface CreateWorkflowRequestBeta {
    /**
     * The name of the workflow
     * @type {string}
     * @memberof CreateWorkflowRequestBeta
     */
    'name': string;
    /**
     * 
     * @type {WorkflowBodyOwnerBeta}
     * @memberof CreateWorkflowRequestBeta
     */
    'owner': WorkflowBodyOwnerBeta;
    /**
     * Description of what the workflow accomplishes
     * @type {string}
     * @memberof CreateWorkflowRequestBeta
     */
    'description'?: string;
    /**
     * 
     * @type {WorkflowDefinitionBeta}
     * @memberof CreateWorkflowRequestBeta
     */
    'definition'?: WorkflowDefinitionBeta;
    /**
     * Enable or disable the workflow.  Workflows cannot be created in an enabled state.
     * @type {boolean}
     * @memberof CreateWorkflowRequestBeta
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {WorkflowTriggerBeta}
     * @memberof CreateWorkflowRequestBeta
     */
    'trigger'?: WorkflowTriggerBeta;
}
/**
 * 
 * @export
 * @interface CustomPasswordInstructionBeta
 */
export interface CustomPasswordInstructionBeta {
    /**
     * The page ID that represents the page for forget user name, reset password and unlock account flow.
     * @type {string}
     * @memberof CustomPasswordInstructionBeta
     */
    'pageId'?: CustomPasswordInstructionBetaPageIdEnum;
    /**
     * The custom instructions for the specified page. Allow basic HTML format and maximum length is 1000 characters. The custom instructions will be sanitized to avoid attacks. If the customization text includes a link, like <A HREF=\\\"URL\\\">...</A> clicking on this will open the link on the current browser page. If you want your link to be redirected to a different page, please redirect it to \"_blank\" like this: <a href=\\\"URL\" target=\\\"_blank\\\" >link</a>. This will open a new tab when the link is clicked. Notice we\'re only supporting _blank as the redirection target.
     * @type {string}
     * @memberof CustomPasswordInstructionBeta
     */
    'pageContent'?: string;
    /**
     * The locale for the custom instructions, a BCP47 language tag. The default value is \\\"default\\\".
     * @type {string}
     * @memberof CustomPasswordInstructionBeta
     */
    'locale'?: string;
}

export const CustomPasswordInstructionBetaPageIdEnum = {
    ChangePasswordenterPassword: 'change-password:enter-password',
    ChangePasswordfinish: 'change-password:finish',
    FlowSelectionselect: 'flow-selection:select',
    ForgetUsernameuserEmail: 'forget-username:user-email',
    MfaenterCode: 'mfa:enter-code',
    MfaenterKba: 'mfa:enter-kba',
    Mfaselect: 'mfa:select',
    ResetPasswordenterPassword: 'reset-password:enter-password',
    ResetPasswordenterUsername: 'reset-password:enter-username',
    ResetPasswordfinish: 'reset-password:finish',
    UnlockAccountenterUsername: 'unlock-account:enter-username',
    UnlockAccountfinish: 'unlock-account:finish'
} as const;

export type CustomPasswordInstructionBetaPageIdEnum = typeof CustomPasswordInstructionBetaPageIdEnum[keyof typeof CustomPasswordInstructionBetaPageIdEnum];

/**
 * 
 * @export
 * @interface Delete202ResponseBeta
 */
export interface Delete202ResponseBeta {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof Delete202ResponseBeta
     */
    'type'?: Delete202ResponseBetaTypeEnum;
    /**
     * ID of the task result
     * @type {string}
     * @memberof Delete202ResponseBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of the task result (should be null/empty)
     * @type {string}
     * @memberof Delete202ResponseBeta
     */
    'name'?: string;
}

export const Delete202ResponseBetaTypeEnum = {
    TaskResult: 'TASK_RESULT'
} as const;

export type Delete202ResponseBetaTypeEnum = typeof Delete202ResponseBetaTypeEnum[keyof typeof Delete202ResponseBetaTypeEnum];

/**
 * 
 * @export
 * @interface DeleteCampaignsRequestBeta
 */
export interface DeleteCampaignsRequestBeta {
    /**
     * The ids of the campaigns to delete
     * @type {Array<string>}
     * @memberof DeleteCampaignsRequestBeta
     */
    'ids'?: Array<string>;
}
/**
 * 
 * @export
 * @interface DeleteNonEmployeeRecordInBulkRequestBeta
 */
export interface DeleteNonEmployeeRecordInBulkRequestBeta {
    /**
     * List of non-employee ids.
     * @type {Array<string>}
     * @memberof DeleteNonEmployeeRecordInBulkRequestBeta
     */
    'ids': Array<string>;
}
/**
 * DKIM attributes for a domain or identity
 * @export
 * @interface DkimAttributesBeta
 */
export interface DkimAttributesBeta {
    /**
     * UUID associated with domain to be verified
     * @type {string}
     * @memberof DkimAttributesBeta
     */
    'id'?: string;
    /**
     * The identity or domain address
     * @type {string}
     * @memberof DkimAttributesBeta
     */
    'address'?: string;
    /**
     * Whether or not DKIM has been enabled for this domain / identity
     * @type {boolean}
     * @memberof DkimAttributesBeta
     */
    'dkimEnabled'?: boolean;
    /**
     * The tokens to be added to a DNS for verification
     * @type {Array<string>}
     * @memberof DkimAttributesBeta
     */
    'dkimTokens'?: Array<string>;
    /**
     * The current status if the domain /identity has been verified. Ie Success, Failed, Pending
     * @type {string}
     * @memberof DkimAttributesBeta
     */
    'dkimVerificationStatus'?: string;
}
/**
 * 
 * @export
 * @interface DomainAddressBeta
 */
export interface DomainAddressBeta {
    /**
     * A domain address
     * @type {string}
     * @memberof DomainAddressBeta
     */
    'domain'?: string;
}
/**
 * Domain status DTO containing everything required to verify via DKIM
 * @export
 * @interface DomainStatusDtoBeta
 */
export interface DomainStatusDtoBeta {
    /**
     * New UUID associated with domain to be verified
     * @type {string}
     * @memberof DomainStatusDtoBeta
     */
    'id'?: string;
    /**
     * A domain address
     * @type {string}
     * @memberof DomainStatusDtoBeta
     */
    'domain'?: string;
    /**
     * DKIM is enabled for this domain
     * @type {object}
     * @memberof DomainStatusDtoBeta
     */
    'dkimEnabled'?: object;
    /**
     * DKIM tokens required for authentication
     * @type {Array<string>}
     * @memberof DomainStatusDtoBeta
     */
    'dkimTokens'?: Array<string>;
    /**
     * Status of DKIM authentication
     * @type {string}
     * @memberof DomainStatusDtoBeta
     */
    'dkimVerificationStatus'?: string;
}
/**
 * An enumeration of the types of DTOs supported within the IdentityNow infrastructure.
 * @export
 * @enum {string}
 */

export const DtoTypeBeta = {
    AccountCorrelationConfig: 'ACCOUNT_CORRELATION_CONFIG',
    AccessProfile: 'ACCESS_PROFILE',
    AccessRequestApproval: 'ACCESS_REQUEST_APPROVAL',
    Account: 'ACCOUNT',
    Application: 'APPLICATION',
    Campaign: 'CAMPAIGN',
    CampaignFilter: 'CAMPAIGN_FILTER',
    Certification: 'CERTIFICATION',
    Cluster: 'CLUSTER',
    ConnectorSchema: 'CONNECTOR_SCHEMA',
    Entitlement: 'ENTITLEMENT',
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY',
    IdentityProfile: 'IDENTITY_PROFILE',
    IdentityRequest: 'IDENTITY_REQUEST',
    LifecycleState: 'LIFECYCLE_STATE',
    PasswordPolicy: 'PASSWORD_POLICY',
    Role: 'ROLE',
    Rule: 'RULE',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE',
    Tag: 'TAG',
    TagCategory: 'TAG_CATEGORY',
    TaskResult: 'TASK_RESULT',
    ReportResult: 'REPORT_RESULT',
    SodViolation: 'SOD_VIOLATION',
    AccountActivity: 'ACCOUNT_ACTIVITY',
    Workgroup: 'WORKGROUP'
} as const;

export type DtoTypeBeta = typeof DtoTypeBeta[keyof typeof DtoTypeBeta];


/**
 * 
 * @export
 * @interface EmailNotificationOptionBeta
 */
export interface EmailNotificationOptionBeta {
    /**
     * If true, then the manager is notified of the lifecycle state change.
     * @type {boolean}
     * @memberof EmailNotificationOptionBeta
     */
    'notifyManagers'?: boolean;
    /**
     * If true, then all the admins are notified of the lifecycle state change.
     * @type {boolean}
     * @memberof EmailNotificationOptionBeta
     */
    'notifyAllAdmins'?: boolean;
    /**
     * If true, then the users specified in \"emailAddressList\" below are notified of lifecycle state change.
     * @type {boolean}
     * @memberof EmailNotificationOptionBeta
     */
    'notifySpecificUsers'?: boolean;
    /**
     * List of user email addresses. If \"notifySpecificUsers\" option is true, then these users are notified of lifecycle state change.
     * @type {Array<string>}
     * @memberof EmailNotificationOptionBeta
     */
    'emailAddressList'?: Array<string>;
}
/**
 * 
 * @export
 * @interface EmailStatusDtoBeta
 */
export interface EmailStatusDtoBeta {
    /**
     * 
     * @type {string}
     * @memberof EmailStatusDtoBeta
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailStatusDtoBeta
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailStatusDtoBeta
     */
    'verificationStatus'?: EmailStatusDtoBetaVerificationStatusEnum;
}

export const EmailStatusDtoBetaVerificationStatusEnum = {
    Pending: 'PENDING',
    Success: 'SUCCESS',
    Failed: 'FAILED'
} as const;

export type EmailStatusDtoBetaVerificationStatusEnum = typeof EmailStatusDtoBetaVerificationStatusEnum[keyof typeof EmailStatusDtoBetaVerificationStatusEnum];

/**
 * 
 * @export
 * @interface EntitlementAccessRequestConfigBeta
 */
export interface EntitlementAccessRequestConfigBeta {
    /**
     * Ordered list of approval steps for the access request. Empty when no approval is required.
     * @type {Array<EntitlementApprovalSchemeBeta>}
     * @memberof EntitlementAccessRequestConfigBeta
     */
    'approvalSchemes'?: Array<EntitlementApprovalSchemeBeta>;
    /**
     * If the requester must provide a comment during access request.
     * @type {boolean}
     * @memberof EntitlementAccessRequestConfigBeta
     */
    'requestCommentRequired'?: boolean;
    /**
     * If the reviewer must provide a comment when denying the access request.
     * @type {boolean}
     * @memberof EntitlementAccessRequestConfigBeta
     */
    'denialCommentRequired'?: boolean;
}
/**
 * 
 * @export
 * @interface EntitlementApprovalSchemeBeta
 */
export interface EntitlementApprovalSchemeBeta {
    /**
     * Describes the individual or group that is responsible for an approval step. Values are as follows.  **ENTITLEMENT_OWNER**: Owner of the associated Entitlement  **SOURCE_OWNER**: Owner of the associated Source  **MANAGER**: Manager of the Identity for whom the request is being made  **GOVERNANCE_GROUP**: A Governance Group, the ID of which is specified by the **approverId** field
     * @type {string}
     * @memberof EntitlementApprovalSchemeBeta
     */
    'approverType'?: EntitlementApprovalSchemeBetaApproverTypeEnum;
    /**
     * Id of the specific approver, used only when approverType is GOVERNANCE_GROUP
     * @type {string}
     * @memberof EntitlementApprovalSchemeBeta
     */
    'approverId'?: string | null;
}

export const EntitlementApprovalSchemeBetaApproverTypeEnum = {
    EntitlementOwner: 'ENTITLEMENT_OWNER',
    SourceOwner: 'SOURCE_OWNER',
    Manager: 'MANAGER',
    GovernanceGroup: 'GOVERNANCE_GROUP'
} as const;

export type EntitlementApprovalSchemeBetaApproverTypeEnum = typeof EntitlementApprovalSchemeBetaApproverTypeEnum[keyof typeof EntitlementApprovalSchemeBetaApproverTypeEnum];

/**
 * 
 * @export
 * @interface EntitlementBeta
 */
export interface EntitlementBeta {
    /**
     * The entitlement id
     * @type {string}
     * @memberof EntitlementBeta
     */
    'id'?: string;
    /**
     * The entitlement name
     * @type {string}
     * @memberof EntitlementBeta
     */
    'name'?: string;
    /**
     * Time when the entitlement was created
     * @type {string}
     * @memberof EntitlementBeta
     */
    'created'?: string;
    /**
     * Time when the entitlement was last modified
     * @type {string}
     * @memberof EntitlementBeta
     */
    'modified'?: string;
    /**
     * The entitlement attribute name
     * @type {string}
     * @memberof EntitlementBeta
     */
    'attribute'?: string;
    /**
     * The value of the entitlement
     * @type {string}
     * @memberof EntitlementBeta
     */
    'value'?: string;
    /**
     * The object type of the entitlement from the source schema
     * @type {string}
     * @memberof EntitlementBeta
     */
    'sourceSchemaObjectType'?: string;
    /**
     * True if the entitlement is privileged
     * @type {boolean}
     * @memberof EntitlementBeta
     */
    'privileged'?: boolean;
    /**
     * True if the entitlement is cloud governed
     * @type {boolean}
     * @memberof EntitlementBeta
     */
    'cloudGoverned'?: boolean;
    /**
     * The description of the entitlement
     * @type {string}
     * @memberof EntitlementBeta
     */
    'description'?: string;
    /**
     * True if the entitlement is requestable
     * @type {boolean}
     * @memberof EntitlementBeta
     */
    'requestable'?: boolean;
    /**
     * A map of free-form key-value pairs from the source system
     * @type {{ [key: string]: any; }}
     * @memberof EntitlementBeta
     */
    'attributes'?: { [key: string]: any; };
    /**
     * 
     * @type {EntitlementSourceBeta}
     * @memberof EntitlementBeta
     */
    'source'?: EntitlementSourceBeta;
    /**
     * 
     * @type {OwnerReferenceDtoBeta}
     * @memberof EntitlementBeta
     */
    'owner'?: OwnerReferenceDtoBeta;
    /**
     * 
     * @type {Array<PermissionDtoBeta>}
     * @memberof EntitlementBeta
     */
    'directPermissions'?: Array<PermissionDtoBeta>;
    /**
     * List of IDs of segments, if any, to which this Entitlement is assigned.
     * @type {Array<string>}
     * @memberof EntitlementBeta
     */
    'segments'?: Array<string> | null;
    /**
     * 
     * @type {ManuallyUpdatedFieldsDTOBeta}
     * @memberof EntitlementBeta
     */
    'manuallyUpdatedFields'?: ManuallyUpdatedFieldsDTOBeta;
}
/**
 * 
 * @export
 * @interface EntitlementBulkUpdateRequestBeta
 */
export interface EntitlementBulkUpdateRequestBeta {
    /**
     * List of entitlement ids to update
     * @type {Array<string>}
     * @memberof EntitlementBulkUpdateRequestBeta
     */
    'entitlementIds': Array<string>;
    /**
     * 
     * @type {Array<JsonPatchOperationBeta>}
     * @memberof EntitlementBulkUpdateRequestBeta
     */
    'jsonPatch': Array<JsonPatchOperationBeta>;
}
/**
 * 
 * @export
 * @interface EntitlementRefBeta
 */
export interface EntitlementRefBeta {
    /**
     * The ID of the Entitlement
     * @type {string}
     * @memberof EntitlementRefBeta
     */
    'id'?: string;
    /**
     * The type of the Entitlement, will always be ENTITLEMENT
     * @type {string}
     * @memberof EntitlementRefBeta
     */
    'type'?: EntitlementRefBetaTypeEnum;
    /**
     * The display name of the Entitlement
     * @type {string}
     * @memberof EntitlementRefBeta
     */
    'name'?: string;
}

export const EntitlementRefBetaTypeEnum = {
    Entitlement: 'ENTITLEMENT'
} as const;

export type EntitlementRefBetaTypeEnum = typeof EntitlementRefBetaTypeEnum[keyof typeof EntitlementRefBetaTypeEnum];

/**
 * 
 * @export
 * @interface EntitlementRequestConfig1Beta
 */
export interface EntitlementRequestConfig1Beta {
    /**
     * Flag for allowing entitlement request.
     * @type {boolean}
     * @memberof EntitlementRequestConfig1Beta
     */
    'allowEntitlementRequest'?: boolean;
    /**
     * Flag for requiring comments while submitting an entitlement request.
     * @type {boolean}
     * @memberof EntitlementRequestConfig1Beta
     */
    'requestCommentsRequired'?: boolean;
    /**
     * Flag for requiring comments while rejecting an entitlement request.
     * @type {boolean}
     * @memberof EntitlementRequestConfig1Beta
     */
    'deniedCommentsRequired'?: boolean;
    /**
     * Approval schemes for granting entitlement request. This can be empty if no approval is needed. Multiple schemes must be comma-separated. The valid schemes are \"entitlementOwner\", \"sourceOwner\", \"manager\" and \"workgroup:{id}\". Multiple workgroups (governance groups) can be used. 
     * @type {string}
     * @memberof EntitlementRequestConfig1Beta
     */
    'grantRequestApprovalSchemes'?: string;
}
/**
 * 
 * @export
 * @interface EntitlementRequestConfigBeta
 */
export interface EntitlementRequestConfigBeta {
    /**
     * 
     * @type {EntitlementAccessRequestConfigBeta}
     * @memberof EntitlementRequestConfigBeta
     */
    'accessRequestConfig'?: EntitlementAccessRequestConfigBeta;
}
/**
 * 
 * @export
 * @interface EntitlementSourceBeta
 */
export interface EntitlementSourceBeta {
    /**
     * The source ID
     * @type {string}
     * @memberof EntitlementSourceBeta
     */
    'id'?: string;
    /**
     * The source type, will always be \"SOURCE\"
     * @type {string}
     * @memberof EntitlementSourceBeta
     */
    'type'?: string;
    /**
     * The source name
     * @type {string}
     * @memberof EntitlementSourceBeta
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface EntityCreatedByDTOBeta
 */
export interface EntityCreatedByDTOBeta {
    /**
     * ID of the creator
     * @type {string}
     * @memberof EntityCreatedByDTOBeta
     */
    'id'?: string;
    /**
     * The display name of the creator
     * @type {string}
     * @memberof EntityCreatedByDTOBeta
     */
    'displayName'?: string;
}
/**
 * 
 * @export
 * @interface ErrorBeta
 */
export interface ErrorBeta {
    /**
     * DetailCode is the text of the status code returned
     * @type {string}
     * @memberof ErrorBeta
     */
    'detailCode'?: string;
    /**
     * 
     * @type {Array<ErrorMessageBeta>}
     * @memberof ErrorBeta
     */
    'messages'?: Array<ErrorMessageBeta>;
    /**
     * TrackingID is the request tracking unique identifier
     * @type {string}
     * @memberof ErrorBeta
     */
    'trackingId'?: string;
}
/**
 * 
 * @export
 * @interface ErrorMessageBeta
 */
export interface ErrorMessageBeta {
    /**
     * Locale is the current Locale
     * @type {string}
     * @memberof ErrorMessageBeta
     */
    'locale'?: string;
    /**
     * LocaleOrigin holds possible values of how the locale was selected
     * @type {string}
     * @memberof ErrorMessageBeta
     */
    'localeOrigin'?: string;
    /**
     * Text is the actual text of the error message
     * @type {string}
     * @memberof ErrorMessageBeta
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface ErrorMessageDtoBeta
 */
export interface ErrorMessageDtoBeta {
    /**
     * The locale for the message text, a BCP 47 language tag.
     * @type {string}
     * @memberof ErrorMessageDtoBeta
     */
    'locale'?: string;
    /**
     * 
     * @type {LocaleOriginBeta}
     * @memberof ErrorMessageDtoBeta
     */
    'localeOrigin'?: LocaleOriginBeta;
    /**
     * Actual text of the error message in the indicated locale.
     * @type {string}
     * @memberof ErrorMessageDtoBeta
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface ErrorResponseDtoBeta
 */
export interface ErrorResponseDtoBeta {
    /**
     * Fine-grained error code providing more detail of the error.
     * @type {string}
     * @memberof ErrorResponseDtoBeta
     */
    'detailCode'?: string;
    /**
     * Unique tracking id for the error.
     * @type {string}
     * @memberof ErrorResponseDtoBeta
     */
    'trackingId'?: string;
    /**
     * Generic localized reason for error
     * @type {Array<ErrorMessageDtoBeta>}
     * @memberof ErrorResponseDtoBeta
     */
    'messages'?: Array<ErrorMessageDtoBeta>;
    /**
     * Plain-text descriptive reasons to provide additional detail to the text provided in the messages field
     * @type {Array<ErrorMessageDtoBeta>}
     * @memberof ErrorResponseDtoBeta
     */
    'causes'?: Array<ErrorMessageDtoBeta>;
}
/**
 * The response body for Evaluate Reassignment Configuration
 * @export
 * @interface EvaluateResponseBeta
 */
export interface EvaluateResponseBeta {
    /**
     * The Identity ID which should be the recipient of any work items sent to a specific identity & work type
     * @type {string}
     * @memberof EvaluateResponseBeta
     */
    'reassignToId'?: string;
    /**
     * List of Reassignments found by looking up the next `TargetIdentity` in a ReassignmentConfiguration
     * @type {Array<LookupStepBeta>}
     * @memberof EvaluateResponseBeta
     */
    'lookupTrail'?: Array<LookupStepBeta>;
}
/**
 * Attributes related to an IdentityNow ETS event
 * @export
 * @interface EventAttributesBeta
 */
export interface EventAttributesBeta {
    /**
     * The unique ID of the trigger
     * @type {string}
     * @memberof EventAttributesBeta
     */
    'id': string;
    /**
     * JSON path expression that will limit which events the trigger will fire on
     * @type {string}
     * @memberof EventAttributesBeta
     */
    'filter.$'?: string;
}
/**
 * 
 * @export
 * @interface EventBridgeConfigBeta
 */
export interface EventBridgeConfigBeta {
    /**
     * AWS Account Number (12-digit number) that has the EventBridge Partner Event Source Resource.
     * @type {string}
     * @memberof EventBridgeConfigBeta
     */
    'awsAccount': string;
    /**
     * AWS Region that has the EventBridge Partner Event Source Resource. See https://docs.aws.amazon.com/general/latest/gr/rande.html for a full list of available values.
     * @type {string}
     * @memberof EventBridgeConfigBeta
     */
    'awsRegion': string;
}
/**
 * 
 * @export
 * @interface ExceptionAccessCriteriaBeta
 */
export interface ExceptionAccessCriteriaBeta {
    /**
     * 
     * @type {ExceptionCriteriaBeta}
     * @memberof ExceptionAccessCriteriaBeta
     */
    'leftCriteria'?: ExceptionCriteriaBeta;
    /**
     * 
     * @type {ExceptionCriteriaBeta}
     * @memberof ExceptionAccessCriteriaBeta
     */
    'rightCriteria'?: ExceptionCriteriaBeta;
}
/**
 * Access reference with addition of boolean existing flag to indicate whether the access was extant
 * @export
 * @interface ExceptionCriteriaAccessBeta
 */
export interface ExceptionCriteriaAccessBeta {
    /**
     * 
     * @type {DtoTypeBeta}
     * @memberof ExceptionCriteriaAccessBeta
     */
    'type'?: DtoTypeBeta;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof ExceptionCriteriaAccessBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof ExceptionCriteriaAccessBeta
     */
    'name'?: string;
    /**
     * Whether the subject identity already had that access or not
     * @type {boolean}
     * @memberof ExceptionCriteriaAccessBeta
     */
    'existing'?: boolean;
}
/**
 * 
 * @export
 * @interface ExceptionCriteriaBeta
 */
export interface ExceptionCriteriaBeta {
    /**
     * List of exception criteria. There is a min of 1 and max of 50 items in the list.
     * @type {Array<ExceptionCriteriaCriteriaListInnerBeta>}
     * @memberof ExceptionCriteriaBeta
     */
    'criteriaList'?: Array<ExceptionCriteriaCriteriaListInnerBeta>;
}
/**
 * The types of objects supported for SOD violations
 * @export
 * @interface ExceptionCriteriaCriteriaListInnerBeta
 */
export interface ExceptionCriteriaCriteriaListInnerBeta {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof ExceptionCriteriaCriteriaListInnerBeta
     */
    'type'?: ExceptionCriteriaCriteriaListInnerBetaTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof ExceptionCriteriaCriteriaListInnerBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof ExceptionCriteriaCriteriaListInnerBeta
     */
    'name'?: string;
    /**
     * Whether the subject identity already had that access or not
     * @type {boolean}
     * @memberof ExceptionCriteriaCriteriaListInnerBeta
     */
    'existing'?: boolean;
}

export const ExceptionCriteriaCriteriaListInnerBetaTypeEnum = {
    Entitlement: 'ENTITLEMENT'
} as const;

export type ExceptionCriteriaCriteriaListInnerBetaTypeEnum = typeof ExceptionCriteriaCriteriaListInnerBetaTypeEnum[keyof typeof ExceptionCriteriaCriteriaListInnerBetaTypeEnum];

/**
 * The current state of execution.
 * @export
 * @enum {string}
 */

export const ExecutionStatusBeta = {
    Executing: 'EXECUTING',
    Verifying: 'VERIFYING',
    Terminated: 'TERMINATED',
    Completed: 'COMPLETED'
} as const;

export type ExecutionStatusBeta = typeof ExecutionStatusBeta[keyof typeof ExecutionStatusBeta];


/**
 * 
 * @export
 * @interface ExportFormDefinitionsByTenant200ResponseInnerBeta
 */
export interface ExportFormDefinitionsByTenant200ResponseInnerBeta {
    /**
     * 
     * @type {FormDefinitionResponseBeta}
     * @memberof ExportFormDefinitionsByTenant200ResponseInnerBeta
     */
    'object'?: FormDefinitionResponseBeta;
    /**
     * 
     * @type {string}
     * @memberof ExportFormDefinitionsByTenant200ResponseInnerBeta
     */
    'self'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExportFormDefinitionsByTenant200ResponseInnerBeta
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface ExportOptionsBeta
 */
export interface ExportOptionsBeta {
    /**
     * Object type names to be excluded from an sp-config export command.
     * @type {Array<string>}
     * @memberof ExportOptionsBeta
     */
    'excludeTypes'?: Array<ExportOptionsBetaExcludeTypesEnum>;
    /**
     * Object type names to be included in an sp-config export command. IncludeTypes takes precedence over excludeTypes.
     * @type {Array<string>}
     * @memberof ExportOptionsBeta
     */
    'includeTypes'?: Array<ExportOptionsBetaIncludeTypesEnum>;
    /**
     * Additional options targeting specific objects related to each item in the includeTypes field
     * @type {{ [key: string]: ObjectExportImportOptionsBeta; }}
     * @memberof ExportOptionsBeta
     */
    'objectOptions'?: { [key: string]: ObjectExportImportOptionsBeta; };
}

export const ExportOptionsBetaExcludeTypesEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    AccessRequestConfig: 'ACCESS_REQUEST_CONFIG',
    AttrSyncSourceConfig: 'ATTR_SYNC_SOURCE_CONFIG',
    AuthOrg: 'AUTH_ORG',
    CampaignFilter: 'CAMPAIGN_FILTER',
    FormDefinition: 'FORM_DEFINITION',
    GovernanceGroup: 'GOVERNANCE_GROUP',
    IdentityObjectConfig: 'IDENTITY_OBJECT_CONFIG',
    IdentityProfile: 'IDENTITY_PROFILE',
    LifecycleState: 'LIFECYCLE_STATE',
    NotificationTemplate: 'NOTIFICATION_TEMPLATE',
    PasswordPolicy: 'PASSWORD_POLICY',
    PasswordSyncGroup: 'PASSWORD_SYNC_GROUP',
    PublicIdentitiesConfig: 'PUBLIC_IDENTITIES_CONFIG',
    Role: 'ROLE',
    Rule: 'RULE',
    ServiceDeskIntegration: 'SERVICE_DESK_INTEGRATION',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE',
    Transform: 'TRANSFORM',
    TriggerSubscription: 'TRIGGER_SUBSCRIPTION',
    Workflows: 'WORKFLOWS'
} as const;

export type ExportOptionsBetaExcludeTypesEnum = typeof ExportOptionsBetaExcludeTypesEnum[keyof typeof ExportOptionsBetaExcludeTypesEnum];
export const ExportOptionsBetaIncludeTypesEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    AccessRequestConfig: 'ACCESS_REQUEST_CONFIG',
    AttrSyncSourceConfig: 'ATTR_SYNC_SOURCE_CONFIG',
    AuthOrg: 'AUTH_ORG',
    CampaignFilter: 'CAMPAIGN_FILTER',
    FormDefinition: 'FORM_DEFINITION',
    GovernanceGroup: 'GOVERNANCE_GROUP',
    IdentityObjectConfig: 'IDENTITY_OBJECT_CONFIG',
    IdentityProfile: 'IDENTITY_PROFILE',
    LifecycleState: 'LIFECYCLE_STATE',
    NotificationTemplate: 'NOTIFICATION_TEMPLATE',
    PasswordPolicy: 'PASSWORD_POLICY',
    PasswordSyncGroup: 'PASSWORD_SYNC_GROUP',
    PublicIdentitiesConfig: 'PUBLIC_IDENTITIES_CONFIG',
    Role: 'ROLE',
    Rule: 'RULE',
    ServiceDeskIntegration: 'SERVICE_DESK_INTEGRATION',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE',
    Transform: 'TRANSFORM',
    TriggerSubscription: 'TRIGGER_SUBSCRIPTION',
    Workflows: 'WORKFLOWS'
} as const;

export type ExportOptionsBetaIncludeTypesEnum = typeof ExportOptionsBetaIncludeTypesEnum[keyof typeof ExportOptionsBetaIncludeTypesEnum];

/**
 * 
 * @export
 * @interface ExportPayloadBeta
 */
export interface ExportPayloadBeta {
    /**
     * Optional user defined description/name for export job.
     * @type {string}
     * @memberof ExportPayloadBeta
     */
    'description'?: string;
    /**
     * Object type names to be excluded from an sp-config export command.
     * @type {Array<string>}
     * @memberof ExportPayloadBeta
     */
    'excludeTypes'?: Array<ExportPayloadBetaExcludeTypesEnum>;
    /**
     * Object type names to be included in an sp-config export command. IncludeTypes takes precedence over excludeTypes.
     * @type {Array<string>}
     * @memberof ExportPayloadBeta
     */
    'includeTypes'?: Array<ExportPayloadBetaIncludeTypesEnum>;
    /**
     * Additional options targeting specific objects related to each item in the includeTypes field
     * @type {{ [key: string]: ObjectExportImportOptionsBeta; }}
     * @memberof ExportPayloadBeta
     */
    'objectOptions'?: { [key: string]: ObjectExportImportOptionsBeta; };
}

export const ExportPayloadBetaExcludeTypesEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    AccessRequestConfig: 'ACCESS_REQUEST_CONFIG',
    AttrSyncSourceConfig: 'ATTR_SYNC_SOURCE_CONFIG',
    AuthOrg: 'AUTH_ORG',
    CampaignFilter: 'CAMPAIGN_FILTER',
    FormDefinition: 'FORM_DEFINITION',
    GovernanceGroup: 'GOVERNANCE_GROUP',
    IdentityObjectConfig: 'IDENTITY_OBJECT_CONFIG',
    IdentityProfile: 'IDENTITY_PROFILE',
    LifecycleState: 'LIFECYCLE_STATE',
    NotificationTemplate: 'NOTIFICATION_TEMPLATE',
    PasswordPolicy: 'PASSWORD_POLICY',
    PasswordSyncGroup: 'PASSWORD_SYNC_GROUP',
    PublicIdentitiesConfig: 'PUBLIC_IDENTITIES_CONFIG',
    Role: 'ROLE',
    Rule: 'RULE',
    ServiceDeskIntegration: 'SERVICE_DESK_INTEGRATION',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE',
    Transform: 'TRANSFORM',
    TriggerSubscription: 'TRIGGER_SUBSCRIPTION',
    Workflows: 'WORKFLOWS'
} as const;

export type ExportPayloadBetaExcludeTypesEnum = typeof ExportPayloadBetaExcludeTypesEnum[keyof typeof ExportPayloadBetaExcludeTypesEnum];
export const ExportPayloadBetaIncludeTypesEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    AccessRequestConfig: 'ACCESS_REQUEST_CONFIG',
    AttrSyncSourceConfig: 'ATTR_SYNC_SOURCE_CONFIG',
    AuthOrg: 'AUTH_ORG',
    CampaignFilter: 'CAMPAIGN_FILTER',
    FormDefinition: 'FORM_DEFINITION',
    GovernanceGroup: 'GOVERNANCE_GROUP',
    IdentityObjectConfig: 'IDENTITY_OBJECT_CONFIG',
    IdentityProfile: 'IDENTITY_PROFILE',
    LifecycleState: 'LIFECYCLE_STATE',
    NotificationTemplate: 'NOTIFICATION_TEMPLATE',
    PasswordPolicy: 'PASSWORD_POLICY',
    PasswordSyncGroup: 'PASSWORD_SYNC_GROUP',
    PublicIdentitiesConfig: 'PUBLIC_IDENTITIES_CONFIG',
    Role: 'ROLE',
    Rule: 'RULE',
    ServiceDeskIntegration: 'SERVICE_DESK_INTEGRATION',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE',
    Transform: 'TRANSFORM',
    TriggerSubscription: 'TRIGGER_SUBSCRIPTION',
    Workflows: 'WORKFLOWS'
} as const;

export type ExportPayloadBetaIncludeTypesEnum = typeof ExportPayloadBetaIncludeTypesEnum[keyof typeof ExportPayloadBetaIncludeTypesEnum];

/**
 * 
 * @export
 * @interface ExpressionBeta
 */
export interface ExpressionBeta {
    /**
     * Operator for the expression
     * @type {string}
     * @memberof ExpressionBeta
     */
    'operator'?: ExpressionBetaOperatorEnum;
    /**
     * Name for the attribute
     * @type {string}
     * @memberof ExpressionBeta
     */
    'attribute'?: string;
    /**
     * 
     * @type {ValueBeta}
     * @memberof ExpressionBeta
     */
    'value'?: ValueBeta;
    /**
     * List of expressions
     * @type {Array<ValueBeta>}
     * @memberof ExpressionBeta
     */
    'children'?: Array<ValueBeta>;
}

export const ExpressionBetaOperatorEnum = {
    And: 'AND',
    Equals: 'EQUALS'
} as const;

export type ExpressionBetaOperatorEnum = typeof ExpressionBetaOperatorEnum[keyof typeof ExpressionBetaOperatorEnum];

/**
 * Attributes related to an external trigger
 * @export
 * @interface ExternalAttributesBeta
 */
export interface ExternalAttributesBeta {
    /**
     * A unique name for the external trigger
     * @type {string}
     * @memberof ExternalAttributesBeta
     */
    'name': string;
    /**
     * Additonal context about the external trigger
     * @type {string}
     * @memberof ExternalAttributesBeta
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface FeatureValueDtoBeta
 */
export interface FeatureValueDtoBeta {
    /**
     * The type of feature
     * @type {string}
     * @memberof FeatureValueDtoBeta
     */
    'feature'?: string;
    /**
     * The number of identities that have access to the feature
     * @type {number}
     * @memberof FeatureValueDtoBeta
     */
    'numerator'?: number;
    /**
     * The number of identities with the corresponding feature
     * @type {number}
     * @memberof FeatureValueDtoBeta
     */
    'denominator'?: number;
}
/**
 * 
 * @export
 * @interface FieldAllOfBeta
 */
export interface FieldAllOfBeta {
    /**
     * Display name of the field
     * @type {string}
     * @memberof FieldAllOfBeta
     */
    'displayName'?: string;
    /**
     * Type of the field to display
     * @type {string}
     * @memberof FieldAllOfBeta
     */
    'displayType'?: string;
    /**
     * True if the field is required
     * @type {boolean}
     * @memberof FieldAllOfBeta
     */
    'required'?: boolean;
    /**
     * List of allowed values for the field
     * @type {Array<object>}
     * @memberof FieldAllOfBeta
     */
    'allowedValuesList'?: Array<object>;
    /**
     * Value of the field
     * @type {object}
     * @memberof FieldAllOfBeta
     */
    'value'?: object;
}
/**
 * 
 * @export
 * @interface FieldBeta
 */
export interface FieldBeta {
    /**
     * Name of the FormItem
     * @type {string}
     * @memberof FieldBeta
     */
    'name'?: string;
    /**
     * Display name of the field
     * @type {string}
     * @memberof FieldBeta
     */
    'displayName'?: string;
    /**
     * Type of the field to display
     * @type {string}
     * @memberof FieldBeta
     */
    'displayType'?: string;
    /**
     * True if the field is required
     * @type {boolean}
     * @memberof FieldBeta
     */
    'required'?: boolean;
    /**
     * List of allowed values for the field
     * @type {Array<object>}
     * @memberof FieldBeta
     */
    'allowedValuesList'?: Array<object>;
    /**
     * Value of the field
     * @type {object}
     * @memberof FieldBeta
     */
    'value'?: object;
}
/**
 * 
 * @export
 * @interface FieldDetailsBeta
 */
export interface FieldDetailsBeta {
    /**
     * Name of the FormItem
     * @type {string}
     * @memberof FieldDetailsBeta
     */
    'name'?: string;
    /**
     * Display name of the field
     * @type {string}
     * @memberof FieldDetailsBeta
     */
    'displayName'?: string;
    /**
     * Type of the field to display
     * @type {string}
     * @memberof FieldDetailsBeta
     */
    'displayType'?: string;
    /**
     * True if the field is required
     * @type {boolean}
     * @memberof FieldDetailsBeta
     */
    'required'?: boolean;
    /**
     * List of allowed values for the field
     * @type {Array<object>}
     * @memberof FieldDetailsBeta
     */
    'allowedValuesList'?: Array<object>;
    /**
     * Value of the field
     * @type {object}
     * @memberof FieldDetailsBeta
     */
    'value'?: object;
}
/**
 * 
 * @export
 * @interface FieldDetailsDtoBeta
 */
export interface FieldDetailsDtoBeta {
    /**
     * The name of the attribute.
     * @type {string}
     * @memberof FieldDetailsDtoBeta
     */
    'name'?: string;
    /**
     * The transform to apply to the field
     * @type {object}
     * @memberof FieldDetailsDtoBeta
     */
    'transform'?: object;
    /**
     * Attributes required for the transform
     * @type {object}
     * @memberof FieldDetailsDtoBeta
     */
    'attributes'?: object;
    /**
     * Flag indicating whether or not the attribute is required.
     * @type {boolean}
     * @memberof FieldDetailsDtoBeta
     */
    'isRequired'?: boolean;
    /**
     * The type of the attribute.
     * @type {string}
     * @memberof FieldDetailsDtoBeta
     */
    'type'?: string;
    /**
     * Flag indicating whether or not the attribute is multi-valued.
     * @type {boolean}
     * @memberof FieldDetailsDtoBeta
     */
    'isMultiValued'?: boolean;
}
/**
 * 
 * @export
 * @interface FormBeta
 */
export interface FormBeta {
    /**
     * ID of the form
     * @type {string}
     * @memberof FormBeta
     */
    'id'?: string;
    /**
     * Name of the form
     * @type {string}
     * @memberof FormBeta
     */
    'name'?: string;
    /**
     * The form title
     * @type {string}
     * @memberof FormBeta
     */
    'title'?: string;
    /**
     * The form subtitle.
     * @type {string}
     * @memberof FormBeta
     */
    'subtitle'?: string;
    /**
     * The name of the user that should be shown this form
     * @type {string}
     * @memberof FormBeta
     */
    'targetUser'?: string;
    /**
     * 
     * @type {SectionDetailsBeta}
     * @memberof FormBeta
     */
    'sections'?: SectionDetailsBeta;
}
/**
 * FormCondition represent a form conditional
 * @export
 * @interface FormConditionBeta
 */
export interface FormConditionBeta {
    /**
     * Effects is a list of effects
     * @type {Array<ConditionEffectBeta>}
     * @memberof FormConditionBeta
     */
    'effects'?: Array<ConditionEffectBeta>;
    /**
     * RuleOperator is a ConditionRuleLogicalOperatorType value AND ConditionRuleLogicalOperatorTypeAnd OR ConditionRuleLogicalOperatorTypeOr
     * @type {string}
     * @memberof FormConditionBeta
     */
    'ruleOperator'?: FormConditionBetaRuleOperatorEnum;
    /**
     * Rules is a list of rules
     * @type {Array<ConditionRuleBeta>}
     * @memberof FormConditionBeta
     */
    'rules'?: Array<ConditionRuleBeta>;
}

export const FormConditionBetaRuleOperatorEnum = {
    And: 'AND',
    Or: 'OR'
} as const;

export type FormConditionBetaRuleOperatorEnum = typeof FormConditionBetaRuleOperatorEnum[keyof typeof FormConditionBetaRuleOperatorEnum];

/**
 * 
 * @export
 * @interface FormDefinitionDynamicSchemaRequestAttributesBeta
 */
export interface FormDefinitionDynamicSchemaRequestAttributesBeta {
    /**
     * FormDefinitionID is a unique guid identifying this form definition
     * @type {string}
     * @memberof FormDefinitionDynamicSchemaRequestAttributesBeta
     */
    'formDefinitionId'?: string;
}
/**
 * 
 * @export
 * @interface FormDefinitionDynamicSchemaRequestBeta
 */
export interface FormDefinitionDynamicSchemaRequestBeta {
    /**
     * 
     * @type {FormDefinitionDynamicSchemaRequestAttributesBeta}
     * @memberof FormDefinitionDynamicSchemaRequestBeta
     */
    'attributes'?: FormDefinitionDynamicSchemaRequestAttributesBeta;
    /**
     * Description is the form definition dynamic schema description text
     * @type {string}
     * @memberof FormDefinitionDynamicSchemaRequestBeta
     */
    'description'?: string;
    /**
     * ID is a unique identifier
     * @type {string}
     * @memberof FormDefinitionDynamicSchemaRequestBeta
     */
    'id'?: string;
    /**
     * Type is the form definition dynamic schema type
     * @type {string}
     * @memberof FormDefinitionDynamicSchemaRequestBeta
     */
    'type'?: string;
    /**
     * VersionNumber is the form definition dynamic schema version number
     * @type {number}
     * @memberof FormDefinitionDynamicSchemaRequestBeta
     */
    'versionNumber'?: number;
}
/**
 * 
 * @export
 * @interface FormDefinitionDynamicSchemaResponseBeta
 */
export interface FormDefinitionDynamicSchemaResponseBeta {
    /**
     * OutputSchema holds a JSON schema generated dynamically
     * @type {{ [key: string]: object; }}
     * @memberof FormDefinitionDynamicSchemaResponseBeta
     */
    'outputSchema'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface FormDefinitionInputBeta
 */
export interface FormDefinitionInputBeta {
    /**
     * Description is the description for this form input value
     * @type {string}
     * @memberof FormDefinitionInputBeta
     */
    'description'?: string;
    /**
     * ID is a unique identifier
     * @type {string}
     * @memberof FormDefinitionInputBeta
     */
    'id'?: string;
    /**
     * Label is the name for this form input value
     * @type {string}
     * @memberof FormDefinitionInputBeta
     */
    'label'?: string;
    /**
     * Type is a FormDefinitionInputType value STRING FormDefinitionInputTypeString
     * @type {string}
     * @memberof FormDefinitionInputBeta
     */
    'type'?: FormDefinitionInputBetaTypeEnum;
}

export const FormDefinitionInputBetaTypeEnum = {
    String: 'STRING'
} as const;

export type FormDefinitionInputBetaTypeEnum = typeof FormDefinitionInputBetaTypeEnum[keyof typeof FormDefinitionInputBetaTypeEnum];

/**
 * 
 * @export
 * @interface FormDefinitionResponseBeta
 */
export interface FormDefinitionResponseBeta {
    /**
     * Created is the date the form definition was created
     * @type {string}
     * @memberof FormDefinitionResponseBeta
     */
    'created'?: string;
    /**
     * Description is the form definition description
     * @type {string}
     * @memberof FormDefinitionResponseBeta
     */
    'description'?: string;
    /**
     * FormConditions is the conditional logic that modify the form dynamically modify the form as the recipient is interacting out the form
     * @type {Array<FormConditionBeta>}
     * @memberof FormDefinitionResponseBeta
     */
    'formConditions'?: Array<FormConditionBeta>;
    /**
     * FormElements is a list of nested form elements
     * @type {Array<FormElementBeta>}
     * @memberof FormDefinitionResponseBeta
     */
    'formElements'?: Array<FormElementBeta>;
    /**
     * FormInput is a list of form inputs that are required when creating a form-instance object
     * @type {Array<FormDefinitionInputBeta>}
     * @memberof FormDefinitionResponseBeta
     */
    'formInput'?: Array<FormDefinitionInputBeta>;
    /**
     * FormDefinitionID is a unique guid identifying this form definition
     * @type {string}
     * @memberof FormDefinitionResponseBeta
     */
    'id'?: string;
    /**
     * Modified is the last date the form definition was modified
     * @type {string}
     * @memberof FormDefinitionResponseBeta
     */
    'modified'?: string;
    /**
     * Name is the form definition name
     * @type {string}
     * @memberof FormDefinitionResponseBeta
     */
    'name'?: string;
    /**
     * 
     * @type {FormOwnerBeta}
     * @memberof FormDefinitionResponseBeta
     */
    'owner'?: FormOwnerBeta;
    /**
     * UsedBy is a list of objects where when any system uses a particular form it reaches out to the form service to record it is currently being used
     * @type {Array<FormUsedByBeta>}
     * @memberof FormDefinitionResponseBeta
     */
    'usedBy'?: Array<FormUsedByBeta>;
}
/**
 * 
 * @export
 * @interface FormDetailsBeta
 */
export interface FormDetailsBeta {
    /**
     * ID of the form
     * @type {string}
     * @memberof FormDetailsBeta
     */
    'id'?: string;
    /**
     * Name of the form
     * @type {string}
     * @memberof FormDetailsBeta
     */
    'name'?: string;
    /**
     * The form title
     * @type {string}
     * @memberof FormDetailsBeta
     */
    'title'?: string;
    /**
     * The form subtitle.
     * @type {string}
     * @memberof FormDetailsBeta
     */
    'subtitle'?: string;
    /**
     * The name of the user that should be shown this form
     * @type {string}
     * @memberof FormDetailsBeta
     */
    'targetUser'?: string;
    /**
     * 
     * @type {SectionDetailsBeta}
     * @memberof FormDetailsBeta
     */
    'sections'?: SectionDetailsBeta;
}
/**
 * 
 * @export
 * @interface FormElementBeta
 */
export interface FormElementBeta {
    /**
     * Config is a config object
     * @type {{ [key: string]: object; }}
     * @memberof FormElementBeta
     */
    'config'?: { [key: string]: object; };
    /**
     * ElementType is a FormElementType value TEXT FormElementTypeText TOGGLE FormElementTypeToggle TEXTAREA FormElementTypeTextArea HIDDEN FormElementTypeHidden PHONE FormElementTypePhone EMAIL FormElementTypeEmail SELECT FormElementTypeSelect DATE FormElementTypeDate SECTION FormElementTypeSection COLUMNS FormElementTypeColumns
     * @type {string}
     * @memberof FormElementBeta
     */
    'elementType'?: FormElementBetaElementTypeEnum;
    /**
     * ID is a form element identifier
     * @type {string}
     * @memberof FormElementBeta
     */
    'id'?: string;
    /**
     * Key is the technical key
     * @type {string}
     * @memberof FormElementBeta
     */
    'key'?: string;
    /**
     * FormElementValidationsSet is a set of FormElementValidation items
     * @type {object}
     * @memberof FormElementBeta
     */
    'validations'?: object;
}

export const FormElementBetaElementTypeEnum = {
    Text: 'TEXT',
    Toggle: 'TOGGLE',
    Textarea: 'TEXTAREA',
    Hidden: 'HIDDEN',
    Phone: 'PHONE',
    Email: 'EMAIL',
    Select: 'SELECT',
    Date: 'DATE',
    Section: 'SECTION',
    Columns: 'COLUMNS'
} as const;

export type FormElementBetaElementTypeEnum = typeof FormElementBetaElementTypeEnum[keyof typeof FormElementBetaElementTypeEnum];

/**
 * 
 * @export
 * @interface FormElementDataSourceConfigOptionsBeta
 */
export interface FormElementDataSourceConfigOptionsBeta {
    /**
     * Label is the main label to display to the user when selecting this option
     * @type {string}
     * @memberof FormElementDataSourceConfigOptionsBeta
     */
    'label'?: string;
    /**
     * SubLabel is the sub label to display below the label in diminutive styling to help describe or identify this option
     * @type {string}
     * @memberof FormElementDataSourceConfigOptionsBeta
     */
    'subLabel'?: string;
    /**
     * Value is the value to save as an entry when the user selects this option
     * @type {string}
     * @memberof FormElementDataSourceConfigOptionsBeta
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface FormElementDynamicDataSourceBeta
 */
export interface FormElementDynamicDataSourceBeta {
    /**
     * 
     * @type {FormElementDynamicDataSourceConfigBeta}
     * @memberof FormElementDynamicDataSourceBeta
     */
    'config'?: FormElementDynamicDataSourceConfigBeta;
    /**
     * DataSourceType is a FormElementDataSourceType value STATIC FormElementDataSourceTypeStatic INTERNAL FormElementDataSourceTypeInternal SEARCH FormElementDataSourceTypeSearch
     * @type {string}
     * @memberof FormElementDynamicDataSourceBeta
     */
    'dataSourceType'?: FormElementDynamicDataSourceBetaDataSourceTypeEnum;
}

export const FormElementDynamicDataSourceBetaDataSourceTypeEnum = {
    Static: 'STATIC',
    Internal: 'INTERNAL',
    Search: 'SEARCH'
} as const;

export type FormElementDynamicDataSourceBetaDataSourceTypeEnum = typeof FormElementDynamicDataSourceBetaDataSourceTypeEnum[keyof typeof FormElementDynamicDataSourceBetaDataSourceTypeEnum];

/**
 * 
 * @export
 * @interface FormElementDynamicDataSourceConfigBeta
 */
export interface FormElementDynamicDataSourceConfigBeta {
    /**
     * AggregationBucketField is the aggregation bucket field name
     * @type {string}
     * @memberof FormElementDynamicDataSourceConfigBeta
     */
    'aggregationBucketField'?: string;
    /**
     * Indices is a list of indices to use
     * @type {Array<string>}
     * @memberof FormElementDynamicDataSourceConfigBeta
     */
    'indices'?: Array<FormElementDynamicDataSourceConfigBetaIndicesEnum>;
    /**
     * ObjectType is a PreDefinedSelectOption value IDENTITY PreDefinedSelectOptionIdentity ACCESS_PROFILE PreDefinedSelectOptionAccessProfile SOURCES PreDefinedSelectOptionSources ROLE PreDefinedSelectOptionRole ENTITLEMENT PreDefinedSelectOptionEntitlement
     * @type {string}
     * @memberof FormElementDynamicDataSourceConfigBeta
     */
    'objectType'?: FormElementDynamicDataSourceConfigBetaObjectTypeEnum;
    /**
     * Query is a text
     * @type {string}
     * @memberof FormElementDynamicDataSourceConfigBeta
     */
    'query'?: string;
}

export const FormElementDynamicDataSourceConfigBetaIndicesEnum = {
    Accessprofiles: 'accessprofiles',
    Accountactivities: 'accountactivities',
    Entitlements: 'entitlements',
    Identities: 'identities',
    Events: 'events',
    Roles: 'roles',
    Star: '*'
} as const;

export type FormElementDynamicDataSourceConfigBetaIndicesEnum = typeof FormElementDynamicDataSourceConfigBetaIndicesEnum[keyof typeof FormElementDynamicDataSourceConfigBetaIndicesEnum];
export const FormElementDynamicDataSourceConfigBetaObjectTypeEnum = {
    Identity: 'IDENTITY',
    AccessProfile: 'ACCESS_PROFILE',
    Sources: 'SOURCES',
    Role: 'ROLE',
    Entitlement: 'ENTITLEMENT'
} as const;

export type FormElementDynamicDataSourceConfigBetaObjectTypeEnum = typeof FormElementDynamicDataSourceConfigBetaObjectTypeEnum[keyof typeof FormElementDynamicDataSourceConfigBetaObjectTypeEnum];

/**
 * 
 * @export
 * @interface FormElementPreviewRequestBeta
 */
export interface FormElementPreviewRequestBeta {
    /**
     * 
     * @type {FormElementDynamicDataSourceBeta}
     * @memberof FormElementPreviewRequestBeta
     */
    'dataSource'?: FormElementDynamicDataSourceBeta;
}
/**
 * 
 * @export
 * @interface FormErrorBeta
 */
export interface FormErrorBeta {
    /**
     * Key is the technical key
     * @type {string}
     * @memberof FormErrorBeta
     */
    'key'?: string;
    /**
     * Messages is a list of web.ErrorMessage items
     * @type {Array<ErrorMessageBeta>}
     * @memberof FormErrorBeta
     */
    'messages'?: Array<ErrorMessageBeta>;
    /**
     * Value is the value associated with a Key
     * @type {object}
     * @memberof FormErrorBeta
     */
    'value'?: object;
}
/**
 * 
 * @export
 * @interface FormInstanceCreatedByBeta
 */
export interface FormInstanceCreatedByBeta {
    /**
     * ID is a unique identifier
     * @type {string}
     * @memberof FormInstanceCreatedByBeta
     */
    'id'?: string;
    /**
     * Type is a form instance created by type enum value WORKFLOW_EXECUTION FormInstanceCreatedByTypeWorkflowExecution SOURCE FormInstanceCreatedByTypeSource
     * @type {string}
     * @memberof FormInstanceCreatedByBeta
     */
    'type'?: FormInstanceCreatedByBetaTypeEnum;
}

export const FormInstanceCreatedByBetaTypeEnum = {
    WorkflowExecution: 'WORKFLOW_EXECUTION',
    Source: 'SOURCE'
} as const;

export type FormInstanceCreatedByBetaTypeEnum = typeof FormInstanceCreatedByBetaTypeEnum[keyof typeof FormInstanceCreatedByBetaTypeEnum];

/**
 * 
 * @export
 * @interface FormInstanceRecipientBeta
 */
export interface FormInstanceRecipientBeta {
    /**
     * ID is a unique identifier
     * @type {string}
     * @memberof FormInstanceRecipientBeta
     */
    'id'?: string;
    /**
     * Type is a FormInstanceRecipientType value IDENTITY FormInstanceRecipientIdentity
     * @type {string}
     * @memberof FormInstanceRecipientBeta
     */
    'type'?: FormInstanceRecipientBetaTypeEnum;
}

export const FormInstanceRecipientBetaTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type FormInstanceRecipientBetaTypeEnum = typeof FormInstanceRecipientBetaTypeEnum[keyof typeof FormInstanceRecipientBetaTypeEnum];

/**
 * 
 * @export
 * @interface FormInstanceResponseBeta
 */
export interface FormInstanceResponseBeta {
    /**
     * Created is the date the form instance was assigned
     * @type {string}
     * @memberof FormInstanceResponseBeta
     */
    'created'?: string;
    /**
     * 
     * @type {FormInstanceCreatedByBeta}
     * @memberof FormInstanceResponseBeta
     */
    'createdBy'?: FormInstanceCreatedByBeta;
    /**
     * Expire is the maximum amount of time that a form can be in progress. After this time is reached then the form will be moved to a CANCELED state automatically. The user will no longer be able to complete the submission. When a form instance is expires an audit log will be generated for that record
     * @type {string}
     * @memberof FormInstanceResponseBeta
     */
    'expire'?: string;
    /**
     * FormConditions is the conditional logic that modify the form dynamically modify the form as the recipient is interacting out the form
     * @type {Array<FormConditionBeta>}
     * @memberof FormInstanceResponseBeta
     */
    'formConditions'?: Array<FormConditionBeta>;
    /**
     * FormData is the data provided by the form on submit. The data is in a key -> value map
     * @type {{ [key: string]: object; }}
     * @memberof FormInstanceResponseBeta
     */
    'formData'?: { [key: string]: object; };
    /**
     * FormDefinitionID is the id of the form definition that created this form
     * @type {string}
     * @memberof FormInstanceResponseBeta
     */
    'formDefinitionId'?: string;
    /**
     * FormElements is the configuration of the form, this would be a repeat of the fields from the form-config
     * @type {Array<FormElementBeta>}
     * @memberof FormInstanceResponseBeta
     */
    'formElements'?: Array<FormElementBeta>;
    /**
     * FormErrors is an array of form validation errors from the last time the form instance was transitioned to the SUBMITTED state. If the form instance had validation errors then it would be moved to the IN PROGRESS state where the client can retrieve these errors
     * @type {Array<FormErrorBeta>}
     * @memberof FormInstanceResponseBeta
     */
    'formErrors'?: Array<FormErrorBeta>;
    /**
     * FormInput is an object of form input labels to value
     * @type {{ [key: string]: object; }}
     * @memberof FormInstanceResponseBeta
     */
    'formInput'?: { [key: string]: object; };
    /**
     * FormInstanceID is a unique guid identifying this form instance
     * @type {string}
     * @memberof FormInstanceResponseBeta
     */
    'id'?: string;
    /**
     * Modified is the last date the form instance was modified
     * @type {string}
     * @memberof FormInstanceResponseBeta
     */
    'modified'?: string;
    /**
     * Recipients references to the recipient of a form. The recipients are those who are responsible for filling out a form and completing it
     * @type {Array<FormInstanceRecipientBeta>}
     * @memberof FormInstanceResponseBeta
     */
    'recipients'?: Array<FormInstanceRecipientBeta>;
    /**
     * StandAloneForm is a boolean flag to indicate if this form should be available for users to complete via the standalone form UI or should this only be available to be completed by as an embedded form
     * @type {boolean}
     * @memberof FormInstanceResponseBeta
     */
    'standAloneForm'?: boolean;
    /**
     * StandAloneFormURL is the URL where this form may be completed by the designated recipients using the standalone form UI
     * @type {string}
     * @memberof FormInstanceResponseBeta
     */
    'standAloneFormUrl'?: string;
    /**
     * State the state of the form instance ASSIGNED FormInstanceStateAssigned IN_PROGRESS FormInstanceStateInProgress SUBMITTED FormInstanceStateSubmitted COMPLETED FormInstanceStateCompleted CANCELLED FormInstanceStateCancelled
     * @type {string}
     * @memberof FormInstanceResponseBeta
     */
    'state'?: FormInstanceResponseBetaStateEnum;
}

export const FormInstanceResponseBetaStateEnum = {
    Assigned: 'ASSIGNED',
    InProgress: 'IN_PROGRESS',
    Submitted: 'SUBMITTED',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED'
} as const;

export type FormInstanceResponseBetaStateEnum = typeof FormInstanceResponseBetaStateEnum[keyof typeof FormInstanceResponseBetaStateEnum];

/**
 * 
 * @export
 * @interface FormItemBeta
 */
export interface FormItemBeta {
    /**
     * Name of the FormItem
     * @type {string}
     * @memberof FormItemBeta
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface FormItemDetailsBeta
 */
export interface FormItemDetailsBeta {
    /**
     * Name of the FormItem
     * @type {string}
     * @memberof FormItemDetailsBeta
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface FormOwnerBeta
 */
export interface FormOwnerBeta {
    /**
     * ID is a unique identifier
     * @type {string}
     * @memberof FormOwnerBeta
     */
    'id'?: string;
    /**
     * Type is a FormOwnerType value IDENTITY FormOwnerTypeIdentity
     * @type {string}
     * @memberof FormOwnerBeta
     */
    'type'?: FormOwnerBetaTypeEnum;
}

export const FormOwnerBetaTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type FormOwnerBetaTypeEnum = typeof FormOwnerBetaTypeEnum[keyof typeof FormOwnerBetaTypeEnum];

/**
 * 
 * @export
 * @interface FormUsedByBeta
 */
export interface FormUsedByBeta {
    /**
     * ID is a unique identifier
     * @type {string}
     * @memberof FormUsedByBeta
     */
    'id'?: string;
    /**
     * Type is a FormUsedByType value WORKFLOW FormUsedByTypeWorkflow SOURCE FormUsedByTypeSource
     * @type {string}
     * @memberof FormUsedByBeta
     */
    'type'?: FormUsedByBetaTypeEnum;
}

export const FormUsedByBetaTypeEnum = {
    Workflow: 'WORKFLOW',
    Source: 'SOURCE'
} as const;

export type FormUsedByBetaTypeEnum = typeof FormUsedByBetaTypeEnum[keyof typeof FormUsedByBetaTypeEnum];

/**
 * 
 * @export
 * @interface ForwardApprovalDtoBeta
 */
export interface ForwardApprovalDtoBeta {
    /**
     * The Id of the new owner
     * @type {string}
     * @memberof ForwardApprovalDtoBeta
     */
    'newOwnerId': string;
    /**
     * The comment provided by the forwarder
     * @type {string}
     * @memberof ForwardApprovalDtoBeta
     */
    'comment': string;
}
/**
 * 
 * @export
 * @interface FullAccountAllOfBeta
 */
export interface FullAccountAllOfBeta {
    /**
     * Whether this account belongs to an authoritative source
     * @type {boolean}
     * @memberof FullAccountAllOfBeta
     */
    'authoritative'?: boolean;
    /**
     * Whether this account is for the IdentityNow source
     * @type {boolean}
     * @memberof FullAccountAllOfBeta
     */
    'systemAccount'?: boolean;
    /**
     * True if this account is not correlated to an identity
     * @type {boolean}
     * @memberof FullAccountAllOfBeta
     */
    'uncorrelated'?: boolean;
    /**
     * A string list containing the owning source\'s features
     * @type {string}
     * @memberof FullAccountAllOfBeta
     */
    'features'?: string;
}
/**
 * 
 * @export
 * @interface FullAccountBeta
 */
export interface FullAccountBeta {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof FullAccountBeta
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof FullAccountBeta
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof FullAccountBeta
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof FullAccountBeta
     */
    'modified'?: string;
    /**
     * Unique ID from the owning source
     * @type {string}
     * @memberof FullAccountBeta
     */
    'uuid'?: string | null;
    /**
     * The native identifier of the account
     * @type {string}
     * @memberof FullAccountBeta
     */
    'nativeIdentity'?: string;
    /**
     * The description for the account
     * @type {string}
     * @memberof FullAccountBeta
     */
    'description'?: string | null;
    /**
     * Whether the account is disabled
     * @type {boolean}
     * @memberof FullAccountBeta
     */
    'disabled'?: boolean;
    /**
     * Whether the account is locked
     * @type {boolean}
     * @memberof FullAccountBeta
     */
    'locked'?: boolean;
    /**
     * Whether the account was manually correlated
     * @type {boolean}
     * @memberof FullAccountBeta
     */
    'manuallyCorrelated'?: boolean;
    /**
     * Whether the account has any entitlements associated with it
     * @type {boolean}
     * @memberof FullAccountBeta
     */
    'hasEntitlements'?: boolean;
    /**
     * The ID of the source for which this account belongs
     * @type {string}
     * @memberof FullAccountBeta
     */
    'sourceId'?: string;
    /**
     * The name of the source
     * @type {string}
     * @memberof FullAccountBeta
     */
    'sourceName'?: string;
    /**
     * The ID of the identity for which this account is correlated to if not uncorrelated
     * @type {string}
     * @memberof FullAccountBeta
     */
    'identityId'?: string;
    /**
     * A map containing attributes associated with the account
     * @type {{ [key: string]: any; }}
     * @memberof FullAccountBeta
     */
    'attributes'?: { [key: string]: any; };
    /**
     * Whether this account belongs to an authoritative source
     * @type {boolean}
     * @memberof FullAccountBeta
     */
    'authoritative'?: boolean;
    /**
     * Whether this account is for the IdentityNow source
     * @type {boolean}
     * @memberof FullAccountBeta
     */
    'systemAccount'?: boolean;
    /**
     * True if this account is not correlated to an identity
     * @type {boolean}
     * @memberof FullAccountBeta
     */
    'uncorrelated'?: boolean;
    /**
     * A string list containing the owning source\'s features
     * @type {string}
     * @memberof FullAccountBeta
     */
    'features'?: string;
}
/**
 * 
 * @export
 * @interface FullcampaignAllOfBeta
 */
export interface FullcampaignAllOfBeta {
    /**
     * Created time of the campaign
     * @type {string}
     * @memberof FullcampaignAllOfBeta
     */
    'created'?: string;
    /**
     * Modified time of the campaign
     * @type {string}
     * @memberof FullcampaignAllOfBeta
     */
    'modified'?: string;
    /**
     * The correlatedStatus of the campaign. Only SOURCE_OWNER campaigns can be Uncorrelated. An Uncorrelated certification campaign only includes Uncorrelated identities (An identity is uncorrelated if it has no accounts on an authoritative source).
     * @type {object}
     * @memberof FullcampaignAllOfBeta
     */
    'correlatedStatus'?: FullcampaignAllOfBetaCorrelatedStatusEnum;
    /**
     * 
     * @type {FullcampaignAllOfFilterBeta}
     * @memberof FullcampaignAllOfBeta
     */
    'filter'?: FullcampaignAllOfFilterBeta;
    /**
     * Determines if comments on sunset date changes are required.
     * @type {boolean}
     * @memberof FullcampaignAllOfBeta
     */
    'sunsetCommentsRequired'?: boolean;
    /**
     * 
     * @type {FullcampaignAllOfSourceOwnerCampaignInfoBeta}
     * @memberof FullcampaignAllOfBeta
     */
    'sourceOwnerCampaignInfo'?: FullcampaignAllOfSourceOwnerCampaignInfoBeta;
    /**
     * 
     * @type {FullcampaignAllOfSearchCampaignInfoBeta}
     * @memberof FullcampaignAllOfBeta
     */
    'searchCampaignInfo'?: FullcampaignAllOfSearchCampaignInfoBeta;
    /**
     * 
     * @type {FullcampaignAllOfRoleCompositionCampaignInfoBeta}
     * @memberof FullcampaignAllOfBeta
     */
    'roleCompositionCampaignInfo'?: FullcampaignAllOfRoleCompositionCampaignInfoBeta;
    /**
     * A list of errors and warnings that have accumulated.
     * @type {Array<CampaignAlertBeta>}
     * @memberof FullcampaignAllOfBeta
     */
    'alerts'?: Array<CampaignAlertBeta>;
    /**
     * The total number of certifications in this campaign.
     * @type {number}
     * @memberof FullcampaignAllOfBeta
     */
    'totalCertifications'?: number;
    /**
     * The number of completed certifications in this campaign.
     * @type {number}
     * @memberof FullcampaignAllOfBeta
     */
    'completedCertifications'?: number;
    /**
     * A list of sources in the campaign that contain \\\"orphan entitlements\\\" (entitlements without a corresponding Managed Attribute). An empty list indicates the campaign has no orphan entitlements. Null indicates there may be unknown orphan entitlements in the campaign (the campaign was created before this feature was implemented).
     * @type {Array<FullcampaignAllOfSourcesWithOrphanEntitlementsBeta>}
     * @memberof FullcampaignAllOfBeta
     */
    'sourcesWithOrphanEntitlements'?: Array<FullcampaignAllOfSourcesWithOrphanEntitlementsBeta>;
    /**
     * Determines whether comments are required for decisions during certification reviews. You can require comments for all decisions, revoke-only decisions, or no decisions. By default, comments are not required for decisions.
     * @type {string}
     * @memberof FullcampaignAllOfBeta
     */
    'mandatoryCommentRequirement'?: FullcampaignAllOfBetaMandatoryCommentRequirementEnum;
}

export const FullcampaignAllOfBetaCorrelatedStatusEnum = {
    Correlated: 'CORRELATED',
    Uncorrelated: 'UNCORRELATED'
} as const;

export type FullcampaignAllOfBetaCorrelatedStatusEnum = typeof FullcampaignAllOfBetaCorrelatedStatusEnum[keyof typeof FullcampaignAllOfBetaCorrelatedStatusEnum];
export const FullcampaignAllOfBetaMandatoryCommentRequirementEnum = {
    AllDecisions: 'ALL_DECISIONS',
    RevokeOnlyDecisions: 'REVOKE_ONLY_DECISIONS',
    NoDecisions: 'NO_DECISIONS'
} as const;

export type FullcampaignAllOfBetaMandatoryCommentRequirementEnum = typeof FullcampaignAllOfBetaMandatoryCommentRequirementEnum[keyof typeof FullcampaignAllOfBetaMandatoryCommentRequirementEnum];

/**
 * Determines which items will be included in this campaign. The default campaign filter is used if this field is left blank.
 * @export
 * @interface FullcampaignAllOfFilterBeta
 */
export interface FullcampaignAllOfFilterBeta {
    /**
     * The ID of whatever type of filter is being used.
     * @type {string}
     * @memberof FullcampaignAllOfFilterBeta
     */
    'id'?: string;
    /**
     * Type of the filter
     * @type {string}
     * @memberof FullcampaignAllOfFilterBeta
     */
    'type'?: FullcampaignAllOfFilterBetaTypeEnum;
    /**
     * Name of the filter
     * @type {string}
     * @memberof FullcampaignAllOfFilterBeta
     */
    'name'?: string;
}

export const FullcampaignAllOfFilterBetaTypeEnum = {
    CampaignFilter: 'CAMPAIGN_FILTER',
    Rule: 'RULE'
} as const;

export type FullcampaignAllOfFilterBetaTypeEnum = typeof FullcampaignAllOfFilterBetaTypeEnum[keyof typeof FullcampaignAllOfFilterBetaTypeEnum];

/**
 * Optional configuration options for role composition campaigns.
 * @export
 * @interface FullcampaignAllOfRoleCompositionCampaignInfoBeta
 */
export interface FullcampaignAllOfRoleCompositionCampaignInfoBeta {
    /**
     * If specified, this identity or governance group will be the reviewer for all certifications in this campaign. The allowed DTO types are IDENTITY and GOVERNANCE_GROUP
     * @type {BaseReferenceDto1Beta & object}
     * @memberof FullcampaignAllOfRoleCompositionCampaignInfoBeta
     */
    'reviewer'?: BaseReferenceDto1Beta & object;
    /**
     * Optional list of roles to include in this campaign. Only one of `roleIds` and `query` may be set; if neither are set, all roles are included.
     * @type {Array<string>}
     * @memberof FullcampaignAllOfRoleCompositionCampaignInfoBeta
     */
    'roleIds'?: Array<string>;
    /**
     * 
     * @type {FullcampaignAllOfRoleCompositionCampaignInfoRemediatorRefBeta}
     * @memberof FullcampaignAllOfRoleCompositionCampaignInfoBeta
     */
    'remediatorRef': FullcampaignAllOfRoleCompositionCampaignInfoRemediatorRefBeta;
    /**
     * Optional search query to scope this campaign to a set of roles. Only one of `roleIds` and `query` may be set; if neither are set, all roles are included.
     * @type {string}
     * @memberof FullcampaignAllOfRoleCompositionCampaignInfoBeta
     */
    'query'?: string;
    /**
     * Describes this role composition campaign. Intended for storing the query used, and possibly the number of roles selected/available.
     * @type {string}
     * @memberof FullcampaignAllOfRoleCompositionCampaignInfoBeta
     */
    'description'?: string;
}
/**
 * This determines who remediation tasks will be assigned to. Remediation tasks are created for each revoke decision on items in the campaign. The only legal remediator type is \'IDENTITY\', and the chosen identity must be a Role Admin or Org Admin.
 * @export
 * @interface FullcampaignAllOfRoleCompositionCampaignInfoRemediatorRefBeta
 */
export interface FullcampaignAllOfRoleCompositionCampaignInfoRemediatorRefBeta {
    /**
     * Legal Remediator Type
     * @type {string}
     * @memberof FullcampaignAllOfRoleCompositionCampaignInfoRemediatorRefBeta
     */
    'type': FullcampaignAllOfRoleCompositionCampaignInfoRemediatorRefBetaTypeEnum;
    /**
     * The ID of the remediator.
     * @type {string}
     * @memberof FullcampaignAllOfRoleCompositionCampaignInfoRemediatorRefBeta
     */
    'id': string;
    /**
     * The name of the remediator.
     * @type {string}
     * @memberof FullcampaignAllOfRoleCompositionCampaignInfoRemediatorRefBeta
     */
    'name'?: string;
}

export const FullcampaignAllOfRoleCompositionCampaignInfoRemediatorRefBetaTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type FullcampaignAllOfRoleCompositionCampaignInfoRemediatorRefBetaTypeEnum = typeof FullcampaignAllOfRoleCompositionCampaignInfoRemediatorRefBetaTypeEnum[keyof typeof FullcampaignAllOfRoleCompositionCampaignInfoRemediatorRefBetaTypeEnum];

/**
 * Must be set only if the campaign type is SEARCH.
 * @export
 * @interface FullcampaignAllOfSearchCampaignInfoBeta
 */
export interface FullcampaignAllOfSearchCampaignInfoBeta {
    /**
     * The type of search campaign represented.
     * @type {string}
     * @memberof FullcampaignAllOfSearchCampaignInfoBeta
     */
    'type': FullcampaignAllOfSearchCampaignInfoBetaTypeEnum;
    /**
     * Describes this search campaign. Intended for storing the query used, and possibly the number of identities selected/available.
     * @type {string}
     * @memberof FullcampaignAllOfSearchCampaignInfoBeta
     */
    'description'?: string;
    /**
     * If specified, this identity or governance group will be the reviewer for all certifications in this campaign. The allowed DTO types are IDENTITY and GOVERNANCE_GROUP
     * @type {BaseReferenceDto1Beta & object}
     * @memberof FullcampaignAllOfSearchCampaignInfoBeta
     */
    'reviewer'?: BaseReferenceDto1Beta & object;
    /**
     * The scope for the campaign. The campaign will cover identities returned by the query and identities that have access items returned by the query. One of `query` or `identityIds` must be set.
     * @type {string}
     * @memberof FullcampaignAllOfSearchCampaignInfoBeta
     */
    'query'?: string;
    /**
     * A direct list of identities to include in this campaign. One of `identityIds` or `query` must be set.
     * @type {Array<string>}
     * @memberof FullcampaignAllOfSearchCampaignInfoBeta
     */
    'identityIds'?: Array<string>;
    /**
     * Further reduces the scope of the campaign by excluding identities (from `query` or `identityIds`) that do not have this access.
     * @type {Array<AccessConstraintBeta>}
     * @memberof FullcampaignAllOfSearchCampaignInfoBeta
     */
    'accessConstraints'?: Array<AccessConstraintBeta>;
}

export const FullcampaignAllOfSearchCampaignInfoBetaTypeEnum = {
    Identity: 'IDENTITY',
    Access: 'ACCESS'
} as const;

export type FullcampaignAllOfSearchCampaignInfoBetaTypeEnum = typeof FullcampaignAllOfSearchCampaignInfoBetaTypeEnum[keyof typeof FullcampaignAllOfSearchCampaignInfoBetaTypeEnum];

/**
 * Must be set only if the campaign type is SOURCE_OWNER.
 * @export
 * @interface FullcampaignAllOfSourceOwnerCampaignInfoBeta
 */
export interface FullcampaignAllOfSourceOwnerCampaignInfoBeta {
    /**
     * The list of sources to be included in the campaign.
     * @type {Array<string>}
     * @memberof FullcampaignAllOfSourceOwnerCampaignInfoBeta
     */
    'sourceIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface FullcampaignAllOfSourcesWithOrphanEntitlementsBeta
 */
export interface FullcampaignAllOfSourcesWithOrphanEntitlementsBeta {
    /**
     * Id of the source
     * @type {string}
     * @memberof FullcampaignAllOfSourcesWithOrphanEntitlementsBeta
     */
    'id'?: string;
    /**
     * Type
     * @type {string}
     * @memberof FullcampaignAllOfSourcesWithOrphanEntitlementsBeta
     */
    'type'?: FullcampaignAllOfSourcesWithOrphanEntitlementsBetaTypeEnum;
    /**
     * Name of the source
     * @type {string}
     * @memberof FullcampaignAllOfSourcesWithOrphanEntitlementsBeta
     */
    'name'?: string;
}

export const FullcampaignAllOfSourcesWithOrphanEntitlementsBetaTypeEnum = {
    Source: 'SOURCE'
} as const;

export type FullcampaignAllOfSourcesWithOrphanEntitlementsBetaTypeEnum = typeof FullcampaignAllOfSourcesWithOrphanEntitlementsBetaTypeEnum[keyof typeof FullcampaignAllOfSourcesWithOrphanEntitlementsBetaTypeEnum];

/**
 * 
 * @export
 * @interface FullcampaignBeta
 */
export interface FullcampaignBeta {
    /**
     * Id of the campaign
     * @type {string}
     * @memberof FullcampaignBeta
     */
    'id'?: string;
    /**
     * The campaign name. If this object is part of a template, special formatting applies; see the `/campaign-templates/{id}/generate` endpoint documentation for details.
     * @type {string}
     * @memberof FullcampaignBeta
     */
    'name': string;
    /**
     * The campaign description. If this object is part of a template, special formatting applies; see the `/campaign-templates/{id}/generate` endpoint documentation for details.
     * @type {string}
     * @memberof FullcampaignBeta
     */
    'description': string;
    /**
     * The campaign\'s completion deadline.
     * @type {string}
     * @memberof FullcampaignBeta
     */
    'deadline'?: string;
    /**
     * The type of campaign. Could be extended in the future.
     * @type {string}
     * @memberof FullcampaignBeta
     */
    'type': FullcampaignBetaTypeEnum;
    /**
     * Enables email notification for this campaign
     * @type {boolean}
     * @memberof FullcampaignBeta
     */
    'emailNotificationEnabled'?: boolean;
    /**
     * Allows auto revoke for this campaign
     * @type {boolean}
     * @memberof FullcampaignBeta
     */
    'autoRevokeAllowed'?: boolean;
    /**
     * Enables IAI for this campaign. Accepts true even if the IAI product feature is off. If IAI is turned off then campaigns generated from this template will indicate false. The real value will then be returned if IAI is ever enabled for the org in the future.
     * @type {boolean}
     * @memberof FullcampaignBeta
     */
    'recommendationsEnabled'?: boolean;
    /**
     * The campaign\'s current status.
     * @type {string}
     * @memberof FullcampaignBeta
     */
    'status'?: FullcampaignBetaStatusEnum;
    /**
     * The correlatedStatus of the campaign. Only SOURCE_OWNER campaigns can be Uncorrelated. An Uncorrelated certification campaign only includes Uncorrelated identities (An identity is uncorrelated if it has no accounts on an authoritative source).
     * @type {object}
     * @memberof FullcampaignBeta
     */
    'correlatedStatus'?: FullcampaignBetaCorrelatedStatusEnum;
    /**
     * Created time of the campaign
     * @type {string}
     * @memberof FullcampaignBeta
     */
    'created'?: string;
    /**
     * Modified time of the campaign
     * @type {string}
     * @memberof FullcampaignBeta
     */
    'modified'?: string;
    /**
     * 
     * @type {FullcampaignAllOfFilterBeta}
     * @memberof FullcampaignBeta
     */
    'filter'?: FullcampaignAllOfFilterBeta;
    /**
     * Determines if comments on sunset date changes are required.
     * @type {boolean}
     * @memberof FullcampaignBeta
     */
    'sunsetCommentsRequired'?: boolean;
    /**
     * 
     * @type {FullcampaignAllOfSourceOwnerCampaignInfoBeta}
     * @memberof FullcampaignBeta
     */
    'sourceOwnerCampaignInfo'?: FullcampaignAllOfSourceOwnerCampaignInfoBeta;
    /**
     * 
     * @type {FullcampaignAllOfSearchCampaignInfoBeta}
     * @memberof FullcampaignBeta
     */
    'searchCampaignInfo'?: FullcampaignAllOfSearchCampaignInfoBeta;
    /**
     * 
     * @type {FullcampaignAllOfRoleCompositionCampaignInfoBeta}
     * @memberof FullcampaignBeta
     */
    'roleCompositionCampaignInfo'?: FullcampaignAllOfRoleCompositionCampaignInfoBeta;
    /**
     * A list of errors and warnings that have accumulated.
     * @type {Array<CampaignAlertBeta>}
     * @memberof FullcampaignBeta
     */
    'alerts'?: Array<CampaignAlertBeta>;
    /**
     * The total number of certifications in this campaign.
     * @type {number}
     * @memberof FullcampaignBeta
     */
    'totalCertifications'?: number;
    /**
     * The number of completed certifications in this campaign.
     * @type {number}
     * @memberof FullcampaignBeta
     */
    'completedCertifications'?: number;
    /**
     * A list of sources in the campaign that contain \\\"orphan entitlements\\\" (entitlements without a corresponding Managed Attribute). An empty list indicates the campaign has no orphan entitlements. Null indicates there may be unknown orphan entitlements in the campaign (the campaign was created before this feature was implemented).
     * @type {Array<FullcampaignAllOfSourcesWithOrphanEntitlementsBeta>}
     * @memberof FullcampaignBeta
     */
    'sourcesWithOrphanEntitlements'?: Array<FullcampaignAllOfSourcesWithOrphanEntitlementsBeta>;
    /**
     * Determines whether comments are required for decisions during certification reviews. You can require comments for all decisions, revoke-only decisions, or no decisions. By default, comments are not required for decisions.
     * @type {string}
     * @memberof FullcampaignBeta
     */
    'mandatoryCommentRequirement'?: FullcampaignBetaMandatoryCommentRequirementEnum;
}

export const FullcampaignBetaTypeEnum = {
    Manager: 'MANAGER',
    SourceOwner: 'SOURCE_OWNER',
    Search: 'SEARCH',
    RoleComposition: 'ROLE_COMPOSITION'
} as const;

export type FullcampaignBetaTypeEnum = typeof FullcampaignBetaTypeEnum[keyof typeof FullcampaignBetaTypeEnum];
export const FullcampaignBetaStatusEnum = {
    Pending: 'PENDING',
    Staged: 'STAGED',
    Canceling: 'CANCELING',
    Activating: 'ACTIVATING',
    Active: 'ACTIVE',
    Completing: 'COMPLETING',
    Completed: 'COMPLETED',
    Error: 'ERROR',
    Archived: 'ARCHIVED'
} as const;

export type FullcampaignBetaStatusEnum = typeof FullcampaignBetaStatusEnum[keyof typeof FullcampaignBetaStatusEnum];
export const FullcampaignBetaCorrelatedStatusEnum = {
    Correlated: 'CORRELATED',
    Uncorrelated: 'UNCORRELATED'
} as const;

export type FullcampaignBetaCorrelatedStatusEnum = typeof FullcampaignBetaCorrelatedStatusEnum[keyof typeof FullcampaignBetaCorrelatedStatusEnum];
export const FullcampaignBetaMandatoryCommentRequirementEnum = {
    AllDecisions: 'ALL_DECISIONS',
    RevokeOnlyDecisions: 'REVOKE_ONLY_DECISIONS',
    NoDecisions: 'NO_DECISIONS'
} as const;

export type FullcampaignBetaMandatoryCommentRequirementEnum = typeof FullcampaignBetaMandatoryCommentRequirementEnum[keyof typeof FullcampaignBetaMandatoryCommentRequirementEnum];

/**
 * @type GetActiveCampaigns200ResponseInnerBeta
 * @export
 */
export type GetActiveCampaigns200ResponseInnerBeta = CampaignBeta | SlimcampaignBeta;

/**
 * 
 * @export
 * @interface GetHistoricalIdentityEvents200ResponseInnerBeta
 */
export interface GetHistoricalIdentityEvents200ResponseInnerBeta {
    /**
     * 
     * @type {AccessItemAssociatedAccessItemBeta}
     * @memberof GetHistoricalIdentityEvents200ResponseInnerBeta
     */
    'accessItem'?: AccessItemAssociatedAccessItemBeta;
    /**
     * the identity id
     * @type {string}
     * @memberof GetHistoricalIdentityEvents200ResponseInnerBeta
     */
    'identityId'?: string;
    /**
     * the event type
     * @type {string}
     * @memberof GetHistoricalIdentityEvents200ResponseInnerBeta
     */
    'eventType'?: string;
    /**
     * the date of event
     * @type {string}
     * @memberof GetHistoricalIdentityEvents200ResponseInnerBeta
     */
    'dt'?: string;
    /**
     * 
     * @type {CorrelatedGovernanceEventBeta}
     * @memberof GetHistoricalIdentityEvents200ResponseInnerBeta
     */
    'governanceEvent'?: CorrelatedGovernanceEventBeta;
    /**
     * 
     * @type {Array<AttributeChangeBeta>}
     * @memberof GetHistoricalIdentityEvents200ResponseInnerBeta
     */
    'changes'?: Array<AttributeChangeBeta>;
    /**
     * 
     * @type {AccessRequestResponseBeta}
     * @memberof GetHistoricalIdentityEvents200ResponseInnerBeta
     */
    'accessRequest'?: AccessRequestResponseBeta;
    /**
     * the id of the certification item
     * @type {string}
     * @memberof GetHistoricalIdentityEvents200ResponseInnerBeta
     */
    'certificationId'?: string;
    /**
     * the certification item name
     * @type {string}
     * @memberof GetHistoricalIdentityEvents200ResponseInnerBeta
     */
    'certificationName'?: string;
    /**
     * the date ceritification was signed
     * @type {string}
     * @memberof GetHistoricalIdentityEvents200ResponseInnerBeta
     */
    'signedDate'?: string;
    /**
     * this field is deprecated and may go away
     * @type {Array<CertifierResponseBeta>}
     * @memberof GetHistoricalIdentityEvents200ResponseInnerBeta
     */
    'certifiers'?: Array<CertifierResponseBeta>;
    /**
     * The list of identities who review this certification
     * @type {Array<CertifierResponseBeta>}
     * @memberof GetHistoricalIdentityEvents200ResponseInnerBeta
     */
    'reviewers'?: Array<CertifierResponseBeta>;
    /**
     * 
     * @type {CertifierResponseBeta}
     * @memberof GetHistoricalIdentityEvents200ResponseInnerBeta
     */
    'signer'?: CertifierResponseBeta;
    /**
     * 
     * @type {AccountStatusChangedAccountBeta}
     * @memberof GetHistoricalIdentityEvents200ResponseInnerBeta
     */
    'account'?: AccountStatusChangedAccountBeta;
    /**
     * 
     * @type {AccountStatusChangedStatusChangeBeta}
     * @memberof GetHistoricalIdentityEvents200ResponseInnerBeta
     */
    'statusChange'?: AccountStatusChangedStatusChangeBeta;
}
/**
 * 
 * @export
 * @interface GetOAuthClientResponseBeta
 */
export interface GetOAuthClientResponseBeta {
    /**
     * ID of the OAuth client
     * @type {string}
     * @memberof GetOAuthClientResponseBeta
     */
    'id': string;
    /**
     * The name of the business the API Client should belong to
     * @type {string}
     * @memberof GetOAuthClientResponseBeta
     */
    'businessName': string | null;
    /**
     * The homepage URL associated with the owner of the API Client
     * @type {string}
     * @memberof GetOAuthClientResponseBeta
     */
    'homepageUrl': string | null;
    /**
     * A human-readable name for the API Client
     * @type {string}
     * @memberof GetOAuthClientResponseBeta
     */
    'name': string;
    /**
     * A description of the API Client
     * @type {string}
     * @memberof GetOAuthClientResponseBeta
     */
    'description': string | null;
    /**
     * The number of seconds an access token generated for this API Client is valid for
     * @type {number}
     * @memberof GetOAuthClientResponseBeta
     */
    'accessTokenValiditySeconds': number;
    /**
     * The number of seconds a refresh token generated for this API Client is valid for
     * @type {number}
     * @memberof GetOAuthClientResponseBeta
     */
    'refreshTokenValiditySeconds': number;
    /**
     * A list of the approved redirect URIs used with the authorization_code flow
     * @type {Array<string>}
     * @memberof GetOAuthClientResponseBeta
     */
    'redirectUris': Array<string> | null;
    /**
     * A list of OAuth 2.0 grant types this API Client can be used with
     * @type {Array<GrantTypeBeta>}
     * @memberof GetOAuthClientResponseBeta
     */
    'grantTypes': Array<GrantTypeBeta>;
    /**
     * 
     * @type {AccessTypeBeta}
     * @memberof GetOAuthClientResponseBeta
     */
    'accessType': AccessTypeBeta;
    /**
     * 
     * @type {ClientTypeBeta}
     * @memberof GetOAuthClientResponseBeta
     */
    'type': ClientTypeBeta;
    /**
     * An indicator of whether the API Client can be used for requests internal to IDN
     * @type {boolean}
     * @memberof GetOAuthClientResponseBeta
     */
    'internal': boolean;
    /**
     * An indicator of whether the API Client is enabled for use
     * @type {boolean}
     * @memberof GetOAuthClientResponseBeta
     */
    'enabled': boolean;
    /**
     * An indicator of whether the API Client supports strong authentication
     * @type {boolean}
     * @memberof GetOAuthClientResponseBeta
     */
    'strongAuthSupported': boolean;
    /**
     * An indicator of whether the API Client supports the serialization of SAML claims when used with the authorization_code flow
     * @type {boolean}
     * @memberof GetOAuthClientResponseBeta
     */
    'claimsSupported': boolean;
    /**
     * The date and time, down to the millisecond, when the API Client was created
     * @type {string}
     * @memberof GetOAuthClientResponseBeta
     */
    'created': string;
    /**
     * The date and time, down to the millisecond, when the API Client was last updated
     * @type {string}
     * @memberof GetOAuthClientResponseBeta
     */
    'modified': string;
    /**
     * The date and time, down to the millisecond, when this API Client was last used to generate an access token. This timestamp does not get updated on every API Client usage, but only once a day. This property can be useful for identifying which API Clients are no longer actively used and can be removed.
     * @type {string}
     * @memberof GetOAuthClientResponseBeta
     */
    'lastUsed'?: string | null;
    /**
     * Scopes of the API Client.
     * @type {Array<string>}
     * @memberof GetOAuthClientResponseBeta
     */
    'scope': Array<string> | null;
}
/**
 * 
 * @export
 * @interface GetPersonalAccessTokenResponseBeta
 */
export interface GetPersonalAccessTokenResponseBeta {
    /**
     * The ID of the personal access token (to be used as the username for Basic Auth).
     * @type {string}
     * @memberof GetPersonalAccessTokenResponseBeta
     */
    'id': string;
    /**
     * The name of the personal access token. Cannot be the same as other personal access tokens owned by a user.
     * @type {string}
     * @memberof GetPersonalAccessTokenResponseBeta
     */
    'name': string;
    /**
     * Scopes of the personal  access token.
     * @type {Array<string>}
     * @memberof GetPersonalAccessTokenResponseBeta
     */
    'scope': Array<string> | null;
    /**
     * 
     * @type {BaseReferenceDto1Beta}
     * @memberof GetPersonalAccessTokenResponseBeta
     */
    'owner': BaseReferenceDto1Beta;
    /**
     * The date and time, down to the millisecond, when this personal access token was created.
     * @type {string}
     * @memberof GetPersonalAccessTokenResponseBeta
     */
    'created': string;
    /**
     * The date and time, down to the millisecond, when this personal access token was last used to generate an access token. This timestamp does not get updated on every PAT usage, but only once a day. This property can be useful for identifying which PATs are no longer actively used and can be removed.
     * @type {string}
     * @memberof GetPersonalAccessTokenResponseBeta
     */
    'lastUsed'?: string | null;
}
/**
 * OAuth2 Grant Type
 * @export
 * @enum {string}
 */

export const GrantTypeBeta = {
    ClientCredentials: 'CLIENT_CREDENTIALS',
    AuthorizationCode: 'AUTHORIZATION_CODE',
    RefreshToken: 'REFRESH_TOKEN'
} as const;

export type GrantTypeBeta = typeof GrantTypeBeta[keyof typeof GrantTypeBeta];


/**
 * Defines the HTTP Authentication type. Additional values may be added in the future.  If *NO_AUTH* is selected, no extra information will be in HttpConfig.  If *BASIC_AUTH* is selected, HttpConfig will include BasicAuthConfig with Username and Password as strings.  If *BEARER_TOKEN* is selected, HttpConfig will include BearerTokenAuthConfig with Token as string.
 * @export
 * @enum {string}
 */

export const HttpAuthenticationTypeBeta = {
    NoAuth: 'NO_AUTH',
    BasicAuth: 'BASIC_AUTH',
    BearerToken: 'BEARER_TOKEN'
} as const;

export type HttpAuthenticationTypeBeta = typeof HttpAuthenticationTypeBeta[keyof typeof HttpAuthenticationTypeBeta];


/**
 * 
 * @export
 * @interface HttpConfigBeta
 */
export interface HttpConfigBeta {
    /**
     * URL of the external/custom integration.
     * @type {string}
     * @memberof HttpConfigBeta
     */
    'url': string;
    /**
     * 
     * @type {HttpDispatchModeBeta}
     * @memberof HttpConfigBeta
     */
    'httpDispatchMode': HttpDispatchModeBeta;
    /**
     * 
     * @type {HttpAuthenticationTypeBeta}
     * @memberof HttpConfigBeta
     */
    'httpAuthenticationType'?: HttpAuthenticationTypeBeta;
    /**
     * 
     * @type {BasicAuthConfigBeta}
     * @memberof HttpConfigBeta
     */
    'basicAuthConfig'?: BasicAuthConfigBeta | null;
    /**
     * 
     * @type {BearerTokenAuthConfigBeta}
     * @memberof HttpConfigBeta
     */
    'bearerTokenAuthConfig'?: BearerTokenAuthConfigBeta | null;
}
/**
 * HTTP response modes, i.e. SYNC, ASYNC, or DYNAMIC.
 * @export
 * @enum {string}
 */

export const HttpDispatchModeBeta = {
    Sync: 'SYNC',
    Async: 'ASYNC',
    Dynamic: 'DYNAMIC'
} as const;

export type HttpDispatchModeBeta = typeof HttpDispatchModeBeta[keyof typeof HttpDispatchModeBeta];


/**
 * 
 * @export
 * @interface IdentitiesAccountsBulkRequestBeta
 */
export interface IdentitiesAccountsBulkRequestBeta {
    /**
     * The ids of the identities for which enable/disable accounts.
     * @type {Array<string>}
     * @memberof IdentitiesAccountsBulkRequestBeta
     */
    'identityIds'?: Array<string>;
}
/**
 * The definition of an Identity according to the Reassignment Configuration service
 * @export
 * @interface Identity1Beta
 */
export interface Identity1Beta {
    /**
     * The ID of the object
     * @type {string}
     * @memberof Identity1Beta
     */
    'id'?: string;
    /**
     * Human-readable display name of the object
     * @type {string}
     * @memberof Identity1Beta
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface IdentityAssociationDetailsAssociationDetailsInnerBeta
 */
export interface IdentityAssociationDetailsAssociationDetailsInnerBeta {
    /**
     * association type with the identity
     * @type {string}
     * @memberof IdentityAssociationDetailsAssociationDetailsInnerBeta
     */
    'associationType'?: string;
    /**
     * the specific resource this identity has ownership on
     * @type {Array<IdentityEntitiesBeta>}
     * @memberof IdentityAssociationDetailsAssociationDetailsInnerBeta
     */
    'entities'?: Array<IdentityEntitiesBeta>;
}
/**
 * 
 * @export
 * @interface IdentityAssociationDetailsBeta
 */
export interface IdentityAssociationDetailsBeta {
    /**
     * any additional context information of the http call result
     * @type {string}
     * @memberof IdentityAssociationDetailsBeta
     */
    'message'?: string;
    /**
     * list of all the resource associations for the identity
     * @type {Array<IdentityAssociationDetailsAssociationDetailsInnerBeta>}
     * @memberof IdentityAssociationDetailsBeta
     */
    'associationDetails'?: Array<IdentityAssociationDetailsAssociationDetailsInnerBeta>;
}
/**
 * Defines all the identity attribute mapping configurations. This defines how to generate or collect data for each identity attributes in identity refresh process.
 * @export
 * @interface IdentityAttributeConfig1Beta
 */
export interface IdentityAttributeConfig1Beta {
    /**
     * The backend will only promote values if the profile/mapping is enabled.
     * @type {boolean}
     * @memberof IdentityAttributeConfig1Beta
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<IdentityAttributeTransform1Beta>}
     * @memberof IdentityAttributeConfig1Beta
     */
    'attributeTransforms'?: Array<IdentityAttributeTransform1Beta>;
}
/**
 * 
 * @export
 * @interface IdentityAttributeConfigBeta
 */
export interface IdentityAttributeConfigBeta {
    /**
     * If the profile or mapping is enabled
     * @type {boolean}
     * @memberof IdentityAttributeConfigBeta
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<IdentityAttributeTransformBeta>}
     * @memberof IdentityAttributeConfigBeta
     */
    'attributeTransforms'?: Array<IdentityAttributeTransformBeta>;
}
/**
 * 
 * @export
 * @interface IdentityAttributePreviewBeta
 */
export interface IdentityAttributePreviewBeta {
    /**
     * Name of the attribute that is being previewed.
     * @type {string}
     * @memberof IdentityAttributePreviewBeta
     */
    'name'?: string;
    /**
     * Value that was derived during the preview.
     * @type {object}
     * @memberof IdentityAttributePreviewBeta
     */
    'value'?: object;
    /**
     * The value of the attribute before the preview.
     * @type {object}
     * @memberof IdentityAttributePreviewBeta
     */
    'previousValue'?: object;
    /**
     * 
     * @type {Array<ErrorMessageDtoBeta>}
     * @memberof IdentityAttributePreviewBeta
     */
    'errorMessages'?: Array<ErrorMessageDtoBeta>;
}
/**
 * Defines a transformation definition for an identity attribute.
 * @export
 * @interface IdentityAttributeTransform1Beta
 */
export interface IdentityAttributeTransform1Beta {
    /**
     * Name of the identity attribute.
     * @type {string}
     * @memberof IdentityAttributeTransform1Beta
     */
    'identityAttributeName'?: string;
    /**
     * 
     * @type {TransformDefinition1Beta}
     * @memberof IdentityAttributeTransform1Beta
     */
    'transformDefinition'?: TransformDefinition1Beta;
}
/**
 * 
 * @export
 * @interface IdentityAttributeTransformBeta
 */
export interface IdentityAttributeTransformBeta {
    /**
     * Name of the identity attribute
     * @type {string}
     * @memberof IdentityAttributeTransformBeta
     */
    'identityAttributeName'?: string;
    /**
     * 
     * @type {TransformDefinitionBeta}
     * @memberof IdentityAttributeTransformBeta
     */
    'transformDefinition'?: TransformDefinitionBeta;
}
/**
 * 
 * @export
 * @interface IdentityAttributesChangedBeta
 */
export interface IdentityAttributesChangedBeta {
    /**
     * 
     * @type {IdentityAttributesChangedIdentityBeta}
     * @memberof IdentityAttributesChangedBeta
     */
    'identity': IdentityAttributesChangedIdentityBeta;
    /**
     * A list of one or more identity attributes that changed on the identity.
     * @type {Array<IdentityAttributesChangedChangesInnerBeta>}
     * @memberof IdentityAttributesChangedBeta
     */
    'changes': Array<IdentityAttributesChangedChangesInnerBeta>;
}
/**
 * 
 * @export
 * @interface IdentityAttributesChangedChangesInnerBeta
 */
export interface IdentityAttributesChangedChangesInnerBeta {
    /**
     * The name of the identity attribute that changed.
     * @type {string}
     * @memberof IdentityAttributesChangedChangesInnerBeta
     */
    'attribute': string;
    /**
     * 
     * @type {IdentityAttributesChangedChangesInnerOldValueBeta}
     * @memberof IdentityAttributesChangedChangesInnerBeta
     */
    'oldValue'?: IdentityAttributesChangedChangesInnerOldValueBeta | null;
    /**
     * 
     * @type {IdentityAttributesChangedChangesInnerNewValueBeta}
     * @memberof IdentityAttributesChangedChangesInnerBeta
     */
    'newValue'?: IdentityAttributesChangedChangesInnerNewValueBeta;
}
/**
 * @type IdentityAttributesChangedChangesInnerNewValueBeta
 * The value of the identity attribute after it changed.
 * @export
 */
export type IdentityAttributesChangedChangesInnerNewValueBeta = Array<string> | boolean | string | { [key: string]: IdentityAttributesChangedChangesInnerOldValueOneOfValueBeta; };

/**
 * @type IdentityAttributesChangedChangesInnerOldValueBeta
 * The value of the identity attribute before it changed.
 * @export
 */
export type IdentityAttributesChangedChangesInnerOldValueBeta = Array<string> | boolean | string | { [key: string]: IdentityAttributesChangedChangesInnerOldValueOneOfValueBeta; };

/**
 * @type IdentityAttributesChangedChangesInnerOldValueOneOfValueBeta
 * @export
 */
export type IdentityAttributesChangedChangesInnerOldValueOneOfValueBeta = boolean | number | string;

/**
 * The identity who\'s attributes changed.
 * @export
 * @interface IdentityAttributesChangedIdentityBeta
 */
export interface IdentityAttributesChangedIdentityBeta {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof IdentityAttributesChangedIdentityBeta
     */
    'type': IdentityAttributesChangedIdentityBetaTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof IdentityAttributesChangedIdentityBeta
     */
    'id': string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof IdentityAttributesChangedIdentityBeta
     */
    'name': string;
}

export const IdentityAttributesChangedIdentityBetaTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type IdentityAttributesChangedIdentityBetaTypeEnum = typeof IdentityAttributesChangedIdentityBetaTypeEnum[keyof typeof IdentityAttributesChangedIdentityBetaTypeEnum];

/**
 * 
 * @export
 * @interface IdentityBeta
 */
export interface IdentityBeta {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof IdentityBeta
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof IdentityBeta
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof IdentityBeta
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof IdentityBeta
     */
    'modified'?: string;
    /**
     * Alternate unique identifier for the identity
     * @type {string}
     * @memberof IdentityBeta
     */
    'alias'?: string;
    /**
     * The email address of the identity
     * @type {string}
     * @memberof IdentityBeta
     */
    'emailAddress'?: string;
    /**
     * The processing state of the identity
     * @type {string}
     * @memberof IdentityBeta
     */
    'processingState'?: IdentityBetaProcessingStateEnum;
    /**
     * The identity\'s status in the system
     * @type {string}
     * @memberof IdentityBeta
     */
    'identityStatus'?: IdentityBetaIdentityStatusEnum;
    /**
     * 
     * @type {BaseReferenceDto1Beta}
     * @memberof IdentityBeta
     */
    'managerRef'?: BaseReferenceDto1Beta;
    /**
     * Whether this identity is a manager of another identity
     * @type {boolean}
     * @memberof IdentityBeta
     */
    'isManager'?: boolean;
    /**
     * The last time the identity was refreshed by the system
     * @type {string}
     * @memberof IdentityBeta
     */
    'lastRefresh'?: string;
    /**
     * A map with the identity attributes for the identity
     * @type {object}
     * @memberof IdentityBeta
     */
    'attributes'?: object;
    /**
     * 
     * @type {LifecycleStateDtoBeta}
     * @memberof IdentityBeta
     */
    'lifecycleState'?: LifecycleStateDtoBeta;
}

export const IdentityBetaProcessingStateEnum = {
    Error: 'ERROR',
    Ok: 'OK'
} as const;

export type IdentityBetaProcessingStateEnum = typeof IdentityBetaProcessingStateEnum[keyof typeof IdentityBetaProcessingStateEnum];
export const IdentityBetaIdentityStatusEnum = {
    Unregistered: 'UNREGISTERED',
    Registered: 'REGISTERED',
    Pending: 'PENDING',
    Warning: 'WARNING',
    Disabled: 'DISABLED',
    Active: 'ACTIVE',
    Deactivated: 'DEACTIVATED',
    Terminated: 'TERMINATED',
    Error: 'ERROR',
    Locked: 'LOCKED'
} as const;

export type IdentityBetaIdentityStatusEnum = typeof IdentityBetaIdentityStatusEnum[keyof typeof IdentityBetaIdentityStatusEnum];

/**
 * 
 * @export
 * @interface IdentityCertificationTaskBeta
 */
export interface IdentityCertificationTaskBeta {
    /**
     * The task id
     * @type {string}
     * @memberof IdentityCertificationTaskBeta
     */
    'id'?: string;
    /**
     * The certification id
     * @type {string}
     * @memberof IdentityCertificationTaskBeta
     */
    'certificationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityCertificationTaskBeta
     */
    'type'?: IdentityCertificationTaskBetaTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof IdentityCertificationTaskBeta
     */
    'status'?: IdentityCertificationTaskBetaStatusEnum;
    /**
     * Any errors executing the task (Optional).
     * @type {Array<string>}
     * @memberof IdentityCertificationTaskBeta
     */
    'errors'?: Array<string>;
}

export const IdentityCertificationTaskBetaTypeEnum = {
    Reassign: 'REASSIGN'
} as const;

export type IdentityCertificationTaskBetaTypeEnum = typeof IdentityCertificationTaskBetaTypeEnum[keyof typeof IdentityCertificationTaskBetaTypeEnum];
export const IdentityCertificationTaskBetaStatusEnum = {
    Queued: 'QUEUED',
    InProgress: 'IN_PROGRESS',
    Success: 'SUCCESS',
    Error: 'ERROR'
} as const;

export type IdentityCertificationTaskBetaStatusEnum = typeof IdentityCertificationTaskBetaStatusEnum[keyof typeof IdentityCertificationTaskBetaStatusEnum];

/**
 * 
 * @export
 * @interface IdentityCertifiedBeta
 */
export interface IdentityCertifiedBeta {
    /**
     * the id of the certification item
     * @type {string}
     * @memberof IdentityCertifiedBeta
     */
    'certificationId'?: string;
    /**
     * the certification item name
     * @type {string}
     * @memberof IdentityCertifiedBeta
     */
    'certificationName'?: string;
    /**
     * the date ceritification was signed
     * @type {string}
     * @memberof IdentityCertifiedBeta
     */
    'signedDate'?: string;
    /**
     * this field is deprecated and may go away
     * @type {Array<CertifierResponseBeta>}
     * @memberof IdentityCertifiedBeta
     */
    'certifiers'?: Array<CertifierResponseBeta>;
    /**
     * The list of identities who review this certification
     * @type {Array<CertifierResponseBeta>}
     * @memberof IdentityCertifiedBeta
     */
    'reviewers'?: Array<CertifierResponseBeta>;
    /**
     * 
     * @type {CertifierResponseBeta}
     * @memberof IdentityCertifiedBeta
     */
    'signer'?: CertifierResponseBeta;
    /**
     * the event type
     * @type {string}
     * @memberof IdentityCertifiedBeta
     */
    'eventType'?: string;
    /**
     * the date of event
     * @type {string}
     * @memberof IdentityCertifiedBeta
     */
    'dt'?: string;
}
/**
 * 
 * @export
 * @interface IdentityCompareResponseBeta
 */
export interface IdentityCompareResponseBeta {
    /**
     * Arbitrary key-value pairs. They will never be processed by the IdentityNow system but will be returned on completion of the violation check.
     * @type {{ [key: string]: object; }}
     * @memberof IdentityCompareResponseBeta
     */
    'accessItemDiff'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface IdentityCreatedBeta
 */
export interface IdentityCreatedBeta {
    /**
     * 
     * @type {IdentityCreatedIdentityBeta}
     * @memberof IdentityCreatedBeta
     */
    'identity': IdentityCreatedIdentityBeta;
    /**
     * The attributes assigned to the identity.  Attributes are determined by the identity profile.
     * @type {{ [key: string]: any; }}
     * @memberof IdentityCreatedBeta
     */
    'attributes': { [key: string]: any; };
}
/**
 * The identity that was created.
 * @export
 * @interface IdentityCreatedIdentityBeta
 */
export interface IdentityCreatedIdentityBeta {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof IdentityCreatedIdentityBeta
     */
    'type': IdentityCreatedIdentityBetaTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof IdentityCreatedIdentityBeta
     */
    'id': string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof IdentityCreatedIdentityBeta
     */
    'name': string;
}

export const IdentityCreatedIdentityBetaTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type IdentityCreatedIdentityBetaTypeEnum = typeof IdentityCreatedIdentityBetaTypeEnum[keyof typeof IdentityCreatedIdentityBetaTypeEnum];

/**
 * 
 * @export
 * @interface IdentityDeletedBeta
 */
export interface IdentityDeletedBeta {
    /**
     * 
     * @type {IdentityDeletedIdentityBeta}
     * @memberof IdentityDeletedBeta
     */
    'identity': IdentityDeletedIdentityBeta;
    /**
     * The attributes assigned to the identity.  Attributes are determined by the identity profile.
     * @type {{ [key: string]: any; }}
     * @memberof IdentityDeletedBeta
     */
    'attributes': { [key: string]: any; };
}
/**
 * The identity that was deleted.
 * @export
 * @interface IdentityDeletedIdentityBeta
 */
export interface IdentityDeletedIdentityBeta {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof IdentityDeletedIdentityBeta
     */
    'type': IdentityDeletedIdentityBetaTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof IdentityDeletedIdentityBeta
     */
    'id': string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof IdentityDeletedIdentityBeta
     */
    'name': string;
}

export const IdentityDeletedIdentityBetaTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type IdentityDeletedIdentityBetaTypeEnum = typeof IdentityDeletedIdentityBetaTypeEnum[keyof typeof IdentityDeletedIdentityBetaTypeEnum];

/**
 * 
 * @export
 * @interface IdentityDtoBeta
 */
export interface IdentityDtoBeta {
    /**
     * Alternate unique identifier for the identity
     * @type {string}
     * @memberof IdentityDtoBeta
     */
    'alias'?: string;
    /**
     * The email address of the identity
     * @type {string}
     * @memberof IdentityDtoBeta
     */
    'emailAddress'?: string;
    /**
     * The processing state of the identity
     * @type {string}
     * @memberof IdentityDtoBeta
     */
    'processingState'?: IdentityDtoBetaProcessingStateEnum;
    /**
     * The identity\'s status in the system
     * @type {string}
     * @memberof IdentityDtoBeta
     */
    'identityStatus'?: IdentityDtoBetaIdentityStatusEnum;
    /**
     * 
     * @type {BaseReferenceDto1Beta}
     * @memberof IdentityDtoBeta
     */
    'managerRef'?: BaseReferenceDto1Beta;
    /**
     * Whether this identity is a manager of another identity
     * @type {boolean}
     * @memberof IdentityDtoBeta
     */
    'isManager'?: boolean;
    /**
     * The last time the identity was refreshed by the system
     * @type {string}
     * @memberof IdentityDtoBeta
     */
    'lastRefresh'?: string;
    /**
     * A map with the identity attributes for the identity
     * @type {object}
     * @memberof IdentityDtoBeta
     */
    'attributes'?: object;
    /**
     * 
     * @type {LifecycleStateDtoBeta}
     * @memberof IdentityDtoBeta
     */
    'lifecycleState'?: LifecycleStateDtoBeta;
}

export const IdentityDtoBetaProcessingStateEnum = {
    Error: 'ERROR',
    Ok: 'OK'
} as const;

export type IdentityDtoBetaProcessingStateEnum = typeof IdentityDtoBetaProcessingStateEnum[keyof typeof IdentityDtoBetaProcessingStateEnum];
export const IdentityDtoBetaIdentityStatusEnum = {
    Unregistered: 'UNREGISTERED',
    Registered: 'REGISTERED',
    Pending: 'PENDING',
    Warning: 'WARNING',
    Disabled: 'DISABLED',
    Active: 'ACTIVE',
    Deactivated: 'DEACTIVATED',
    Terminated: 'TERMINATED',
    Error: 'ERROR',
    Locked: 'LOCKED'
} as const;

export type IdentityDtoBetaIdentityStatusEnum = typeof IdentityDtoBetaIdentityStatusEnum[keyof typeof IdentityDtoBetaIdentityStatusEnum];

/**
 * 
 * @export
 * @interface IdentityEntitiesBeta
 */
export interface IdentityEntitiesBeta {
    /**
     * 
     * @type {IdentityEntitiesIdentityEntityBeta}
     * @memberof IdentityEntitiesBeta
     */
    'identityEntity'?: IdentityEntitiesIdentityEntityBeta;
}
/**
 * 
 * @export
 * @interface IdentityEntitiesIdentityEntityBeta
 */
export interface IdentityEntitiesIdentityEntityBeta {
    /**
     * id of the resource to which the identity is associated
     * @type {string}
     * @memberof IdentityEntitiesIdentityEntityBeta
     */
    'id'?: string;
    /**
     * name of the resource to which the identity is associated
     * @type {string}
     * @memberof IdentityEntitiesIdentityEntityBeta
     */
    'name'?: string;
    /**
     * type of the resource to which the identity is associated
     * @type {string}
     * @memberof IdentityEntitiesIdentityEntityBeta
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface IdentityExceptionReportReference1Beta
 */
export interface IdentityExceptionReportReference1Beta {
    /**
     * The id of the task result.
     * @type {string}
     * @memberof IdentityExceptionReportReference1Beta
     */
    'taskResultId'?: string;
    /**
     * The name of the report.
     * @type {string}
     * @memberof IdentityExceptionReportReference1Beta
     */
    'reportName'?: string;
}
/**
 * 
 * @export
 * @interface IdentityExceptionReportReferenceBeta
 */
export interface IdentityExceptionReportReferenceBeta {
    /**
     * The id of the task result
     * @type {string}
     * @memberof IdentityExceptionReportReferenceBeta
     */
    'taskResultId'?: string;
    /**
     * The name of the report
     * @type {string}
     * @memberof IdentityExceptionReportReferenceBeta
     */
    'reportName'?: string;
}
/**
 * 
 * @export
 * @interface IdentityHistoryResponseBeta
 */
export interface IdentityHistoryResponseBeta {
    /**
     * the identity ID
     * @type {string}
     * @memberof IdentityHistoryResponseBeta
     */
    'id'?: string;
    /**
     * the display name of the identity
     * @type {string}
     * @memberof IdentityHistoryResponseBeta
     */
    'displayName'?: string;
    /**
     * the date when the identity record was created
     * @type {string}
     * @memberof IdentityHistoryResponseBeta
     */
    'snapshot'?: string;
    /**
     * the date when the identity was deleted
     * @type {string}
     * @memberof IdentityHistoryResponseBeta
     */
    'deletedDate'?: string;
    /**
     * A map containing the count of each access item
     * @type {{ [key: string]: string; }}
     * @memberof IdentityHistoryResponseBeta
     */
    'accessItemCount'?: { [key: string]: string; };
    /**
     * A map containing the identity attributes
     * @type {{ [key: string]: string; }}
     * @memberof IdentityHistoryResponseBeta
     */
    'attributes'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface IdentityListItemBeta
 */
export interface IdentityListItemBeta {
    /**
     * the identity ID
     * @type {string}
     * @memberof IdentityListItemBeta
     */
    'id'?: string;
    /**
     * the display name of the identity
     * @type {string}
     * @memberof IdentityListItemBeta
     */
    'displayName'?: string;
    /**
     * the first name of the identity
     * @type {string}
     * @memberof IdentityListItemBeta
     */
    'firstName'?: string;
    /**
     * the last name of the identity
     * @type {string}
     * @memberof IdentityListItemBeta
     */
    'lastName'?: string;
    /**
     * indicates if an identity is active or not
     * @type {boolean}
     * @memberof IdentityListItemBeta
     */
    'active'?: boolean;
    /**
     * the date when the identity was deleted
     * @type {string}
     * @memberof IdentityListItemBeta
     */
    'deletedDate'?: string | null;
}
/**
 * 
 * @export
 * @interface IdentityPreviewRequestBeta
 */
export interface IdentityPreviewRequestBeta {
    /**
     * 
     * @type {string}
     * @memberof IdentityPreviewRequestBeta
     */
    'identityId'?: string;
    /**
     * 
     * @type {IdentityAttributeConfigBeta}
     * @memberof IdentityPreviewRequestBeta
     */
    'identityAttributeConfig'?: IdentityAttributeConfigBeta;
}
/**
 * 
 * @export
 * @interface IdentityPreviewResponseBeta
 */
export interface IdentityPreviewResponseBeta {
    /**
     * 
     * @type {BaseReferenceDto1Beta}
     * @memberof IdentityPreviewResponseBeta
     */
    'identity'?: BaseReferenceDto1Beta;
    /**
     * 
     * @type {Array<IdentityAttributePreviewBeta>}
     * @memberof IdentityPreviewResponseBeta
     */
    'previewAttributes'?: Array<IdentityAttributePreviewBeta>;
}
/**
 * 
 * @export
 * @interface IdentityProfile1AllOfAuthoritativeSourceBeta
 */
export interface IdentityProfile1AllOfAuthoritativeSourceBeta {
    /**
     * Type of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfile1AllOfAuthoritativeSourceBeta
     */
    'type'?: IdentityProfile1AllOfAuthoritativeSourceBetaTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfile1AllOfAuthoritativeSourceBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfile1AllOfAuthoritativeSourceBeta
     */
    'name'?: string;
}

export const IdentityProfile1AllOfAuthoritativeSourceBetaTypeEnum = {
    Source: 'SOURCE'
} as const;

export type IdentityProfile1AllOfAuthoritativeSourceBetaTypeEnum = typeof IdentityProfile1AllOfAuthoritativeSourceBetaTypeEnum[keyof typeof IdentityProfile1AllOfAuthoritativeSourceBetaTypeEnum];

/**
 * 
 * @export
 * @interface IdentityProfile1AllOfBeta
 */
export interface IdentityProfile1AllOfBeta {
    /**
     * The description of the Identity Profile.
     * @type {string}
     * @memberof IdentityProfile1AllOfBeta
     */
    'description'?: string | null;
    /**
     * 
     * @type {IdentityProfileAllOfOwnerBeta}
     * @memberof IdentityProfile1AllOfBeta
     */
    'owner'?: IdentityProfileAllOfOwnerBeta | null;
    /**
     * The priority for an Identity Profile.
     * @type {number}
     * @memberof IdentityProfile1AllOfBeta
     */
    'priority'?: number;
    /**
     * 
     * @type {IdentityProfile1AllOfAuthoritativeSourceBeta}
     * @memberof IdentityProfile1AllOfBeta
     */
    'authoritativeSource': IdentityProfile1AllOfAuthoritativeSourceBeta;
    /**
     * True if a identity refresh is needed. Typically triggered when a change on the source has been made.
     * @type {boolean}
     * @memberof IdentityProfile1AllOfBeta
     */
    'identityRefreshRequired'?: boolean;
    /**
     * The number of identities that belong to the Identity Profile.
     * @type {number}
     * @memberof IdentityProfile1AllOfBeta
     */
    'identityCount'?: number;
    /**
     * 
     * @type {IdentityAttributeConfig1Beta}
     * @memberof IdentityProfile1AllOfBeta
     */
    'identityAttributeConfig'?: IdentityAttributeConfig1Beta;
    /**
     * 
     * @type {IdentityExceptionReportReference1Beta}
     * @memberof IdentityProfile1AllOfBeta
     */
    'identityExceptionReportReference'?: IdentityExceptionReportReference1Beta | null;
    /**
     * Indicates the value of requiresPeriodicRefresh attribute for the Identity Profile.
     * @type {boolean}
     * @memberof IdentityProfile1AllOfBeta
     */
    'hasTimeBasedAttr'?: boolean;
}
/**
 * 
 * @export
 * @interface IdentityProfile1Beta
 */
export interface IdentityProfile1Beta {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof IdentityProfile1Beta
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof IdentityProfile1Beta
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof IdentityProfile1Beta
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof IdentityProfile1Beta
     */
    'modified'?: string;
    /**
     * The description of the Identity Profile.
     * @type {string}
     * @memberof IdentityProfile1Beta
     */
    'description'?: string | null;
    /**
     * 
     * @type {IdentityProfileAllOfOwnerBeta}
     * @memberof IdentityProfile1Beta
     */
    'owner'?: IdentityProfileAllOfOwnerBeta | null;
    /**
     * The priority for an Identity Profile.
     * @type {number}
     * @memberof IdentityProfile1Beta
     */
    'priority'?: number;
    /**
     * 
     * @type {IdentityProfile1AllOfAuthoritativeSourceBeta}
     * @memberof IdentityProfile1Beta
     */
    'authoritativeSource': IdentityProfile1AllOfAuthoritativeSourceBeta;
    /**
     * True if a identity refresh is needed. Typically triggered when a change on the source has been made.
     * @type {boolean}
     * @memberof IdentityProfile1Beta
     */
    'identityRefreshRequired'?: boolean;
    /**
     * The number of identities that belong to the Identity Profile.
     * @type {number}
     * @memberof IdentityProfile1Beta
     */
    'identityCount'?: number;
    /**
     * 
     * @type {IdentityAttributeConfig1Beta}
     * @memberof IdentityProfile1Beta
     */
    'identityAttributeConfig'?: IdentityAttributeConfig1Beta;
    /**
     * 
     * @type {IdentityExceptionReportReference1Beta}
     * @memberof IdentityProfile1Beta
     */
    'identityExceptionReportReference'?: IdentityExceptionReportReference1Beta | null;
    /**
     * Indicates the value of requiresPeriodicRefresh attribute for the Identity Profile.
     * @type {boolean}
     * @memberof IdentityProfile1Beta
     */
    'hasTimeBasedAttr'?: boolean;
}
/**
 * The authoritative source for this Identity Profile.
 * @export
 * @interface IdentityProfileAllOfAuthoritativeSourceBeta
 */
export interface IdentityProfileAllOfAuthoritativeSourceBeta {
    /**
     * Type of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfileAllOfAuthoritativeSourceBeta
     */
    'type'?: IdentityProfileAllOfAuthoritativeSourceBetaTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfileAllOfAuthoritativeSourceBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfileAllOfAuthoritativeSourceBeta
     */
    'name'?: string;
}

export const IdentityProfileAllOfAuthoritativeSourceBetaTypeEnum = {
    Source: 'SOURCE'
} as const;

export type IdentityProfileAllOfAuthoritativeSourceBetaTypeEnum = typeof IdentityProfileAllOfAuthoritativeSourceBetaTypeEnum[keyof typeof IdentityProfileAllOfAuthoritativeSourceBetaTypeEnum];

/**
 * 
 * @export
 * @interface IdentityProfileAllOfBeta
 */
export interface IdentityProfileAllOfBeta {
    /**
     * The description of the Identity Profile.
     * @type {string}
     * @memberof IdentityProfileAllOfBeta
     */
    'description'?: string | null;
    /**
     * 
     * @type {IdentityProfileAllOfOwnerBeta}
     * @memberof IdentityProfileAllOfBeta
     */
    'owner'?: IdentityProfileAllOfOwnerBeta | null;
    /**
     * The priority for an Identity Profile.
     * @type {number}
     * @memberof IdentityProfileAllOfBeta
     */
    'priority'?: number;
    /**
     * 
     * @type {IdentityProfileAllOfAuthoritativeSourceBeta}
     * @memberof IdentityProfileAllOfBeta
     */
    'authoritativeSource': IdentityProfileAllOfAuthoritativeSourceBeta;
    /**
     * True if a identity refresh is needed. Typically triggered when a change on the source has been made
     * @type {boolean}
     * @memberof IdentityProfileAllOfBeta
     */
    'identityRefreshRequired'?: boolean;
    /**
     * The number of identities that belong to the Identity Profile.
     * @type {number}
     * @memberof IdentityProfileAllOfBeta
     */
    'identityCount'?: number;
    /**
     * 
     * @type {IdentityAttributeConfigBeta}
     * @memberof IdentityProfileAllOfBeta
     */
    'identityAttributeConfig'?: IdentityAttributeConfigBeta;
    /**
     * 
     * @type {IdentityExceptionReportReferenceBeta}
     * @memberof IdentityProfileAllOfBeta
     */
    'identityExceptionReportReference'?: IdentityExceptionReportReferenceBeta | null;
    /**
     * Indicates the value of requiresPeriodicRefresh attribute for the Identity Profile.
     * @type {boolean}
     * @memberof IdentityProfileAllOfBeta
     */
    'hasTimeBasedAttr'?: boolean;
}
/**
 * The owner of the Identity Profile.
 * @export
 * @interface IdentityProfileAllOfOwnerBeta
 */
export interface IdentityProfileAllOfOwnerBeta {
    /**
     * Type of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfileAllOfOwnerBeta
     */
    'type'?: IdentityProfileAllOfOwnerBetaTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfileAllOfOwnerBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfileAllOfOwnerBeta
     */
    'name'?: string;
}

export const IdentityProfileAllOfOwnerBetaTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type IdentityProfileAllOfOwnerBetaTypeEnum = typeof IdentityProfileAllOfOwnerBetaTypeEnum[keyof typeof IdentityProfileAllOfOwnerBetaTypeEnum];

/**
 * 
 * @export
 * @interface IdentityProfileBeta
 */
export interface IdentityProfileBeta {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof IdentityProfileBeta
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof IdentityProfileBeta
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof IdentityProfileBeta
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof IdentityProfileBeta
     */
    'modified'?: string;
    /**
     * The description of the Identity Profile.
     * @type {string}
     * @memberof IdentityProfileBeta
     */
    'description'?: string | null;
    /**
     * 
     * @type {IdentityProfileAllOfOwnerBeta}
     * @memberof IdentityProfileBeta
     */
    'owner'?: IdentityProfileAllOfOwnerBeta | null;
    /**
     * The priority for an Identity Profile.
     * @type {number}
     * @memberof IdentityProfileBeta
     */
    'priority'?: number;
    /**
     * 
     * @type {IdentityProfileAllOfAuthoritativeSourceBeta}
     * @memberof IdentityProfileBeta
     */
    'authoritativeSource': IdentityProfileAllOfAuthoritativeSourceBeta;
    /**
     * True if a identity refresh is needed. Typically triggered when a change on the source has been made
     * @type {boolean}
     * @memberof IdentityProfileBeta
     */
    'identityRefreshRequired'?: boolean;
    /**
     * The number of identities that belong to the Identity Profile.
     * @type {number}
     * @memberof IdentityProfileBeta
     */
    'identityCount'?: number;
    /**
     * 
     * @type {IdentityAttributeConfigBeta}
     * @memberof IdentityProfileBeta
     */
    'identityAttributeConfig'?: IdentityAttributeConfigBeta;
    /**
     * 
     * @type {IdentityExceptionReportReferenceBeta}
     * @memberof IdentityProfileBeta
     */
    'identityExceptionReportReference'?: IdentityExceptionReportReferenceBeta | null;
    /**
     * Indicates the value of requiresPeriodicRefresh attribute for the Identity Profile.
     * @type {boolean}
     * @memberof IdentityProfileBeta
     */
    'hasTimeBasedAttr'?: boolean;
}
/**
 * Identity Profile exported object
 * @export
 * @interface IdentityProfileExportedObjectBeta
 */
export interface IdentityProfileExportedObjectBeta {
    /**
     * Version or object from the target service.
     * @type {number}
     * @memberof IdentityProfileExportedObjectBeta
     */
    'version'?: number;
    /**
     * 
     * @type {BaseReferenceDto1Beta}
     * @memberof IdentityProfileExportedObjectBeta
     */
    'self'?: BaseReferenceDto1Beta;
    /**
     * 
     * @type {IdentityProfile1Beta}
     * @memberof IdentityProfileExportedObjectBeta
     */
    'object'?: IdentityProfile1Beta;
}
/**
 * The manager for the identity.
 * @export
 * @interface IdentityReferenceBeta
 */
export interface IdentityReferenceBeta {
    /**
     * 
     * @type {DtoTypeBeta}
     * @memberof IdentityReferenceBeta
     */
    'type'?: DtoTypeBeta;
    /**
     * Identity id
     * @type {string}
     * @memberof IdentityReferenceBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of identity.
     * @type {string}
     * @memberof IdentityReferenceBeta
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface IdentityReferenceWithIdBeta
 */
export interface IdentityReferenceWithIdBeta {
    /**
     * 
     * @type {DtoTypeBeta}
     * @memberof IdentityReferenceWithIdBeta
     */
    'type'?: DtoTypeBeta;
    /**
     * Identity id
     * @type {string}
     * @memberof IdentityReferenceWithIdBeta
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface IdentityReferenceWithNameAndEmailBeta
 */
export interface IdentityReferenceWithNameAndEmailBeta {
    /**
     * The type can only be IDENTITY. This is read-only
     * @type {string}
     * @memberof IdentityReferenceWithNameAndEmailBeta
     */
    'type'?: string;
    /**
     * Identity id.
     * @type {string}
     * @memberof IdentityReferenceWithNameAndEmailBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of identity. This is read-only
     * @type {string}
     * @memberof IdentityReferenceWithNameAndEmailBeta
     */
    'name'?: string;
    /**
     * Email address of identity. This is read-only
     * @type {string}
     * @memberof IdentityReferenceWithNameAndEmailBeta
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface IdentitySnapshotSummaryResponseBeta
 */
export interface IdentitySnapshotSummaryResponseBeta {
    /**
     * the date when the identity record was created
     * @type {string}
     * @memberof IdentitySnapshotSummaryResponseBeta
     */
    'snapshot'?: string;
}
/**
 * 
 * @export
 * @interface IdentitySummaryBeta
 */
export interface IdentitySummaryBeta {
    /**
     * ID of this identity summary
     * @type {string}
     * @memberof IdentitySummaryBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of identity
     * @type {string}
     * @memberof IdentitySummaryBeta
     */
    'name'?: string;
    /**
     * ID of the identity that this summary represents
     * @type {string}
     * @memberof IdentitySummaryBeta
     */
    'identityId'?: string;
    /**
     * Indicates if all access items for this summary have been decided on
     * @type {boolean}
     * @memberof IdentitySummaryBeta
     */
    'completed'?: boolean;
}
/**
 * 
 * @export
 * @interface IdentitySyncJobBeta
 */
export interface IdentitySyncJobBeta {
    /**
     * Job ID.
     * @type {string}
     * @memberof IdentitySyncJobBeta
     */
    'id': string;
    /**
     * The job status.
     * @type {string}
     * @memberof IdentitySyncJobBeta
     */
    'status': IdentitySyncJobBetaStatusEnum;
    /**
     * 
     * @type {IdentitySyncPayloadBeta}
     * @memberof IdentitySyncJobBeta
     */
    'payload': IdentitySyncPayloadBeta;
}

export const IdentitySyncJobBetaStatusEnum = {
    Queued: 'QUEUED',
    InProgress: 'IN_PROGRESS',
    Success: 'SUCCESS',
    Error: 'ERROR'
} as const;

export type IdentitySyncJobBetaStatusEnum = typeof IdentitySyncJobBetaStatusEnum[keyof typeof IdentitySyncJobBetaStatusEnum];

/**
 * 
 * @export
 * @interface IdentitySyncPayloadBeta
 */
export interface IdentitySyncPayloadBeta {
    /**
     * Payload type.
     * @type {string}
     * @memberof IdentitySyncPayloadBeta
     */
    'type': string;
    /**
     * Payload type.
     * @type {string}
     * @memberof IdentitySyncPayloadBeta
     */
    'dataJson': string;
}
/**
 * The types of objects supported for SOD violations
 * @export
 * @interface IdentityWithNewAccessAccessRefsInnerBeta
 */
export interface IdentityWithNewAccessAccessRefsInnerBeta {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof IdentityWithNewAccessAccessRefsInnerBeta
     */
    'type'?: IdentityWithNewAccessAccessRefsInnerBetaTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof IdentityWithNewAccessAccessRefsInnerBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof IdentityWithNewAccessAccessRefsInnerBeta
     */
    'name'?: string;
}

export const IdentityWithNewAccessAccessRefsInnerBetaTypeEnum = {
    Entitlement: 'ENTITLEMENT'
} as const;

export type IdentityWithNewAccessAccessRefsInnerBetaTypeEnum = typeof IdentityWithNewAccessAccessRefsInnerBetaTypeEnum[keyof typeof IdentityWithNewAccessAccessRefsInnerBetaTypeEnum];

/**
 * An identity with a set of access to be added
 * @export
 * @interface IdentityWithNewAccessBeta
 */
export interface IdentityWithNewAccessBeta {
    /**
     * Identity id to be checked.
     * @type {string}
     * @memberof IdentityWithNewAccessBeta
     */
    'identityId': string;
    /**
     * The list of ENTITLEMENTs to consider for calculating possible violations in a preventive check.
     * @type {Array<IdentityWithNewAccessAccessRefsInnerBeta>}
     * @memberof IdentityWithNewAccessBeta
     */
    'accessRefs': Array<IdentityWithNewAccessAccessRefsInnerBeta>;
}
/**
 * 
 * @export
 * @interface ImportFormDefinitions202ResponseBeta
 */
export interface ImportFormDefinitions202ResponseBeta {
    /**
     * 
     * @type {Array<ImportFormDefinitions202ResponseErrorsInnerBeta>}
     * @memberof ImportFormDefinitions202ResponseBeta
     */
    'errors'?: Array<ImportFormDefinitions202ResponseErrorsInnerBeta>;
    /**
     * 
     * @type {Array<ExportFormDefinitionsByTenant200ResponseInnerBeta>}
     * @memberof ImportFormDefinitions202ResponseBeta
     */
    'importedObjects'?: Array<ExportFormDefinitionsByTenant200ResponseInnerBeta>;
    /**
     * 
     * @type {Array<ImportFormDefinitions202ResponseErrorsInnerBeta>}
     * @memberof ImportFormDefinitions202ResponseBeta
     */
    'infos'?: Array<ImportFormDefinitions202ResponseErrorsInnerBeta>;
    /**
     * 
     * @type {Array<ImportFormDefinitions202ResponseErrorsInnerBeta>}
     * @memberof ImportFormDefinitions202ResponseBeta
     */
    'warnings'?: Array<ImportFormDefinitions202ResponseErrorsInnerBeta>;
}
/**
 * 
 * @export
 * @interface ImportFormDefinitions202ResponseErrorsInnerBeta
 */
export interface ImportFormDefinitions202ResponseErrorsInnerBeta {
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ImportFormDefinitions202ResponseErrorsInnerBeta
     */
    'detail'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof ImportFormDefinitions202ResponseErrorsInnerBeta
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportFormDefinitions202ResponseErrorsInnerBeta
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface ImportNonEmployeeRecordsInBulkRequestBeta
 */
export interface ImportNonEmployeeRecordsInBulkRequestBeta {
    /**
     * 
     * @type {any}
     * @memberof ImportNonEmployeeRecordsInBulkRequestBeta
     */
    'data': any;
}
/**
 * 
 * @export
 * @interface ImportOptionsBeta
 */
export interface ImportOptionsBeta {
    /**
     * Object type names to be excluded from an sp-config export command.
     * @type {Array<string>}
     * @memberof ImportOptionsBeta
     */
    'excludeTypes'?: Array<ImportOptionsBetaExcludeTypesEnum>;
    /**
     * Object type names to be included in an sp-config export command. IncludeTypes takes precedence over excludeTypes.
     * @type {Array<string>}
     * @memberof ImportOptionsBeta
     */
    'includeTypes'?: Array<ImportOptionsBetaIncludeTypesEnum>;
    /**
     * Additional options targeting specific objects related to each item in the includeTypes field
     * @type {{ [key: string]: ObjectExportImportOptionsBeta; }}
     * @memberof ImportOptionsBeta
     */
    'objectOptions'?: { [key: string]: ObjectExportImportOptionsBeta; };
    /**
     * List of BaseRefenceDtos that can be used to resolve references on import.
     * @type {Array<BaseReferenceDto1Beta>}
     * @memberof ImportOptionsBeta
     */
    'defaultReferences'?: Array<BaseReferenceDto1Beta>;
    /**
     * By default, every import will first export all existing objects supported by sp-config as a backup before the import is attempted. If excludeBackup is true, the backup will not be performed.
     * @type {boolean}
     * @memberof ImportOptionsBeta
     */
    'excludeBackup'?: boolean;
}

export const ImportOptionsBetaExcludeTypesEnum = {
    IdentityObjectConfig: 'IDENTITY_OBJECT_CONFIG',
    IdentityProfile: 'IDENTITY_PROFILE',
    Rule: 'RULE',
    Source: 'SOURCE',
    Transform: 'TRANSFORM',
    TriggerSubscription: 'TRIGGER_SUBSCRIPTION'
} as const;

export type ImportOptionsBetaExcludeTypesEnum = typeof ImportOptionsBetaExcludeTypesEnum[keyof typeof ImportOptionsBetaExcludeTypesEnum];
export const ImportOptionsBetaIncludeTypesEnum = {
    IdentityObjectConfig: 'IDENTITY_OBJECT_CONFIG',
    IdentityProfile: 'IDENTITY_PROFILE',
    Rule: 'RULE',
    Source: 'SOURCE',
    Transform: 'TRANSFORM',
    TriggerSubscription: 'TRIGGER_SUBSCRIPTION'
} as const;

export type ImportOptionsBetaIncludeTypesEnum = typeof ImportOptionsBetaIncludeTypesEnum[keyof typeof ImportOptionsBetaIncludeTypesEnum];

/**
 * 
 * @export
 * @interface ImportSpConfigRequestBeta
 */
export interface ImportSpConfigRequestBeta {
    /**
     * JSON file containing the objects to be imported.
     * @type {any}
     * @memberof ImportSpConfigRequestBeta
     */
    'data': any;
    /**
     * 
     * @type {ImportOptionsBeta}
     * @memberof ImportSpConfigRequestBeta
     */
    'options'?: ImportOptionsBeta;
}
/**
 * 
 * @export
 * @interface InvocationBeta
 */
export interface InvocationBeta {
    /**
     * Invocation ID
     * @type {string}
     * @memberof InvocationBeta
     */
    'id'?: string;
    /**
     * Trigger ID
     * @type {string}
     * @memberof InvocationBeta
     */
    'triggerId'?: string;
    /**
     * Unique invocation secret.
     * @type {string}
     * @memberof InvocationBeta
     */
    'secret'?: string;
    /**
     * JSON map of invocation metadata.
     * @type {object}
     * @memberof InvocationBeta
     */
    'contentJson'?: object;
}
/**
 * 
 * @export
 * @interface InvocationStatusBeta
 */
export interface InvocationStatusBeta {
    /**
     * Invocation ID
     * @type {string}
     * @memberof InvocationStatusBeta
     */
    'id': string;
    /**
     * Trigger ID
     * @type {string}
     * @memberof InvocationStatusBeta
     */
    'triggerId': string;
    /**
     * Subscription ID
     * @type {string}
     * @memberof InvocationStatusBeta
     */
    'subscriptionId': string;
    /**
     * 
     * @type {InvocationStatusTypeBeta}
     * @memberof InvocationStatusBeta
     */
    'type': InvocationStatusTypeBeta;
    /**
     * Invocation created timestamp. ISO-8601 in UTC.
     * @type {string}
     * @memberof InvocationStatusBeta
     */
    'created': string;
    /**
     * Invocation completed timestamp; empty fields imply invocation is in-flight or not completed. ISO-8601 in UTC.
     * @type {string}
     * @memberof InvocationStatusBeta
     */
    'completed'?: string;
    /**
     * 
     * @type {StartInvocationInputBeta}
     * @memberof InvocationStatusBeta
     */
    'startInvocationInput': StartInvocationInputBeta;
    /**
     * 
     * @type {CompleteInvocationInputBeta}
     * @memberof InvocationStatusBeta
     */
    'completeInvocationInput'?: CompleteInvocationInputBeta;
}
/**
 * Defines the Invocation type.  **TEST** The trigger was invocated as a test, either via the test subscription button in the UI or via the start test invocation API.  **REAL_TIME** The trigger subscription is live and was invocated by a real event in IdentityNow.
 * @export
 * @enum {string}
 */

export const InvocationStatusTypeBeta = {
    Test: 'TEST',
    RealTime: 'REAL_TIME'
} as const;

export type InvocationStatusTypeBeta = typeof InvocationStatusTypeBeta[keyof typeof InvocationStatusTypeBeta];


/**
 * A JSONPatch document as defined by [RFC 6902 - JSON Patch](https://tools.ietf.org/html/rfc6902)
 * @export
 * @interface JsonPatchBeta
 */
export interface JsonPatchBeta {
    /**
     * Operations to be applied
     * @type {Array<JsonPatchOperationBeta>}
     * @memberof JsonPatchBeta
     */
    'operations'?: Array<JsonPatchOperationBeta>;
}
/**
 * A JSONPatch Operation as defined by [RFC 6902 - JSON Patch](https://tools.ietf.org/html/rfc6902)
 * @export
 * @interface JsonPatchOperationBeta
 */
export interface JsonPatchOperationBeta {
    /**
     * The operation to be performed
     * @type {string}
     * @memberof JsonPatchOperationBeta
     */
    'op': JsonPatchOperationBetaOpEnum;
    /**
     * A string JSON Pointer representing the target path to an element to be affected by the operation
     * @type {string}
     * @memberof JsonPatchOperationBeta
     */
    'path': string;
    /**
     * 
     * @type {JsonPatchOperationValueBeta}
     * @memberof JsonPatchOperationBeta
     */
    'value'?: JsonPatchOperationValueBeta;
}

export const JsonPatchOperationBetaOpEnum = {
    Add: 'add',
    Remove: 'remove',
    Replace: 'replace',
    Move: 'move',
    Copy: 'copy',
    Test: 'test'
} as const;

export type JsonPatchOperationBetaOpEnum = typeof JsonPatchOperationBetaOpEnum[keyof typeof JsonPatchOperationBetaOpEnum];

/**
 * 
 * @export
 * @interface JsonPatchOperationValueAnyOfInnerBeta
 */
export interface JsonPatchOperationValueAnyOfInnerBeta {
}
/**
 * The value to be used for the operation, required for \"add\" and \"replace\" operations
 * @export
 * @interface JsonPatchOperationValueBeta
 */
export interface JsonPatchOperationValueBeta {
}
/**
 * 
 * @export
 * @interface LatestOutlierSummaryBeta
 */
export interface LatestOutlierSummaryBeta {
    /**
     * The type of outlier summary
     * @type {string}
     * @memberof LatestOutlierSummaryBeta
     */
    'type'?: LatestOutlierSummaryBetaTypeEnum;
    /**
     * The date the bulk outlier detection ran/snapshot was created
     * @type {string}
     * @memberof LatestOutlierSummaryBeta
     */
    'snapshotDate'?: string;
    /**
     * Total number of outliers for the customer making the request
     * @type {number}
     * @memberof LatestOutlierSummaryBeta
     */
    'totalOutliers'?: number;
    /**
     * Total number of identities for the customer making the request
     * @type {number}
     * @memberof LatestOutlierSummaryBeta
     */
    'totalIdentities'?: number;
    /**
     * Total number of ignored outliers
     * @type {number}
     * @memberof LatestOutlierSummaryBeta
     */
    'totalIgnored'?: number;
}

export const LatestOutlierSummaryBetaTypeEnum = {
    LowSimilarity: 'LOW_SIMILARITY',
    Structural: 'STRUCTURAL'
} as const;

export type LatestOutlierSummaryBetaTypeEnum = typeof LatestOutlierSummaryBetaTypeEnum[keyof typeof LatestOutlierSummaryBetaTypeEnum];

/**
 * 
 * @export
 * @interface LifecycleStateBeta
 */
export interface LifecycleStateBeta {
    /**
     * lifecycle stat id.
     * @type {string}
     * @memberof LifecycleStateBeta
     */
    'id'?: string;
    /**
     * Lifecycle-state name.
     * @type {string}
     * @memberof LifecycleStateBeta
     */
    'name'?: string;
    /**
     * The technical name for lifecycle state. This is for internal use.
     * @type {string}
     * @memberof LifecycleStateBeta
     */
    'technicalName'?: string;
    /**
     * Lifecycle state description.
     * @type {string}
     * @memberof LifecycleStateBeta
     */
    'description'?: string;
    /**
     * Lifecycle state created date.
     * @type {string}
     * @memberof LifecycleStateBeta
     */
    'created'?: string;
    /**
     * Lifecycle state modified date.
     * @type {string}
     * @memberof LifecycleStateBeta
     */
    'modified'?: string;
    /**
     * Whether the lifecycle state is enabled or disabled.
     * @type {boolean}
     * @memberof LifecycleStateBeta
     */
    'enabled'?: boolean;
    /**
     * Number of identities that have the lifecycle state.
     * @type {number}
     * @memberof LifecycleStateBeta
     */
    'identityCount'?: number;
    /**
     * 
     * @type {EmailNotificationOptionBeta}
     * @memberof LifecycleStateBeta
     */
    'emailNotificationOption'?: EmailNotificationOptionBeta;
    /**
     * 
     * @type {Array<AccountActionBeta>}
     * @memberof LifecycleStateBeta
     */
    'accountActions'?: Array<AccountActionBeta>;
    /**
     * List of access-profile IDs that are associated with the lifecycle state.
     * @type {Array<string>}
     * @memberof LifecycleStateBeta
     */
    'accessProfileIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface LifecycleStateDtoBeta
 */
export interface LifecycleStateDtoBeta {
    /**
     * The name of the lifecycle state
     * @type {string}
     * @memberof LifecycleStateDtoBeta
     */
    'stateName': string;
    /**
     * Whether the lifecycle state has been manually or automatically set
     * @type {boolean}
     * @memberof LifecycleStateDtoBeta
     */
    'manuallyUpdated': boolean;
}
/**
 * 
 * @export
 * @interface ListAccessProfiles401ResponseBeta
 */
export interface ListAccessProfiles401ResponseBeta {
    /**
     * A message describing the error
     * @type {object}
     * @memberof ListAccessProfiles401ResponseBeta
     */
    'error'?: object;
}
/**
 * 
 * @export
 * @interface ListAccessProfiles429ResponseBeta
 */
export interface ListAccessProfiles429ResponseBeta {
    /**
     * A message describing the error
     * @type {object}
     * @memberof ListAccessProfiles429ResponseBeta
     */
    'message'?: object;
}
/**
 * 
 * @export
 * @interface ListAccounts200ResponseInnerBeta
 */
export interface ListAccounts200ResponseInnerBeta {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof ListAccounts200ResponseInnerBeta
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof ListAccounts200ResponseInnerBeta
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof ListAccounts200ResponseInnerBeta
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof ListAccounts200ResponseInnerBeta
     */
    'modified'?: string;
    /**
     * Unique ID from the owning source
     * @type {string}
     * @memberof ListAccounts200ResponseInnerBeta
     */
    'uuid'?: string | null;
    /**
     * The native identifier of the account
     * @type {string}
     * @memberof ListAccounts200ResponseInnerBeta
     */
    'nativeIdentity'?: string;
    /**
     * The description for the account
     * @type {string}
     * @memberof ListAccounts200ResponseInnerBeta
     */
    'description'?: string | null;
    /**
     * Whether the account is disabled
     * @type {boolean}
     * @memberof ListAccounts200ResponseInnerBeta
     */
    'disabled'?: boolean;
    /**
     * Whether the account is locked
     * @type {boolean}
     * @memberof ListAccounts200ResponseInnerBeta
     */
    'locked'?: boolean;
    /**
     * Whether the account was manually correlated
     * @type {boolean}
     * @memberof ListAccounts200ResponseInnerBeta
     */
    'manuallyCorrelated'?: boolean;
    /**
     * Whether the account has any entitlements associated with it
     * @type {boolean}
     * @memberof ListAccounts200ResponseInnerBeta
     */
    'hasEntitlements'?: boolean;
    /**
     * The ID of the source for which this account belongs
     * @type {string}
     * @memberof ListAccounts200ResponseInnerBeta
     */
    'sourceId'?: string;
    /**
     * The name of the source
     * @type {string}
     * @memberof ListAccounts200ResponseInnerBeta
     */
    'sourceName'?: string;
    /**
     * The ID of the identity for which this account is correlated to if not uncorrelated
     * @type {string}
     * @memberof ListAccounts200ResponseInnerBeta
     */
    'identityId'?: string;
    /**
     * A map containing attributes associated with the account
     * @type {{ [key: string]: any; }}
     * @memberof ListAccounts200ResponseInnerBeta
     */
    'attributes'?: { [key: string]: any; };
    /**
     * Whether this account belongs to an authoritative source
     * @type {boolean}
     * @memberof ListAccounts200ResponseInnerBeta
     */
    'authoritative'?: boolean;
    /**
     * Whether this account is for the IdentityNow source
     * @type {boolean}
     * @memberof ListAccounts200ResponseInnerBeta
     */
    'systemAccount'?: boolean;
    /**
     * True if this account is not correlated to an identity
     * @type {boolean}
     * @memberof ListAccounts200ResponseInnerBeta
     */
    'uncorrelated'?: boolean;
    /**
     * A string list containing the owning source\'s features
     * @type {string}
     * @memberof ListAccounts200ResponseInnerBeta
     */
    'features'?: string;
}
/**
 * 
 * @export
 * @interface ListCompleteWorkflowLibrary200ResponseInnerBeta
 */
export interface ListCompleteWorkflowLibrary200ResponseInnerBeta {
    /**
     * Operator ID.
     * @type {string}
     * @memberof ListCompleteWorkflowLibrary200ResponseInnerBeta
     */
    'id'?: string;
    /**
     * Operator friendly name
     * @type {string}
     * @memberof ListCompleteWorkflowLibrary200ResponseInnerBeta
     */
    'name'?: string;
    /**
     * Operator type
     * @type {string}
     * @memberof ListCompleteWorkflowLibrary200ResponseInnerBeta
     */
    'type'?: string;
    /**
     * Description of the operator
     * @type {string}
     * @memberof ListCompleteWorkflowLibrary200ResponseInnerBeta
     */
    'description'?: string;
    /**
     * One or more inputs that the operator accepts
     * @type {Array<WorkflowLibraryFormFieldsBeta>}
     * @memberof ListCompleteWorkflowLibrary200ResponseInnerBeta
     */
    'formFields'?: Array<WorkflowLibraryFormFieldsBeta>;
    /**
     * Determines whether the dynamic output schema is returned in place of the action\'s output schema. The dynamic schema lists non-static properties, like properties of a workflow form where each form has different fields. These will be provided dynamically based on available form fields.
     * @type {boolean}
     * @memberof ListCompleteWorkflowLibrary200ResponseInnerBeta
     */
    'isDynamicSchema'?: boolean;
    /**
     * Defines the output schema, if any, that this action produces.
     * @type {object}
     * @memberof ListCompleteWorkflowLibrary200ResponseInnerBeta
     */
    'outputSchema'?: object;
    /**
     * Example trigger payload if applicable
     * @type {object}
     * @memberof ListCompleteWorkflowLibrary200ResponseInnerBeta
     */
    'inputExample'?: object | null;
}
/**
 * 
 * @export
 * @interface ListFormDefinitionsByTenantResponseBeta
 */
export interface ListFormDefinitionsByTenantResponseBeta {
    /**
     * Count number of Results
     * @type {number}
     * @memberof ListFormDefinitionsByTenantResponseBeta
     */
    'count'?: number;
    /**
     * Results holds a list of FormDefinitionResponse items
     * @type {Array<FormDefinitionResponseBeta>}
     * @memberof ListFormDefinitionsByTenantResponseBeta
     */
    'results'?: Array<FormDefinitionResponseBeta>;
}
/**
 * 
 * @export
 * @interface ListFormElementDataByElementIDResponseBeta
 */
export interface ListFormElementDataByElementIDResponseBeta {
    /**
     * Results holds a list of FormElementDataSourceConfigOptions items
     * @type {Array<FormElementDataSourceConfigOptionsBeta>}
     * @memberof ListFormElementDataByElementIDResponseBeta
     */
    'results'?: Array<FormElementDataSourceConfigOptionsBeta>;
}
/**
 * 
 * @export
 * @interface ListFormInstancesByTenantResponseBeta
 */
export interface ListFormInstancesByTenantResponseBeta {
    /**
     * Count number of Results
     * @type {number}
     * @memberof ListFormInstancesByTenantResponseBeta
     */
    'count'?: number;
    /**
     * Results holds a list of FormInstanceResponse items
     * @type {Array<FormInstanceResponseBeta>}
     * @memberof ListFormInstancesByTenantResponseBeta
     */
    'results'?: Array<FormInstanceResponseBeta>;
}
/**
 * @type ListIdentityAccessItems200ResponseInnerBeta
 * @export
 */
export type ListIdentityAccessItems200ResponseInnerBeta = AccessItemAccessProfileResponseBeta | AccessItemAccountResponseBeta | AccessItemAppResponseBeta | AccessItemEntitlementResponseBeta | AccessItemRoleResponseBeta;

/**
 * 
 * @export
 * @interface ListPredefinedSelectOptionsResponseBeta
 */
export interface ListPredefinedSelectOptionsResponseBeta {
    /**
     * Results holds a list of PreDefinedSelectOption items
     * @type {Array<string>}
     * @memberof ListPredefinedSelectOptionsResponseBeta
     */
    'results'?: Array<string>;
}
/**
 * An indicator of how the locale was selected. *DEFAULT* means the locale is the system default. *REQUEST* means the locale was selected from the request context (i.e., best match based on the *Accept-Language* header). Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const LocaleOriginBeta = {
    Default: 'DEFAULT',
    Request: 'REQUEST'
} as const;

export type LocaleOriginBeta = typeof LocaleOriginBeta[keyof typeof LocaleOriginBeta];


/**
 * Localized error message to indicate a failed invocation or error if any.
 * @export
 * @interface LocalizedMessageBeta
 */
export interface LocalizedMessageBeta {
    /**
     * Message locale
     * @type {string}
     * @memberof LocalizedMessageBeta
     */
    'locale': string;
    /**
     * Message text
     * @type {string}
     * @memberof LocalizedMessageBeta
     */
    'message': string;
}
/**
 * The definition of an Identity according to the Reassignment Configuration service
 * @export
 * @interface LookupStepBeta
 */
export interface LookupStepBeta {
    /**
     * The ID of the Identity who work is reassigned to
     * @type {string}
     * @memberof LookupStepBeta
     */
    'reassignedToId'?: string;
    /**
     * The ID of the Identity who work is reassigned from
     * @type {string}
     * @memberof LookupStepBeta
     */
    'reassignedFromId'?: string;
    /**
     * 
     * @type {ReassignmentTypeEnumBeta}
     * @memberof LookupStepBeta
     */
    'reassignmentType'?: ReassignmentTypeEnumBeta;
}
/**
 * MAIL FROM attributes for a domain / identity
 * @export
 * @interface MailFromAttributesBeta
 */
export interface MailFromAttributesBeta {
    /**
     * The email identity
     * @type {string}
     * @memberof MailFromAttributesBeta
     */
    'identity'?: string;
    /**
     * The name of a domain that an email identity uses as a custom MAIL FROM domain
     * @type {string}
     * @memberof MailFromAttributesBeta
     */
    'mailFromDomain'?: string;
    /**
     * MX record that is required in customer\'s DNS to allow the domain to receive bounce and complaint notifications that email providers send you
     * @type {string}
     * @memberof MailFromAttributesBeta
     */
    'mxRecord'?: string;
    /**
     * TXT record that is required in customer\'s DNS in order to prove that Amazon SES is authorized to send email from your domain
     * @type {string}
     * @memberof MailFromAttributesBeta
     */
    'txtRecord'?: string;
    /**
     * The current status of the MAIL FROM verification
     * @type {string}
     * @memberof MailFromAttributesBeta
     */
    'mailFromDomainStatus'?: MailFromAttributesBetaMailFromDomainStatusEnum;
}

export const MailFromAttributesBetaMailFromDomainStatusEnum = {
    Pending: 'PENDING',
    Success: 'SUCCESS',
    Failed: 'FAILED'
} as const;

export type MailFromAttributesBetaMailFromDomainStatusEnum = typeof MailFromAttributesBetaMailFromDomainStatusEnum[keyof typeof MailFromAttributesBetaMailFromDomainStatusEnum];

/**
 * MAIL FROM attributes for a domain / identity
 * @export
 * @interface MailFromAttributesDtoBeta
 */
export interface MailFromAttributesDtoBeta {
    /**
     * The identity or domain address
     * @type {string}
     * @memberof MailFromAttributesDtoBeta
     */
    'identity'?: string;
    /**
     * The new MAIL FROM domain of the identity. Must be a subdomain of the identity.
     * @type {string}
     * @memberof MailFromAttributesDtoBeta
     */
    'mailFromDomain'?: string;
}
/**
 * Managed Client
 * @export
 * @interface ManagedClientBeta
 */
export interface ManagedClientBeta {
    /**
     * ManagedClient ID
     * @type {string}
     * @memberof ManagedClientBeta
     */
    'id'?: string;
    /**
     * ManagedClient alert key
     * @type {string}
     * @memberof ManagedClientBeta
     */
    'alertKey'?: string;
    /**
     * ManagedClient gateway base url
     * @type {string}
     * @memberof ManagedClientBeta
     */
    'apiGatewayBaseUrl'?: string;
    /**
     * Previous CC ID to be used in data migration. (This field will be deleted after CC migration!)
     * @type {number}
     * @memberof ManagedClientBeta
     */
    'ccId'?: number;
    /**
     * The client ID used in API management
     * @type {string}
     * @memberof ManagedClientBeta
     */
    'clientId': string;
    /**
     * Cluster ID that the ManagedClient is linked to
     * @type {string}
     * @memberof ManagedClientBeta
     */
    'clusterId': string;
    /**
     * VA cookbook
     * @type {string}
     * @memberof ManagedClientBeta
     */
    'cookbook'?: string;
    /**
     * ManagedClient description
     * @type {string}
     * @memberof ManagedClientBeta
     */
    'description': string;
    /**
     * The public IP address of the ManagedClient
     * @type {string}
     * @memberof ManagedClientBeta
     */
    'ipAddress'?: string;
    /**
     * When the ManagedClient was last seen by the server
     * @type {string}
     * @memberof ManagedClientBeta
     */
    'lastSeen'?: string;
    /**
     * ManagedClient name
     * @type {string}
     * @memberof ManagedClientBeta
     */
    'name'?: string;
    /**
     * Milliseconds since the ManagedClient has polled the server
     * @type {string}
     * @memberof ManagedClientBeta
     */
    'sinceLastSeen'?: string;
    /**
     * Status of the ManagedClient
     * @type {ManagedClientStatusEnumBeta}
     * @memberof ManagedClientBeta
     */
    'status'?: ManagedClientStatusEnumBeta;
    /**
     * Type of the ManagedClient (VA, CCG)
     * @type {string}
     * @memberof ManagedClientBeta
     */
    'type': string;
    /**
     * ManagedClient VA download URL
     * @type {string}
     * @memberof ManagedClientBeta
     */
    'vaDownloadUrl'?: string;
    /**
     * Version that the ManagedClient\'s VA is running
     * @type {string}
     * @memberof ManagedClientBeta
     */
    'vaVersion'?: string;
    /**
     * Client\'s apiKey
     * @type {string}
     * @memberof ManagedClientBeta
     */
    'secret'?: string;
}
/**
 * Managed Client Status
 * @export
 * @interface ManagedClientStatusAggResponseBeta
 */
export interface ManagedClientStatusAggResponseBeta {
    /**
     * ManagedClientStatus body information
     * @type {object}
     * @memberof ManagedClientStatusAggResponseBeta
     */
    'body': object;
    /**
     * 
     * @type {ManagedClientStatusEnumBeta}
     * @memberof ManagedClientStatusAggResponseBeta
     */
    'status': ManagedClientStatusEnumBeta;
    /**
     * 
     * @type {ManagedClientTypeBeta}
     * @memberof ManagedClientStatusAggResponseBeta
     */
    'type': ManagedClientTypeBeta | null;
    /**
     * timestamp on the Client Status update
     * @type {string}
     * @memberof ManagedClientStatusAggResponseBeta
     */
    'timestamp': string;
}
/**
 * Managed Client Status
 * @export
 * @interface ManagedClientStatusBeta
 */
export interface ManagedClientStatusBeta {
    /**
     * ManagedClientStatus body information
     * @type {object}
     * @memberof ManagedClientStatusBeta
     */
    'body': object;
    /**
     * 
     * @type {ManagedClientStatusEnumBeta}
     * @memberof ManagedClientStatusBeta
     */
    'status': ManagedClientStatusEnumBeta;
    /**
     * 
     * @type {ManagedClientTypeBeta}
     * @memberof ManagedClientStatusBeta
     */
    'type': ManagedClientTypeBeta | null;
    /**
     * timestamp on the Client Status update
     * @type {string}
     * @memberof ManagedClientStatusBeta
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ManagedClientStatusEnumBeta = {
    Normal: 'NORMAL',
    Undefined: 'UNDEFINED',
    NotConfigured: 'NOT_CONFIGURED',
    Configuring: 'CONFIGURING',
    Warning: 'WARNING',
    Error: 'ERROR',
    Failed: 'FAILED'
} as const;

export type ManagedClientStatusEnumBeta = typeof ManagedClientStatusEnumBeta[keyof typeof ManagedClientStatusEnumBeta];


/**
 * Managed Client type
 * @export
 * @enum {string}
 */

export const ManagedClientTypeBeta = {
    Ccg: 'CCG',
    Va: 'VA',
    Internal: 'INTERNAL',
    IiqHarvester: 'IIQ_HARVESTER',
    Null: 'null'
} as const;

export type ManagedClientTypeBeta = typeof ManagedClientTypeBeta[keyof typeof ManagedClientTypeBeta];


/**
 * Managed Cluster Attributes for Cluster Configuration. Supported Cluster Types [sqsCluster, spConnectCluster]
 * @export
 * @interface ManagedClusterAttributesBeta
 */
export interface ManagedClusterAttributesBeta {
    /**
     * 
     * @type {ManagedClusterQueueBeta}
     * @memberof ManagedClusterAttributesBeta
     */
    'queue'?: ManagedClusterQueueBeta;
    /**
     * ManagedCluster keystore for spConnectCluster type
     * @type {string}
     * @memberof ManagedClusterAttributesBeta
     */
    'keystore'?: string | null;
}
/**
 * Managed Cluster
 * @export
 * @interface ManagedClusterBeta
 */
export interface ManagedClusterBeta {
    /**
     * ManagedCluster ID
     * @type {string}
     * @memberof ManagedClusterBeta
     */
    'id': string;
    /**
     * ManagedCluster name
     * @type {string}
     * @memberof ManagedClusterBeta
     */
    'name'?: string;
    /**
     * ManagedCluster pod
     * @type {string}
     * @memberof ManagedClusterBeta
     */
    'pod'?: string;
    /**
     * ManagedCluster org
     * @type {string}
     * @memberof ManagedClusterBeta
     */
    'org'?: string;
    /**
     * 
     * @type {ManagedClusterTypesBeta}
     * @memberof ManagedClusterBeta
     */
    'type'?: ManagedClusterTypesBeta;
    /**
     * ManagedProcess configuration map
     * @type {{ [key: string]: string; }}
     * @memberof ManagedClusterBeta
     */
    'configuration'?: { [key: string]: string; };
    /**
     * 
     * @type {ManagedClusterKeyPairBeta}
     * @memberof ManagedClusterBeta
     */
    'keyPair'?: ManagedClusterKeyPairBeta;
    /**
     * 
     * @type {ManagedClusterAttributesBeta}
     * @memberof ManagedClusterBeta
     */
    'attributes'?: ManagedClusterAttributesBeta;
    /**
     * ManagedCluster description
     * @type {string}
     * @memberof ManagedClusterBeta
     */
    'description'?: string;
    /**
     * 
     * @type {ManagedClusterRedisBeta}
     * @memberof ManagedClusterBeta
     */
    'redis'?: ManagedClusterRedisBeta;
    /**
     * 
     * @type {ManagedClientTypeBeta}
     * @memberof ManagedClusterBeta
     */
    'clientType': ManagedClientTypeBeta | null;
    /**
     * CCG version used by the ManagedCluster
     * @type {string}
     * @memberof ManagedClusterBeta
     */
    'ccgVersion': string;
    /**
     * boolean flag indiacting whether or not the cluster configuration is pinned
     * @type {boolean}
     * @memberof ManagedClusterBeta
     */
    'pinnedConfig'?: boolean;
    /**
     * 
     * @type {ClientLogConfigurationBeta}
     * @memberof ManagedClusterBeta
     */
    'logConfiguration'?: ClientLogConfigurationBeta | null;
    /**
     * Whether or not the cluster is operational or not
     * @type {boolean}
     * @memberof ManagedClusterBeta
     */
    'operational'?: boolean;
    /**
     * Cluster status
     * @type {string}
     * @memberof ManagedClusterBeta
     */
    'status'?: string;
    /**
     * Public key certificate
     * @type {string}
     * @memberof ManagedClusterBeta
     */
    'publicKeyCertificate'?: string | null;
    /**
     * Public key thumbprint
     * @type {string}
     * @memberof ManagedClusterBeta
     */
    'publicKeyThumbprint'?: string | null;
    /**
     * Public key
     * @type {string}
     * @memberof ManagedClusterBeta
     */
    'publicKey'?: string | null;
    /**
     * Key describing any immediate cluster alerts
     * @type {string}
     * @memberof ManagedClusterBeta
     */
    'alertKey'?: string;
    /**
     * List of clients in a cluster
     * @type {Array<string>}
     * @memberof ManagedClusterBeta
     */
    'clientIds'?: Array<string>;
    /**
     * Number of services bound to a cluster
     * @type {number}
     * @memberof ManagedClusterBeta
     */
    'serviceCount'?: number;
    /**
     * CC ID only used in calling CC, will be removed without notice when Migration to CEGS is finished
     * @type {string}
     * @memberof ManagedClusterBeta
     */
    'ccId'?: string;
}
/**
 * Managed Cluster key pair for Cluster
 * @export
 * @interface ManagedClusterKeyPairBeta
 */
export interface ManagedClusterKeyPairBeta {
    /**
     * ManagedCluster publicKey
     * @type {string}
     * @memberof ManagedClusterKeyPairBeta
     */
    'publicKey'?: string | null;
    /**
     * ManagedCluster publicKeyThumbprint
     * @type {string}
     * @memberof ManagedClusterKeyPairBeta
     */
    'publicKeyThumbprint'?: string | null;
    /**
     * ManagedCluster publicKeyCertificate
     * @type {string}
     * @memberof ManagedClusterKeyPairBeta
     */
    'publicKeyCertificate'?: string | null;
}
/**
 * Managed Cluster key pair for Cluster
 * @export
 * @interface ManagedClusterQueueBeta
 */
export interface ManagedClusterQueueBeta {
    /**
     * ManagedCluster queue name
     * @type {string}
     * @memberof ManagedClusterQueueBeta
     */
    'name'?: string;
    /**
     * ManagedCluster queue aws region
     * @type {string}
     * @memberof ManagedClusterQueueBeta
     */
    'region'?: string;
}
/**
 * Managed Cluster Redis Configuration
 * @export
 * @interface ManagedClusterRedisBeta
 */
export interface ManagedClusterRedisBeta {
    /**
     * ManagedCluster redisHost
     * @type {string}
     * @memberof ManagedClusterRedisBeta
     */
    'redisHost'?: string;
    /**
     * ManagedCluster redisPort
     * @type {number}
     * @memberof ManagedClusterRedisBeta
     */
    'redisPort'?: number;
}
/**
 * The Type of Cluster
 * @export
 * @enum {string}
 */

export const ManagedClusterTypesBeta = {
    Idn: 'idn',
    Iai: 'iai'
} as const;

export type ManagedClusterTypesBeta = typeof ManagedClusterTypesBeta[keyof typeof ManagedClusterTypesBeta];


/**
 * 
 * @export
 * @interface ManagerCorrelationMappingBeta
 */
export interface ManagerCorrelationMappingBeta {
    /**
     * Name of the attribute to use for manager correlation. The value found on the account attribute will be used to lookup the manager\'s identity.
     * @type {string}
     * @memberof ManagerCorrelationMappingBeta
     */
    'accountAttribute'?: string;
    /**
     * Name of the identity attribute to search when trying to find a manager using the value from the accountAttribute.
     * @type {string}
     * @memberof ManagerCorrelationMappingBeta
     */
    'identityAttribute'?: string;
}
/**
 * 
 * @export
 * @interface ManualWorkItemDetailsBeta
 */
export interface ManualWorkItemDetailsBeta {
    /**
     * True if the request for this item was forwarded from one owner to another.
     * @type {boolean}
     * @memberof ManualWorkItemDetailsBeta
     */
    'forwarded'?: boolean;
    /**
     * 
     * @type {BaseReferenceDto1Beta}
     * @memberof ManualWorkItemDetailsBeta
     */
    'originalOwner'?: BaseReferenceDto1Beta;
    /**
     * 
     * @type {BaseReferenceDto1Beta}
     * @memberof ManualWorkItemDetailsBeta
     */
    'currentOwner'?: BaseReferenceDto1Beta;
    /**
     * Time at which item was modified.
     * @type {string}
     * @memberof ManualWorkItemDetailsBeta
     */
    'modified'?: string;
    /**
     * 
     * @type {ManualWorkItemStateBeta}
     * @memberof ManualWorkItemDetailsBeta
     */
    'status'?: ManualWorkItemStateBeta;
    /**
     * The history of approval forward action.
     * @type {Array<ApprovalForwardHistoryBeta>}
     * @memberof ManualWorkItemDetailsBeta
     */
    'forwardHistory'?: Array<ApprovalForwardHistoryBeta>;
}
/**
 * Indicates the state of the request processing for this item: * PENDING: The request for this item is awaiting processing. * APPROVED: The request for this item has been approved. * REJECTED: The request for this item was rejected. * EXPIRED: The request for this item expired with no action taken. * CANCELLED: The request for this item was cancelled with no user action. * ARCHIVED: The request for this item has been archived after completion.
 * @export
 * @enum {string}
 */

export const ManualWorkItemStateBeta = {
    Pending: 'PENDING',
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    Expired: 'EXPIRED',
    Cancelled: 'CANCELLED',
    Archived: 'ARCHIVED'
} as const;

export type ManualWorkItemStateBeta = typeof ManualWorkItemStateBeta[keyof typeof ManualWorkItemStateBeta];


/**
 * 
 * @export
 * @interface ManuallyUpdatedFieldsDTOBeta
 */
export interface ManuallyUpdatedFieldsDTOBeta {
    /**
     * True if the entitlements name was updated manually via entitlement import csv or patch endpoint.  False means that property value has not been change after first entitlement aggregation. Field refers to [Entitlement response schema](https://developer.sailpoint.com/idn/api/beta/get-entitlement) > `name` property.
     * @type {boolean}
     * @memberof ManuallyUpdatedFieldsDTOBeta
     */
    'DISPLAY_NAME'?: boolean;
    /**
     * True if the entitlement description was updated manually via entitlement import csv or patch endpoint.  False means that property value has not been change after first entitlement aggregation. Field refers to [Entitlement response schema](https://developer.sailpoint.com/idn/api/beta/get-entitlement) > `description` property.
     * @type {boolean}
     * @memberof ManuallyUpdatedFieldsDTOBeta
     */
    'DESCRIPTION'?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MediumBeta = {
    Email: 'EMAIL',
    Sms: 'SMS',
    Phone: 'PHONE',
    Slack: 'SLACK',
    Teams: 'TEAMS'
} as const;

export type MediumBeta = typeof MediumBeta[keyof typeof MediumBeta];


/**
 * 
 * @export
 * @interface MessageCatalogDtoBeta
 */
export interface MessageCatalogDtoBeta {
    /**
     * The language in which the messages are returned
     * @type {string}
     * @memberof MessageCatalogDtoBeta
     */
    'locale'?: string;
    /**
     * The list of message with their keys and formats
     * @type {Array<ResourceBundleMessageBeta>}
     * @memberof MessageCatalogDtoBeta
     */
    'messages'?: Array<ResourceBundleMessageBeta>;
}
/**
 * 
 * @export
 * @interface MetricResponseBeta
 */
export interface MetricResponseBeta {
    /**
     * the name of metric
     * @type {string}
     * @memberof MetricResponseBeta
     */
    'name'?: string;
    /**
     * the value associated to the metric
     * @type {number}
     * @memberof MetricResponseBeta
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface MfaConfigBeta
 */
export interface MfaConfigBeta {
    /**
     * If MFA method is enabled.
     * @type {boolean}
     * @memberof MfaConfigBeta
     */
    'enabled'?: boolean;
    /**
     * The server host name or IP address of the MFA provider.
     * @type {string}
     * @memberof MfaConfigBeta
     */
    'host'?: string;
    /**
     * The secret key for authenticating requests to the MFA provider.
     * @type {string}
     * @memberof MfaConfigBeta
     */
    'accessKey'?: string;
    /**
     * Optional. The name of the attribute for mapping IdentityNow identity to the MFA provider.
     * @type {string}
     * @memberof MfaConfigBeta
     */
    'identityAttribute'?: string;
}
/**
 * Response model for configuration test of a given MFA method
 * @export
 * @interface MfaConfigTestResponseBeta
 */
export interface MfaConfigTestResponseBeta {
    /**
     * The configuration test result.
     * @type {string}
     * @memberof MfaConfigTestResponseBeta
     */
    'state'?: MfaConfigTestResponseBetaStateEnum;
    /**
     * The error message to indicate the failure of configuration test.
     * @type {string}
     * @memberof MfaConfigTestResponseBeta
     */
    'error'?: string;
}

export const MfaConfigTestResponseBetaStateEnum = {
    Success: 'SUCCESS',
    Failed: 'FAILED'
} as const;

export type MfaConfigTestResponseBetaStateEnum = typeof MfaConfigTestResponseBetaStateEnum[keyof typeof MfaConfigTestResponseBetaStateEnum];

/**
 * 
 * @export
 * @interface MultiPolicyRequestBeta
 */
export interface MultiPolicyRequestBeta {
    /**
     * Multi-policy report will be run for this list of ids
     * @type {Array<string>}
     * @memberof MultiPolicyRequestBeta
     */
    'filteredPolicyList'?: Array<string>;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalDecisionBeta
 */
export interface NonEmployeeApprovalDecisionBeta {
    /**
     * Comment on the approval item.
     * @type {string}
     * @memberof NonEmployeeApprovalDecisionBeta
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalItemAllOfBeta
 */
export interface NonEmployeeApprovalItemAllOfBeta {
    /**
     * 
     * @type {NonEmployeeRequestLiteBeta}
     * @memberof NonEmployeeApprovalItemAllOfBeta
     */
    'nonEmployeeRequest'?: NonEmployeeRequestLiteBeta;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalItemBaseBeta
 */
export interface NonEmployeeApprovalItemBaseBeta {
    /**
     * Non-Employee approval item id
     * @type {string}
     * @memberof NonEmployeeApprovalItemBaseBeta
     */
    'id'?: string;
    /**
     * 
     * @type {IdentityReferenceWithIdBeta}
     * @memberof NonEmployeeApprovalItemBaseBeta
     */
    'approver'?: IdentityReferenceWithIdBeta;
    /**
     * Requested identity account name
     * @type {string}
     * @memberof NonEmployeeApprovalItemBaseBeta
     */
    'accountName'?: string;
    /**
     * 
     * @type {ApprovalStatusBeta}
     * @memberof NonEmployeeApprovalItemBaseBeta
     */
    'approvalStatus'?: ApprovalStatusBeta;
    /**
     * Approval order
     * @type {number}
     * @memberof NonEmployeeApprovalItemBaseBeta
     */
    'approvalOrder'?: number;
    /**
     * comment of approver
     * @type {string}
     * @memberof NonEmployeeApprovalItemBaseBeta
     */
    'comment'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeApprovalItemBaseBeta
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeApprovalItemBaseBeta
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalItemBeta
 */
export interface NonEmployeeApprovalItemBeta {
    /**
     * Non-Employee approval item id
     * @type {string}
     * @memberof NonEmployeeApprovalItemBeta
     */
    'id'?: string;
    /**
     * 
     * @type {IdentityReferenceWithIdBeta}
     * @memberof NonEmployeeApprovalItemBeta
     */
    'approver'?: IdentityReferenceWithIdBeta;
    /**
     * Requested identity account name
     * @type {string}
     * @memberof NonEmployeeApprovalItemBeta
     */
    'accountName'?: string;
    /**
     * 
     * @type {ApprovalStatusBeta}
     * @memberof NonEmployeeApprovalItemBeta
     */
    'approvalStatus'?: ApprovalStatusBeta;
    /**
     * Approval order
     * @type {number}
     * @memberof NonEmployeeApprovalItemBeta
     */
    'approvalOrder'?: number;
    /**
     * comment of approver
     * @type {string}
     * @memberof NonEmployeeApprovalItemBeta
     */
    'comment'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeApprovalItemBeta
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeApprovalItemBeta
     */
    'created'?: string;
    /**
     * 
     * @type {NonEmployeeRequestLiteBeta}
     * @memberof NonEmployeeApprovalItemBeta
     */
    'nonEmployeeRequest'?: NonEmployeeRequestLiteBeta;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalItemDetailAllOfBeta
 */
export interface NonEmployeeApprovalItemDetailAllOfBeta {
    /**
     * 
     * @type {NonEmployeeRequestWithoutApprovalItemBeta}
     * @memberof NonEmployeeApprovalItemDetailAllOfBeta
     */
    'nonEmployeeRequest'?: NonEmployeeRequestWithoutApprovalItemBeta;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalItemDetailBeta
 */
export interface NonEmployeeApprovalItemDetailBeta {
    /**
     * Non-Employee approval item id
     * @type {string}
     * @memberof NonEmployeeApprovalItemDetailBeta
     */
    'id'?: string;
    /**
     * 
     * @type {IdentityReferenceWithIdBeta}
     * @memberof NonEmployeeApprovalItemDetailBeta
     */
    'approver'?: IdentityReferenceWithIdBeta;
    /**
     * Requested identity account name
     * @type {string}
     * @memberof NonEmployeeApprovalItemDetailBeta
     */
    'accountName'?: string;
    /**
     * 
     * @type {ApprovalStatusBeta}
     * @memberof NonEmployeeApprovalItemDetailBeta
     */
    'approvalStatus'?: ApprovalStatusBeta;
    /**
     * Approval order
     * @type {number}
     * @memberof NonEmployeeApprovalItemDetailBeta
     */
    'approvalOrder'?: number;
    /**
     * comment of approver
     * @type {string}
     * @memberof NonEmployeeApprovalItemDetailBeta
     */
    'comment'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeApprovalItemDetailBeta
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeApprovalItemDetailBeta
     */
    'created'?: string;
    /**
     * 
     * @type {NonEmployeeRequestWithoutApprovalItemBeta}
     * @memberof NonEmployeeApprovalItemDetailBeta
     */
    'nonEmployeeRequest'?: NonEmployeeRequestWithoutApprovalItemBeta;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalSummaryBeta
 */
export interface NonEmployeeApprovalSummaryBeta {
    /**
     * The number of approved non-employee approval requests.
     * @type {number}
     * @memberof NonEmployeeApprovalSummaryBeta
     */
    'approved'?: number;
    /**
     * The number of pending non-employee approval requests.
     * @type {number}
     * @memberof NonEmployeeApprovalSummaryBeta
     */
    'pending'?: number;
    /**
     * The number of rejected non-employee approval requests.
     * @type {number}
     * @memberof NonEmployeeApprovalSummaryBeta
     */
    'rejected'?: number;
}
/**
 * 
 * @export
 * @interface NonEmployeeBulkUploadJobBeta
 */
export interface NonEmployeeBulkUploadJobBeta {
    /**
     * The bulk upload job\'s ID. (UUID)
     * @type {string}
     * @memberof NonEmployeeBulkUploadJobBeta
     */
    'id'?: string;
    /**
     * The ID of the source to bulk-upload non-employees to. (UUID)
     * @type {string}
     * @memberof NonEmployeeBulkUploadJobBeta
     */
    'sourceId'?: string;
    /**
     * The date-time the job was submitted.
     * @type {string}
     * @memberof NonEmployeeBulkUploadJobBeta
     */
    'created'?: string;
    /**
     * The date-time that the job was last updated.
     * @type {string}
     * @memberof NonEmployeeBulkUploadJobBeta
     */
    'modified'?: string;
    /**
     * Returns the following values indicating the progress or result of the bulk upload job. \"PENDING\" means the job is queued and waiting to be processed. \"IN_PROGRESS\" means the job is currently being processed. \"COMPLETED\" means the job has been completed without any errors. \"ERROR\" means the job failed to process with errors. 
     * @type {string}
     * @memberof NonEmployeeBulkUploadJobBeta
     */
    'status'?: NonEmployeeBulkUploadJobBetaStatusEnum;
}

export const NonEmployeeBulkUploadJobBetaStatusEnum = {
    Pending: 'PENDING',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Error: 'ERROR'
} as const;

export type NonEmployeeBulkUploadJobBetaStatusEnum = typeof NonEmployeeBulkUploadJobBetaStatusEnum[keyof typeof NonEmployeeBulkUploadJobBetaStatusEnum];

/**
 * 
 * @export
 * @interface NonEmployeeBulkUploadStatusBeta
 */
export interface NonEmployeeBulkUploadStatusBeta {
    /**
     * Returns the following values indicating the progress or result of the bulk upload job. \"PENDING\" means the job is queued and waiting to be processed. \"IN_PROGRESS\" means the job is currently being processed. \"COMPLETED\" means the job has been completed without any errors. \"ERROR\" means the job failed to process with errors. null means job has been submitted to the source. 
     * @type {string}
     * @memberof NonEmployeeBulkUploadStatusBeta
     */
    'status'?: NonEmployeeBulkUploadStatusBetaStatusEnum;
}

export const NonEmployeeBulkUploadStatusBetaStatusEnum = {
    Pending: 'PENDING',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Error: 'ERROR'
} as const;

export type NonEmployeeBulkUploadStatusBetaStatusEnum = typeof NonEmployeeBulkUploadStatusBetaStatusEnum[keyof typeof NonEmployeeBulkUploadStatusBetaStatusEnum];

/**
 * 
 * @export
 * @interface NonEmployeeIdnUserRequestBeta
 */
export interface NonEmployeeIdnUserRequestBeta {
    /**
     * Identity id.
     * @type {string}
     * @memberof NonEmployeeIdnUserRequestBeta
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRecordBeta
 */
export interface NonEmployeeRecordBeta {
    /**
     * Non-Employee record id.
     * @type {string}
     * @memberof NonEmployeeRecordBeta
     */
    'id'?: string;
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRecordBeta
     */
    'accountName'?: string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRecordBeta
     */
    'firstName'?: string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRecordBeta
     */
    'lastName'?: string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRecordBeta
     */
    'email'?: string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRecordBeta
     */
    'phone'?: string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRecordBeta
     */
    'manager'?: string;
    /**
     * Non-Employee\'s source id.
     * @type {string}
     * @memberof NonEmployeeRecordBeta
     */
    'sourceId'?: string;
    /**
     * Attribute blob/bag for a non-employee.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRecordBeta
     */
    'data'?: { [key: string]: string; };
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRecordBeta
     */
    'startDate'?: string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRecordBeta
     */
    'endDate'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeRecordBeta
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeRecordBeta
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRejectApprovalDecisionBeta
 */
export interface NonEmployeeRejectApprovalDecisionBeta {
    /**
     * Comment on the approval item.
     * @type {string}
     * @memberof NonEmployeeRejectApprovalDecisionBeta
     */
    'comment': string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequestAllOfBeta
 */
export interface NonEmployeeRequestAllOfBeta {
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRequestAllOfBeta
     */
    'accountName'?: string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRequestAllOfBeta
     */
    'firstName'?: string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRequestAllOfBeta
     */
    'lastName'?: string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRequestAllOfBeta
     */
    'email'?: string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRequestAllOfBeta
     */
    'phone'?: string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRequestAllOfBeta
     */
    'manager'?: string;
    /**
     * 
     * @type {NonEmployeeSourceLiteBeta}
     * @memberof NonEmployeeRequestAllOfBeta
     */
    'nonEmployeeSource'?: NonEmployeeSourceLiteBeta;
    /**
     * Attribute blob/bag for a non-employee.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRequestAllOfBeta
     */
    'data'?: { [key: string]: string; };
    /**
     * List of approval item for the request
     * @type {Array<NonEmployeeApprovalItemBaseBeta>}
     * @memberof NonEmployeeRequestAllOfBeta
     */
    'approvalItems'?: Array<NonEmployeeApprovalItemBaseBeta>;
    /**
     * 
     * @type {ApprovalStatusBeta}
     * @memberof NonEmployeeRequestAllOfBeta
     */
    'approvalStatus'?: ApprovalStatusBeta;
    /**
     * comment of requester
     * @type {string}
     * @memberof NonEmployeeRequestAllOfBeta
     */
    'comment'?: string;
    /**
     * When the request was completely approved.
     * @type {string}
     * @memberof NonEmployeeRequestAllOfBeta
     */
    'completionDate'?: string;
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRequestAllOfBeta
     */
    'startDate'?: string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRequestAllOfBeta
     */
    'endDate'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeRequestAllOfBeta
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeRequestAllOfBeta
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequestBeta
 */
export interface NonEmployeeRequestBeta {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeRequestBeta
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeRequestBeta
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeRequestBeta
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeRequestBeta
     */
    'description'?: string;
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRequestBeta
     */
    'accountName'?: string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRequestBeta
     */
    'firstName'?: string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRequestBeta
     */
    'lastName'?: string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRequestBeta
     */
    'email'?: string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRequestBeta
     */
    'phone'?: string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRequestBeta
     */
    'manager'?: string;
    /**
     * 
     * @type {NonEmployeeSourceLiteBeta}
     * @memberof NonEmployeeRequestBeta
     */
    'nonEmployeeSource'?: NonEmployeeSourceLiteBeta;
    /**
     * Attribute blob/bag for a non-employee.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRequestBeta
     */
    'data'?: { [key: string]: string; };
    /**
     * List of approval item for the request
     * @type {Array<NonEmployeeApprovalItemBaseBeta>}
     * @memberof NonEmployeeRequestBeta
     */
    'approvalItems'?: Array<NonEmployeeApprovalItemBaseBeta>;
    /**
     * 
     * @type {ApprovalStatusBeta}
     * @memberof NonEmployeeRequestBeta
     */
    'approvalStatus'?: ApprovalStatusBeta;
    /**
     * comment of requester
     * @type {string}
     * @memberof NonEmployeeRequestBeta
     */
    'comment'?: string;
    /**
     * When the request was completely approved.
     * @type {string}
     * @memberof NonEmployeeRequestBeta
     */
    'completionDate'?: string;
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRequestBeta
     */
    'startDate'?: string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRequestBeta
     */
    'endDate'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeRequestBeta
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeRequestBeta
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequestBodyBeta
 */
export interface NonEmployeeRequestBodyBeta {
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRequestBodyBeta
     */
    'accountName': string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRequestBodyBeta
     */
    'firstName': string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRequestBodyBeta
     */
    'lastName': string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRequestBodyBeta
     */
    'email': string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRequestBodyBeta
     */
    'phone': string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRequestBodyBeta
     */
    'manager': string;
    /**
     * Non-Employee\'s source id.
     * @type {string}
     * @memberof NonEmployeeRequestBodyBeta
     */
    'sourceId': string;
    /**
     * Attribute blob/bag for a non-employee, 10 attributes is the maximum size supported.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRequestBodyBeta
     */
    'data'?: { [key: string]: string; };
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRequestBodyBeta
     */
    'startDate': string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRequestBodyBeta
     */
    'endDate': string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequestLiteBeta
 */
export interface NonEmployeeRequestLiteBeta {
    /**
     * Non-Employee request id.
     * @type {string}
     * @memberof NonEmployeeRequestLiteBeta
     */
    'id'?: string;
    /**
     * 
     * @type {IdentityReferenceWithIdBeta}
     * @memberof NonEmployeeRequestLiteBeta
     */
    'requester'?: IdentityReferenceWithIdBeta;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequestSummaryBeta
 */
export interface NonEmployeeRequestSummaryBeta {
    /**
     * The number of approved non-employee requests on all sources that *requested-for* user manages.
     * @type {number}
     * @memberof NonEmployeeRequestSummaryBeta
     */
    'approved'?: number;
    /**
     * The number of rejected non-employee requests on all sources that *requested-for* user manages.
     * @type {number}
     * @memberof NonEmployeeRequestSummaryBeta
     */
    'rejected'?: number;
    /**
     * The number of pending non-employee requests on all sources that *requested-for* user manages.
     * @type {number}
     * @memberof NonEmployeeRequestSummaryBeta
     */
    'pending'?: number;
    /**
     * The number of non-employee records on all sources that *requested-for* user manages.
     * @type {number}
     * @memberof NonEmployeeRequestSummaryBeta
     */
    'nonEmployeeCount'?: number;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequestWithoutApprovalItemAllOfBeta
 */
export interface NonEmployeeRequestWithoutApprovalItemAllOfBeta {
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOfBeta
     */
    'accountName'?: string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOfBeta
     */
    'firstName'?: string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOfBeta
     */
    'lastName'?: string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOfBeta
     */
    'email'?: string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOfBeta
     */
    'phone'?: string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOfBeta
     */
    'manager'?: string;
    /**
     * 
     * @type {NonEmployeeSourceLiteWithSchemaAttributesBeta}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOfBeta
     */
    'nonEmployeeSource'?: NonEmployeeSourceLiteWithSchemaAttributesBeta;
    /**
     * Attribute blob/bag for a non-employee.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOfBeta
     */
    'data'?: { [key: string]: string; };
    /**
     * 
     * @type {ApprovalStatusBeta}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOfBeta
     */
    'approvalStatus'?: ApprovalStatusBeta;
    /**
     * comment of requester
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOfBeta
     */
    'comment'?: string;
    /**
     * When the request was completely approved.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOfBeta
     */
    'completionDate'?: string;
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOfBeta
     */
    'startDate'?: string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOfBeta
     */
    'endDate'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOfBeta
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOfBeta
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequestWithoutApprovalItemBeta
 */
export interface NonEmployeeRequestWithoutApprovalItemBeta {
    /**
     * Non-Employee request id.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemBeta
     */
    'id'?: string;
    /**
     * 
     * @type {IdentityReferenceWithIdBeta}
     * @memberof NonEmployeeRequestWithoutApprovalItemBeta
     */
    'requester'?: IdentityReferenceWithIdBeta;
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemBeta
     */
    'accountName'?: string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemBeta
     */
    'firstName'?: string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemBeta
     */
    'lastName'?: string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemBeta
     */
    'email'?: string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemBeta
     */
    'phone'?: string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemBeta
     */
    'manager'?: string;
    /**
     * 
     * @type {NonEmployeeSourceLiteWithSchemaAttributesBeta}
     * @memberof NonEmployeeRequestWithoutApprovalItemBeta
     */
    'nonEmployeeSource'?: NonEmployeeSourceLiteWithSchemaAttributesBeta;
    /**
     * Attribute blob/bag for a non-employee.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRequestWithoutApprovalItemBeta
     */
    'data'?: { [key: string]: string; };
    /**
     * 
     * @type {ApprovalStatusBeta}
     * @memberof NonEmployeeRequestWithoutApprovalItemBeta
     */
    'approvalStatus'?: ApprovalStatusBeta;
    /**
     * comment of requester
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemBeta
     */
    'comment'?: string;
    /**
     * When the request was completely approved.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemBeta
     */
    'completionDate'?: string;
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemBeta
     */
    'startDate'?: string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemBeta
     */
    'endDate'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemBeta
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemBeta
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeSchemaAttributeBeta
 */
export interface NonEmployeeSchemaAttributeBeta {
    /**
     * Schema Attribute Id
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBeta
     */
    'id'?: string;
    /**
     * True if this schema attribute is mandatory on all non-employees sources.
     * @type {boolean}
     * @memberof NonEmployeeSchemaAttributeBeta
     */
    'system'?: boolean;
    /**
     * When the schema attribute was last modified.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBeta
     */
    'modified'?: string;
    /**
     * When the schema attribute was created.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBeta
     */
    'created'?: string;
    /**
     * 
     * @type {NonEmployeeSchemaAttributeTypeBeta}
     * @memberof NonEmployeeSchemaAttributeBeta
     */
    'type': NonEmployeeSchemaAttributeTypeBeta;
    /**
     * Label displayed on the UI for this schema attribute.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBeta
     */
    'label': string;
    /**
     * The technical name of the attribute. Must be unique per source.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBeta
     */
    'technicalName': string;
    /**
     * help text displayed by UI.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBeta
     */
    'helpText'?: string;
    /**
     * Hint text that fills UI box.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBeta
     */
    'placeholder'?: string;
    /**
     * If true, the schema attribute is required for all non-employees in the source
     * @type {boolean}
     * @memberof NonEmployeeSchemaAttributeBeta
     */
    'required'?: boolean;
}
/**
 * 
 * @export
 * @interface NonEmployeeSchemaAttributeBodyBeta
 */
export interface NonEmployeeSchemaAttributeBodyBeta {
    /**
     * Type of the attribute. Only type \'TEXT\' is supported for custom attributes.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBodyBeta
     */
    'type': string;
    /**
     * Label displayed on the UI for this schema attribute.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBodyBeta
     */
    'label': string;
    /**
     * The technical name of the attribute. Must be unique per source.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBodyBeta
     */
    'technicalName': string;
    /**
     * help text displayed by UI.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBodyBeta
     */
    'helpText'?: string;
    /**
     * Hint text that fills UI box.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBodyBeta
     */
    'placeholder'?: string;
    /**
     * If true, the schema attribute is required for all non-employees in the source
     * @type {boolean}
     * @memberof NonEmployeeSchemaAttributeBodyBeta
     */
    'required'?: boolean;
}
/**
 * Enum representing the type of data a schema attribute accepts.
 * @export
 * @enum {string}
 */

export const NonEmployeeSchemaAttributeTypeBeta = {
    Text: 'TEXT',
    Date: 'DATE',
    Identity: 'IDENTITY'
} as const;

export type NonEmployeeSchemaAttributeTypeBeta = typeof NonEmployeeSchemaAttributeTypeBeta[keyof typeof NonEmployeeSchemaAttributeTypeBeta];


/**
 * 
 * @export
 * @interface NonEmployeeSourceAllOfBeta
 */
export interface NonEmployeeSourceAllOfBeta {
    /**
     * List of approvers
     * @type {Array<IdentityReferenceWithIdBeta>}
     * @memberof NonEmployeeSourceAllOfBeta
     */
    'approvers'?: Array<IdentityReferenceWithIdBeta>;
    /**
     * List of account managers
     * @type {Array<IdentityReferenceWithIdBeta>}
     * @memberof NonEmployeeSourceAllOfBeta
     */
    'accountManagers'?: Array<IdentityReferenceWithIdBeta>;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeSourceAllOfBeta
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeSourceAllOfBeta
     */
    'created'?: string;
    /**
     * The number of non-employee records on all sources that *requested-for* user manages.
     * @type {number}
     * @memberof NonEmployeeSourceAllOfBeta
     */
    'nonEmployeeCount'?: number | null;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceBeta
 */
export interface NonEmployeeSourceBeta {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeSourceBeta
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceBeta
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceBeta
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceBeta
     */
    'description'?: string;
    /**
     * List of approvers
     * @type {Array<IdentityReferenceWithIdBeta>}
     * @memberof NonEmployeeSourceBeta
     */
    'approvers'?: Array<IdentityReferenceWithIdBeta>;
    /**
     * List of account managers
     * @type {Array<IdentityReferenceWithIdBeta>}
     * @memberof NonEmployeeSourceBeta
     */
    'accountManagers'?: Array<IdentityReferenceWithIdBeta>;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeSourceBeta
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeSourceBeta
     */
    'created'?: string;
    /**
     * The number of non-employee records on all sources that *requested-for* user manages.
     * @type {number}
     * @memberof NonEmployeeSourceBeta
     */
    'nonEmployeeCount'?: number | null;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceLiteBeta
 */
export interface NonEmployeeSourceLiteBeta {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeSourceLiteBeta
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLiteBeta
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLiteBeta
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLiteBeta
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceLiteWithSchemaAttributesAllOfBeta
 */
export interface NonEmployeeSourceLiteWithSchemaAttributesAllOfBeta {
    /**
     * List of schema attributes associated with this non-employee source.
     * @type {Array<NonEmployeeSchemaAttributeBeta>}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributesAllOfBeta
     */
    'schemaAttributes'?: Array<NonEmployeeSchemaAttributeBeta>;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceLiteWithSchemaAttributesBeta
 */
export interface NonEmployeeSourceLiteWithSchemaAttributesBeta {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributesBeta
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributesBeta
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributesBeta
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributesBeta
     */
    'description'?: string;
    /**
     * List of schema attributes associated with this non-employee source.
     * @type {Array<NonEmployeeSchemaAttributeBeta>}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributesBeta
     */
    'schemaAttributes'?: Array<NonEmployeeSchemaAttributeBeta>;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceRequestBodyBeta
 */
export interface NonEmployeeSourceRequestBodyBeta {
    /**
     * Name of non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceRequestBodyBeta
     */
    'name': string;
    /**
     * Description of non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceRequestBodyBeta
     */
    'description': string;
    /**
     * 
     * @type {NonEmployeeIdnUserRequestBeta}
     * @memberof NonEmployeeSourceRequestBodyBeta
     */
    'owner': NonEmployeeIdnUserRequestBeta;
    /**
     * The ID for the management workgroup that contains source sub-admins
     * @type {string}
     * @memberof NonEmployeeSourceRequestBodyBeta
     */
    'managementWorkgroup'?: string;
    /**
     * List of approvers.
     * @type {Array<NonEmployeeIdnUserRequestBeta>}
     * @memberof NonEmployeeSourceRequestBodyBeta
     */
    'approvers'?: Array<NonEmployeeIdnUserRequestBeta>;
    /**
     * List of account managers.
     * @type {Array<NonEmployeeIdnUserRequestBeta>}
     * @memberof NonEmployeeSourceRequestBodyBeta
     */
    'accountManagers'?: Array<NonEmployeeIdnUserRequestBeta>;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceWithCloudExternalIdAllOfBeta
 */
export interface NonEmployeeSourceWithCloudExternalIdAllOfBeta {
    /**
     * Legacy ID used for sources from the V1 API. This attribute will be removed from a future version of the API and will not be considered a breaking change. No clients should rely on this ID always being present.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalIdAllOfBeta
     */
    'cloudExternalId'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceWithCloudExternalIdBeta
 */
export interface NonEmployeeSourceWithCloudExternalIdBeta {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalIdBeta
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalIdBeta
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalIdBeta
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalIdBeta
     */
    'description'?: string;
    /**
     * List of approvers
     * @type {Array<IdentityReferenceWithIdBeta>}
     * @memberof NonEmployeeSourceWithCloudExternalIdBeta
     */
    'approvers'?: Array<IdentityReferenceWithIdBeta>;
    /**
     * List of account managers
     * @type {Array<IdentityReferenceWithIdBeta>}
     * @memberof NonEmployeeSourceWithCloudExternalIdBeta
     */
    'accountManagers'?: Array<IdentityReferenceWithIdBeta>;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalIdBeta
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalIdBeta
     */
    'created'?: string;
    /**
     * The number of non-employee records on all sources that *requested-for* user manages.
     * @type {number}
     * @memberof NonEmployeeSourceWithCloudExternalIdBeta
     */
    'nonEmployeeCount'?: number | null;
    /**
     * Legacy ID used for sources from the V1 API. This attribute will be removed from a future version of the API and will not be considered a breaking change. No clients should rely on this ID always being present.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalIdBeta
     */
    'cloudExternalId'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceWithNECountAllOfBeta
 */
export interface NonEmployeeSourceWithNECountAllOfBeta {
    /**
     * Number of non-employee records associated with this source.
     * @type {number}
     * @memberof NonEmployeeSourceWithNECountAllOfBeta
     */
    'nonEmployeeCount'?: number;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceWithNECountBeta
 */
export interface NonEmployeeSourceWithNECountBeta {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECountBeta
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECountBeta
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECountBeta
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECountBeta
     */
    'description'?: string;
    /**
     * List of approvers
     * @type {Array<IdentityReferenceWithIdBeta>}
     * @memberof NonEmployeeSourceWithNECountBeta
     */
    'approvers'?: Array<IdentityReferenceWithIdBeta>;
    /**
     * List of account managers
     * @type {Array<IdentityReferenceWithIdBeta>}
     * @memberof NonEmployeeSourceWithNECountBeta
     */
    'accountManagers'?: Array<IdentityReferenceWithIdBeta>;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECountBeta
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECountBeta
     */
    'created'?: string;
    /**
     * Number of non-employee records associated with this source.
     * @type {number}
     * @memberof NonEmployeeSourceWithNECountBeta
     */
    'nonEmployeeCount'?: number;
}
/**
 * 
 * @export
 * @interface NotificationTemplateContextBeta
 */
export interface NotificationTemplateContextBeta {
    /**
     * A JSON object that stores the context.
     * @type {object}
     * @memberof NotificationTemplateContextBeta
     */
    'attributes'?: object;
    /**
     * When the global context was created
     * @type {string}
     * @memberof NotificationTemplateContextBeta
     */
    'created'?: string;
    /**
     * When the global context was last modified
     * @type {string}
     * @memberof NotificationTemplateContextBeta
     */
    'modified'?: string;
}
/**
 * 
 * @export
 * @interface ObjectExportImportOptionsBeta
 */
export interface ObjectExportImportOptionsBeta {
    /**
     * Object ids to be included in an import or export.
     * @type {Array<string>}
     * @memberof ObjectExportImportOptionsBeta
     */
    'includedIds'?: Array<string>;
    /**
     * Object names to be included in an import or export.
     * @type {Array<string>}
     * @memberof ObjectExportImportOptionsBeta
     */
    'includedNames'?: Array<string>;
}
/**
 * Response model for import of a single object.
 * @export
 * @interface ObjectImportResultBeta
 */
export interface ObjectImportResultBeta {
    /**
     * Informational messages returned from the target service on import.
     * @type {Array<SpConfigMessageBeta>}
     * @memberof ObjectImportResultBeta
     */
    'infos': Array<SpConfigMessageBeta>;
    /**
     * Warning messages returned from the target service on import.
     * @type {Array<SpConfigMessageBeta>}
     * @memberof ObjectImportResultBeta
     */
    'warnings': Array<SpConfigMessageBeta>;
    /**
     * Error messages returned from the target service on import.
     * @type {Array<SpConfigMessageBeta>}
     * @memberof ObjectImportResultBeta
     */
    'errors': Array<SpConfigMessageBeta>;
    /**
     * References to objects that were created or updated by the import.
     * @type {Array<BaseReferenceDto1Beta>}
     * @memberof ObjectImportResultBeta
     */
    'importedObjects': Array<BaseReferenceDto1Beta>;
}
/**
 * DTO class for OrgConfig data accessible by customer external org admin (\"ORG_ADMIN\") users
 * @export
 * @interface OrgConfigBeta
 */
export interface OrgConfigBeta {
    /**
     * The name of the org.
     * @type {string}
     * @memberof OrgConfigBeta
     */
    'orgName'?: string;
    /**
     * The selected time zone which is to be used for the org.  This directly affects when scheduled tasks are executed.  Valid options can be found at /beta/org-config/valid-time-zones
     * @type {string}
     * @memberof OrgConfigBeta
     */
    'timeZone'?: string;
    /**
     * Flag to determine whether the LCS_CHANGE_HONORS_SOURCE_ENABLE_FEATURE flag is enabled for the current org.
     * @type {boolean}
     * @memberof OrgConfigBeta
     */
    'lcsChangeHonorsSourceEnableFeature'?: boolean;
    /**
     * ARM Customer ID
     * @type {string}
     * @memberof OrgConfigBeta
     */
    'armCustomerId'?: string | null;
    /**
     * A list of IDN::sourceId to ARM::systemId mappings.
     * @type {string}
     * @memberof OrgConfigBeta
     */
    'armSapSystemIdMappings'?: string | null;
    /**
     * ARM authentication string
     * @type {string}
     * @memberof OrgConfigBeta
     */
    'armAuth'?: string | null;
    /**
     * ARM database name
     * @type {string}
     * @memberof OrgConfigBeta
     */
    'armDb'?: string | null;
    /**
     * ARM SSO URL
     * @type {string}
     * @memberof OrgConfigBeta
     */
    'armSsoUrl'?: string | null;
    /**
     * Flag to determine whether IAI Certification Recommendations are enabled for the current org
     * @type {boolean}
     * @memberof OrgConfigBeta
     */
    'iaiEnableCertificationRecommendations'?: boolean;
    /**
     * 
     * @type {Array<ReportConfigDTOBeta>}
     * @memberof OrgConfigBeta
     */
    'sodReportConfigs'?: Array<ReportConfigDTOBeta>;
}
/**
 * 
 * @export
 * @interface OutlierBeta
 */
export interface OutlierBeta {
    /**
     * The identity\'s unique identifier for the outlier record
     * @type {string}
     * @memberof OutlierBeta
     */
    'id'?: string;
    /**
     * The ID of the identity that is detected as an outlier
     * @type {string}
     * @memberof OutlierBeta
     */
    'identityId'?: string;
    /**
     * The type of outlier summary
     * @type {string}
     * @memberof OutlierBeta
     */
    'type'?: OutlierBetaTypeEnum;
    /**
     * The first date the outlier was detected
     * @type {string}
     * @memberof OutlierBeta
     */
    'firstDetectionDate'?: string;
    /**
     * The most recent date the outlier was detected
     * @type {string}
     * @memberof OutlierBeta
     */
    'latestDetectionDate'?: string;
    /**
     * Flag whether or not the outlier has been ignored
     * @type {boolean}
     * @memberof OutlierBeta
     */
    'ignored'?: boolean;
    /**
     * Object containing mapped identity attributes
     * @type {object}
     * @memberof OutlierBeta
     */
    'attributes'?: object;
    /**
     * The outlier score determined by the detection engine ranging from 0..1
     * @type {number}
     * @memberof OutlierBeta
     */
    'score'?: number;
    /**
     * Enum value of if the outlier manually or automatically un-ignored. Will be NULL if outlier is not ignored
     * @type {string}
     * @memberof OutlierBeta
     */
    'unignoreType'?: OutlierBetaUnignoreTypeEnum;
    /**
     * shows date when last time has been unignored outlier
     * @type {string}
     * @memberof OutlierBeta
     */
    'unignoreDate'?: string;
    /**
     * shows date when last time has been ignored outlier
     * @type {string}
     * @memberof OutlierBeta
     */
    'ignoreDate'?: string;
}

export const OutlierBetaTypeEnum = {
    LowSimilarity: 'LOW_SIMILARITY',
    Structural: 'STRUCTURAL'
} as const;

export type OutlierBetaTypeEnum = typeof OutlierBetaTypeEnum[keyof typeof OutlierBetaTypeEnum];
export const OutlierBetaUnignoreTypeEnum = {
    Manual: 'MANUAL',
    Automatic: 'AUTOMATIC'
} as const;

export type OutlierBetaUnignoreTypeEnum = typeof OutlierBetaUnignoreTypeEnum[keyof typeof OutlierBetaUnignoreTypeEnum];

/**
 * 
 * @export
 * @interface OutlierContributingFeatureBeta
 */
export interface OutlierContributingFeatureBeta {
    /**
     * Contributing feature id
     * @type {string}
     * @memberof OutlierContributingFeatureBeta
     */
    'id'?: string;
    /**
     * The name of the feature
     * @type {string}
     * @memberof OutlierContributingFeatureBeta
     */
    'name'?: string;
    /**
     * The data type of the value field
     * @type {string}
     * @memberof OutlierContributingFeatureBeta
     */
    'valueType'?: OutlierContributingFeatureBetaValueTypeEnum;
    /**
     * 
     * @type {OutlierContributingFeatureValueBeta}
     * @memberof OutlierContributingFeatureBeta
     */
    'value'?: OutlierContributingFeatureValueBeta;
    /**
     * The importance of the feature. This can also be a negative value
     * @type {number}
     * @memberof OutlierContributingFeatureBeta
     */
    'importance'?: number;
    /**
     * The (translated if header is passed) displayName for the feature
     * @type {string}
     * @memberof OutlierContributingFeatureBeta
     */
    'displayName'?: string;
    /**
     * The (translated if header is passed) description for the feature
     * @type {string}
     * @memberof OutlierContributingFeatureBeta
     */
    'description'?: string;
    /**
     * 
     * @type {OutlierFeatureTranslationBeta}
     * @memberof OutlierContributingFeatureBeta
     */
    'translationMessages'?: OutlierFeatureTranslationBeta;
}

export const OutlierContributingFeatureBetaValueTypeEnum = {
    Integer: 'INTEGER',
    Float: 'FLOAT'
} as const;

export type OutlierContributingFeatureBetaValueTypeEnum = typeof OutlierContributingFeatureBetaValueTypeEnum[keyof typeof OutlierContributingFeatureBetaValueTypeEnum];

/**
 * @type OutlierContributingFeatureValueBeta
 * The feature value
 * @export
 */
export type OutlierContributingFeatureValueBeta = number;

/**
 * 
 * @export
 * @interface OutlierFeatureSummaryBeta
 */
export interface OutlierFeatureSummaryBeta {
    /**
     * Contributing feature name
     * @type {string}
     * @memberof OutlierFeatureSummaryBeta
     */
    'contributingFeatureName'?: string;
    /**
     * Identity display name
     * @type {string}
     * @memberof OutlierFeatureSummaryBeta
     */
    'identityOutlierDisplayName'?: string;
    /**
     * 
     * @type {Array<OutlierFeatureSummaryOutlierFeatureDisplayValuesInnerBeta>}
     * @memberof OutlierFeatureSummaryBeta
     */
    'outlierFeatureDisplayValues'?: Array<OutlierFeatureSummaryOutlierFeatureDisplayValuesInnerBeta>;
    /**
     * Definition of the feature
     * @type {string}
     * @memberof OutlierFeatureSummaryBeta
     */
    'featureDefinition'?: string;
    /**
     * Detailed explanation of the feature
     * @type {string}
     * @memberof OutlierFeatureSummaryBeta
     */
    'featureExplanation'?: string;
    /**
     * outlier\'s peer identity display name
     * @type {string}
     * @memberof OutlierFeatureSummaryBeta
     */
    'peerDisplayName'?: string;
    /**
     * outlier\'s peer identity id
     * @type {string}
     * @memberof OutlierFeatureSummaryBeta
     */
    'peerIdentityId'?: string;
    /**
     * Access Item reference
     * @type {object}
     * @memberof OutlierFeatureSummaryBeta
     */
    'accessItemReference'?: object;
}
/**
 * 
 * @export
 * @interface OutlierFeatureSummaryOutlierFeatureDisplayValuesInnerBeta
 */
export interface OutlierFeatureSummaryOutlierFeatureDisplayValuesInnerBeta {
    /**
     * display name
     * @type {string}
     * @memberof OutlierFeatureSummaryOutlierFeatureDisplayValuesInnerBeta
     */
    'displayName'?: string;
    /**
     * value
     * @type {string}
     * @memberof OutlierFeatureSummaryOutlierFeatureDisplayValuesInnerBeta
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface OutlierFeatureTranslationBeta
 */
export interface OutlierFeatureTranslationBeta {
    /**
     * 
     * @type {TranslationMessageBeta}
     * @memberof OutlierFeatureTranslationBeta
     */
    'displayName'?: TranslationMessageBeta;
    /**
     * 
     * @type {TranslationMessageBeta}
     * @memberof OutlierFeatureTranslationBeta
     */
    'description'?: TranslationMessageBeta;
}
/**
 * 
 * @export
 * @interface OutlierSummaryBeta
 */
export interface OutlierSummaryBeta {
    /**
     * The type of outlier summary
     * @type {string}
     * @memberof OutlierSummaryBeta
     */
    'type'?: OutlierSummaryBetaTypeEnum;
    /**
     * The date the bulk outlier detection ran/snapshot was created
     * @type {string}
     * @memberof OutlierSummaryBeta
     */
    'snapshotDate'?: string;
    /**
     * Total number of outliers for the customer making the request
     * @type {number}
     * @memberof OutlierSummaryBeta
     */
    'totalOutliers'?: number;
    /**
     * Total number of identities for the customer making the request
     * @type {number}
     * @memberof OutlierSummaryBeta
     */
    'totalIdentities'?: number;
}

export const OutlierSummaryBetaTypeEnum = {
    LowSimilarity: 'LOW_SIMILARITY',
    Structural: 'STRUCTURAL'
} as const;

export type OutlierSummaryBetaTypeEnum = typeof OutlierSummaryBetaTypeEnum[keyof typeof OutlierSummaryBetaTypeEnum];

/**
 * 
 * @export
 * @interface OutliersContributingFeatureAccessItemsBeta
 */
export interface OutliersContributingFeatureAccessItemsBeta {
    /**
     * The ID of the access item
     * @type {string}
     * @memberof OutliersContributingFeatureAccessItemsBeta
     */
    'id'?: string;
    /**
     * the display name of the access item
     * @type {string}
     * @memberof OutliersContributingFeatureAccessItemsBeta
     */
    'displayName'?: string;
    /**
     * Description of the access item.
     * @type {string}
     * @memberof OutliersContributingFeatureAccessItemsBeta
     */
    'description'?: string;
    /**
     * The type of the access item.
     * @type {string}
     * @memberof OutliersContributingFeatureAccessItemsBeta
     */
    'accessType'?: OutliersContributingFeatureAccessItemsBetaAccessTypeEnum;
    /**
     * the associated source name if it exists
     * @type {string}
     * @memberof OutliersContributingFeatureAccessItemsBeta
     */
    'sourceName'?: string;
    /**
     * rarest access
     * @type {boolean}
     * @memberof OutliersContributingFeatureAccessItemsBeta
     */
    'extremelyRare'?: boolean;
}

export const OutliersContributingFeatureAccessItemsBetaAccessTypeEnum = {
    Entitlement: 'ENTITLEMENT',
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE'
} as const;

export type OutliersContributingFeatureAccessItemsBetaAccessTypeEnum = typeof OutliersContributingFeatureAccessItemsBetaAccessTypeEnum[keyof typeof OutliersContributingFeatureAccessItemsBetaAccessTypeEnum];

/**
 * 
 * @export
 * @interface OwnerBeta
 */
export interface OwnerBeta {
    /**
     * 
     * @type {DtoTypeBeta}
     * @memberof OwnerBeta
     */
    'type'?: DtoTypeBeta;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof OwnerBeta
     */
    'id'?: string;
    /**
     * Human-readable name of the owner
     * @type {string}
     * @memberof OwnerBeta
     */
    'name'?: string;
    /**
     * Human-readable display name of the owner
     * @type {string}
     * @memberof OwnerBeta
     */
    'displayName'?: string;
    /**
     * Email ID of the owner
     * @type {string}
     * @memberof OwnerBeta
     */
    'emailAddress'?: string;
}
/**
 * The owner of this object.
 * @export
 * @interface OwnerReferenceBeta
 */
export interface OwnerReferenceBeta {
    /**
     * 
     * @type {DtoTypeBeta}
     * @memberof OwnerReferenceBeta
     */
    'type'?: DtoTypeBeta;
    /**
     * Identity id
     * @type {string}
     * @memberof OwnerReferenceBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of the owner. It may be left null or omitted in a POST or PATCH. If set, it must match the current value of the owner\'s display name, otherwise a 400 Bad Request error will result.
     * @type {string}
     * @memberof OwnerReferenceBeta
     */
    'name'?: string;
}
/**
 * Simplified DTO for the owner object of the entitlement
 * @export
 * @interface OwnerReferenceDtoBeta
 */
export interface OwnerReferenceDtoBeta {
    /**
     * The owner id for the entitlement
     * @type {string}
     * @memberof OwnerReferenceDtoBeta
     */
    'id'?: string;
    /**
     * The owner name for the entitlement
     * @type {string}
     * @memberof OwnerReferenceDtoBeta
     */
    'name'?: string;
    /**
     * The type of the owner. Initially only type IDENTITY is supported
     * @type {string}
     * @memberof OwnerReferenceDtoBeta
     */
    'type'?: OwnerReferenceDtoBetaTypeEnum;
}

export const OwnerReferenceDtoBetaTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type OwnerReferenceDtoBetaTypeEnum = typeof OwnerReferenceDtoBetaTypeEnum[keyof typeof OwnerReferenceDtoBetaTypeEnum];

/**
 * 
 * @export
 * @interface PasswordChangeRequestBeta
 */
export interface PasswordChangeRequestBeta {
    /**
     * The identity ID that requested the password change
     * @type {string}
     * @memberof PasswordChangeRequestBeta
     */
    'identityId'?: string;
    /**
     * The RSA encrypted password
     * @type {string}
     * @memberof PasswordChangeRequestBeta
     */
    'encryptedPassword'?: string;
    /**
     * The encryption key ID
     * @type {string}
     * @memberof PasswordChangeRequestBeta
     */
    'publicKeyId'?: string;
    /**
     * Account ID of the account This is specified per account schema in the source configuration. It is used to distinguish accounts. More info can be found here https://community.sailpoint.com/t5/IdentityNow-Connectors/How-do-I-designate-an-account-attribute-as-the-Account-ID-for-a/ta-p/80350
     * @type {string}
     * @memberof PasswordChangeRequestBeta
     */
    'accountId'?: string;
    /**
     * The ID of the source for which identity is requesting the password change
     * @type {string}
     * @memberof PasswordChangeRequestBeta
     */
    'sourceId'?: string;
}
/**
 * 
 * @export
 * @interface PasswordChangeResponseBeta
 */
export interface PasswordChangeResponseBeta {
    /**
     * The password change request ID
     * @type {string}
     * @memberof PasswordChangeResponseBeta
     */
    'requestId'?: string | null;
    /**
     * Password change state
     * @type {string}
     * @memberof PasswordChangeResponseBeta
     */
    'state'?: PasswordChangeResponseBetaStateEnum;
}

export const PasswordChangeResponseBetaStateEnum = {
    InProgress: 'IN_PROGRESS',
    Finished: 'FINISHED',
    Failed: 'FAILED'
} as const;

export type PasswordChangeResponseBetaStateEnum = typeof PasswordChangeResponseBetaStateEnum[keyof typeof PasswordChangeResponseBetaStateEnum];

/**
 * 
 * @export
 * @interface PasswordDigitTokenBeta
 */
export interface PasswordDigitTokenBeta {
    /**
     * The digit token for password management
     * @type {string}
     * @memberof PasswordDigitTokenBeta
     */
    'digitToken'?: string;
    /**
     * The reference ID of the digit token generation request
     * @type {string}
     * @memberof PasswordDigitTokenBeta
     */
    'requestId'?: string;
}
/**
 * 
 * @export
 * @interface PasswordDigitTokenResetBeta
 */
export interface PasswordDigitTokenResetBeta {
    /**
     * The uid of the user requested for digit token
     * @type {string}
     * @memberof PasswordDigitTokenResetBeta
     */
    'userId': string;
    /**
     * The length of digit token. It should be from 6 to 18, inclusive. The default value is 6.
     * @type {number}
     * @memberof PasswordDigitTokenResetBeta
     */
    'length'?: number;
    /**
     * The time to live for the digit token in minutes. The default value is 5 minutes.
     * @type {number}
     * @memberof PasswordDigitTokenResetBeta
     */
    'durationMinutes'?: number;
}
/**
 * 
 * @export
 * @interface PasswordInfoAccountBeta
 */
export interface PasswordInfoAccountBeta {
    /**
     * Account ID of the account. This is specified per account schema in the source configuration. It is used to distinguish accounts. More info can be found here https://community.sailpoint.com/t5/IdentityNow-Connectors/How-do-I-designate-an-account-attribute-as-the-Account-ID-for-a/ta-p/80350
     * @type {string}
     * @memberof PasswordInfoAccountBeta
     */
    'accountId'?: string;
    /**
     * Display name of the account. This is specified per account schema in the source configuration. It is used to display name of the account. More info can be found here https://community.sailpoint.com/t5/IdentityNow-Connectors/How-do-I-designate-an-account-attribute-as-the-Account-Name-for/ta-p/74008
     * @type {string}
     * @memberof PasswordInfoAccountBeta
     */
    'accountName'?: string;
}
/**
 * 
 * @export
 * @interface PasswordInfoBeta
 */
export interface PasswordInfoBeta {
    /**
     * 
     * @type {string}
     * @memberof PasswordInfoBeta
     */
    'identityId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PasswordInfoBeta
     */
    'sourceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PasswordInfoBeta
     */
    'publicKeyId'?: string;
    /**
     * User\'s public key with Base64 encoding
     * @type {string}
     * @memberof PasswordInfoBeta
     */
    'publicKey'?: string;
    /**
     * Account info related to queried identity and source
     * @type {Array<PasswordInfoAccountBeta>}
     * @memberof PasswordInfoBeta
     */
    'accounts'?: Array<PasswordInfoAccountBeta>;
    /**
     * Password constraints
     * @type {Array<string>}
     * @memberof PasswordInfoBeta
     */
    'policies'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PasswordInfoQueryDTOBeta
 */
export interface PasswordInfoQueryDTOBeta {
    /**
     * The login name of the user
     * @type {string}
     * @memberof PasswordInfoQueryDTOBeta
     */
    'userName'?: string;
    /**
     * The display name of the source
     * @type {string}
     * @memberof PasswordInfoQueryDTOBeta
     */
    'sourceName'?: string;
}
/**
 * 
 * @export
 * @interface PasswordOrgConfigBeta
 */
export interface PasswordOrgConfigBeta {
    /**
     * Indicator whether custom password instructions feature is enabled. The default value is false.
     * @type {boolean}
     * @memberof PasswordOrgConfigBeta
     */
    'customInstructionsEnabled'?: boolean;
    /**
     * Indicator whether \"digit token\" feature is enabled. The default value is false.
     * @type {boolean}
     * @memberof PasswordOrgConfigBeta
     */
    'digitTokenEnabled'?: boolean;
    /**
     * The duration of \"digit token\" in minutes. The default value is 5.
     * @type {number}
     * @memberof PasswordOrgConfigBeta
     */
    'digitTokenDurationMinutes'?: number;
    /**
     * The length of \"digit token\". The default value is 6.
     * @type {number}
     * @memberof PasswordOrgConfigBeta
     */
    'digitTokenLength'?: number;
}
/**
 * 
 * @export
 * @interface PasswordStatusBeta
 */
export interface PasswordStatusBeta {
    /**
     * The password change request ID
     * @type {string}
     * @memberof PasswordStatusBeta
     */
    'requestId'?: string | null;
    /**
     * Password change state
     * @type {string}
     * @memberof PasswordStatusBeta
     */
    'state'?: PasswordStatusBetaStateEnum;
    /**
     * The errors during the password change request
     * @type {Array<string>}
     * @memberof PasswordStatusBeta
     */
    'errors'?: Array<string>;
    /**
     * List of source IDs in the password change request
     * @type {Array<string>}
     * @memberof PasswordStatusBeta
     */
    'sourceIds'?: Array<string>;
}

export const PasswordStatusBetaStateEnum = {
    InProgress: 'IN_PROGRESS',
    Finished: 'FINISHED',
    Failed: 'FAILED'
} as const;

export type PasswordStatusBetaStateEnum = typeof PasswordStatusBetaStateEnum[keyof typeof PasswordStatusBetaStateEnum];

/**
 * 
 * @export
 * @interface PasswordSyncGroupBeta
 */
export interface PasswordSyncGroupBeta {
    /**
     * ID of the sync group
     * @type {string}
     * @memberof PasswordSyncGroupBeta
     */
    'id'?: string;
    /**
     * Name of the sync group
     * @type {string}
     * @memberof PasswordSyncGroupBeta
     */
    'name'?: string;
    /**
     * ID of the password policy
     * @type {string}
     * @memberof PasswordSyncGroupBeta
     */
    'passwordPolicyId'?: string;
    /**
     * List of password managed sources IDs
     * @type {Array<string>}
     * @memberof PasswordSyncGroupBeta
     */
    'sourceIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PatchPotentialRoleRequestInnerBeta
 */
export interface PatchPotentialRoleRequestInnerBeta {
    /**
     * The operation to be performed
     * @type {string}
     * @memberof PatchPotentialRoleRequestInnerBeta
     */
    'op'?: PatchPotentialRoleRequestInnerBetaOpEnum;
    /**
     * A string JSON Pointer representing the target path to an element to be affected by the operation
     * @type {string}
     * @memberof PatchPotentialRoleRequestInnerBeta
     */
    'path': string;
    /**
     * 
     * @type {JsonPatchOperationValueBeta}
     * @memberof PatchPotentialRoleRequestInnerBeta
     */
    'value'?: JsonPatchOperationValueBeta;
}

export const PatchPotentialRoleRequestInnerBetaOpEnum = {
    Remove: 'remove',
    Replace: 'replace'
} as const;

export type PatchPotentialRoleRequestInnerBetaOpEnum = typeof PatchPotentialRoleRequestInnerBetaOpEnum[keyof typeof PatchPotentialRoleRequestInnerBetaOpEnum];

/**
 * 
 * @export
 * @interface PeerGroupMemberBeta
 */
export interface PeerGroupMemberBeta {
    /**
     * A unique identifier for the peer group member.
     * @type {string}
     * @memberof PeerGroupMemberBeta
     */
    'id'?: string;
    /**
     * The type of the peer group member.
     * @type {string}
     * @memberof PeerGroupMemberBeta
     */
    'type'?: string;
    /**
     * The ID of the peer group.
     * @type {string}
     * @memberof PeerGroupMemberBeta
     */
    'peer_group_id'?: string;
    /**
     * Arbitrary key-value pairs, belonging to the peer group member.
     * @type {{ [key: string]: object; }}
     * @memberof PeerGroupMemberBeta
     */
    'attributes'?: { [key: string]: object; };
}
/**
 * Enum represents action that is being processed on an approval.
 * @export
 * @enum {string}
 */

export const PendingApprovalActionBeta = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    Forwarded: 'FORWARDED'
} as const;

export type PendingApprovalActionBeta = typeof PendingApprovalActionBeta[keyof typeof PendingApprovalActionBeta];


/**
 * 
 * @export
 * @interface PendingApprovalBeta
 */
export interface PendingApprovalBeta {
    /**
     * The approval id.
     * @type {string}
     * @memberof PendingApprovalBeta
     */
    'id'?: string;
    /**
     * The name of the approval.
     * @type {string}
     * @memberof PendingApprovalBeta
     */
    'name'?: string;
    /**
     * When the approval was created.
     * @type {string}
     * @memberof PendingApprovalBeta
     */
    'created'?: string;
    /**
     * When the approval was modified last time.
     * @type {string}
     * @memberof PendingApprovalBeta
     */
    'modified'?: string;
    /**
     * When the access-request was created.
     * @type {string}
     * @memberof PendingApprovalBeta
     */
    'requestCreated'?: string;
    /**
     * 
     * @type {AccessRequestTypeBeta}
     * @memberof PendingApprovalBeta
     */
    'requestType'?: AccessRequestTypeBeta;
    /**
     * 
     * @type {BaseReferenceDto1Beta}
     * @memberof PendingApprovalBeta
     */
    'requester'?: BaseReferenceDto1Beta;
    /**
     * 
     * @type {BaseReferenceDto1Beta}
     * @memberof PendingApprovalBeta
     */
    'requestedFor'?: BaseReferenceDto1Beta;
    /**
     * 
     * @type {BaseReferenceDto1Beta}
     * @memberof PendingApprovalBeta
     */
    'owner'?: BaseReferenceDto1Beta;
    /**
     * 
     * @type {RequestableObjectReferenceBeta}
     * @memberof PendingApprovalBeta
     */
    'requestedObject'?: RequestableObjectReferenceBeta;
    /**
     * 
     * @type {CommentDto1Beta}
     * @memberof PendingApprovalBeta
     */
    'requesterComment'?: CommentDto1Beta;
    /**
     * The history of the previous reviewers comments.
     * @type {Array<CommentDto1Beta>}
     * @memberof PendingApprovalBeta
     */
    'previousReviewersComments'?: Array<CommentDto1Beta>;
    /**
     * The history of approval forward action.
     * @type {Array<ApprovalForwardHistoryBeta>}
     * @memberof PendingApprovalBeta
     */
    'forwardHistory'?: Array<ApprovalForwardHistoryBeta>;
    /**
     * When true the rejector has to provide comments when rejecting
     * @type {boolean}
     * @memberof PendingApprovalBeta
     */
    'commentRequiredWhenRejected'?: boolean;
    /**
     * 
     * @type {PendingApprovalActionBeta}
     * @memberof PendingApprovalBeta
     */
    'actionInProcess'?: PendingApprovalActionBeta;
    /**
     * The date the role or access profile is no longer assigned to the specified identity.
     * @type {string}
     * @memberof PendingApprovalBeta
     */
    'removeDate'?: string;
    /**
     * If true, then the request is to change the remove date or sunset date.
     * @type {boolean}
     * @memberof PendingApprovalBeta
     */
    'removeDateUpdateRequested'?: boolean;
    /**
     * The remove date or sunset date that was assigned at the time of the request.
     * @type {string}
     * @memberof PendingApprovalBeta
     */
    'currentRemoveDate'?: string;
    /**
     * 
     * @type {SodViolationContextCheckCompleted1Beta}
     * @memberof PendingApprovalBeta
     */
    'sodViolationContext'?: SodViolationContextCheckCompleted1Beta;
}
/**
 * Simplified DTO for the Permission objects stored in SailPoint\'s database. The data is aggregated from customer systems and is free-form, so its appearance can vary largely between different clients/customers.
 * @export
 * @interface PermissionDtoBeta
 */
export interface PermissionDtoBeta {
    /**
     * All the rights (e.g. actions) that this permission allows on the target
     * @type {Array<string>}
     * @memberof PermissionDtoBeta
     */
    'rights'?: Array<string>;
    /**
     * The target the permission would grants rights on.
     * @type {string}
     * @memberof PermissionDtoBeta
     */
    'target'?: string;
}
/**
 * 
 * @export
 * @interface PostExternalExecuteWorkflow200ResponseBeta
 */
export interface PostExternalExecuteWorkflow200ResponseBeta {
    /**
     * The workflow execution id
     * @type {string}
     * @memberof PostExternalExecuteWorkflow200ResponseBeta
     */
    'workflowExecutionId'?: string;
    /**
     * An error message if any errors occurred
     * @type {string}
     * @memberof PostExternalExecuteWorkflow200ResponseBeta
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface PostExternalExecuteWorkflowRequestBeta
 */
export interface PostExternalExecuteWorkflowRequestBeta {
    /**
     * The input for the workflow
     * @type {object}
     * @memberof PostExternalExecuteWorkflowRequestBeta
     */
    'input'?: object;
}
/**
 * Provides additional details about the pre-approval trigger for this request.
 * @export
 * @interface PreApprovalTriggerDetailsBeta
 */
export interface PreApprovalTriggerDetailsBeta {
    /**
     * Comment left for the pre-approval decision
     * @type {string}
     * @memberof PreApprovalTriggerDetailsBeta
     */
    'comment'?: string;
    /**
     * The reviewer of the pre-approval decision
     * @type {string}
     * @memberof PreApprovalTriggerDetailsBeta
     */
    'reviewer'?: string;
    /**
     * The decision of the pre-approval trigger
     * @type {string}
     * @memberof PreApprovalTriggerDetailsBeta
     */
    'decision'?: PreApprovalTriggerDetailsBetaDecisionEnum;
}

export const PreApprovalTriggerDetailsBetaDecisionEnum = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED'
} as const;

export type PreApprovalTriggerDetailsBetaDecisionEnum = typeof PreApprovalTriggerDetailsBetaDecisionEnum[keyof typeof PreApprovalTriggerDetailsBetaDecisionEnum];

/**
 * Maps an Identity\'s attribute key to a list of preferred notification mediums.
 * @export
 * @interface PreferencesDtoBeta
 */
export interface PreferencesDtoBeta {
    /**
     * The template notification key.
     * @type {string}
     * @memberof PreferencesDtoBeta
     */
    'key'?: string;
    /**
     * List of preferred notification mediums, i.e., the mediums (or method) for which notifications are enabled. More mediums may be added in the future.
     * @type {Array<MediumBeta>}
     * @memberof PreferencesDtoBeta
     */
    'mediums'?: Array<MediumBeta>;
    /**
     * Modified date of preference
     * @type {string}
     * @memberof PreferencesDtoBeta
     */
    'modified'?: string;
}
/**
 * PreviewDataSourceResponse is the response sent by /form-definitions/{formDefinitionID}/data-source endpoint
 * @export
 * @interface PreviewDataSourceResponseBeta
 */
export interface PreviewDataSourceResponseBeta {
    /**
     * Results holds a list of FormElementDataSourceConfigOptions items
     * @type {Array<FormElementDataSourceConfigOptionsBeta>}
     * @memberof PreviewDataSourceResponseBeta
     */
    'results'?: Array<FormElementDataSourceConfigOptionsBeta>;
}
/**
 * 
 * @export
 * @interface ProcessIdentitiesRequestBeta
 */
export interface ProcessIdentitiesRequestBeta {
    /**
     * List of up to 250 identity IDs to process.
     * @type {Array<string>}
     * @memberof ProcessIdentitiesRequestBeta
     */
    'identityIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ProvisioningCompletedAccountRequestsInnerAttributeRequestsInnerBeta
 */
export interface ProvisioningCompletedAccountRequestsInnerAttributeRequestsInnerBeta {
    /**
     * The name of the attribute being provisioned.
     * @type {string}
     * @memberof ProvisioningCompletedAccountRequestsInnerAttributeRequestsInnerBeta
     */
    'attributeName': string;
    /**
     * The value of the attribute being provisioned.
     * @type {string}
     * @memberof ProvisioningCompletedAccountRequestsInnerAttributeRequestsInnerBeta
     */
    'attributeValue'?: string | null;
    /**
     * The operation to handle the attribute.
     * @type {object}
     * @memberof ProvisioningCompletedAccountRequestsInnerAttributeRequestsInnerBeta
     */
    'operation': ProvisioningCompletedAccountRequestsInnerAttributeRequestsInnerBetaOperationEnum;
}

export const ProvisioningCompletedAccountRequestsInnerAttributeRequestsInnerBetaOperationEnum = {
    Add: 'Add',
    Set: 'Set',
    Remove: 'Remove'
} as const;

export type ProvisioningCompletedAccountRequestsInnerAttributeRequestsInnerBetaOperationEnum = typeof ProvisioningCompletedAccountRequestsInnerAttributeRequestsInnerBetaOperationEnum[keyof typeof ProvisioningCompletedAccountRequestsInnerAttributeRequestsInnerBetaOperationEnum];

/**
 * 
 * @export
 * @interface ProvisioningCompletedAccountRequestsInnerBeta
 */
export interface ProvisioningCompletedAccountRequestsInnerBeta {
    /**
     * 
     * @type {ProvisioningCompletedAccountRequestsInnerSourceBeta}
     * @memberof ProvisioningCompletedAccountRequestsInnerBeta
     */
    'source': ProvisioningCompletedAccountRequestsInnerSourceBeta;
    /**
     * The unique idenfier of the account being provisioned.
     * @type {string}
     * @memberof ProvisioningCompletedAccountRequestsInnerBeta
     */
    'accountId'?: string;
    /**
     * The provisioning operation; typically Create, Modify, Enable, Disable, Unlock, or Delete.
     * @type {string}
     * @memberof ProvisioningCompletedAccountRequestsInnerBeta
     */
    'accountOperation': string;
    /**
     * The overall result of the provisioning transaction; this could be success, pending, failed, etc.
     * @type {object}
     * @memberof ProvisioningCompletedAccountRequestsInnerBeta
     */
    'provisioningResult': ProvisioningCompletedAccountRequestsInnerBetaProvisioningResultEnum;
    /**
     * The name of the provisioning channel selected; this could be the same as the source, or could be a Service Desk Integration Module (SDIM).
     * @type {string}
     * @memberof ProvisioningCompletedAccountRequestsInnerBeta
     */
    'provisioningTarget': string;
    /**
     * A reference to a tracking number, if this is sent to a Service Desk Integration Module (SDIM).
     * @type {string}
     * @memberof ProvisioningCompletedAccountRequestsInnerBeta
     */
    'ticketId'?: string | null;
    /**
     * A list of attributes as part of the provisioning transaction.
     * @type {Array<ProvisioningCompletedAccountRequestsInnerAttributeRequestsInnerBeta>}
     * @memberof ProvisioningCompletedAccountRequestsInnerBeta
     */
    'attributeRequests'?: Array<ProvisioningCompletedAccountRequestsInnerAttributeRequestsInnerBeta> | null;
}

export const ProvisioningCompletedAccountRequestsInnerBetaProvisioningResultEnum = {
    Success: 'SUCCESS',
    Pending: 'PENDING',
    Failed: 'FAILED'
} as const;

export type ProvisioningCompletedAccountRequestsInnerBetaProvisioningResultEnum = typeof ProvisioningCompletedAccountRequestsInnerBetaProvisioningResultEnum[keyof typeof ProvisioningCompletedAccountRequestsInnerBetaProvisioningResultEnum];

/**
 * Reference to the source being provisioned against.
 * @export
 * @interface ProvisioningCompletedAccountRequestsInnerSourceBeta
 */
export interface ProvisioningCompletedAccountRequestsInnerSourceBeta {
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof ProvisioningCompletedAccountRequestsInnerSourceBeta
     */
    'id': string;
    /**
     * The type of object that is referenced
     * @type {string}
     * @memberof ProvisioningCompletedAccountRequestsInnerSourceBeta
     */
    'type': ProvisioningCompletedAccountRequestsInnerSourceBetaTypeEnum;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof ProvisioningCompletedAccountRequestsInnerSourceBeta
     */
    'name': string;
}

export const ProvisioningCompletedAccountRequestsInnerSourceBetaTypeEnum = {
    Source: 'SOURCE'
} as const;

export type ProvisioningCompletedAccountRequestsInnerSourceBetaTypeEnum = typeof ProvisioningCompletedAccountRequestsInnerSourceBetaTypeEnum[keyof typeof ProvisioningCompletedAccountRequestsInnerSourceBetaTypeEnum];

/**
 * 
 * @export
 * @interface ProvisioningCompletedBeta
 */
export interface ProvisioningCompletedBeta {
    /**
     * The reference number of the provisioning request. Useful for tracking status in the Account Activity search interface.
     * @type {string}
     * @memberof ProvisioningCompletedBeta
     */
    'trackingNumber': string;
    /**
     * One or more sources that the provisioning transaction(s) were done against.  Sources are comma separated.
     * @type {string}
     * @memberof ProvisioningCompletedBeta
     */
    'sources': string;
    /**
     * Origin of where the provisioning request came from.
     * @type {string}
     * @memberof ProvisioningCompletedBeta
     */
    'action'?: string | null;
    /**
     * A list of any accumulated error messages that occurred during provisioning.
     * @type {Array<string>}
     * @memberof ProvisioningCompletedBeta
     */
    'errors'?: Array<string> | null;
    /**
     * A list of any accumulated warning messages that occurred during provisioning.
     * @type {Array<string>}
     * @memberof ProvisioningCompletedBeta
     */
    'warnings'?: Array<string> | null;
    /**
     * 
     * @type {ProvisioningCompletedRecipientBeta}
     * @memberof ProvisioningCompletedBeta
     */
    'recipient': ProvisioningCompletedRecipientBeta;
    /**
     * 
     * @type {ProvisioningCompletedRequesterBeta}
     * @memberof ProvisioningCompletedBeta
     */
    'requester'?: ProvisioningCompletedRequesterBeta | null;
    /**
     * A list of provisioning instructions to perform on an account-by-account basis.
     * @type {Array<ProvisioningCompletedAccountRequestsInnerBeta>}
     * @memberof ProvisioningCompletedBeta
     */
    'accountRequests': Array<ProvisioningCompletedAccountRequestsInnerBeta>;
}
/**
 * Reference to the identity who is the target of the provisioning request.
 * @export
 * @interface ProvisioningCompletedRecipientBeta
 */
export interface ProvisioningCompletedRecipientBeta {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof ProvisioningCompletedRecipientBeta
     */
    'type': ProvisioningCompletedRecipientBetaTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof ProvisioningCompletedRecipientBeta
     */
    'id': string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof ProvisioningCompletedRecipientBeta
     */
    'name': string;
}

export const ProvisioningCompletedRecipientBetaTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type ProvisioningCompletedRecipientBetaTypeEnum = typeof ProvisioningCompletedRecipientBetaTypeEnum[keyof typeof ProvisioningCompletedRecipientBetaTypeEnum];

/**
 * Reference to the identity (if any) who submitted the provisioning request.
 * @export
 * @interface ProvisioningCompletedRequesterBeta
 */
export interface ProvisioningCompletedRequesterBeta {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof ProvisioningCompletedRequesterBeta
     */
    'type': ProvisioningCompletedRequesterBetaTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof ProvisioningCompletedRequesterBeta
     */
    'id': string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof ProvisioningCompletedRequesterBeta
     */
    'name': string;
}

export const ProvisioningCompletedRequesterBetaTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type ProvisioningCompletedRequesterBetaTypeEnum = typeof ProvisioningCompletedRequesterBetaTypeEnum[keyof typeof ProvisioningCompletedRequesterBetaTypeEnum];

/**
 * Specification of a Service Desk integration provisioning configuration.
 * @export
 * @interface ProvisioningConfigBeta
 */
export interface ProvisioningConfigBeta {
    /**
     * Specifies whether this configuration is used to manage provisioning requests for all sources from the org.  If true, no managedResourceRefs are allowed.
     * @type {boolean}
     * @memberof ProvisioningConfigBeta
     */
    'universalManager'?: boolean;
    /**
     * References to sources for the Service Desk integration template.  May only be specified if universalManager is false.
     * @type {Array<ProvisioningConfigManagedResourceRefsInnerBeta>}
     * @memberof ProvisioningConfigBeta
     */
    'managedResourceRefs'?: Array<ProvisioningConfigManagedResourceRefsInnerBeta>;
    /**
     * 
     * @type {ProvisioningConfigPlanInitializerScriptBeta}
     * @memberof ProvisioningConfigBeta
     */
    'planInitializerScript'?: ProvisioningConfigPlanInitializerScriptBeta;
    /**
     * Name of an attribute that when true disables the saving of ProvisioningRequest objects whenever plans are sent through this integration.
     * @type {boolean}
     * @memberof ProvisioningConfigBeta
     */
    'noProvisioningRequests'?: boolean;
    /**
     * When saving pending requests is enabled, this defines the number of hours the request is allowed to live before it is considered expired and no longer affects plan compilation.
     * @type {number}
     * @memberof ProvisioningConfigBeta
     */
    'provisioningRequestExpiration'?: number;
}
/**
 * 
 * @export
 * @interface ProvisioningConfigManagedResourceRefsInnerBeta
 */
export interface ProvisioningConfigManagedResourceRefsInnerBeta {
    /**
     * The type of object being referenced
     * @type {object}
     * @memberof ProvisioningConfigManagedResourceRefsInnerBeta
     */
    'type'?: ProvisioningConfigManagedResourceRefsInnerBetaTypeEnum;
    /**
     * ID of the source
     * @type {object}
     * @memberof ProvisioningConfigManagedResourceRefsInnerBeta
     */
    'id'?: object;
    /**
     * Human-readable display name of the source
     * @type {object}
     * @memberof ProvisioningConfigManagedResourceRefsInnerBeta
     */
    'name'?: object;
}

export const ProvisioningConfigManagedResourceRefsInnerBetaTypeEnum = {
    Source: 'SOURCE'
} as const;

export type ProvisioningConfigManagedResourceRefsInnerBetaTypeEnum = typeof ProvisioningConfigManagedResourceRefsInnerBetaTypeEnum[keyof typeof ProvisioningConfigManagedResourceRefsInnerBetaTypeEnum];

/**
 * This is a reference to a plan initializer script.
 * @export
 * @interface ProvisioningConfigPlanInitializerScriptBeta
 */
export interface ProvisioningConfigPlanInitializerScriptBeta {
    /**
     * This is a Rule that allows provisioning instruction changes.
     * @type {string}
     * @memberof ProvisioningConfigPlanInitializerScriptBeta
     */
    'source'?: string;
}
/**
 * Defines matching criteria for an Account to be provisioned with a specific Access Profile
 * @export
 * @interface ProvisioningCriteriaLevel1Beta
 */
export interface ProvisioningCriteriaLevel1Beta {
    /**
     * 
     * @type {ProvisioningCriteriaOperationBeta}
     * @memberof ProvisioningCriteriaLevel1Beta
     */
    'operation'?: ProvisioningCriteriaOperationBeta;
    /**
     * Name of the Account attribute to be tested. If **operation** is one of EQUALS, NOT_EQUALS, CONTAINS, or HAS, this field is required. Otherwise, specifying it is an error.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel1Beta
     */
    'attribute'?: string | null;
    /**
     * String value to test the Account attribute w/r/t the specified operation. If the operation is one of EQUALS, NOT_EQUALS, or CONTAINS, this field is required. Otherwise, specifying it is an error. If the Attribute is not String-typed, it will be converted to the appropriate type.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel1Beta
     */
    'value'?: string | null;
    /**
     * Array of child criteria. Required if the operation is AND or OR, otherwise it must be left null. A maximum of three levels of criteria are supported, including leaf nodes.
     * @type {Array<ProvisioningCriteriaLevel2Beta>}
     * @memberof ProvisioningCriteriaLevel1Beta
     */
    'children'?: Array<ProvisioningCriteriaLevel2Beta> | null;
}
/**
 * Defines matching criteria for an Account to be provisioned with a specific Access Profile
 * @export
 * @interface ProvisioningCriteriaLevel2Beta
 */
export interface ProvisioningCriteriaLevel2Beta {
    /**
     * 
     * @type {ProvisioningCriteriaOperationBeta}
     * @memberof ProvisioningCriteriaLevel2Beta
     */
    'operation'?: ProvisioningCriteriaOperationBeta;
    /**
     * Name of the Account attribute to be tested. If **operation** is one of EQUALS, NOT_EQUALS, CONTAINS, or HAS, this field is required. Otherwise, specifying it is an error.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel2Beta
     */
    'attribute'?: string | null;
    /**
     * String value to test the Account attribute w/r/t the specified operation. If the operation is one of EQUALS, NOT_EQUALS, or CONTAINS, this field is required. Otherwise, specifying it is an error. If the Attribute is not String-typed, it will be converted to the appropriate type.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel2Beta
     */
    'value'?: string | null;
    /**
     * Array of child criteria. Required if the operation is AND or OR, otherwise it must be left null. A maximum of three levels of criteria are supported, including leaf nodes.
     * @type {Array<ProvisioningCriteriaLevel3Beta>}
     * @memberof ProvisioningCriteriaLevel2Beta
     */
    'children'?: Array<ProvisioningCriteriaLevel3Beta> | null;
}
/**
 * Defines matching criteria for an Account to be provisioned with a specific Access Profile
 * @export
 * @interface ProvisioningCriteriaLevel3Beta
 */
export interface ProvisioningCriteriaLevel3Beta {
    /**
     * 
     * @type {ProvisioningCriteriaOperationBeta}
     * @memberof ProvisioningCriteriaLevel3Beta
     */
    'operation'?: ProvisioningCriteriaOperationBeta;
    /**
     * Name of the Account attribute to be tested. If **operation** is one of EQUALS, NOT_EQUALS, CONTAINS, or HAS, this field is required. Otherwise, specifying it is an error.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel3Beta
     */
    'attribute'?: string | null;
    /**
     * String value to test the Account attribute w/r/t the specified operation. If the operation is one of EQUALS, NOT_EQUALS, or CONTAINS, this field is required. Otherwise, specifying it is an error. If the Attribute is not String-typed, it will be converted to the appropriate type.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel3Beta
     */
    'value'?: string;
}
/**
 * Supported operations on ProvisioningCriteria
 * @export
 * @enum {string}
 */

export const ProvisioningCriteriaOperationBeta = {
    Equals: 'EQUALS',
    NotEquals: 'NOT_EQUALS',
    Contains: 'CONTAINS',
    Has: 'HAS',
    And: 'AND',
    Or: 'OR'
} as const;

export type ProvisioningCriteriaOperationBeta = typeof ProvisioningCriteriaOperationBeta[keyof typeof ProvisioningCriteriaOperationBeta];


/**
 * Provides additional details about provisioning for this request.
 * @export
 * @interface ProvisioningDetailsBeta
 */
export interface ProvisioningDetailsBeta {
    /**
     * Ordered CSV of sub phase references to objects that contain more information about provisioning. For example, this can contain \"manualWorkItemDetails\" which indicate that there is further information in that object for this phase.
     * @type {string}
     * @memberof ProvisioningDetailsBeta
     */
    'orderedSubPhaseReferences'?: string;
}
/**
 * 
 * @export
 * @interface ProvisioningPolicyDtoBeta
 */
export interface ProvisioningPolicyDtoBeta {
    /**
     * the provisioning policy name
     * @type {string}
     * @memberof ProvisioningPolicyDtoBeta
     */
    'name': string;
    /**
     * the description of the provisioning policy
     * @type {string}
     * @memberof ProvisioningPolicyDtoBeta
     */
    'description'?: string;
    /**
     * 
     * @type {UsageTypeBeta}
     * @memberof ProvisioningPolicyDtoBeta
     */
    'usageType'?: UsageTypeBeta;
    /**
     * 
     * @type {Array<FieldDetailsDtoBeta>}
     * @memberof ProvisioningPolicyDtoBeta
     */
    'fields'?: Array<FieldDetailsDtoBeta>;
}
/**
 * Provisioning state of an account activity item
 * @export
 * @enum {string}
 */

export const ProvisioningStateBeta = {
    Pending: 'PENDING',
    Finished: 'FINISHED',
    Unverifiable: 'UNVERIFIABLE',
    Commited: 'COMMITED',
    Failed: 'FAILED',
    Retry: 'RETRY'
} as const;

export type ProvisioningStateBeta = typeof ProvisioningStateBeta[keyof typeof ProvisioningStateBeta];


/**
 * Used to map an attribute key for an Identity to its display name.
 * @export
 * @interface PublicIdentityAttributeConfigBeta
 */
export interface PublicIdentityAttributeConfigBeta {
    /**
     * the key of the attribute
     * @type {string}
     * @memberof PublicIdentityAttributeConfigBeta
     */
    'key'?: string;
    /**
     * the display name of the attribute
     * @type {string}
     * @memberof PublicIdentityAttributeConfigBeta
     */
    'name'?: string;
}
/**
 * Details of up to 5 Identity attributes that will be publicly accessible for all Identities to anyone in the org
 * @export
 * @interface PublicIdentityConfigBeta
 */
export interface PublicIdentityConfigBeta {
    /**
     * 
     * @type {Array<PublicIdentityAttributeConfigBeta>}
     * @memberof PublicIdentityConfigBeta
     */
    'attributes'?: Array<PublicIdentityAttributeConfigBeta>;
    /**
     * 
     * @type {IdentityReferenceBeta}
     * @memberof PublicIdentityConfigBeta
     */
    'modifiedBy'?: IdentityReferenceBeta | null;
    /**
     * the date/time of the modification
     * @type {string}
     * @memberof PublicIdentityConfigBeta
     */
    'modified'?: string;
}
/**
 * Configuration of maximum number days and interval for checking Service Desk integration queue status
 * @export
 * @interface QueuedCheckConfigDetailsBeta
 */
export interface QueuedCheckConfigDetailsBeta {
    /**
     * interval in minutes between status checks
     * @type {string}
     * @memberof QueuedCheckConfigDetailsBeta
     */
    'provisioningStatusCheckIntervalMinutes': string;
    /**
     * maximum number of days to check
     * @type {string}
     * @memberof QueuedCheckConfigDetailsBeta
     */
    'provisioningMaxStatusCheckDays': string;
}
/**
 * 
 * @export
 * @interface ReassignReferenceBeta
 */
export interface ReassignReferenceBeta {
    /**
     * The ID of item or identity being reassigned.
     * @type {string}
     * @memberof ReassignReferenceBeta
     */
    'id': string;
    /**
     * The type of item or identity being reassigned.
     * @type {string}
     * @memberof ReassignReferenceBeta
     */
    'type': ReassignReferenceBetaTypeEnum;
}

export const ReassignReferenceBetaTypeEnum = {
    TargetSummary: 'TARGET_SUMMARY',
    Item: 'ITEM',
    IdentitySummary: 'IDENTITY_SUMMARY'
} as const;

export type ReassignReferenceBetaTypeEnum = typeof ReassignReferenceBetaTypeEnum[keyof typeof ReassignReferenceBetaTypeEnum];

/**
 * 
 * @export
 * @interface ReassignmentBeta
 */
export interface ReassignmentBeta {
    /**
     * 
     * @type {CertificationReferenceBeta}
     * @memberof ReassignmentBeta
     */
    'from'?: CertificationReferenceBeta;
    /**
     * Comments from the previous reviewer.
     * @type {string}
     * @memberof ReassignmentBeta
     */
    'comment'?: string;
}
/**
 * The approval reassignment type.  * MANUAL_REASSIGNMENT: An approval with this reassignment type has been specifically reassigned by the approval task\'s owner, from their queue to someone else\'s.  * AUTOMATIC_REASSIGNMENT: An approval with this reassignment type has been automatically reassigned from another approver\'s queue, according to that approver\'s reassignment configuration. The approver\'s reassignment configuration may be set up to automatically reassign approval tasks for a defined (or possibly open-ended) period of time. * AUTO_ESCALATION: An approval with this reassignment type has been automatically reassigned from another approver\'s queue, according to the request\'s escalation configuration. For more information about escalation configuration, refer to [Setting Global Reminders and Escalation Policies](https://documentation.sailpoint.com/saas/help/requests/config_emails.html). * SELF_REVIEW_DELEGATION: An approval with this reassignment type has been automatically reassigned by the system to prevent self-review. This helps prevent situations like a requester being tasked with approving their own request. For more information about preventing self-review, refer to [Self-review Prevention](https://documentation.sailpoint.com/saas/help/users/work_reassignment.html#self-review-prevention) and [Preventing Self-approval](https://documentation.sailpoint.com/saas/help/requests/config_ap_roles.html#preventing-self-approval).
 * @export
 * @enum {string}
 */

export const ReassignmentTypeBeta = {
    ManualReassignment: 'MANUAL_REASSIGNMENT',
    AutomaticReassignment: 'AUTOMATIC_REASSIGNMENT',
    AutoEscalation: 'AUTO_ESCALATION',
    SelfReviewDelegation: 'SELF_REVIEW_DELEGATION'
} as const;

export type ReassignmentTypeBeta = typeof ReassignmentTypeBeta[keyof typeof ReassignmentTypeBeta];


/**
 * Enum list containing types of Reassignment that can be found in the evaluate response.
 * @export
 * @enum {string}
 */

export const ReassignmentTypeEnumBeta = {
    ManualReassignment: 'MANUAL_REASSIGNMENT,',
    AutomaticReassignment: 'AUTOMATIC_REASSIGNMENT,',
    AutoEscalation: 'AUTO_ESCALATION,',
    SelfReviewDelegation: 'SELF_REVIEW_DELEGATION'
} as const;

export type ReassignmentTypeEnumBeta = typeof ReassignmentTypeEnumBeta[keyof typeof ReassignmentTypeEnumBeta];


/**
 * 
 * @export
 * @interface RecommendationConfigDtoBeta
 */
export interface RecommendationConfigDtoBeta {
    /**
     * List of identity attributes to use for calculating certification recommendations
     * @type {Array<string>}
     * @memberof RecommendationConfigDtoBeta
     */
    'recommenderFeatures'?: Array<string>;
    /**
     * The percent value that the recommendation calculation must surpass to produce a YES recommendation
     * @type {number}
     * @memberof RecommendationConfigDtoBeta
     */
    'peerGroupPercentageThreshold'?: number;
    /**
     * If true, rulesRecommenderConfig will be refreshed with new programatically selected attribute and threshold values on the next pipeline run
     * @type {boolean}
     * @memberof RecommendationConfigDtoBeta
     */
    'forceRefresh'?: boolean;
}
/**
 * 
 * @export
 * @interface RecommendationRequestBeta
 */
export interface RecommendationRequestBeta {
    /**
     * The identity ID
     * @type {string}
     * @memberof RecommendationRequestBeta
     */
    'identityId'?: string;
    /**
     * 
     * @type {AccessItemRefBeta}
     * @memberof RecommendationRequestBeta
     */
    'item'?: AccessItemRefBeta;
}
/**
 * 
 * @export
 * @interface RecommendationRequestDtoBeta
 */
export interface RecommendationRequestDtoBeta {
    /**
     * 
     * @type {Array<RecommendationRequestBeta>}
     * @memberof RecommendationRequestDtoBeta
     */
    'requests'?: Array<RecommendationRequestBeta>;
    /**
     * Exclude interpretations in the response if \"true\". Return interpretations in the response if this attribute is not specified.
     * @type {boolean}
     * @memberof RecommendationRequestDtoBeta
     */
    'excludeInterpretations'?: boolean;
    /**
     * When set to true, the calling system uses the translated messages for the specified language
     * @type {boolean}
     * @memberof RecommendationRequestDtoBeta
     */
    'includeTranslationMessages'?: boolean;
    /**
     * Returns the recommender calculations if set to true
     * @type {boolean}
     * @memberof RecommendationRequestDtoBeta
     */
    'includeDebugInformation'?: boolean;
    /**
     * When set to true, uses prescribedRulesRecommenderConfig to get identity attributes and peer group threshold instead of standard config.
     * @type {boolean}
     * @memberof RecommendationRequestDtoBeta
     */
    'prescribeMode'?: boolean;
}
/**
 * 
 * @export
 * @interface RecommendationResponseBeta
 */
export interface RecommendationResponseBeta {
    /**
     * 
     * @type {RecommendationRequestBeta}
     * @memberof RecommendationResponseBeta
     */
    'request'?: RecommendationRequestBeta;
    /**
     * The recommendation - YES if the access is recommended, NO if not recommended, MAYBE if there is not enough information to make a recommendation, NOT_FOUND if the identity is not found in the system
     * @type {string}
     * @memberof RecommendationResponseBeta
     */
    'recommendation'?: RecommendationResponseBetaRecommendationEnum;
    /**
     * The list of interpretations explaining the recommendation. The array is empty if includeInterpretations is false or not present in the request. e.g. - [ \"Not approved in the last 6 months.\" ]. Interpretations will be translated using the client\'s locale as found in the Accept-Language header. If a translation for the client\'s locale cannot be found, the US English translation will be returned.
     * @type {Array<string>}
     * @memberof RecommendationResponseBeta
     */
    'interpretations'?: Array<string>;
    /**
     * The list of translation messages, if they have been requested.
     * @type {Array<TranslationMessageBeta>}
     * @memberof RecommendationResponseBeta
     */
    'translationMessages'?: Array<TranslationMessageBeta>;
    /**
     * 
     * @type {RecommenderCalculationsBeta}
     * @memberof RecommendationResponseBeta
     */
    'recommenderCalculations'?: RecommenderCalculationsBeta;
}

export const RecommendationResponseBetaRecommendationEnum = {
    True: 'true',
    False: 'false',
    Maybe: 'MAYBE',
    NotFound: 'NOT_FOUND'
} as const;

export type RecommendationResponseBetaRecommendationEnum = typeof RecommendationResponseBetaRecommendationEnum[keyof typeof RecommendationResponseBetaRecommendationEnum];

/**
 * 
 * @export
 * @interface RecommendationResponseDtoBeta
 */
export interface RecommendationResponseDtoBeta {
    /**
     * 
     * @type {Array<RecommendationResponseBeta>}
     * @memberof RecommendationResponseDtoBeta
     */
    'response'?: Array<RecommendationResponseBeta>;
}
/**
 * 
 * @export
 * @interface RecommenderCalculationsBeta
 */
export interface RecommenderCalculationsBeta {
    /**
     * The ID of the identity
     * @type {string}
     * @memberof RecommenderCalculationsBeta
     */
    'identityId'?: string;
    /**
     * The entitlement ID
     * @type {string}
     * @memberof RecommenderCalculationsBeta
     */
    'entitlementId'?: string;
    /**
     * The actual recommendation
     * @type {string}
     * @memberof RecommenderCalculationsBeta
     */
    'recommendation'?: string;
    /**
     * The overall weighted score
     * @type {number}
     * @memberof RecommenderCalculationsBeta
     */
    'overallWeightedScore'?: number;
    /**
     * The weighted score of each individual feature
     * @type {{ [key: string]: number; }}
     * @memberof RecommenderCalculationsBeta
     */
    'featureWeightedScores'?: { [key: string]: number; };
    /**
     * The configured value against which the overallWeightedScore is compared
     * @type {number}
     * @memberof RecommenderCalculationsBeta
     */
    'threshold'?: number;
    /**
     * The values for your configured features
     * @type {{ [key: string]: RecommenderCalculationsIdentityAttributesValueBeta; }}
     * @memberof RecommenderCalculationsBeta
     */
    'identityAttributes'?: { [key: string]: RecommenderCalculationsIdentityAttributesValueBeta; };
    /**
     * 
     * @type {FeatureValueDtoBeta}
     * @memberof RecommenderCalculationsBeta
     */
    'featureValues'?: FeatureValueDtoBeta;
}
/**
 * 
 * @export
 * @interface RecommenderCalculationsIdentityAttributesValueBeta
 */
export interface RecommenderCalculationsIdentityAttributesValueBeta {
    /**
     * 
     * @type {string}
     * @memberof RecommenderCalculationsIdentityAttributesValueBeta
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface RemediationItemDetailsBeta
 */
export interface RemediationItemDetailsBeta {
    /**
     * The ID of the certification
     * @type {string}
     * @memberof RemediationItemDetailsBeta
     */
    'id'?: string;
    /**
     * The ID of the certification target
     * @type {string}
     * @memberof RemediationItemDetailsBeta
     */
    'targetId'?: string;
    /**
     * The name of the certification target
     * @type {string}
     * @memberof RemediationItemDetailsBeta
     */
    'targetName'?: string;
    /**
     * The display name of the certification target
     * @type {string}
     * @memberof RemediationItemDetailsBeta
     */
    'targetDisplayName'?: string;
    /**
     * The name of the application/source
     * @type {string}
     * @memberof RemediationItemDetailsBeta
     */
    'applicationName'?: string;
    /**
     * The name of the attribute being certified
     * @type {string}
     * @memberof RemediationItemDetailsBeta
     */
    'attributeName'?: string;
    /**
     * The operation of the certification on the attribute
     * @type {string}
     * @memberof RemediationItemDetailsBeta
     */
    'attributeOperation'?: string;
    /**
     * The value of the attribute being certified
     * @type {string}
     * @memberof RemediationItemDetailsBeta
     */
    'attributeValue'?: string;
    /**
     * The native identity of the target
     * @type {string}
     * @memberof RemediationItemDetailsBeta
     */
    'nativeIdentity'?: string;
}
/**
 * 
 * @export
 * @interface RemediationItemsBeta
 */
export interface RemediationItemsBeta {
    /**
     * The ID of the certification
     * @type {string}
     * @memberof RemediationItemsBeta
     */
    'id'?: string;
    /**
     * The ID of the certification target
     * @type {string}
     * @memberof RemediationItemsBeta
     */
    'targetId'?: string;
    /**
     * The name of the certification target
     * @type {string}
     * @memberof RemediationItemsBeta
     */
    'targetName'?: string;
    /**
     * The display name of the certification target
     * @type {string}
     * @memberof RemediationItemsBeta
     */
    'targetDisplayName'?: string;
    /**
     * The name of the application/source
     * @type {string}
     * @memberof RemediationItemsBeta
     */
    'applicationName'?: string;
    /**
     * The name of the attribute being certified
     * @type {string}
     * @memberof RemediationItemsBeta
     */
    'attributeName'?: string;
    /**
     * The operation of the certification on the attribute
     * @type {string}
     * @memberof RemediationItemsBeta
     */
    'attributeOperation'?: string;
    /**
     * The value of the attribute being certified
     * @type {string}
     * @memberof RemediationItemsBeta
     */
    'attributeValue'?: string;
    /**
     * The native identity of the target
     * @type {string}
     * @memberof RemediationItemsBeta
     */
    'nativeIdentity'?: string;
}
/**
 * 
 * @export
 * @interface ReportConfigDTOBeta
 */
export interface ReportConfigDTOBeta {
    /**
     * Name of column in report
     * @type {string}
     * @memberof ReportConfigDTOBeta
     */
    'columnName'?: string;
    /**
     * If true, column is required in all reports, and this entry is immutable. A 400 error will result from any attempt to modify the column\'s definition.
     * @type {boolean}
     * @memberof ReportConfigDTOBeta
     */
    'required'?: boolean;
    /**
     * If true, column is included in the report. A 400 error will be thrown if an attempt is made to set included=false if required==true.
     * @type {boolean}
     * @memberof ReportConfigDTOBeta
     */
    'included'?: boolean;
    /**
     * Relative sort order for the column. Columns will be displayed left-to-right in nondecreasing order.
     * @type {number}
     * @memberof ReportConfigDTOBeta
     */
    'order'?: number;
}
/**
 * 
 * @export
 * @interface ReportResultReferenceAllOfBeta
 */
export interface ReportResultReferenceAllOfBeta {
    /**
     * 
     * @type {string}
     * @memberof ReportResultReferenceAllOfBeta
     */
    'status'?: ReportResultReferenceAllOfBetaStatusEnum;
}

export const ReportResultReferenceAllOfBetaStatusEnum = {
    Success: 'SUCCESS',
    Warning: 'WARNING',
    Error: 'ERROR',
    Terminated: 'TERMINATED',
    TempError: 'TEMP_ERROR',
    Pending: 'PENDING'
} as const;

export type ReportResultReferenceAllOfBetaStatusEnum = typeof ReportResultReferenceAllOfBetaStatusEnum[keyof typeof ReportResultReferenceAllOfBetaStatusEnum];

/**
 * 
 * @export
 * @interface ReportResultReferenceBeta
 */
export interface ReportResultReferenceBeta {
    /**
     * 
     * @type {DtoTypeBeta}
     * @memberof ReportResultReferenceBeta
     */
    'type'?: DtoTypeBeta;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof ReportResultReferenceBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof ReportResultReferenceBeta
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportResultReferenceBeta
     */
    'status'?: ReportResultReferenceBetaStatusEnum;
}

export const ReportResultReferenceBetaStatusEnum = {
    Success: 'SUCCESS',
    Warning: 'WARNING',
    Error: 'ERROR',
    Terminated: 'TERMINATED',
    TempError: 'TEMP_ERROR',
    Pending: 'PENDING'
} as const;

export type ReportResultReferenceBetaStatusEnum = typeof ReportResultReferenceBetaStatusEnum[keyof typeof ReportResultReferenceBetaStatusEnum];

/**
 * type of a Report
 * @export
 * @enum {string}
 */

export const ReportTypeBeta = {
    CampaignCompositionReport: 'CAMPAIGN_COMPOSITION_REPORT',
    CampaignRemediationStatusReport: 'CAMPAIGN_REMEDIATION_STATUS_REPORT',
    CampaignStatusReport: 'CAMPAIGN_STATUS_REPORT',
    CertificationSignoffReport: 'CERTIFICATION_SIGNOFF_REPORT'
} as const;

export type ReportTypeBeta = typeof ReportTypeBeta[keyof typeof ReportTypeBeta];


/**
 * 
 * @export
 * @interface RequestOnBehalfOfConfigBeta
 */
export interface RequestOnBehalfOfConfigBeta {
    /**
     * If anyone can request access for anyone.
     * @type {boolean}
     * @memberof RequestOnBehalfOfConfigBeta
     */
    'allowRequestOnBehalfOfAnyoneByAnyone'?: boolean;
    /**
     * If a manager can request access for his/her direct reports.
     * @type {boolean}
     * @memberof RequestOnBehalfOfConfigBeta
     */
    'allowRequestOnBehalfOfEmployeeByManager'?: boolean;
}
/**
 * 
 * @export
 * @interface RequestabilityBeta
 */
export interface RequestabilityBeta {
    /**
     * Whether the requester of the containing object must provide comments justifying the request
     * @type {boolean}
     * @memberof RequestabilityBeta
     */
    'commentsRequired'?: boolean;
    /**
     * Whether an approver must provide comments when denying the request
     * @type {boolean}
     * @memberof RequestabilityBeta
     */
    'denialCommentsRequired'?: boolean;
    /**
     * List describing the steps in approving the request
     * @type {Array<AccessProfileApprovalSchemeBeta>}
     * @memberof RequestabilityBeta
     */
    'approvalSchemes'?: Array<AccessProfileApprovalSchemeBeta>;
}
/**
 * 
 * @export
 * @interface RequestabilityForRoleBeta
 */
export interface RequestabilityForRoleBeta {
    /**
     * Whether the requester of the containing object must provide comments justifying the request
     * @type {boolean}
     * @memberof RequestabilityForRoleBeta
     */
    'commentsRequired'?: boolean | null;
    /**
     * Whether an approver must provide comments when denying the request
     * @type {boolean}
     * @memberof RequestabilityForRoleBeta
     */
    'denialCommentsRequired'?: boolean | null;
    /**
     * List describing the steps in approving the request
     * @type {Array<ApprovalSchemeForRoleBeta>}
     * @memberof RequestabilityForRoleBeta
     */
    'approvalSchemes'?: Array<ApprovalSchemeForRoleBeta>;
}
/**
 * 
 * @export
 * @interface RequestableObjectBeta
 */
export interface RequestableObjectBeta {
    /**
     * Id of the requestable object itself
     * @type {string}
     * @memberof RequestableObjectBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of the requestable object
     * @type {string}
     * @memberof RequestableObjectBeta
     */
    'name'?: string;
    /**
     * The time when the requestable object was created
     * @type {string}
     * @memberof RequestableObjectBeta
     */
    'created'?: string;
    /**
     * The time when the requestable object was last modified
     * @type {string}
     * @memberof RequestableObjectBeta
     */
    'modified'?: string | null;
    /**
     * Description of the requestable object.
     * @type {string}
     * @memberof RequestableObjectBeta
     */
    'description'?: string;
    /**
     * 
     * @type {RequestableObjectTypeBeta}
     * @memberof RequestableObjectBeta
     */
    'type'?: RequestableObjectTypeBeta;
    /**
     * 
     * @type {RequestableObjectRequestStatusBeta}
     * @memberof RequestableObjectBeta
     */
    'requestStatus'?: RequestableObjectRequestStatusBeta;
    /**
     * If *requestStatus* is *PENDING*, indicates the id of the associated account activity.
     * @type {string}
     * @memberof RequestableObjectBeta
     */
    'identityRequestId'?: string | null;
    /**
     * 
     * @type {IdentityReferenceWithNameAndEmailBeta}
     * @memberof RequestableObjectBeta
     */
    'ownerRef'?: IdentityReferenceWithNameAndEmailBeta | null;
    /**
     * Whether the requester must provide comments when requesting the object.
     * @type {boolean}
     * @memberof RequestableObjectBeta
     */
    'requestCommentsRequired'?: boolean;
}
/**
 * 
 * @export
 * @interface RequestableObjectReferenceBeta
 */
export interface RequestableObjectReferenceBeta {
    /**
     * Id of the object.
     * @type {string}
     * @memberof RequestableObjectReferenceBeta
     */
    'id'?: string;
    /**
     * Name of the object.
     * @type {string}
     * @memberof RequestableObjectReferenceBeta
     */
    'name'?: string;
    /**
     * Description of the object.
     * @type {string}
     * @memberof RequestableObjectReferenceBeta
     */
    'description'?: string;
    /**
     * Type of the object.
     * @type {string}
     * @memberof RequestableObjectReferenceBeta
     */
    'type'?: RequestableObjectReferenceBetaTypeEnum;
}

export const RequestableObjectReferenceBetaTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE',
    Entitlement: 'ENTITLEMENT'
} as const;

export type RequestableObjectReferenceBetaTypeEnum = typeof RequestableObjectReferenceBetaTypeEnum[keyof typeof RequestableObjectReferenceBetaTypeEnum];

/**
 * Status indicating the ability of an access request for the object to be made by or on behalf of the identity specified by *identity-id*. *AVAILABLE* indicates the object is available to request. *PENDING* indicates the object is unavailable because the identity has a pending request in flight. *ASSIGNED* indicates the object is unavailable because the identity already has the indicated role or access profile. If *identity-id* is not specified (allowed only for admin users), then status will be *AVAILABLE* for all results.
 * @export
 * @enum {string}
 */

export const RequestableObjectRequestStatusBeta = {
    Available: 'AVAILABLE',
    Pending: 'PENDING',
    Assigned: 'ASSIGNED'
} as const;

export type RequestableObjectRequestStatusBeta = typeof RequestableObjectRequestStatusBeta[keyof typeof RequestableObjectRequestStatusBeta];


/**
 * The currently supported requestable object types. 
 * @export
 * @enum {string}
 */

export const RequestableObjectTypeBeta = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE'
} as const;

export type RequestableObjectTypeBeta = typeof RequestableObjectTypeBeta[keyof typeof RequestableObjectTypeBeta];


/**
 * 
 * @export
 * @interface RequestedItemStatusBeta
 */
export interface RequestedItemStatusBeta {
    /**
     * Human-readable display name of the item being requested.
     * @type {string}
     * @memberof RequestedItemStatusBeta
     */
    'name'?: string;
    /**
     * Type of requested object.
     * @type {string}
     * @memberof RequestedItemStatusBeta
     */
    'type'?: RequestedItemStatusBetaTypeEnum;
    /**
     * 
     * @type {CancelledRequestDetailsBeta}
     * @memberof RequestedItemStatusBeta
     */
    'cancelledRequestDetails'?: CancelledRequestDetailsBeta;
    /**
     * List of list of localized error messages, if any, encountered during the approval/provisioning process.
     * @type {Array<Array<ErrorMessageDtoBeta>>}
     * @memberof RequestedItemStatusBeta
     */
    'errorMessages'?: Array<Array<ErrorMessageDtoBeta>> | null;
    /**
     * 
     * @type {RequestedItemStatusRequestStateBeta}
     * @memberof RequestedItemStatusBeta
     */
    'state'?: RequestedItemStatusRequestStateBeta;
    /**
     * Approval details for each item.
     * @type {Array<ApprovalStatusDtoBeta>}
     * @memberof RequestedItemStatusBeta
     */
    'approvalDetails'?: Array<ApprovalStatusDtoBeta>;
    /**
     * Manual work items created for provisioning the item.
     * @type {Array<ManualWorkItemDetailsBeta>}
     * @memberof RequestedItemStatusBeta
     */
    'manualWorkItemDetails'?: Array<ManualWorkItemDetailsBeta> | null;
    /**
     * Id of associated account activity item.
     * @type {string}
     * @memberof RequestedItemStatusBeta
     */
    'accountActivityItemId'?: string;
    /**
     * 
     * @type {AccessRequestTypeBeta}
     * @memberof RequestedItemStatusBeta
     */
    'requestType'?: AccessRequestTypeBeta;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof RequestedItemStatusBeta
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof RequestedItemStatusBeta
     */
    'created'?: string;
    /**
     * 
     * @type {BaseReferenceDto1Beta}
     * @memberof RequestedItemStatusBeta
     */
    'requester'?: BaseReferenceDto1Beta;
    /**
     * 
     * @type {BaseReferenceDto1Beta}
     * @memberof RequestedItemStatusBeta
     */
    'requestedFor'?: BaseReferenceDto1Beta;
    /**
     * 
     * @type {CommentDto1Beta}
     * @memberof RequestedItemStatusBeta
     */
    'requesterComment'?: CommentDto1Beta;
    /**
     * 
     * @type {SodViolationContextCheckCompletedBeta}
     * @memberof RequestedItemStatusBeta
     */
    'sodViolationContext'?: SodViolationContextCheckCompletedBeta;
    /**
     * 
     * @type {ProvisioningDetailsBeta}
     * @memberof RequestedItemStatusBeta
     */
    'provisioningDetails'?: ProvisioningDetailsBeta;
    /**
     * 
     * @type {PreApprovalTriggerDetailsBeta}
     * @memberof RequestedItemStatusBeta
     */
    'preApprovalTriggerDetails'?: PreApprovalTriggerDetailsBeta;
    /**
     * A list of Phases that the Access Request has gone through in order, to help determine the status of the request.
     * @type {Array<AccessRequestPhasesBeta>}
     * @memberof RequestedItemStatusBeta
     */
    'accessRequestPhases'?: Array<AccessRequestPhasesBeta>;
    /**
     * Description associated to the requested object.
     * @type {string}
     * @memberof RequestedItemStatusBeta
     */
    'description'?: string;
    /**
     * When the role access is scheduled for removal.
     * @type {string}
     * @memberof RequestedItemStatusBeta
     */
    'removeDate'?: string | null;
    /**
     * True if the request can be canceled.
     * @type {boolean}
     * @memberof RequestedItemStatusBeta
     */
    'cancelable'?: boolean;
    /**
     * This is the account activity id.
     * @type {string}
     * @memberof RequestedItemStatusBeta
     */
    'accessRequestId'?: string;
    /**
     * Arbitrary key-value pairs, if any were included in the corresponding access request
     * @type {{ [key: string]: string; }}
     * @memberof RequestedItemStatusBeta
     */
    'clientMetadata'?: { [key: string]: string; } | null;
}

export const RequestedItemStatusBetaTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE',
    Entitlement: 'ENTITLEMENT'
} as const;

export type RequestedItemStatusBetaTypeEnum = typeof RequestedItemStatusBetaTypeEnum[keyof typeof RequestedItemStatusBetaTypeEnum];

/**
 * Indicates the state of an access request: * EXECUTING: The request is executing, which indicates the system is doing some processing. * REQUEST_COMPLETED: Indicates the request  has been completed. * CANCELLED: The request was cancelled with no user input. * TERMINATED: The request has been terminated before it was able to complete. * PROVISIONING_VERIFICATION_PENDING: The request has finished any approval steps and provisioning is waiting to be verified. * REJECTED: The request was rejected. * PROVISIONING_FAILED: The request has failed to complete. * NOT_ALL_ITEMS_PROVISIONED: One or more of the requested items failed to complete, but there were one or more  successes. * ERROR: An error occurred during request processing.
 * @export
 * @enum {string}
 */

export const RequestedItemStatusRequestStateBeta = {
    Executing: 'EXECUTING',
    RequestCompleted: 'REQUEST_COMPLETED',
    Cancelled: 'CANCELLED',
    Terminated: 'TERMINATED',
    ProvisioningVerificationPending: 'PROVISIONING_VERIFICATION_PENDING',
    Rejected: 'REJECTED',
    ProvisioningFailed: 'PROVISIONING_FAILED',
    NotAllItemsProvisioned: 'NOT_ALL_ITEMS_PROVISIONED',
    Error: 'ERROR'
} as const;

export type RequestedItemStatusRequestStateBeta = typeof RequestedItemStatusRequestStateBeta[keyof typeof RequestedItemStatusRequestStateBeta];


/**
 * 
 * @export
 * @interface ResourceBundleMessageBeta
 */
export interface ResourceBundleMessageBeta {
    /**
     * The key of the message
     * @type {string}
     * @memberof ResourceBundleMessageBeta
     */
    'key'?: string;
    /**
     * The format of the message
     * @type {string}
     * @memberof ResourceBundleMessageBeta
     */
    'format'?: string;
}
/**
 * Representation of the object which is returned from source connectors.
 * @export
 * @interface ResourceObjectBeta
 */
export interface ResourceObjectBeta {
    /**
     * Identifier of the specific instance where this object resides.
     * @type {string}
     * @memberof ResourceObjectBeta
     */
    'instance'?: string;
    /**
     * Native identity of the object in the Source.
     * @type {string}
     * @memberof ResourceObjectBeta
     */
    'identity'?: string;
    /**
     * Universal unique identifier of the object in the Source.
     * @type {string}
     * @memberof ResourceObjectBeta
     */
    'uuid'?: string;
    /**
     * Native identity that the object has previously.
     * @type {string}
     * @memberof ResourceObjectBeta
     */
    'previousIdentity'?: string;
    /**
     * Display name for this object.
     * @type {string}
     * @memberof ResourceObjectBeta
     */
    'name'?: string;
    /**
     * Type of object.
     * @type {string}
     * @memberof ResourceObjectBeta
     */
    'objectType'?: string;
    /**
     * A flag indicating that this is an incomplete object. Used in special cases where the connector has to return account information in several phases and the objects might not have a complete set of all account attributes. The attributes in this object will replace the corresponding attributes in the Link, but no other Link attributes will be changed.
     * @type {boolean}
     * @memberof ResourceObjectBeta
     */
    'incomplete'?: boolean;
    /**
     * A flag indicating that this is an incremental change object. This is similar to incomplete but it also means that the values of any multi-valued attributes in this object should be merged with the existing values in the Link rather than replacing the existing Link value.
     * @type {boolean}
     * @memberof ResourceObjectBeta
     */
    'incremental'?: boolean;
    /**
     * A flag indicating that this object has been deleted. This is set only when doing delta aggregation and the connector supports detection of native deletes.
     * @type {boolean}
     * @memberof ResourceObjectBeta
     */
    'delete'?: boolean;
    /**
     * A flag set indicating that the values in the attributes represent things to remove rather than things to add. Setting this implies incremental. The values which are always for multi-valued attributes are removed from the current values.
     * @type {boolean}
     * @memberof ResourceObjectBeta
     */
    'remove'?: boolean;
    /**
     * A list of attribute names that are not included in this object. This is only used with SMConnector and will only contain \"groups\".
     * @type {Array<string>}
     * @memberof ResourceObjectBeta
     */
    'missing'?: Array<string>;
    /**
     * Attributes of this ResourceObject.
     * @type {object}
     * @memberof ResourceObjectBeta
     */
    'attributes'?: object;
    /**
     * In Aggregation, for sparse object the count for total accounts scanned identities updated is not incremented.
     * @type {boolean}
     * @memberof ResourceObjectBeta
     */
    'finalUpdate'?: boolean;
}
/**
 * Request model for peek resource objects from source connectors.
 * @export
 * @interface ResourceObjectsRequestBeta
 */
export interface ResourceObjectsRequestBeta {
    /**
     * The type of resource objects to iterate over.
     * @type {string}
     * @memberof ResourceObjectsRequestBeta
     */
    'objectType'?: string;
    /**
     * The maximum number of resource objects to iterate over and return.
     * @type {number}
     * @memberof ResourceObjectsRequestBeta
     */
    'maxCount'?: number;
}
/**
 * Response model for peek resource objects from source connectors.
 * @export
 * @interface ResourceObjectsResponseBeta
 */
export interface ResourceObjectsResponseBeta {
    /**
     * ID of the source
     * @type {string}
     * @memberof ResourceObjectsResponseBeta
     */
    'id'?: string;
    /**
     * Name of the source
     * @type {string}
     * @memberof ResourceObjectsResponseBeta
     */
    'name'?: string;
    /**
     * The number of objects that were fetched by the connector.
     * @type {number}
     * @memberof ResourceObjectsResponseBeta
     */
    'objectCount'?: number;
    /**
     * The number of milliseconds spent on the entire request.
     * @type {number}
     * @memberof ResourceObjectsResponseBeta
     */
    'elapsedMillis'?: number;
    /**
     * Fetched objects from the source connector.
     * @type {Array<ResourceObjectBeta>}
     * @memberof ResourceObjectsResponseBeta
     */
    'resourceObjects'?: Array<ResourceObjectBeta>;
}
/**
 * 
 * @export
 * @interface ReviewReassignBeta
 */
export interface ReviewReassignBeta {
    /**
     * 
     * @type {Array<ReassignReferenceBeta>}
     * @memberof ReviewReassignBeta
     */
    'reassign': Array<ReassignReferenceBeta>;
    /**
     * The ID of the identity to which the certification is reassigned
     * @type {string}
     * @memberof ReviewReassignBeta
     */
    'reassignTo': string;
    /**
     * The reason comment for why the reassign was made
     * @type {string}
     * @memberof ReviewReassignBeta
     */
    'reason': string;
}
/**
 * Details of the reviewer for certification.
 * @export
 * @interface ReviewerBeta
 */
export interface ReviewerBeta {
    /**
     * The type of object that the reviewer is.
     * @type {object}
     * @memberof ReviewerBeta
     */
    'type': ReviewerBetaTypeEnum;
    /**
     * The email of the reviewing identity. Only applicable to `IDENTITY`
     * @type {string}
     * @memberof ReviewerBeta
     */
    'email'?: string | null;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof ReviewerBeta
     */
    'id': string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof ReviewerBeta
     */
    'name': string;
}

export const ReviewerBetaTypeEnum = {
    Identity: 'IDENTITY',
    GovernanceGroup: 'GOVERNANCE_GROUP'
} as const;

export type ReviewerBetaTypeEnum = typeof ReviewerBetaTypeEnum[keyof typeof ReviewerBetaTypeEnum];

/**
 * 
 * @export
 * @interface RevocabilityBeta
 */
export interface RevocabilityBeta {
    /**
     * Whether the requester of the containing object must provide comments justifying the request
     * @type {boolean}
     * @memberof RevocabilityBeta
     */
    'commentsRequired'?: boolean | null;
    /**
     * Whether an approver must provide comments when denying the request
     * @type {boolean}
     * @memberof RevocabilityBeta
     */
    'denialCommentsRequired'?: boolean | null;
    /**
     * List describing the steps in approving the revocation request
     * @type {Array<AccessProfileApprovalSchemeBeta>}
     * @memberof RevocabilityBeta
     */
    'approvalSchemes'?: Array<AccessProfileApprovalSchemeBeta>;
}
/**
 * Type which indicates how a particular Identity obtained a particular Role
 * @export
 * @enum {string}
 */

export const RoleAssignmentSourceTypeBeta = {
    AccessRequest: 'ACCESS_REQUEST',
    RoleMembership: 'ROLE_MEMBERSHIP'
} as const;

export type RoleAssignmentSourceTypeBeta = typeof RoleAssignmentSourceTypeBeta[keyof typeof RoleAssignmentSourceTypeBeta];


/**
 * A Role
 * @export
 * @interface RoleBeta
 */
export interface RoleBeta {
    /**
     * The id of the Role. This field must be left null when creating an Role, otherwise a 400 Bad Request error will result.
     * @type {string}
     * @memberof RoleBeta
     */
    'id'?: string;
    /**
     * The human-readable display name of the Role
     * @type {string}
     * @memberof RoleBeta
     */
    'name': string;
    /**
     * Date the Role was created
     * @type {string}
     * @memberof RoleBeta
     */
    'created'?: string;
    /**
     * Date the Role was last modified.
     * @type {string}
     * @memberof RoleBeta
     */
    'modified'?: string;
    /**
     * A human-readable description of the Role
     * @type {string}
     * @memberof RoleBeta
     */
    'description'?: string | null;
    /**
     * 
     * @type {OwnerReferenceBeta}
     * @memberof RoleBeta
     */
    'owner': OwnerReferenceBeta | null;
    /**
     * 
     * @type {Array<AccessProfileRefBeta>}
     * @memberof RoleBeta
     */
    'accessProfiles'?: Array<AccessProfileRefBeta> | null;
    /**
     * 
     * @type {RoleMembershipSelectorBeta}
     * @memberof RoleBeta
     */
    'membership'?: RoleMembershipSelectorBeta | null;
    /**
     * This field is not directly modifiable and is generally expected to be *null*. In very rare instances, some Roles may have been created using membership selection criteria that are no longer fully supported. While these Roles will still work, they should be migrated to STANDARD or IDENTITY_LIST selection criteria. This field exists for informational purposes as an aid to such migration.
     * @type {{ [key: string]: any; }}
     * @memberof RoleBeta
     */
    'legacyMembershipInfo'?: { [key: string]: any; } | null;
    /**
     * Whether the Role is enabled or not.
     * @type {boolean}
     * @memberof RoleBeta
     */
    'enabled'?: boolean;
    /**
     * Whether the Role can be the target of access requests.
     * @type {boolean}
     * @memberof RoleBeta
     */
    'requestable'?: boolean;
    /**
     * 
     * @type {RequestabilityForRoleBeta}
     * @memberof RoleBeta
     */
    'accessRequestConfig'?: RequestabilityForRoleBeta;
    /**
     * 
     * @type {RevocabilityBeta}
     * @memberof RoleBeta
     */
    'revocationRequestConfig'?: RevocabilityBeta;
    /**
     * List of IDs of segments, if any, to which this Role is assigned.
     * @type {Array<string>}
     * @memberof RoleBeta
     */
    'segments'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface RoleBulkDeleteRequestBeta
 */
export interface RoleBulkDeleteRequestBeta {
    /**
     * List of IDs of Roles to be deleted.
     * @type {Array<string>}
     * @memberof RoleBulkDeleteRequestBeta
     */
    'roleIds': Array<string>;
}
/**
 * Refers to a specific Identity attribute, Account attibute, or Entitlement used in Role membership criteria
 * @export
 * @interface RoleCriteriaKeyBeta
 */
export interface RoleCriteriaKeyBeta {
    /**
     * 
     * @type {RoleCriteriaKeyTypeBeta}
     * @memberof RoleCriteriaKeyBeta
     */
    'type': RoleCriteriaKeyTypeBeta;
    /**
     * The name of the attribute or entitlement to which the associated criteria applies.
     * @type {string}
     * @memberof RoleCriteriaKeyBeta
     */
    'property': string;
    /**
     * ID of the Source from which an account attribute or entitlement is drawn. Required if type is ACCOUNT or ENTITLEMENT
     * @type {string}
     * @memberof RoleCriteriaKeyBeta
     */
    'sourceId'?: string | null;
}
/**
 * Indicates whether the associated criteria represents an expression on identity attributes, account attributes, or entitlements, respectively.
 * @export
 * @enum {string}
 */

export const RoleCriteriaKeyTypeBeta = {
    Identity: 'IDENTITY',
    Account: 'ACCOUNT',
    Entitlement: 'ENTITLEMENT'
} as const;

export type RoleCriteriaKeyTypeBeta = typeof RoleCriteriaKeyTypeBeta[keyof typeof RoleCriteriaKeyTypeBeta];


/**
 * Defines STANDARD type Role membership
 * @export
 * @interface RoleCriteriaLevel1Beta
 */
export interface RoleCriteriaLevel1Beta {
    /**
     * 
     * @type {RoleCriteriaOperationBeta}
     * @memberof RoleCriteriaLevel1Beta
     */
    'operation'?: RoleCriteriaOperationBeta;
    /**
     * 
     * @type {RoleCriteriaKeyBeta}
     * @memberof RoleCriteriaLevel1Beta
     */
    'key'?: RoleCriteriaKeyBeta | null;
    /**
     * String value to test the Identity attribute, Account attribute, or Entitlement specified in the key w/r/t the specified operation. If this criteria is a leaf node, that is, if the operation is one of EQUALS, NOT_EQUALS, CONTAINS, STARTS_WITH, or ENDS_WITH, this field is required. Otherwise, specifying it is an error.
     * @type {string}
     * @memberof RoleCriteriaLevel1Beta
     */
    'stringValue'?: string | null;
    /**
     * Array of child criteria. Required if the operation is AND or OR, otherwise it must be left null. A maximum of three levels of criteria are supported, including leaf nodes. Additionally, AND nodes can only be children or OR nodes and vice-versa.
     * @type {Array<RoleCriteriaLevel2Beta>}
     * @memberof RoleCriteriaLevel1Beta
     */
    'children'?: Array<RoleCriteriaLevel2Beta> | null;
}
/**
 * Defines STANDARD type Role membership
 * @export
 * @interface RoleCriteriaLevel2Beta
 */
export interface RoleCriteriaLevel2Beta {
    /**
     * 
     * @type {RoleCriteriaOperationBeta}
     * @memberof RoleCriteriaLevel2Beta
     */
    'operation'?: RoleCriteriaOperationBeta;
    /**
     * 
     * @type {RoleCriteriaKeyBeta}
     * @memberof RoleCriteriaLevel2Beta
     */
    'key'?: RoleCriteriaKeyBeta | null;
    /**
     * String value to test the Identity attribute, Account attribute, or Entitlement specified in the key w/r/t the specified operation. If this criteria is a leaf node, that is, if the operation is one of EQUALS, NOT_EQUALS, CONTAINS, STARTS_WITH, or ENDS_WITH, this field is required. Otherwise, specifying it is an error.
     * @type {string}
     * @memberof RoleCriteriaLevel2Beta
     */
    'stringValue'?: string | null;
    /**
     * Array of child criteria. Required if the operation is AND or OR, otherwise it must be left null. A maximum of three levels of criteria are supported, including leaf nodes. Additionally, AND nodes can only be children or OR nodes and vice-versa.
     * @type {Array<RoleCriteriaLevel3Beta>}
     * @memberof RoleCriteriaLevel2Beta
     */
    'children'?: Array<RoleCriteriaLevel3Beta> | null;
}
/**
 * Defines STANDARD type Role membership
 * @export
 * @interface RoleCriteriaLevel3Beta
 */
export interface RoleCriteriaLevel3Beta {
    /**
     * 
     * @type {RoleCriteriaOperationBeta}
     * @memberof RoleCriteriaLevel3Beta
     */
    'operation'?: RoleCriteriaOperationBeta;
    /**
     * 
     * @type {RoleCriteriaKeyBeta}
     * @memberof RoleCriteriaLevel3Beta
     */
    'key'?: RoleCriteriaKeyBeta | null;
    /**
     * String value to test the Identity attribute, Account attribute, or Entitlement specified in the key w/r/t the specified operation. If this criteria is a leaf node, that is, if the operation is one of EQUALS, NOT_EQUALS, CONTAINS, STARTS_WITH, or ENDS_WITH, this field is required. Otherwise, specifying it is an error.
     * @type {string}
     * @memberof RoleCriteriaLevel3Beta
     */
    'stringValue'?: string;
}
/**
 * An operation
 * @export
 * @enum {string}
 */

export const RoleCriteriaOperationBeta = {
    Equals: 'EQUALS',
    NotEquals: 'NOT_EQUALS',
    Contains: 'CONTAINS',
    StartsWith: 'STARTS_WITH',
    EndsWith: 'ENDS_WITH',
    And: 'AND',
    Or: 'OR'
} as const;

export type RoleCriteriaOperationBeta = typeof RoleCriteriaOperationBeta[keyof typeof RoleCriteriaOperationBeta];


/**
 * A subset of the fields of an Identity which is a member of a Role.
 * @export
 * @interface RoleIdentityBeta
 */
export interface RoleIdentityBeta {
    /**
     * The ID of the Identity
     * @type {string}
     * @memberof RoleIdentityBeta
     */
    'id'?: string;
    /**
     * The alias / username of the Identity
     * @type {string}
     * @memberof RoleIdentityBeta
     */
    'aliasName'?: string;
    /**
     * The human-readable display name of the Identity
     * @type {string}
     * @memberof RoleIdentityBeta
     */
    'name'?: string;
    /**
     * Email address of the Identity
     * @type {string}
     * @memberof RoleIdentityBeta
     */
    'email'?: string;
    /**
     * 
     * @type {RoleAssignmentSourceTypeBeta}
     * @memberof RoleIdentityBeta
     */
    'roleAssignmentSource'?: RoleAssignmentSourceTypeBeta;
}
/**
 * 
 * @export
 * @interface RoleInsightBeta
 */
export interface RoleInsightBeta {
    /**
     * Insight id
     * @type {string}
     * @memberof RoleInsightBeta
     */
    'id'?: string;
    /**
     * Total number of updates for this role
     * @type {number}
     * @memberof RoleInsightBeta
     */
    'numberOfUpdates'?: number;
    /**
     * The date-time insights were last created for this role.
     * @type {string}
     * @memberof RoleInsightBeta
     */
    'createdDate'?: string;
    /**
     * 
     * @type {RoleInsightsRoleBeta}
     * @memberof RoleInsightBeta
     */
    'role'?: RoleInsightsRoleBeta;
    /**
     * 
     * @type {RoleInsightsInsightBeta}
     * @memberof RoleInsightBeta
     */
    'insight'?: RoleInsightsInsightBeta;
}
/**
 * 
 * @export
 * @interface RoleInsightsEntitlementBeta
 */
export interface RoleInsightsEntitlementBeta {
    /**
     * Name of the entitlement
     * @type {string}
     * @memberof RoleInsightsEntitlementBeta
     */
    'name'?: string;
    /**
     * Id of the entitlement
     * @type {string}
     * @memberof RoleInsightsEntitlementBeta
     */
    'id'?: string;
    /**
     * Description for the entitlement
     * @type {string}
     * @memberof RoleInsightsEntitlementBeta
     */
    'description'?: string;
    /**
     * Source or the application for the entitlement
     * @type {string}
     * @memberof RoleInsightsEntitlementBeta
     */
    'source'?: string;
    /**
     * Attribute for the entitlement
     * @type {string}
     * @memberof RoleInsightsEntitlementBeta
     */
    'attribute'?: string;
    /**
     * Attribute value for the entitlement
     * @type {string}
     * @memberof RoleInsightsEntitlementBeta
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface RoleInsightsEntitlementChangesBeta
 */
export interface RoleInsightsEntitlementChangesBeta {
    /**
     * Name of the entitlement
     * @type {string}
     * @memberof RoleInsightsEntitlementChangesBeta
     */
    'name'?: string;
    /**
     * Id of the entitlement
     * @type {string}
     * @memberof RoleInsightsEntitlementChangesBeta
     */
    'id'?: string;
    /**
     * Description for the entitlement
     * @type {string}
     * @memberof RoleInsightsEntitlementChangesBeta
     */
    'description'?: string;
    /**
     * Attribute for the entitlement
     * @type {string}
     * @memberof RoleInsightsEntitlementChangesBeta
     */
    'attribute'?: string;
    /**
     * Attribute value for the entitlement
     * @type {string}
     * @memberof RoleInsightsEntitlementChangesBeta
     */
    'value'?: string;
    /**
     * Source or the application for the entitlement
     * @type {string}
     * @memberof RoleInsightsEntitlementChangesBeta
     */
    'source'?: string;
    /**
     * 
     * @type {RoleInsightsInsightBeta}
     * @memberof RoleInsightsEntitlementChangesBeta
     */
    'insight'?: RoleInsightsInsightBeta;
}
/**
 * 
 * @export
 * @interface RoleInsightsIdentitiesBeta
 */
export interface RoleInsightsIdentitiesBeta {
    /**
     * Id for identity
     * @type {string}
     * @memberof RoleInsightsIdentitiesBeta
     */
    'id'?: string;
    /**
     * Name for identity
     * @type {string}
     * @memberof RoleInsightsIdentitiesBeta
     */
    'name'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RoleInsightsIdentitiesBeta
     */
    'attributes'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface RoleInsightsInsightBeta
 */
export interface RoleInsightsInsightBeta {
    /**
     * The number of identities in this role with the entitlement.
     * @type {string}
     * @memberof RoleInsightsInsightBeta
     */
    'type'?: string;
    /**
     * The number of identities in this role with the entitlement.
     * @type {number}
     * @memberof RoleInsightsInsightBeta
     */
    'identitiesWithAccess'?: number;
    /**
     * The number of identities in this role that do not have the specified entitlement.
     * @type {number}
     * @memberof RoleInsightsInsightBeta
     */
    'identitiesImpacted'?: number;
    /**
     * The total number of identities.
     * @type {number}
     * @memberof RoleInsightsInsightBeta
     */
    'totalNumberOfIdentities'?: number;
}
/**
 * 
 * @export
 * @interface RoleInsightsResponseBeta
 */
export interface RoleInsightsResponseBeta {
    /**
     * Request Id for a role insight generation request
     * @type {string}
     * @memberof RoleInsightsResponseBeta
     */
    'id'?: string;
    /**
     * The date-time role insights request was created.
     * @type {string}
     * @memberof RoleInsightsResponseBeta
     */
    'createdDate'?: string;
    /**
     * The date-time role insights request was completed.
     * @type {string}
     * @memberof RoleInsightsResponseBeta
     */
    'lastGenerated'?: string;
    /**
     * Total number of updates for this request. Starts with 0 and will have correct number when request is COMPLETED.
     * @type {number}
     * @memberof RoleInsightsResponseBeta
     */
    'numberOfUpdates'?: number;
    /**
     * The role IDs that are in this request.
     * @type {Array<string>}
     * @memberof RoleInsightsResponseBeta
     */
    'roleIds'?: Array<string>;
    /**
     * Request status
     * @type {string}
     * @memberof RoleInsightsResponseBeta
     */
    'status'?: RoleInsightsResponseBetaStatusEnum;
}

export const RoleInsightsResponseBetaStatusEnum = {
    Created: 'CREATED',
    InProgress: 'IN PROGRESS',
    Completed: 'COMPLETED',
    Failed: 'FAILED'
} as const;

export type RoleInsightsResponseBetaStatusEnum = typeof RoleInsightsResponseBetaStatusEnum[keyof typeof RoleInsightsResponseBetaStatusEnum];

/**
 * 
 * @export
 * @interface RoleInsightsRoleBeta
 */
export interface RoleInsightsRoleBeta {
    /**
     * Role name
     * @type {string}
     * @memberof RoleInsightsRoleBeta
     */
    'name'?: string;
    /**
     * Role id
     * @type {string}
     * @memberof RoleInsightsRoleBeta
     */
    'id'?: string;
    /**
     * Role description
     * @type {string}
     * @memberof RoleInsightsRoleBeta
     */
    'description'?: string;
    /**
     * Role owner name
     * @type {string}
     * @memberof RoleInsightsRoleBeta
     */
    'ownerName'?: string;
    /**
     * Role owner id
     * @type {string}
     * @memberof RoleInsightsRoleBeta
     */
    'ownerId'?: string;
}
/**
 * 
 * @export
 * @interface RoleInsightsSummaryBeta
 */
export interface RoleInsightsSummaryBeta {
    /**
     * Total number of roles with updates
     * @type {number}
     * @memberof RoleInsightsSummaryBeta
     */
    'numberOfUpdates'?: number;
    /**
     * The date-time role insights were last found.
     * @type {string}
     * @memberof RoleInsightsSummaryBeta
     */
    'lastGenerated'?: string;
    /**
     * The number of entitlements included in roles (vs free radicals).
     * @type {number}
     * @memberof RoleInsightsSummaryBeta
     */
    'entitlementsIncludedInRoles'?: number;
    /**
     * The total number of entitlements.
     * @type {number}
     * @memberof RoleInsightsSummaryBeta
     */
    'totalNumberOfEntitlements'?: number;
    /**
     * The number of identities in roles vs. identities with just entitlements and not in roles.
     * @type {number}
     * @memberof RoleInsightsSummaryBeta
     */
    'identitiesWithAccessViaRoles'?: number;
    /**
     * The total number of identities.
     * @type {number}
     * @memberof RoleInsightsSummaryBeta
     */
    'totalNumberOfIdentities'?: number;
}
/**
 * A reference to an Identity in an IDENTITY_LIST role membership criteria.
 * @export
 * @interface RoleMembershipIdentityBeta
 */
export interface RoleMembershipIdentityBeta {
    /**
     * 
     * @type {DtoTypeBeta}
     * @memberof RoleMembershipIdentityBeta
     */
    'type'?: DtoTypeBeta;
    /**
     * Identity id
     * @type {string}
     * @memberof RoleMembershipIdentityBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of the Identity.
     * @type {string}
     * @memberof RoleMembershipIdentityBeta
     */
    'name'?: string | null;
    /**
     * User name of the Identity
     * @type {string}
     * @memberof RoleMembershipIdentityBeta
     */
    'aliasName'?: string | null;
}
/**
 * When present, specifies that the Role is to be granted to Identities which either satisfy specific criteria or which are members of a given list of Identities.
 * @export
 * @interface RoleMembershipSelectorBeta
 */
export interface RoleMembershipSelectorBeta {
    /**
     * 
     * @type {RoleMembershipSelectorTypeBeta}
     * @memberof RoleMembershipSelectorBeta
     */
    'type'?: RoleMembershipSelectorTypeBeta;
    /**
     * 
     * @type {RoleCriteriaLevel1Beta}
     * @memberof RoleMembershipSelectorBeta
     */
    'criteria'?: RoleCriteriaLevel1Beta | null;
    /**
     * Defines role membership as being exclusive to the specified Identities, when type is IDENTITY_LIST.
     * @type {Array<RoleMembershipIdentityBeta>}
     * @memberof RoleMembershipSelectorBeta
     */
    'identities'?: Array<RoleMembershipIdentityBeta> | null;
}
/**
 * This enum characterizes the type of a Role\'s membership selector. Only the following two are fully supported:  STANDARD: Indicates that Role membership is defined in terms of a criteria expression  IDENTITY_LIST: Indicates that Role membership is conferred on the specific identities listed
 * @export
 * @enum {string}
 */

export const RoleMembershipSelectorTypeBeta = {
    Standard: 'STANDARD',
    IdentityList: 'IDENTITY_LIST'
} as const;

export type RoleMembershipSelectorTypeBeta = typeof RoleMembershipSelectorTypeBeta[keyof typeof RoleMembershipSelectorTypeBeta];


/**
 * 
 * @export
 * @interface RoleMiningEntitlementBeta
 */
export interface RoleMiningEntitlementBeta {
    /**
     * 
     * @type {RoleMiningEntitlementRefBeta}
     * @memberof RoleMiningEntitlementBeta
     */
    'entitlementRef'?: RoleMiningEntitlementRefBeta;
    /**
     * Name of the entitlement
     * @type {string}
     * @memberof RoleMiningEntitlementBeta
     */
    'name'?: string;
    /**
     * Application name of the entitlement
     * @type {string}
     * @memberof RoleMiningEntitlementBeta
     */
    'applicationName'?: string;
    /**
     * The number of identities with this entitlement in a role.
     * @type {number}
     * @memberof RoleMiningEntitlementBeta
     */
    'identityCount'?: number;
    /**
     * The % popularity of this entitlement in a role.
     * @type {number}
     * @memberof RoleMiningEntitlementBeta
     */
    'popularity'?: number;
    /**
     * TThe % popularity of this entitlement in the org.
     * @type {number}
     * @memberof RoleMiningEntitlementBeta
     */
    'popularityInOrg'?: number;
}
/**
 * 
 * @export
 * @interface RoleMiningEntitlementRefBeta
 */
export interface RoleMiningEntitlementRefBeta {
    /**
     * Id of the entitlement
     * @type {string}
     * @memberof RoleMiningEntitlementRefBeta
     */
    'id'?: string;
    /**
     * Name of the entitlement
     * @type {string}
     * @memberof RoleMiningEntitlementRefBeta
     */
    'name'?: string;
    /**
     * Description forthe entitlement
     * @type {string}
     * @memberof RoleMiningEntitlementRefBeta
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface RoleMiningIdentityBeta
 */
export interface RoleMiningIdentityBeta {
    /**
     * Id of the identity
     * @type {string}
     * @memberof RoleMiningIdentityBeta
     */
    'id'?: string;
    /**
     * Name of the identity
     * @type {string}
     * @memberof RoleMiningIdentityBeta
     */
    'name'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RoleMiningIdentityBeta
     */
    'attributes'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface RoleMiningIdentityDistributionBeta
 */
export interface RoleMiningIdentityDistributionBeta {
    /**
     * Id of the potential role
     * @type {string}
     * @memberof RoleMiningIdentityDistributionBeta
     */
    'attributeName'?: string;
    /**
     * 
     * @type {Array<{ [key: string]: string; }>}
     * @memberof RoleMiningIdentityDistributionBeta
     */
    'distribution'?: Array<{ [key: string]: string; }>;
}
/**
 * 
 * @export
 * @interface RoleMiningPotentialRoleApplicationBeta
 */
export interface RoleMiningPotentialRoleApplicationBeta {
    /**
     * Id of the potential role
     * @type {string}
     * @memberof RoleMiningPotentialRoleApplicationBeta
     */
    'id'?: string;
    /**
     * Name of the potential role
     * @type {string}
     * @memberof RoleMiningPotentialRoleApplicationBeta
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface RoleMiningPotentialRoleBeta
 */
export interface RoleMiningPotentialRoleBeta {
    /**
     * 
     * @type {EntityCreatedByDTOBeta}
     * @memberof RoleMiningPotentialRoleBeta
     */
    'createdBy'?: EntityCreatedByDTOBeta;
    /**
     * The density of a potential role.
     * @type {number}
     * @memberof RoleMiningPotentialRoleBeta
     */
    'density'?: number;
    /**
     * The description of a potential role.
     * @type {string}
     * @memberof RoleMiningPotentialRoleBeta
     */
    'description'?: string;
    /**
     * The number of entitlements in a potential role.
     * @type {number}
     * @memberof RoleMiningPotentialRoleBeta
     */
    'entitlementCount'?: number;
    /**
     * The list of entitlement ids to be excluded.
     * @type {Array<string>}
     * @memberof RoleMiningPotentialRoleBeta
     */
    'excludedEntitlements'?: Array<string>;
    /**
     * The freshness of a potential role.
     * @type {number}
     * @memberof RoleMiningPotentialRoleBeta
     */
    'freshness'?: number;
    /**
     * The number of identities in a potential role.
     * @type {number}
     * @memberof RoleMiningPotentialRoleBeta
     */
    'identityCount'?: number;
    /**
     * Identity attribute distribution.
     * @type {Array<RoleMiningIdentityDistributionBeta>}
     * @memberof RoleMiningPotentialRoleBeta
     */
    'identityDistribution'?: Array<RoleMiningIdentityDistributionBeta>;
    /**
     * The list of ids in a potential role.
     * @type {Array<string>}
     * @memberof RoleMiningPotentialRoleBeta
     */
    'identityIds'?: Array<string>;
    /**
     * Name of the potential role.
     * @type {string}
     * @memberof RoleMiningPotentialRoleBeta
     */
    'name'?: string;
    /**
     * 
     * @type {RoleMiningPotentialRoleProvisionStateBeta}
     * @memberof RoleMiningPotentialRoleBeta
     */
    'provisionState'?: RoleMiningPotentialRoleProvisionStateBeta;
    /**
     * The quality of a potential role.
     * @type {number}
     * @memberof RoleMiningPotentialRoleBeta
     */
    'quality'?: number;
    /**
     * The roleId of a potential role.
     * @type {string}
     * @memberof RoleMiningPotentialRoleBeta
     */
    'roleId'?: string;
    /**
     * The potential role\'s saved status.
     * @type {boolean}
     * @memberof RoleMiningPotentialRoleBeta
     */
    'saved'?: boolean;
    /**
     * 
     * @type {RoleMiningSessionParametersDtoBeta}
     * @memberof RoleMiningPotentialRoleBeta
     */
    'session'?: RoleMiningSessionParametersDtoBeta;
    /**
     * 
     * @type {RoleMiningRoleTypeBeta}
     * @memberof RoleMiningPotentialRoleBeta
     */
    'type'?: RoleMiningRoleTypeBeta;
}
/**
 * 
 * @export
 * @interface RoleMiningPotentialRoleEditEntitlementsBeta
 */
export interface RoleMiningPotentialRoleEditEntitlementsBeta {
    /**
     * The list of entitlement ids to be edited
     * @type {Array<string>}
     * @memberof RoleMiningPotentialRoleEditEntitlementsBeta
     */
    'ids'?: Array<string>;
    /**
     * If true, add ids to be exclusion list. If false, remove ids from the exclusion list.
     * @type {boolean}
     * @memberof RoleMiningPotentialRoleEditEntitlementsBeta
     */
    'exclude'?: boolean;
}
/**
 * 
 * @export
 * @interface RoleMiningPotentialRoleExportRequestBeta
 */
export interface RoleMiningPotentialRoleExportRequestBeta {
    /**
     * The minimum popularity among identities in the role which an entitlement must have to be included in the report
     * @type {number}
     * @memberof RoleMiningPotentialRoleExportRequestBeta
     */
    'minEntitlementPopularity'?: number;
    /**
     * If false, do not include entitlements that are highly popular among the entire orginization
     * @type {boolean}
     * @memberof RoleMiningPotentialRoleExportRequestBeta
     */
    'includeCommonAccess'?: boolean;
}
/**
 * 
 * @export
 * @interface RoleMiningPotentialRoleExportResponseAllOfBeta
 */
export interface RoleMiningPotentialRoleExportResponseAllOfBeta {
    /**
     * ID used to reference this export
     * @type {string}
     * @memberof RoleMiningPotentialRoleExportResponseAllOfBeta
     */
    'exportId'?: string;
    /**
     * 
     * @type {RoleMiningPotentialRoleExportStateBeta}
     * @memberof RoleMiningPotentialRoleExportResponseAllOfBeta
     */
    'status'?: RoleMiningPotentialRoleExportStateBeta;
}
/**
 * 
 * @export
 * @interface RoleMiningPotentialRoleExportResponseBeta
 */
export interface RoleMiningPotentialRoleExportResponseBeta {
    /**
     * The minimum popularity among identities in the role which an entitlement must have to be included in the report
     * @type {number}
     * @memberof RoleMiningPotentialRoleExportResponseBeta
     */
    'minEntitlementPopularity'?: number;
    /**
     * If false, do not include entitlements that are highly popular among the entire orginization
     * @type {boolean}
     * @memberof RoleMiningPotentialRoleExportResponseBeta
     */
    'includeCommonAccess'?: boolean;
    /**
     * ID used to reference this export
     * @type {string}
     * @memberof RoleMiningPotentialRoleExportResponseBeta
     */
    'exportId'?: string;
    /**
     * 
     * @type {RoleMiningPotentialRoleExportStateBeta}
     * @memberof RoleMiningPotentialRoleExportResponseBeta
     */
    'status'?: RoleMiningPotentialRoleExportStateBeta;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RoleMiningPotentialRoleExportStateBeta = {
    Queued: 'QUEUED',
    InProgress: 'IN_PROGRESS',
    Success: 'SUCCESS',
    Error: 'ERROR'
} as const;

export type RoleMiningPotentialRoleExportStateBeta = typeof RoleMiningPotentialRoleExportStateBeta[keyof typeof RoleMiningPotentialRoleExportStateBeta];


/**
 * 
 * @export
 * @interface RoleMiningPotentialRoleProvisionRequestBeta
 */
export interface RoleMiningPotentialRoleProvisionRequestBeta {
    /**
     * Name of the new role being created
     * @type {string}
     * @memberof RoleMiningPotentialRoleProvisionRequestBeta
     */
    'roleName'?: string;
    /**
     * Short description of the new role being created
     * @type {string}
     * @memberof RoleMiningPotentialRoleProvisionRequestBeta
     */
    'roleDescription'?: string;
    /**
     * ID of the identity that will own this role
     * @type {string}
     * @memberof RoleMiningPotentialRoleProvisionRequestBeta
     */
    'ownerId'?: string;
}
/**
 * Provision state
 * @export
 * @enum {string}
 */

export const RoleMiningPotentialRoleProvisionStateBeta = {
    Potential: 'POTENTIAL',
    Pending: 'PENDING',
    Complete: 'COMPLETE',
    Failed: 'FAILED'
} as const;

export type RoleMiningPotentialRoleProvisionStateBeta = typeof RoleMiningPotentialRoleProvisionStateBeta[keyof typeof RoleMiningPotentialRoleProvisionStateBeta];


/**
 * 
 * @export
 * @interface RoleMiningPotentialRoleRefBeta
 */
export interface RoleMiningPotentialRoleRefBeta {
    /**
     * Id of the potential role
     * @type {string}
     * @memberof RoleMiningPotentialRoleRefBeta
     */
    'id'?: string;
    /**
     * Name of the potential role
     * @type {string}
     * @memberof RoleMiningPotentialRoleRefBeta
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface RoleMiningPotentialRoleSummaryBeta
 */
export interface RoleMiningPotentialRoleSummaryBeta {
    /**
     * 
     * @type {RoleMiningPotentialRoleRefBeta}
     * @memberof RoleMiningPotentialRoleSummaryBeta
     */
    'potentialRoleRef'?: RoleMiningPotentialRoleRefBeta;
    /**
     * The number of identities in a potential role.
     * @type {number}
     * @memberof RoleMiningPotentialRoleSummaryBeta
     */
    'identityCount'?: number;
    /**
     * The number of entitlements in a potential role.
     * @type {number}
     * @memberof RoleMiningPotentialRoleSummaryBeta
     */
    'entitlementCount'?: number;
    /**
     * The status for this identity group which can be \"REQUESTED\" or \"OBTAINED\"
     * @type {string}
     * @memberof RoleMiningPotentialRoleSummaryBeta
     */
    'identityGroupStatus'?: string;
    /**
     * 
     * @type {RoleMiningPotentialRoleProvisionStateBeta}
     * @memberof RoleMiningPotentialRoleSummaryBeta
     */
    'provisionState'?: RoleMiningPotentialRoleProvisionStateBeta;
    /**
     * ID of the provisioned role in IIQ or IDN.  Null if this potential role has not been provisioned.
     * @type {string}
     * @memberof RoleMiningPotentialRoleSummaryBeta
     */
    'roleId'?: string;
    /**
     * The density metric (0-100) of this potential role. Higher density values indicate higher similarity amongst the identities.
     * @type {number}
     * @memberof RoleMiningPotentialRoleSummaryBeta
     */
    'density'?: number;
    /**
     * The freshness metric (0-100) of this potential role. Higher freshness values indicate this potential role is more distinctive compared to existing roles.
     * @type {number}
     * @memberof RoleMiningPotentialRoleSummaryBeta
     */
    'freshness'?: number;
    /**
     * The quality metric (0-100) of this potential role. Higher quality values indicate this potential role has high density and freshness.
     * @type {number}
     * @memberof RoleMiningPotentialRoleSummaryBeta
     */
    'quality'?: number;
}
/**
 * Role type
 * @export
 * @enum {string}
 */

export const RoleMiningRoleTypeBeta = {
    Specialized: 'SPECIALIZED',
    Common: 'COMMON'
} as const;

export type RoleMiningRoleTypeBeta = typeof RoleMiningRoleTypeBeta[keyof typeof RoleMiningRoleTypeBeta];


/**
 * 
 * @export
 * @interface RoleMiningSessionDtoBeta
 */
export interface RoleMiningSessionDtoBeta {
    /**
     * 
     * @type {RoleMiningSessionScopeBeta}
     * @memberof RoleMiningSessionDtoBeta
     */
    'scope'?: RoleMiningSessionScopeBeta;
    /**
     * The prune threshold to be used or null to calculate prescribedPruneThreshold
     * @type {number}
     * @memberof RoleMiningSessionDtoBeta
     */
    'pruneThreshold'?: number;
    /**
     * The calculated prescribedPruneThreshold
     * @type {number}
     * @memberof RoleMiningSessionDtoBeta
     */
    'prescribedPruneThreshold'?: number;
    /**
     * Minimum number of identities in a potential role
     * @type {number}
     * @memberof RoleMiningSessionDtoBeta
     */
    'minNumIdentitiesInPotentialRole'?: number;
    /**
     * Number of potential roles
     * @type {number}
     * @memberof RoleMiningSessionDtoBeta
     */
    'potentialRoleCount'?: number;
    /**
     * Number of potential roles ready
     * @type {number}
     * @memberof RoleMiningSessionDtoBeta
     */
    'potentialRolesReadyCount'?: number;
    /**
     * 
     * @type {RoleMiningSessionStatusBeta}
     * @memberof RoleMiningSessionDtoBeta
     */
    'status'?: RoleMiningSessionStatusBeta;
    /**
     * 
     * @type {RoleMiningRoleTypeBeta}
     * @memberof RoleMiningSessionDtoBeta
     */
    'type'?: RoleMiningRoleTypeBeta;
    /**
     * The id of the user who will receive an email about the role mining session
     * @type {string}
     * @memberof RoleMiningSessionDtoBeta
     */
    'emailRecipientId'?: string;
    /**
     * 
     * @type {EntityCreatedByDTOBeta}
     * @memberof RoleMiningSessionDtoBeta
     */
    'createdBy'?: EntityCreatedByDTOBeta;
    /**
     * Number of identities in the population which meet the search criteria or identity list provided
     * @type {number}
     * @memberof RoleMiningSessionDtoBeta
     */
    'identityCount'?: number;
    /**
     * The session\'s saved status
     * @type {boolean}
     * @memberof RoleMiningSessionDtoBeta
     */
    'saved'?: boolean;
    /**
     * The session\'s saved name
     * @type {string}
     * @memberof RoleMiningSessionDtoBeta
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface RoleMiningSessionParametersDtoBeta
 */
export interface RoleMiningSessionParametersDtoBeta {
    /**
     * Minimum number of identities in a potential role
     * @type {number}
     * @memberof RoleMiningSessionParametersDtoBeta
     */
    'minNumIdentitiesInPotentialRole'?: number;
    /**
     * The session\'s saved name
     * @type {string}
     * @memberof RoleMiningSessionParametersDtoBeta
     */
    'name'?: string;
    /**
     * The prune threshold to be used or null to calculate prescribedPruneThreshold
     * @type {number}
     * @memberof RoleMiningSessionParametersDtoBeta
     */
    'pruneThreshold'?: number;
    /**
     * The session\'s saved status
     * @type {boolean}
     * @memberof RoleMiningSessionParametersDtoBeta
     */
    'saved'?: boolean;
    /**
     * 
     * @type {RoleMiningSessionScopeBeta}
     * @memberof RoleMiningSessionParametersDtoBeta
     */
    'scope'?: RoleMiningSessionScopeBeta;
    /**
     * 
     * @type {RoleMiningRoleTypeBeta}
     * @memberof RoleMiningSessionParametersDtoBeta
     */
    'type'?: RoleMiningRoleTypeBeta;
}
/**
 * 
 * @export
 * @interface RoleMiningSessionResponseBeta
 */
export interface RoleMiningSessionResponseBeta {
    /**
     * 
     * @type {RoleMiningSessionScopeBeta}
     * @memberof RoleMiningSessionResponseBeta
     */
    'scope'?: RoleMiningSessionScopeBeta;
    /**
     * Minimum number of identities in a potential role
     * @type {number}
     * @memberof RoleMiningSessionResponseBeta
     */
    'minNumIdentitiesInPotentialRole'?: number;
    /**
     * The computed (or prescribed) prune threshold for this session
     * @type {number}
     * @memberof RoleMiningSessionResponseBeta
     */
    'prescribedPruneThreshold'?: number;
    /**
     * The prune threshold to be used for this role mining session
     * @type {number}
     * @memberof RoleMiningSessionResponseBeta
     */
    'pruneThreshold'?: number;
    /**
     * The number of potential roles
     * @type {number}
     * @memberof RoleMiningSessionResponseBeta
     */
    'potentialRoleCount'?: number;
    /**
     * The number of potential roles which have completed processing
     * @type {number}
     * @memberof RoleMiningSessionResponseBeta
     */
    'potentialRolesReadyCount'?: number;
    /**
     * 
     * @type {RoleMiningSessionStatusBeta}
     * @memberof RoleMiningSessionResponseBeta
     */
    'status'?: RoleMiningSessionStatusBeta;
    /**
     * Session Id for this role mining session
     * @type {string}
     * @memberof RoleMiningSessionResponseBeta
     */
    'id'?: string;
    /**
     * The date-time when this role mining session was created.
     * @type {string}
     * @memberof RoleMiningSessionResponseBeta
     */
    'createdDate'?: string;
    /**
     * The date-time when this role mining session was completed.
     * @type {string}
     * @memberof RoleMiningSessionResponseBeta
     */
    'modifiedDate'?: string;
    /**
     * 
     * @type {RoleMiningRoleTypeBeta}
     * @memberof RoleMiningSessionResponseBeta
     */
    'type'?: RoleMiningRoleTypeBeta;
}
/**
 * 
 * @export
 * @interface RoleMiningSessionScopeBeta
 */
export interface RoleMiningSessionScopeBeta {
    /**
     * The list of identities for this role mining session.
     * @type {Array<string>}
     * @memberof RoleMiningSessionScopeBeta
     */
    'identityIds'?: Array<string>;
    /**
     * The \"search\" criteria that produces the list of identities for this role mining session.
     * @type {string}
     * @memberof RoleMiningSessionScopeBeta
     */
    'criteria'?: string;
    /**
     * The filter criteria for this role mining session.
     * @type {Array<object>}
     * @memberof RoleMiningSessionScopeBeta
     */
    'attributeFilterCriteria'?: Array<object>;
}
/**
 * 
 * @export
 * @interface RoleMiningSessionStatusBeta
 */
export interface RoleMiningSessionStatusBeta {
    /**
     * The role mining session status. Can be one of these states - CREATED|UPDATED|IDENTITIES_OBTAINED|PRUNE_THRESHOLD_OBTAINED|POTENTIAL_ROLES_PROCESSING|POTENTIAL_ROLES_CREATED
     * @type {string}
     * @memberof RoleMiningSessionStatusBeta
     */
    'state'?: string;
}
/**
 * 
 * @export
 * @interface SavedSearchCompleteBeta
 */
export interface SavedSearchCompleteBeta {
    /**
     * A name for the report file.
     * @type {string}
     * @memberof SavedSearchCompleteBeta
     */
    'fileName': string;
    /**
     * The email address of the identity that owns the saved search.
     * @type {string}
     * @memberof SavedSearchCompleteBeta
     */
    'ownerEmail': string;
    /**
     * The name of the identity that owns the saved search.
     * @type {string}
     * @memberof SavedSearchCompleteBeta
     */
    'ownerName': string;
    /**
     * The search query that was used to generate the report.
     * @type {string}
     * @memberof SavedSearchCompleteBeta
     */
    'query': string;
    /**
     * The name of the saved search.
     * @type {string}
     * @memberof SavedSearchCompleteBeta
     */
    'searchName': string;
    /**
     * 
     * @type {SavedSearchCompleteSearchResultsBeta}
     * @memberof SavedSearchCompleteBeta
     */
    'searchResults': SavedSearchCompleteSearchResultsBeta;
    /**
     * The Amazon S3 URL to download the report from.
     * @type {string}
     * @memberof SavedSearchCompleteBeta
     */
    'signedS3Url': string;
}
/**
 * A table of accounts that match the search criteria.
 * @export
 * @interface SavedSearchCompleteSearchResultsAccountBeta
 */
export interface SavedSearchCompleteSearchResultsAccountBeta {
    /**
     * The number of rows in the table.
     * @type {string}
     * @memberof SavedSearchCompleteSearchResultsAccountBeta
     */
    'count': string;
    /**
     * The type of object represented in the table.
     * @type {string}
     * @memberof SavedSearchCompleteSearchResultsAccountBeta
     */
    'noun': string;
    /**
     * A sample of the data in the table.
     * @type {Array<Array<string>>}
     * @memberof SavedSearchCompleteSearchResultsAccountBeta
     */
    'preview': Array<Array<string>>;
}
/**
 * A preview of the search results for each object type. This includes a count as well as headers, and the first several rows of data, per object type.
 * @export
 * @interface SavedSearchCompleteSearchResultsBeta
 */
export interface SavedSearchCompleteSearchResultsBeta {
    /**
     * 
     * @type {SavedSearchCompleteSearchResultsAccountBeta}
     * @memberof SavedSearchCompleteSearchResultsBeta
     */
    'Account'?: SavedSearchCompleteSearchResultsAccountBeta | null;
    /**
     * 
     * @type {SavedSearchCompleteSearchResultsEntitlementBeta}
     * @memberof SavedSearchCompleteSearchResultsBeta
     */
    'Entitlement'?: SavedSearchCompleteSearchResultsEntitlementBeta | null;
    /**
     * 
     * @type {SavedSearchCompleteSearchResultsIdentityBeta}
     * @memberof SavedSearchCompleteSearchResultsBeta
     */
    'Identity'?: SavedSearchCompleteSearchResultsIdentityBeta | null;
}
/**
 * A table of entitlements that match the search criteria.
 * @export
 * @interface SavedSearchCompleteSearchResultsEntitlementBeta
 */
export interface SavedSearchCompleteSearchResultsEntitlementBeta {
    /**
     * The number of rows in the table.
     * @type {string}
     * @memberof SavedSearchCompleteSearchResultsEntitlementBeta
     */
    'count': string;
    /**
     * The type of object represented in the table.
     * @type {string}
     * @memberof SavedSearchCompleteSearchResultsEntitlementBeta
     */
    'noun': string;
    /**
     * A sample of the data in the table.
     * @type {Array<Array<string>>}
     * @memberof SavedSearchCompleteSearchResultsEntitlementBeta
     */
    'preview': Array<Array<string>>;
}
/**
 * A table of identities that match the search criteria.
 * @export
 * @interface SavedSearchCompleteSearchResultsIdentityBeta
 */
export interface SavedSearchCompleteSearchResultsIdentityBeta {
    /**
     * The number of rows in the table.
     * @type {string}
     * @memberof SavedSearchCompleteSearchResultsIdentityBeta
     */
    'count': string;
    /**
     * The type of object represented in the table.
     * @type {string}
     * @memberof SavedSearchCompleteSearchResultsIdentityBeta
     */
    'noun': string;
    /**
     * A sample of the data in the table.
     * @type {Array<Array<string>>}
     * @memberof SavedSearchCompleteSearchResultsIdentityBeta
     */
    'preview': Array<Array<string>>;
}
/**
 * The schedule information.
 * @export
 * @interface Schedule1Beta
 */
export interface Schedule1Beta {
    /**
     * 
     * @type {ScheduleTypeBeta}
     * @memberof Schedule1Beta
     */
    'type': ScheduleTypeBeta;
    /**
     * 
     * @type {Schedule1DaysBeta}
     * @memberof Schedule1Beta
     */
    'days'?: Schedule1DaysBeta;
    /**
     * 
     * @type {Schedule1HoursBeta}
     * @memberof Schedule1Beta
     */
    'hours': Schedule1HoursBeta;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof Schedule1Beta
     */
    'expiration'?: string | null;
    /**
     * The GMT formatted timezone the schedule will run in (ex. GMT-06:00).  If no timezone is specified, the org\'s default timezone is used.
     * @type {string}
     * @memberof Schedule1Beta
     */
    'timeZoneId'?: string | null;
}
/**
 * 
 * @export
 * @interface Schedule1DaysBeta
 */
export interface Schedule1DaysBeta {
    /**
     * 
     * @type {SelectorTypeBeta}
     * @memberof Schedule1DaysBeta
     */
    'type': SelectorTypeBeta;
    /**
     * The selected values. 
     * @type {Array<string>}
     * @memberof Schedule1DaysBeta
     */
    'values': Array<string>;
    /**
     * The selected interval for RANGE selectors. 
     * @type {number}
     * @memberof Schedule1DaysBeta
     */
    'interval'?: number | null;
}
/**
 * 
 * @export
 * @interface Schedule1HoursBeta
 */
export interface Schedule1HoursBeta {
    /**
     * 
     * @type {SelectorTypeBeta}
     * @memberof Schedule1HoursBeta
     */
    'type': SelectorTypeBeta;
    /**
     * The selected values. 
     * @type {Array<string>}
     * @memberof Schedule1HoursBeta
     */
    'values': Array<string>;
    /**
     * The selected interval for RANGE selectors. 
     * @type {number}
     * @memberof Schedule1HoursBeta
     */
    'interval'?: number | null;
}
/**
 * 
 * @export
 * @interface ScheduleBeta
 */
export interface ScheduleBeta {
    /**
     * Determines the overall schedule cadence. In general, all time period fields smaller than the chosen type can be configured. For example, a DAILY schedule can have \'hours\' set, but not \'days\'; a WEEKLY schedule can have both \'hours\' and \'days\' set.
     * @type {string}
     * @memberof ScheduleBeta
     */
    'type': ScheduleBetaTypeEnum;
    /**
     * 
     * @type {ScheduleMonthsBeta}
     * @memberof ScheduleBeta
     */
    'months'?: ScheduleMonthsBeta;
    /**
     * 
     * @type {ScheduleDaysBeta}
     * @memberof ScheduleBeta
     */
    'days'?: ScheduleDaysBeta;
    /**
     * 
     * @type {ScheduleHoursBeta}
     * @memberof ScheduleBeta
     */
    'hours': ScheduleHoursBeta;
    /**
     * Specifies the time after which this schedule will no longer occur.
     * @type {string}
     * @memberof ScheduleBeta
     */
    'expiration'?: string;
    /**
     * The time zone to use when running the schedule. For instance, if the schedule is a DAILY schedule that runs at 1AM, and this field is set to \"CST\", the schedule will run at 1AM CST.
     * @type {string}
     * @memberof ScheduleBeta
     */
    'timeZoneId'?: string;
}

export const ScheduleBetaTypeEnum = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Monthly: 'MONTHLY',
    Annually: 'ANNUALLY',
    Calendar: 'CALENDAR'
} as const;

export type ScheduleBetaTypeEnum = typeof ScheduleBetaTypeEnum[keyof typeof ScheduleBetaTypeEnum];

/**
 * Specifies which day(s) a schedule is active for. This is required for all schedule types except DAILY. The \"values\" field holds different data depending on the type of schedule: * WEEKLY: days of the week (1-7) * MONTHLY: days of the month (1-31, L, L-1...) * ANNUALLY: if the \"months\" field is also set: days of the month (1-31, L, L-1...); otherwise: ISO-8601 dates without year (\"--12-31\") * CALENDAR: ISO-8601 dates (\"2020-12-31\")  Note that CALENDAR only supports the LIST type, and ANNUALLY does not support the RANGE type when provided with ISO-8601 dates without year.  Examples:  On Sundays: * type LIST * values \"1\"  The second to last day of the month: * type LIST * values \"L-1\"  From the 20th to the last day of the month: * type RANGE * values \"20\", \"L\"  Every March 2nd: * type LIST * values \"--03-02\"  On March 2nd, 2021: * type: LIST * values \"2021-03-02\" 
 * @export
 * @interface ScheduleDaysBeta
 */
export interface ScheduleDaysBeta {
    /**
     * 
     * @type {string}
     * @memberof ScheduleDaysBeta
     */
    'type': ScheduleDaysBetaTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScheduleDaysBeta
     */
    'values': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ScheduleDaysBeta
     */
    'interval'?: number;
}

export const ScheduleDaysBetaTypeEnum = {
    List: 'LIST',
    Range: 'RANGE'
} as const;

export type ScheduleDaysBetaTypeEnum = typeof ScheduleDaysBetaTypeEnum[keyof typeof ScheduleDaysBetaTypeEnum];

/**
 * Specifies which hour(s) a schedule is active for. Examples:  Every three hours starting from 8AM, inclusive: * type LIST * values \"8\" * interval 3  During business hours: * type RANGE * values \"9\", \"5\"  At 5AM, noon, and 5PM: * type LIST * values \"5\", \"12\", \"17\" 
 * @export
 * @interface ScheduleHoursBeta
 */
export interface ScheduleHoursBeta {
    /**
     * 
     * @type {string}
     * @memberof ScheduleHoursBeta
     */
    'type': ScheduleHoursBetaTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScheduleHoursBeta
     */
    'values': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ScheduleHoursBeta
     */
    'interval'?: number;
}

export const ScheduleHoursBetaTypeEnum = {
    List: 'LIST',
    Range: 'RANGE'
} as const;

export type ScheduleHoursBetaTypeEnum = typeof ScheduleHoursBetaTypeEnum[keyof typeof ScheduleHoursBetaTypeEnum];

/**
 * Specifies which months of a schedule are active. Only valid for ANNUALLY schedule types. Examples:  On February and March: * type LIST * values \"2\", \"3\"  Every 3 months, starting in January (quarterly): * type LIST * values \"1\" * interval 3  Every two months between July and December: * type RANGE * values \"7\", \"12\" * interval 2 
 * @export
 * @interface ScheduleMonthsBeta
 */
export interface ScheduleMonthsBeta {
    /**
     * 
     * @type {string}
     * @memberof ScheduleMonthsBeta
     */
    'type': ScheduleMonthsBetaTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScheduleMonthsBeta
     */
    'values': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ScheduleMonthsBeta
     */
    'interval'?: number;
}

export const ScheduleMonthsBetaTypeEnum = {
    List: 'LIST',
    Range: 'RANGE'
} as const;

export type ScheduleMonthsBetaTypeEnum = typeof ScheduleMonthsBetaTypeEnum[keyof typeof ScheduleMonthsBetaTypeEnum];

/**
 * Enum representing the currently supported schedule types.  Additional values may be added in the future without notice. 
 * @export
 * @enum {string}
 */

export const ScheduleTypeBeta = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Monthly: 'MONTHLY',
    Calendar: 'CALENDAR'
} as const;

export type ScheduleTypeBeta = typeof ScheduleTypeBeta[keyof typeof ScheduleTypeBeta];


/**
 * Attributes related to a scheduled trigger
 * @export
 * @interface ScheduledAttributesBeta
 */
export interface ScheduledAttributesBeta {
    /**
     * A valid CRON expression
     * @type {string}
     * @memberof ScheduledAttributesBeta
     */
    'cronString': string;
}
/**
 * 
 * @export
 * @interface SchemaBeta
 */
export interface SchemaBeta {
    /**
     * The id of the Schema.
     * @type {string}
     * @memberof SchemaBeta
     */
    'id'?: string;
    /**
     * The name of the Schema.
     * @type {string}
     * @memberof SchemaBeta
     */
    'name'?: string;
    /**
     * The name of the object type on the native system that the schema represents.
     * @type {string}
     * @memberof SchemaBeta
     */
    'nativeObjectType'?: string;
    /**
     * The name of the attribute used to calculate the unique identifier for an object in the schema.
     * @type {string}
     * @memberof SchemaBeta
     */
    'identityAttribute'?: string;
    /**
     * The name of the attribute used to calculate the display value for an object in the schema.
     * @type {string}
     * @memberof SchemaBeta
     */
    'displayAttribute'?: string;
    /**
     * The name of the attribute whose values represent other objects in a hierarchy. Only relevant to group schemas.
     * @type {string}
     * @memberof SchemaBeta
     */
    'hierarchyAttribute'?: string;
    /**
     * Flag indicating whether or not the include permissions with the object data when aggregating the schema.
     * @type {boolean}
     * @memberof SchemaBeta
     */
    'includePermissions'?: boolean;
    /**
     * The features that the schema supports.
     * @type {Array<SourceFeatureBeta>}
     * @memberof SchemaBeta
     */
    'features'?: Array<SourceFeatureBeta>;
    /**
     * Holds any extra configuration data that the schema may require.
     * @type {object}
     * @memberof SchemaBeta
     */
    'configuration'?: object;
    /**
     * The attribute definitions which form the schema.
     * @type {Array<AttributeDefinitionBeta>}
     * @memberof SchemaBeta
     */
    'attributes'?: Array<AttributeDefinitionBeta>;
    /**
     * The date the Schema was created.
     * @type {string}
     * @memberof SchemaBeta
     */
    'created'?: string;
    /**
     * The date the Schema was last modified.
     * @type {string}
     * @memberof SchemaBeta
     */
    'modified'?: string;
}
/**
 * 
 * @export
 * @interface SearchAttributeConfigBeta
 */
export interface SearchAttributeConfigBeta {
    /**
     * Name of the new attribute
     * @type {string}
     * @memberof SearchAttributeConfigBeta
     */
    'name'?: string;
    /**
     * The display name of the new attribute
     * @type {string}
     * @memberof SearchAttributeConfigBeta
     */
    'displayName'?: string;
    /**
     * Map of application id and their associated attribute.
     * @type {object}
     * @memberof SearchAttributeConfigBeta
     */
    'applicationAttributes'?: object;
}
/**
 * 
 * @export
 * @interface SearchFormDefinitionsByTenant400ResponseBeta
 */
export interface SearchFormDefinitionsByTenant400ResponseBeta {
    /**
     * 
     * @type {string}
     * @memberof SearchFormDefinitionsByTenant400ResponseBeta
     */
    'detailCode'?: string;
    /**
     * 
     * @type {Array<ErrorMessageBeta>}
     * @memberof SearchFormDefinitionsByTenant400ResponseBeta
     */
    'messages'?: Array<ErrorMessageBeta>;
    /**
     * 
     * @type {number}
     * @memberof SearchFormDefinitionsByTenant400ResponseBeta
     */
    'statusCode'?: number;
    /**
     * 
     * @type {string}
     * @memberof SearchFormDefinitionsByTenant400ResponseBeta
     */
    'trackingId'?: string;
}
/**
 * 
 * @export
 * @interface SectionAllOfBeta
 */
export interface SectionAllOfBeta {
    /**
     * Label of the section
     * @type {string}
     * @memberof SectionAllOfBeta
     */
    'label'?: string;
    /**
     * List of FormItems. FormItems can be SectionDetails and/or FieldDetails
     * @type {Array<object>}
     * @memberof SectionAllOfBeta
     */
    'formItems'?: Array<object>;
}
/**
 * 
 * @export
 * @interface SectionBeta
 */
export interface SectionBeta {
    /**
     * Name of the FormItem
     * @type {string}
     * @memberof SectionBeta
     */
    'name'?: string;
    /**
     * Label of the section
     * @type {string}
     * @memberof SectionBeta
     */
    'label'?: string;
    /**
     * List of FormItems. FormItems can be SectionDetails and/or FieldDetails
     * @type {Array<object>}
     * @memberof SectionBeta
     */
    'formItems'?: Array<object>;
}
/**
 * 
 * @export
 * @interface SectionDetailsBeta
 */
export interface SectionDetailsBeta {
    /**
     * Name of the FormItem
     * @type {string}
     * @memberof SectionDetailsBeta
     */
    'name'?: string;
    /**
     * Label of the section
     * @type {string}
     * @memberof SectionDetailsBeta
     */
    'label'?: string;
    /**
     * List of FormItems. FormItems can be SectionDetails and/or FieldDetails
     * @type {Array<object>}
     * @memberof SectionDetailsBeta
     */
    'formItems'?: Array<object>;
}
/**
 * 
 * @export
 * @interface SegmentBeta
 */
export interface SegmentBeta {
    /**
     * 
     * @type {string}
     * @memberof SegmentBeta
     */
    'id'?: string;
    /**
     * Segment Business Name
     * @type {string}
     * @memberof SegmentBeta
     */
    'name'?: string;
    /**
     * The time when this Segment is created
     * @type {string}
     * @memberof SegmentBeta
     */
    'created'?: string;
    /**
     * The time when this Segment is modified
     * @type {string}
     * @memberof SegmentBeta
     */
    'modified'?: string;
    /**
     * Optional description of the Segment
     * @type {string}
     * @memberof SegmentBeta
     */
    'description'?: string;
    /**
     * 
     * @type {OwnerReferenceBeta}
     * @memberof SegmentBeta
     */
    'owner'?: OwnerReferenceBeta | null;
    /**
     * 
     * @type {VisibilityCriteriaBeta}
     * @memberof SegmentBeta
     */
    'visibilityCriteria'?: VisibilityCriteriaBeta;
    /**
     * Whether the Segment is currently active. Inactive segments have no effect.
     * @type {boolean}
     * @memberof SegmentBeta
     */
    'active'?: boolean;
}
/**
 * 
 * @export
 * @interface SelectorBeta
 */
export interface SelectorBeta {
    /**
     * 
     * @type {SelectorTypeBeta}
     * @memberof SelectorBeta
     */
    'type': SelectorTypeBeta;
    /**
     * The selected values. 
     * @type {Array<string>}
     * @memberof SelectorBeta
     */
    'values': Array<string>;
    /**
     * The selected interval for RANGE selectors. 
     * @type {number}
     * @memberof SelectorBeta
     */
    'interval'?: number | null;
}
/**
 * Enum representing the currently supported selector types.  LIST - the *values* array contains one or more distinct values.  RANGE - the *values* array contains two values: the start and end of the range, inclusive.  Additional values may be added in the future without notice. 
 * @export
 * @enum {string}
 */

export const SelectorTypeBeta = {
    List: 'LIST',
    Range: 'RANGE'
} as const;

export type SelectorTypeBeta = typeof SelectorTypeBeta[keyof typeof SelectorTypeBeta];


/**
 * 
 * @export
 * @interface SendTestNotificationRequestDtoBeta
 */
export interface SendTestNotificationRequestDtoBeta {
    /**
     * The template notification key.
     * @type {string}
     * @memberof SendTestNotificationRequestDtoBeta
     */
    'key'?: string;
    /**
     * The notification medium. Has to be one of the following enum values.
     * @type {string}
     * @memberof SendTestNotificationRequestDtoBeta
     */
    'medium'?: SendTestNotificationRequestDtoBetaMediumEnum;
    /**
     * A Json object that denotes the context specific to the template.
     * @type {object}
     * @memberof SendTestNotificationRequestDtoBeta
     */
    'context'?: object;
}

export const SendTestNotificationRequestDtoBetaMediumEnum = {
    Email: 'EMAIL',
    Slack: 'SLACK',
    Teams: 'TEAMS'
} as const;

export type SendTestNotificationRequestDtoBetaMediumEnum = typeof SendTestNotificationRequestDtoBetaMediumEnum[keyof typeof SendTestNotificationRequestDtoBetaMediumEnum];

/**
 * Specification of a Service Desk integration
 * @export
 * @interface ServiceDeskIntegrationDtoAllOfBeta
 */
export interface ServiceDeskIntegrationDtoAllOfBeta {
    /**
     * Description of the Service Desk integration
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoAllOfBeta
     */
    'description': string;
    /**
     * Service Desk integration types  - ServiceNowSDIM - ServiceNow 
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoAllOfBeta
     */
    'type': string;
    /**
     * Reference to the identity that is the owner of this Service Desk integration
     * @type {BaseReferenceDto1Beta}
     * @memberof ServiceDeskIntegrationDtoAllOfBeta
     */
    'ownerRef'?: BaseReferenceDto1Beta;
    /**
     * Reference to the source cluster for this Service Desk integration
     * @type {BaseReferenceDto1Beta}
     * @memberof ServiceDeskIntegrationDtoAllOfBeta
     */
    'clusterRef'?: BaseReferenceDto1Beta;
    /**
     * ID of the cluster for the Service Desk integration (replaced by clusterRef, retained for backward compatibility)
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoAllOfBeta
     * @deprecated
     */
    'cluster'?: string;
    /**
     * Source IDs for the Service Desk integration (replaced by provisioningConfig.managedSResourceRefs, but retained here for backward compatibility)
     * @type {Array<string>}
     * @memberof ServiceDeskIntegrationDtoAllOfBeta
     * @deprecated
     */
    'managedSources'?: Array<string>;
    /**
     * 
     * @type {ProvisioningConfigBeta}
     * @memberof ServiceDeskIntegrationDtoAllOfBeta
     */
    'provisioningConfig'?: ProvisioningConfigBeta;
    /**
     * Attributes of the Service Desk integration.  Validation constraints enforced by the implementation.
     * @type {{ [key: string]: any; }}
     * @memberof ServiceDeskIntegrationDtoAllOfBeta
     */
    'attributes': { [key: string]: any; };
    /**
     * Reference to beforeProvisioningRule for this Service Desk integration
     * @type {BaseReferenceDto1Beta}
     * @memberof ServiceDeskIntegrationDtoAllOfBeta
     */
    'beforeProvisioningRule'?: BaseReferenceDto1Beta;
}
/**
 * 
 * @export
 * @interface ServiceDeskIntegrationDtoBeta
 */
export interface ServiceDeskIntegrationDtoBeta {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoBeta
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoBeta
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoBeta
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoBeta
     */
    'modified'?: string;
    /**
     * Description of the Service Desk integration
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoBeta
     */
    'description': string;
    /**
     * Service Desk integration types  - ServiceNowSDIM - ServiceNow 
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoBeta
     */
    'type': string;
    /**
     * Reference to the identity that is the owner of this Service Desk integration
     * @type {BaseReferenceDto1Beta}
     * @memberof ServiceDeskIntegrationDtoBeta
     */
    'ownerRef'?: BaseReferenceDto1Beta;
    /**
     * Reference to the source cluster for this Service Desk integration
     * @type {BaseReferenceDto1Beta}
     * @memberof ServiceDeskIntegrationDtoBeta
     */
    'clusterRef'?: BaseReferenceDto1Beta;
    /**
     * ID of the cluster for the Service Desk integration (replaced by clusterRef, retained for backward compatibility)
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoBeta
     * @deprecated
     */
    'cluster'?: string;
    /**
     * Source IDs for the Service Desk integration (replaced by provisioningConfig.managedSResourceRefs, but retained here for backward compatibility)
     * @type {Array<string>}
     * @memberof ServiceDeskIntegrationDtoBeta
     * @deprecated
     */
    'managedSources'?: Array<string>;
    /**
     * 
     * @type {ProvisioningConfigBeta}
     * @memberof ServiceDeskIntegrationDtoBeta
     */
    'provisioningConfig'?: ProvisioningConfigBeta;
    /**
     * Attributes of the Service Desk integration.  Validation constraints enforced by the implementation.
     * @type {{ [key: string]: any; }}
     * @memberof ServiceDeskIntegrationDtoBeta
     */
    'attributes': { [key: string]: any; };
    /**
     * Reference to beforeProvisioningRule for this Service Desk integration
     * @type {BaseReferenceDto1Beta}
     * @memberof ServiceDeskIntegrationDtoBeta
     */
    'beforeProvisioningRule'?: BaseReferenceDto1Beta;
}
/**
 * This is the model for a Service Desk integration template, used to create and edit Service Desk Integrations.
 * @export
 * @interface ServiceDeskIntegrationTemplateDtoAllOfBeta
 */
export interface ServiceDeskIntegrationTemplateDtoAllOfBeta {
    /**
     * The \'type\' property specifies the type of the Service Desk integration template.
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDtoAllOfBeta
     */
    'type': string;
    /**
     * The \'attributes\' property value is a map of attributes available for integrations using this Service Desk integration template.
     * @type {{ [key: string]: any; }}
     * @memberof ServiceDeskIntegrationTemplateDtoAllOfBeta
     */
    'attributes': { [key: string]: any; };
    /**
     * 
     * @type {ProvisioningConfigBeta}
     * @memberof ServiceDeskIntegrationTemplateDtoAllOfBeta
     */
    'provisioningConfig': ProvisioningConfigBeta;
}
/**
 * 
 * @export
 * @interface ServiceDeskIntegrationTemplateDtoBeta
 */
export interface ServiceDeskIntegrationTemplateDtoBeta {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDtoBeta
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDtoBeta
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDtoBeta
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDtoBeta
     */
    'modified'?: string;
    /**
     * The \'type\' property specifies the type of the Service Desk integration template.
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDtoBeta
     */
    'type': string;
    /**
     * The \'attributes\' property value is a map of attributes available for integrations using this Service Desk integration template.
     * @type {{ [key: string]: any; }}
     * @memberof ServiceDeskIntegrationTemplateDtoBeta
     */
    'attributes': { [key: string]: any; };
    /**
     * 
     * @type {ProvisioningConfigBeta}
     * @memberof ServiceDeskIntegrationTemplateDtoBeta
     */
    'provisioningConfig': ProvisioningConfigBeta;
}
/**
 * This represents a Service Desk Integration template type.
 * @export
 * @interface ServiceDeskIntegrationTemplateTypeBeta
 */
export interface ServiceDeskIntegrationTemplateTypeBeta {
    /**
     * This is the name of the type.
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateTypeBeta
     */
    'name'?: string;
    /**
     * This is the type value for the type.
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateTypeBeta
     */
    'type': string;
    /**
     * This is the scriptName attribute value for the type.
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateTypeBeta
     */
    'scriptName': string;
}
/**
 * 
 * @export
 * @interface SlimAccountAllOfBeta
 */
export interface SlimAccountAllOfBeta {
    /**
     * Unique ID from the owning source
     * @type {string}
     * @memberof SlimAccountAllOfBeta
     */
    'uuid'?: string | null;
    /**
     * The native identifier of the account
     * @type {string}
     * @memberof SlimAccountAllOfBeta
     */
    'nativeIdentity'?: string;
    /**
     * The description for the account
     * @type {string}
     * @memberof SlimAccountAllOfBeta
     */
    'description'?: string | null;
    /**
     * Whether the account is disabled
     * @type {boolean}
     * @memberof SlimAccountAllOfBeta
     */
    'disabled'?: boolean;
    /**
     * Whether the account is locked
     * @type {boolean}
     * @memberof SlimAccountAllOfBeta
     */
    'locked'?: boolean;
    /**
     * Whether the account was manually correlated
     * @type {boolean}
     * @memberof SlimAccountAllOfBeta
     */
    'manuallyCorrelated'?: boolean;
    /**
     * Whether the account has any entitlements associated with it
     * @type {boolean}
     * @memberof SlimAccountAllOfBeta
     */
    'hasEntitlements'?: boolean;
    /**
     * The ID of the source for which this account belongs
     * @type {string}
     * @memberof SlimAccountAllOfBeta
     */
    'sourceId'?: string;
    /**
     * The name of the source
     * @type {string}
     * @memberof SlimAccountAllOfBeta
     */
    'sourceName'?: string;
    /**
     * The ID of the identity for which this account is correlated to if not uncorrelated
     * @type {string}
     * @memberof SlimAccountAllOfBeta
     */
    'identityId'?: string;
    /**
     * A map containing attributes associated with the account
     * @type {{ [key: string]: any; }}
     * @memberof SlimAccountAllOfBeta
     */
    'attributes'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface SlimAccountBeta
 */
export interface SlimAccountBeta {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof SlimAccountBeta
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof SlimAccountBeta
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof SlimAccountBeta
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof SlimAccountBeta
     */
    'modified'?: string;
    /**
     * Unique ID from the owning source
     * @type {string}
     * @memberof SlimAccountBeta
     */
    'uuid'?: string | null;
    /**
     * The native identifier of the account
     * @type {string}
     * @memberof SlimAccountBeta
     */
    'nativeIdentity'?: string;
    /**
     * The description for the account
     * @type {string}
     * @memberof SlimAccountBeta
     */
    'description'?: string | null;
    /**
     * Whether the account is disabled
     * @type {boolean}
     * @memberof SlimAccountBeta
     */
    'disabled'?: boolean;
    /**
     * Whether the account is locked
     * @type {boolean}
     * @memberof SlimAccountBeta
     */
    'locked'?: boolean;
    /**
     * Whether the account was manually correlated
     * @type {boolean}
     * @memberof SlimAccountBeta
     */
    'manuallyCorrelated'?: boolean;
    /**
     * Whether the account has any entitlements associated with it
     * @type {boolean}
     * @memberof SlimAccountBeta
     */
    'hasEntitlements'?: boolean;
    /**
     * The ID of the source for which this account belongs
     * @type {string}
     * @memberof SlimAccountBeta
     */
    'sourceId'?: string;
    /**
     * The name of the source
     * @type {string}
     * @memberof SlimAccountBeta
     */
    'sourceName'?: string;
    /**
     * The ID of the identity for which this account is correlated to if not uncorrelated
     * @type {string}
     * @memberof SlimAccountBeta
     */
    'identityId'?: string;
    /**
     * A map containing attributes associated with the account
     * @type {{ [key: string]: any; }}
     * @memberof SlimAccountBeta
     */
    'attributes'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface SlimcampaignBeta
 */
export interface SlimcampaignBeta {
    /**
     * Id of the campaign
     * @type {string}
     * @memberof SlimcampaignBeta
     */
    'id'?: string;
    /**
     * The campaign name. If this object is part of a template, special formatting applies; see the `/campaign-templates/{id}/generate` endpoint documentation for details.
     * @type {string}
     * @memberof SlimcampaignBeta
     */
    'name': string;
    /**
     * The campaign description. If this object is part of a template, special formatting applies; see the `/campaign-templates/{id}/generate` endpoint documentation for details.
     * @type {string}
     * @memberof SlimcampaignBeta
     */
    'description': string;
    /**
     * The campaign\'s completion deadline.
     * @type {string}
     * @memberof SlimcampaignBeta
     */
    'deadline'?: string;
    /**
     * The type of campaign. Could be extended in the future.
     * @type {string}
     * @memberof SlimcampaignBeta
     */
    'type': SlimcampaignBetaTypeEnum;
    /**
     * Enables email notification for this campaign
     * @type {boolean}
     * @memberof SlimcampaignBeta
     */
    'emailNotificationEnabled'?: boolean;
    /**
     * Allows auto revoke for this campaign
     * @type {boolean}
     * @memberof SlimcampaignBeta
     */
    'autoRevokeAllowed'?: boolean;
    /**
     * Enables IAI for this campaign. Accepts true even if the IAI product feature is off. If IAI is turned off then campaigns generated from this template will indicate false. The real value will then be returned if IAI is ever enabled for the org in the future.
     * @type {boolean}
     * @memberof SlimcampaignBeta
     */
    'recommendationsEnabled'?: boolean;
    /**
     * The campaign\'s current status.
     * @type {string}
     * @memberof SlimcampaignBeta
     */
    'status'?: SlimcampaignBetaStatusEnum;
    /**
     * The correlatedStatus of the campaign. Only SOURCE_OWNER campaigns can be Uncorrelated. An Uncorrelated certification campaign only includes Uncorrelated identities (An identity is uncorrelated if it has no accounts on an authoritative source).
     * @type {string}
     * @memberof SlimcampaignBeta
     */
    'correlatedStatus'?: SlimcampaignBetaCorrelatedStatusEnum;
}

export const SlimcampaignBetaTypeEnum = {
    Manager: 'MANAGER',
    SourceOwner: 'SOURCE_OWNER',
    Search: 'SEARCH',
    RoleComposition: 'ROLE_COMPOSITION'
} as const;

export type SlimcampaignBetaTypeEnum = typeof SlimcampaignBetaTypeEnum[keyof typeof SlimcampaignBetaTypeEnum];
export const SlimcampaignBetaStatusEnum = {
    Pending: 'PENDING',
    Staged: 'STAGED',
    Canceling: 'CANCELING',
    Activating: 'ACTIVATING',
    Active: 'ACTIVE',
    Completing: 'COMPLETING',
    Completed: 'COMPLETED',
    Error: 'ERROR',
    Archived: 'ARCHIVED'
} as const;

export type SlimcampaignBetaStatusEnum = typeof SlimcampaignBetaStatusEnum[keyof typeof SlimcampaignBetaStatusEnum];
export const SlimcampaignBetaCorrelatedStatusEnum = {
    Correlated: 'CORRELATED',
    Uncorrelated: 'UNCORRELATED'
} as const;

export type SlimcampaignBetaCorrelatedStatusEnum = typeof SlimcampaignBetaCorrelatedStatusEnum[keyof typeof SlimcampaignBetaCorrelatedStatusEnum];

/**
 * Details of the Entitlement criteria
 * @export
 * @interface SodExemptCriteria1Beta
 */
export interface SodExemptCriteria1Beta {
    /**
     * If the entitlement already belonged to the user or not.
     * @type {boolean}
     * @memberof SodExemptCriteria1Beta
     */
    'existing'?: boolean;
    /**
     * 
     * @type {DtoTypeBeta}
     * @memberof SodExemptCriteria1Beta
     */
    'type'?: DtoTypeBeta;
    /**
     * Entitlement ID
     * @type {string}
     * @memberof SodExemptCriteria1Beta
     */
    'id'?: string;
    /**
     * Entitlement name
     * @type {string}
     * @memberof SodExemptCriteria1Beta
     */
    'name'?: string;
}
/**
 * Details of the Entitlement criteria
 * @export
 * @interface SodExemptCriteriaBeta
 */
export interface SodExemptCriteriaBeta {
    /**
     * If the entitlement already belonged to the user or not.
     * @type {boolean}
     * @memberof SodExemptCriteriaBeta
     */
    'existing'?: boolean;
    /**
     * 
     * @type {DtoTypeBeta}
     * @memberof SodExemptCriteriaBeta
     */
    'type'?: DtoTypeBeta;
    /**
     * Entitlement ID
     * @type {string}
     * @memberof SodExemptCriteriaBeta
     */
    'id'?: string;
    /**
     * Entitlement name
     * @type {string}
     * @memberof SodExemptCriteriaBeta
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface SodPolicyBeta
 */
export interface SodPolicyBeta {
    /**
     * Policy id
     * @type {string}
     * @memberof SodPolicyBeta
     */
    'id'?: string;
    /**
     * Policy Business Name
     * @type {string}
     * @memberof SodPolicyBeta
     */
    'name'?: string;
    /**
     * The time when this SOD policy is created.
     * @type {string}
     * @memberof SodPolicyBeta
     */
    'created'?: string;
    /**
     * The time when this SOD policy is modified.
     * @type {string}
     * @memberof SodPolicyBeta
     */
    'modified'?: string;
    /**
     * Optional description of the SOD policy
     * @type {string}
     * @memberof SodPolicyBeta
     */
    'description'?: string | null;
    /**
     * 
     * @type {BaseReferenceDto1Beta}
     * @memberof SodPolicyBeta
     */
    'ownerRef'?: BaseReferenceDto1Beta;
    /**
     * Optional External Policy Reference
     * @type {string}
     * @memberof SodPolicyBeta
     */
    'externalPolicyReference'?: string | null;
    /**
     * Search query of the SOD policy
     * @type {string}
     * @memberof SodPolicyBeta
     */
    'policyQuery'?: string;
    /**
     * Optional compensating controls(Mitigating Controls)
     * @type {string}
     * @memberof SodPolicyBeta
     */
    'compensatingControls'?: string | null;
    /**
     * Optional correction advice
     * @type {string}
     * @memberof SodPolicyBeta
     */
    'correctionAdvice'?: string | null;
    /**
     * whether the policy is enforced or not
     * @type {string}
     * @memberof SodPolicyBeta
     */
    'state'?: SodPolicyBetaStateEnum;
    /**
     * tags for this policy object
     * @type {Array<string>}
     * @memberof SodPolicyBeta
     */
    'tags'?: Array<string>;
    /**
     * Policy\'s creator ID
     * @type {string}
     * @memberof SodPolicyBeta
     */
    'creatorId'?: string;
    /**
     * Policy\'s modifier ID
     * @type {string}
     * @memberof SodPolicyBeta
     */
    'modifierId'?: string | null;
    /**
     * 
     * @type {ViolationOwnerAssignmentConfigBeta}
     * @memberof SodPolicyBeta
     */
    'violationOwnerAssignmentConfig'?: ViolationOwnerAssignmentConfigBeta;
    /**
     * defines whether a policy has been scheduled or not
     * @type {boolean}
     * @memberof SodPolicyBeta
     */
    'scheduled'?: boolean;
    /**
     * whether a policy is query based or conflicting access based
     * @type {string}
     * @memberof SodPolicyBeta
     */
    'type'?: SodPolicyBetaTypeEnum;
    /**
     * 
     * @type {SodPolicyConflictingAccessCriteriaBeta}
     * @memberof SodPolicyBeta
     */
    'conflictingAccessCriteria'?: SodPolicyConflictingAccessCriteriaBeta;
}

export const SodPolicyBetaStateEnum = {
    Enforced: 'ENFORCED',
    NotEnforced: 'NOT_ENFORCED'
} as const;

export type SodPolicyBetaStateEnum = typeof SodPolicyBetaStateEnum[keyof typeof SodPolicyBetaStateEnum];
export const SodPolicyBetaTypeEnum = {
    General: 'GENERAL',
    ConflictingAccessBased: 'CONFLICTING_ACCESS_BASED'
} as const;

export type SodPolicyBetaTypeEnum = typeof SodPolicyBetaTypeEnum[keyof typeof SodPolicyBetaTypeEnum];

/**
 * 
 * @export
 * @interface SodPolicyConflictingAccessCriteriaBeta
 */
export interface SodPolicyConflictingAccessCriteriaBeta {
    /**
     * 
     * @type {AccessCriteriaBeta}
     * @memberof SodPolicyConflictingAccessCriteriaBeta
     */
    'leftCriteria'?: AccessCriteriaBeta;
    /**
     * 
     * @type {AccessCriteriaBeta}
     * @memberof SodPolicyConflictingAccessCriteriaBeta
     */
    'rightCriteria'?: AccessCriteriaBeta;
}
/**
 * 
 * @export
 * @interface SodPolicyScheduleBeta
 */
export interface SodPolicyScheduleBeta {
    /**
     * SOD Policy schedule name
     * @type {string}
     * @memberof SodPolicyScheduleBeta
     */
    'name'?: string;
    /**
     * The time when this SOD policy schedule is created.
     * @type {string}
     * @memberof SodPolicyScheduleBeta
     */
    'created'?: string;
    /**
     * The time when this SOD policy schedule is modified.
     * @type {string}
     * @memberof SodPolicyScheduleBeta
     */
    'modified'?: string;
    /**
     * SOD Policy schedule description
     * @type {string}
     * @memberof SodPolicyScheduleBeta
     */
    'description'?: string;
    /**
     * 
     * @type {Schedule1Beta}
     * @memberof SodPolicyScheduleBeta
     */
    'schedule'?: Schedule1Beta;
    /**
     * 
     * @type {Array<BaseReferenceDto1Beta>}
     * @memberof SodPolicyScheduleBeta
     */
    'recipients'?: Array<BaseReferenceDto1Beta>;
    /**
     * Indicates if empty results need to be emailed
     * @type {boolean}
     * @memberof SodPolicyScheduleBeta
     */
    'emailEmptyResults'?: boolean;
    /**
     * Policy\'s creator ID
     * @type {string}
     * @memberof SodPolicyScheduleBeta
     */
    'creatorId'?: string;
    /**
     * Policy\'s modifier ID
     * @type {string}
     * @memberof SodPolicyScheduleBeta
     */
    'modifierId'?: string;
}
/**
 * The inner object representing the completed SOD Violation check
 * @export
 * @interface SodViolationCheckResult1Beta
 */
export interface SodViolationCheckResult1Beta {
    /**
     * 
     * @type {ErrorMessageDtoBeta}
     * @memberof SodViolationCheckResult1Beta
     */
    'message'?: ErrorMessageDtoBeta;
    /**
     * Arbitrary key-value pairs. They will never be processed by the IdentityNow system but will be returned on completion of the violation check.
     * @type {{ [key: string]: string; }}
     * @memberof SodViolationCheckResult1Beta
     */
    'clientMetadata'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<SodViolationContext1Beta>}
     * @memberof SodViolationCheckResult1Beta
     */
    'violationContexts'?: Array<SodViolationContext1Beta>;
    /**
     * A list of the Policies that were violated
     * @type {Array<BaseReferenceDtoBeta>}
     * @memberof SodViolationCheckResult1Beta
     */
    'violatedPolicies'?: Array<BaseReferenceDtoBeta>;
}
/**
 * The inner object representing the completed SOD Violation check
 * @export
 * @interface SodViolationCheckResultBeta
 */
export interface SodViolationCheckResultBeta {
    /**
     * 
     * @type {ErrorMessageDtoBeta}
     * @memberof SodViolationCheckResultBeta
     */
    'message'?: ErrorMessageDtoBeta;
    /**
     * Arbitrary key-value pairs. They will never be processed by the IdentityNow system but will be returned on completion of the violation check.
     * @type {{ [key: string]: string; }}
     * @memberof SodViolationCheckResultBeta
     */
    'clientMetadata'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<SodViolationContextBeta>}
     * @memberof SodViolationCheckResultBeta
     */
    'violationContexts'?: Array<SodViolationContextBeta>;
    /**
     * A list of the Policies that were violated
     * @type {Array<BaseReferenceDto1Beta>}
     * @memberof SodViolationCheckResultBeta
     */
    'violatedPolicies'?: Array<BaseReferenceDto1Beta>;
}
/**
 * The contextual information of the violated criteria
 * @export
 * @interface SodViolationContext1Beta
 */
export interface SodViolationContext1Beta {
    /**
     * 
     * @type {BaseReferenceDto1Beta}
     * @memberof SodViolationContext1Beta
     */
    'policy'?: BaseReferenceDto1Beta;
    /**
     * 
     * @type {SodViolationContext1ConflictingAccessCriteriaBeta}
     * @memberof SodViolationContext1Beta
     */
    'conflictingAccessCriteria'?: SodViolationContext1ConflictingAccessCriteriaBeta;
}
/**
 * The object which contains the left and right hand side of the entitlements that got violated according to the policy.
 * @export
 * @interface SodViolationContext1ConflictingAccessCriteriaBeta
 */
export interface SodViolationContext1ConflictingAccessCriteriaBeta {
    /**
     * 
     * @type {SodViolationContext1ConflictingAccessCriteriaLeftCriteriaBeta}
     * @memberof SodViolationContext1ConflictingAccessCriteriaBeta
     */
    'leftCriteria'?: SodViolationContext1ConflictingAccessCriteriaLeftCriteriaBeta;
    /**
     * 
     * @type {SodViolationContext1ConflictingAccessCriteriaLeftCriteriaBeta}
     * @memberof SodViolationContext1ConflictingAccessCriteriaBeta
     */
    'rightCriteria'?: SodViolationContext1ConflictingAccessCriteriaLeftCriteriaBeta;
}
/**
 * 
 * @export
 * @interface SodViolationContext1ConflictingAccessCriteriaLeftCriteriaBeta
 */
export interface SodViolationContext1ConflictingAccessCriteriaLeftCriteriaBeta {
    /**
     * 
     * @type {Array<SodExemptCriteria1Beta>}
     * @memberof SodViolationContext1ConflictingAccessCriteriaLeftCriteriaBeta
     */
    'criteriaList'?: Array<SodExemptCriteria1Beta>;
}
/**
 * The contextual information of the violated criteria
 * @export
 * @interface SodViolationContextBeta
 */
export interface SodViolationContextBeta {
    /**
     * 
     * @type {BaseReferenceDto1Beta}
     * @memberof SodViolationContextBeta
     */
    'policy'?: BaseReferenceDto1Beta;
    /**
     * 
     * @type {SodViolationContextConflictingAccessCriteriaBeta}
     * @memberof SodViolationContextBeta
     */
    'conflictingAccessCriteria'?: SodViolationContextConflictingAccessCriteriaBeta;
}
/**
 * An object referencing a completed SOD violation check
 * @export
 * @interface SodViolationContextCheckCompleted1Beta
 */
export interface SodViolationContextCheckCompleted1Beta {
    /**
     * The status of SOD violation check
     * @type {string}
     * @memberof SodViolationContextCheckCompleted1Beta
     */
    'state'?: SodViolationContextCheckCompleted1BetaStateEnum;
    /**
     * The id of the Violation check event
     * @type {string}
     * @memberof SodViolationContextCheckCompleted1Beta
     */
    'uuid'?: string;
    /**
     * 
     * @type {SodViolationCheckResult1Beta}
     * @memberof SodViolationContextCheckCompleted1Beta
     */
    'violationCheckResult'?: SodViolationCheckResult1Beta;
}

export const SodViolationContextCheckCompleted1BetaStateEnum = {
    Success: 'SUCCESS',
    Error: 'ERROR'
} as const;

export type SodViolationContextCheckCompleted1BetaStateEnum = typeof SodViolationContextCheckCompleted1BetaStateEnum[keyof typeof SodViolationContextCheckCompleted1BetaStateEnum];

/**
 * An object referencing a completed SOD violation check
 * @export
 * @interface SodViolationContextCheckCompletedBeta
 */
export interface SodViolationContextCheckCompletedBeta {
    /**
     * The status of SOD violation check
     * @type {string}
     * @memberof SodViolationContextCheckCompletedBeta
     */
    'state'?: SodViolationContextCheckCompletedBetaStateEnum;
    /**
     * The id of the Violation check event
     * @type {string}
     * @memberof SodViolationContextCheckCompletedBeta
     */
    'uuid'?: string;
    /**
     * 
     * @type {SodViolationCheckResultBeta}
     * @memberof SodViolationContextCheckCompletedBeta
     */
    'violationCheckResult'?: SodViolationCheckResultBeta;
}

export const SodViolationContextCheckCompletedBetaStateEnum = {
    Success: 'SUCCESS',
    Error: 'ERROR'
} as const;

export type SodViolationContextCheckCompletedBetaStateEnum = typeof SodViolationContextCheckCompletedBetaStateEnum[keyof typeof SodViolationContextCheckCompletedBetaStateEnum];

/**
 * The object which contains the left and right hand side of the entitlements that got violated according to the policy.
 * @export
 * @interface SodViolationContextConflictingAccessCriteriaBeta
 */
export interface SodViolationContextConflictingAccessCriteriaBeta {
    /**
     * 
     * @type {SodViolationContextConflictingAccessCriteriaLeftCriteriaBeta}
     * @memberof SodViolationContextConflictingAccessCriteriaBeta
     */
    'leftCriteria'?: SodViolationContextConflictingAccessCriteriaLeftCriteriaBeta;
    /**
     * 
     * @type {SodViolationContextConflictingAccessCriteriaLeftCriteriaBeta}
     * @memberof SodViolationContextConflictingAccessCriteriaBeta
     */
    'rightCriteria'?: SodViolationContextConflictingAccessCriteriaLeftCriteriaBeta;
}
/**
 * 
 * @export
 * @interface SodViolationContextConflictingAccessCriteriaLeftCriteriaBeta
 */
export interface SodViolationContextConflictingAccessCriteriaLeftCriteriaBeta {
    /**
     * 
     * @type {Array<SodExemptCriteriaBeta>}
     * @memberof SodViolationContextConflictingAccessCriteriaLeftCriteriaBeta
     */
    'criteriaList'?: Array<SodExemptCriteriaBeta>;
}
/**
 * 
 * @export
 * @interface SourceAccountBeta
 */
export interface SourceAccountBeta {
    /**
     * Source unique identifier for the identity. UUID is generated by the source system.
     * @type {string}
     * @memberof SourceAccountBeta
     */
    'uuid'?: string;
    /**
     * SailPoint generated unique identifier.
     * @type {string}
     * @memberof SourceAccountBeta
     */
    'id': string;
    /**
     * Unique ID of the account on the source.
     * @type {string}
     * @memberof SourceAccountBeta
     */
    'nativeIdentifier': string;
    /**
     * The ID of the source.
     * @type {string}
     * @memberof SourceAccountBeta
     */
    'sourceId': string;
    /**
     * The name of the source.
     * @type {string}
     * @memberof SourceAccountBeta
     */
    'sourceName': string;
    /**
     * The ID of the identity that is corellated with this account.
     * @type {string}
     * @memberof SourceAccountBeta
     */
    'identityId': string;
    /**
     * The name of the identity that is corellated with this account.
     * @type {string}
     * @memberof SourceAccountBeta
     */
    'identityName': string;
    /**
     * The attributes of the account. The contents of attributes depends on the account schema for the source.
     * @type {{ [key: string]: any; }}
     * @memberof SourceAccountBeta
     */
    'attributes': { [key: string]: any; };
}
/**
 * Reference to an Account Correlation Config object
 * @export
 * @interface SourceAccountCorrelationConfigBeta
 */
export interface SourceAccountCorrelationConfigBeta {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceAccountCorrelationConfigBeta
     */
    'type'?: SourceAccountCorrelationConfigBetaTypeEnum;
    /**
     * ID of the account correlation config
     * @type {string}
     * @memberof SourceAccountCorrelationConfigBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of the account correlation config
     * @type {string}
     * @memberof SourceAccountCorrelationConfigBeta
     */
    'name'?: string;
}

export const SourceAccountCorrelationConfigBetaTypeEnum = {
    AccountCorrelationConfig: 'ACCOUNT_CORRELATION_CONFIG'
} as const;

export type SourceAccountCorrelationConfigBetaTypeEnum = typeof SourceAccountCorrelationConfigBetaTypeEnum[keyof typeof SourceAccountCorrelationConfigBetaTypeEnum];

/**
 * Reference to a Rule that can do COMPLEX correlation, should only be used when accountCorrelationConfig can\'t be used.
 * @export
 * @interface SourceAccountCorrelationRuleBeta
 */
export interface SourceAccountCorrelationRuleBeta {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceAccountCorrelationRuleBeta
     */
    'type'?: SourceAccountCorrelationRuleBetaTypeEnum;
    /**
     * ID of the rule
     * @type {string}
     * @memberof SourceAccountCorrelationRuleBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of the rule
     * @type {string}
     * @memberof SourceAccountCorrelationRuleBeta
     */
    'name'?: string;
}

export const SourceAccountCorrelationRuleBetaTypeEnum = {
    Rule: 'RULE'
} as const;

export type SourceAccountCorrelationRuleBetaTypeEnum = typeof SourceAccountCorrelationRuleBetaTypeEnum[keyof typeof SourceAccountCorrelationRuleBetaTypeEnum];

/**
 * Rule that runs on the CCG and allows for customization of provisioning plans before the connector is called.
 * @export
 * @interface SourceBeforeProvisioningRuleBeta
 */
export interface SourceBeforeProvisioningRuleBeta {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceBeforeProvisioningRuleBeta
     */
    'type'?: SourceBeforeProvisioningRuleBetaTypeEnum;
    /**
     * ID of the rule
     * @type {string}
     * @memberof SourceBeforeProvisioningRuleBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of the rule
     * @type {string}
     * @memberof SourceBeforeProvisioningRuleBeta
     */
    'name'?: string;
}

export const SourceBeforeProvisioningRuleBetaTypeEnum = {
    Rule: 'RULE'
} as const;

export type SourceBeforeProvisioningRuleBetaTypeEnum = typeof SourceBeforeProvisioningRuleBetaTypeEnum[keyof typeof SourceBeforeProvisioningRuleBetaTypeEnum];

/**
 * 
 * @export
 * @interface SourceBeta
 */
export interface SourceBeta {
    /**
     * the id of the Source
     * @type {string}
     * @memberof SourceBeta
     */
    'id'?: string;
    /**
     * Human-readable name of the source
     * @type {string}
     * @memberof SourceBeta
     */
    'name': string;
    /**
     * Human-readable description of the source
     * @type {string}
     * @memberof SourceBeta
     */
    'description'?: string;
    /**
     * 
     * @type {SourceOwnerBeta}
     * @memberof SourceBeta
     */
    'owner': SourceOwnerBeta;
    /**
     * 
     * @type {SourceClusterBeta}
     * @memberof SourceBeta
     */
    'cluster'?: SourceClusterBeta;
    /**
     * 
     * @type {SourceAccountCorrelationConfigBeta}
     * @memberof SourceBeta
     */
    'accountCorrelationConfig'?: SourceAccountCorrelationConfigBeta;
    /**
     * 
     * @type {SourceAccountCorrelationRuleBeta}
     * @memberof SourceBeta
     */
    'accountCorrelationRule'?: SourceAccountCorrelationRuleBeta;
    /**
     * 
     * @type {ManagerCorrelationMappingBeta}
     * @memberof SourceBeta
     */
    'managerCorrelationMapping'?: ManagerCorrelationMappingBeta;
    /**
     * 
     * @type {SourceManagerCorrelationRuleBeta}
     * @memberof SourceBeta
     */
    'managerCorrelationRule'?: SourceManagerCorrelationRuleBeta;
    /**
     * 
     * @type {SourceBeforeProvisioningRuleBeta}
     * @memberof SourceBeta
     */
    'beforeProvisioningRule'?: SourceBeforeProvisioningRuleBeta;
    /**
     * List of references to Schema objects
     * @type {Array<SourceSchemasInnerBeta>}
     * @memberof SourceBeta
     */
    'schemas'?: Array<SourceSchemasInnerBeta>;
    /**
     * List of references to the associated PasswordPolicy objects.
     * @type {Array<SourcePasswordPoliciesInnerBeta>}
     * @memberof SourceBeta
     */
    'passwordPolicies'?: Array<SourcePasswordPoliciesInnerBeta>;
    /**
     * Optional features that can be supported by a source.
     * @type {Array<SourceFeatureBeta>}
     * @memberof SourceBeta
     */
    'features'?: Array<SourceFeatureBeta>;
    /**
     * Specifies the type of system being managed e.g. Active Directory, Workday, etc.. If you are creating a Delimited File source, you must set the `provisionasCsv` query parameter to `true`. 
     * @type {string}
     * @memberof SourceBeta
     */
    'type'?: string;
    /**
     * Connector script name.
     * @type {string}
     * @memberof SourceBeta
     */
    'connector': string;
    /**
     * The fully qualified name of the Java class that implements the connector interface.
     * @type {string}
     * @memberof SourceBeta
     */
    'connectorClass'?: string;
    /**
     * Connector specific configuration; will differ from type to type.
     * @type {object}
     * @memberof SourceBeta
     */
    'connectorAttributes'?: object;
    /**
     * Number from 0 to 100 that specifies when to skip the delete phase.
     * @type {number}
     * @memberof SourceBeta
     */
    'deleteThreshold'?: number;
    /**
     * When true indicates the source is referenced by an IdentityProfile.
     * @type {boolean}
     * @memberof SourceBeta
     */
    'authoritative'?: boolean;
    /**
     * 
     * @type {SourceManagementWorkgroupBeta}
     * @memberof SourceBeta
     */
    'managementWorkgroup'?: SourceManagementWorkgroupBeta;
    /**
     * When true indicates a healthy source
     * @type {boolean}
     * @memberof SourceBeta
     */
    'healthy'?: boolean;
    /**
     * A status identifier, giving specific information on why a source is healthy or not
     * @type {string}
     * @memberof SourceBeta
     */
    'status'?: string;
    /**
     * Timestamp showing when a source health check was last performed
     * @type {string}
     * @memberof SourceBeta
     */
    'since'?: string;
    /**
     * The id of connector
     * @type {string}
     * @memberof SourceBeta
     */
    'connectorId'?: string;
    /**
     * The name of the connector that was chosen on source creation
     * @type {string}
     * @memberof SourceBeta
     */
    'connectorName'?: string;
    /**
     * The type of connection (direct or file)
     * @type {string}
     * @memberof SourceBeta
     */
    'connectionType'?: string;
    /**
     * The connector implementstion id
     * @type {string}
     * @memberof SourceBeta
     */
    'connectorImplementstionId'?: string;
}
/**
 * Reference to the associated Cluster
 * @export
 * @interface SourceClusterBeta
 */
export interface SourceClusterBeta {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceClusterBeta
     */
    'type'?: SourceClusterBetaTypeEnum;
    /**
     * ID of the cluster
     * @type {string}
     * @memberof SourceClusterBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of the cluster
     * @type {string}
     * @memberof SourceClusterBeta
     */
    'name'?: string;
}

export const SourceClusterBetaTypeEnum = {
    Cluster: 'CLUSTER'
} as const;

export type SourceClusterBetaTypeEnum = typeof SourceClusterBetaTypeEnum[keyof typeof SourceClusterBetaTypeEnum];

/**
 * SourceCode
 * @export
 * @interface SourceCodeBeta
 */
export interface SourceCodeBeta {
    /**
     * the version of the code
     * @type {string}
     * @memberof SourceCodeBeta
     */
    'version': string;
    /**
     * The code
     * @type {string}
     * @memberof SourceCodeBeta
     */
    'script': string;
}
/**
 * The identity that created the source.
 * @export
 * @interface SourceCreatedActorBeta
 */
export interface SourceCreatedActorBeta {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof SourceCreatedActorBeta
     */
    'type': SourceCreatedActorBetaTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof SourceCreatedActorBeta
     */
    'id': string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof SourceCreatedActorBeta
     */
    'name': string;
}

export const SourceCreatedActorBetaTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type SourceCreatedActorBetaTypeEnum = typeof SourceCreatedActorBetaTypeEnum[keyof typeof SourceCreatedActorBetaTypeEnum];

/**
 * 
 * @export
 * @interface SourceCreatedBeta
 */
export interface SourceCreatedBeta {
    /**
     * The unique ID of the source.
     * @type {string}
     * @memberof SourceCreatedBeta
     */
    'id': string;
    /**
     * Human friendly name of the source.
     * @type {string}
     * @memberof SourceCreatedBeta
     */
    'name': string;
    /**
     * The connection type.
     * @type {string}
     * @memberof SourceCreatedBeta
     */
    'type': string;
    /**
     * The date and time the source was created.
     * @type {string}
     * @memberof SourceCreatedBeta
     */
    'created': string;
    /**
     * The connector type used to connect to the source.
     * @type {string}
     * @memberof SourceCreatedBeta
     */
    'connector': string;
    /**
     * 
     * @type {SourceCreatedActorBeta}
     * @memberof SourceCreatedBeta
     */
    'actor': SourceCreatedActorBeta;
}
/**
 * The identity that deleted the source.
 * @export
 * @interface SourceDeletedActorBeta
 */
export interface SourceDeletedActorBeta {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof SourceDeletedActorBeta
     */
    'type': SourceDeletedActorBetaTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof SourceDeletedActorBeta
     */
    'id': string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof SourceDeletedActorBeta
     */
    'name': string;
}

export const SourceDeletedActorBetaTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type SourceDeletedActorBetaTypeEnum = typeof SourceDeletedActorBetaTypeEnum[keyof typeof SourceDeletedActorBetaTypeEnum];

/**
 * 
 * @export
 * @interface SourceDeletedBeta
 */
export interface SourceDeletedBeta {
    /**
     * The unique ID of the source.
     * @type {string}
     * @memberof SourceDeletedBeta
     */
    'id': string;
    /**
     * Human friendly name of the source.
     * @type {string}
     * @memberof SourceDeletedBeta
     */
    'name': string;
    /**
     * The connection type.
     * @type {string}
     * @memberof SourceDeletedBeta
     */
    'type': string;
    /**
     * The date and time the source was deleted.
     * @type {string}
     * @memberof SourceDeletedBeta
     */
    'deleted': string;
    /**
     * The connector type used to connect to the source.
     * @type {string}
     * @memberof SourceDeletedBeta
     */
    'connector': string;
    /**
     * 
     * @type {SourceDeletedActorBeta}
     * @memberof SourceDeletedBeta
     */
    'actor': SourceDeletedActorBeta;
}
/**
 * Entitlement Request Configuration
 * @export
 * @interface SourceEntitlementRequestConfigBeta
 */
export interface SourceEntitlementRequestConfigBeta {
    /**
     * 
     * @type {EntitlementAccessRequestConfigBeta}
     * @memberof SourceEntitlementRequestConfigBeta
     */
    'accessRequestConfig'?: EntitlementAccessRequestConfigBeta;
}
/**
 * Optional features that can be supported by an source. * AUTHENTICATE: The source supports pass-through authentication. * COMPOSITE: The source supports composite source creation. * DIRECT_PERMISSIONS: The source supports returning DirectPermissions. * DISCOVER_SCHEMA: The source supports discovering schemas for users and groups. * ENABLE The source supports reading if an account is enabled or disabled. * MANAGER_LOOKUP: The source supports looking up managers as they are encountered in a feed. This is the opposite of NO_RANDOM_ACCESS. * NO_RANDOM_ACCESS: The source does not support random access and the getObject() methods should not be called and expected to perform. * PROXY: The source can serve as a proxy for another source. When an source has a proxy, all connector calls made with that source are redirected through the connector for the proxy source. * SEARCH * TEMPLATE * UNLOCK: The source supports reading if an account is locked or unlocked. * UNSTRUCTURED_TARGETS: The source supports returning unstructured Targets. * SHAREPOINT_TARGET: The source supports returning unstructured Target data for SharePoint. It will be typically used by AD, LDAP sources. * PROVISIONING: The source can both read and write accounts. Having this feature implies that the provision() method is implemented. It also means that direct and target permissions can also be provisioned if they can be returned by aggregation. * GROUP_PROVISIONING: The source can both read and write groups. Having this feature implies that the provision() method is implemented. * SYNC_PROVISIONING: The source can provision accounts synchronously. * PASSWORD: The source can provision password changes. Since sources can never read passwords, this is should only be used in conjunction with the PROVISIONING feature. * CURRENT_PASSWORD: Some source types support verification of the current password * ACCOUNT_ONLY_REQUEST: The source supports requesting accounts without entitlements. * ADDITIONAL_ACCOUNT_REQUEST: The source supports requesting additional accounts. * NO_AGGREGATION: A source that does not support aggregation. * GROUPS_HAVE_MEMBERS: The source models group memberships with a member attribute on the group object rather than a groups attribute on the account object. This effects the implementation of delta account aggregation. * NO_PERMISSIONS_PROVISIONING: Indicates that the connector cannot provision direct or target permissions for accounts. When DIRECT_PERMISSIONS and PROVISIONING features are present, it is assumed that the connector can also provision direct permissions. This feature disables that assumption and causes permission request to be converted to work items for accounts. * NO_GROUP_PERMISSIONS_PROVISIONING: Indicates that the connector cannot provision direct or target permissions for groups. When DIRECT_PERMISSIONS and PROVISIONING features are present, it is assumed that the connector can also provision direct permissions. This feature disables that assumption and causes permission request to be converted to work items for groups. * NO_UNSTRUCTURED_TARGETS_PROVISIONING: This string will be replaced by NO_GROUP_PERMISSIONS_PROVISIONING and NO_PERMISSIONS_PROVISIONING. * NO_DIRECT_PERMISSIONS_PROVISIONING: This string will be replaced by NO_GROUP_PERMISSIONS_PROVISIONING and NO_PERMISSIONS_PROVISIONING.
 * @export
 * @enum {string}
 */

export const SourceFeatureBeta = {
    Authenticate: 'AUTHENTICATE',
    Composite: 'COMPOSITE',
    DirectPermissions: 'DIRECT_PERMISSIONS',
    DiscoverSchema: 'DISCOVER_SCHEMA',
    Enable: 'ENABLE',
    ManagerLookup: 'MANAGER_LOOKUP',
    NoRandomAccess: 'NO_RANDOM_ACCESS',
    Proxy: 'PROXY',
    Search: 'SEARCH',
    Template: 'TEMPLATE',
    Unlock: 'UNLOCK',
    UnstructuredTargets: 'UNSTRUCTURED_TARGETS',
    SharepointTarget: 'SHAREPOINT_TARGET',
    Provisioning: 'PROVISIONING',
    GroupProvisioning: 'GROUP_PROVISIONING',
    SyncProvisioning: 'SYNC_PROVISIONING',
    Password: 'PASSWORD',
    CurrentPassword: 'CURRENT_PASSWORD',
    AccountOnlyRequest: 'ACCOUNT_ONLY_REQUEST',
    AdditionalAccountRequest: 'ADDITIONAL_ACCOUNT_REQUEST',
    NoAggregation: 'NO_AGGREGATION',
    GroupsHaveMembers: 'GROUPS_HAVE_MEMBERS',
    NoPermissionsProvisioning: 'NO_PERMISSIONS_PROVISIONING',
    NoGroupPermissionsProvisioning: 'NO_GROUP_PERMISSIONS_PROVISIONING',
    NoUnstructuredTargetsProvisioning: 'NO_UNSTRUCTURED_TARGETS_PROVISIONING',
    NoDirectPermissionsProvisioning: 'NO_DIRECT_PERMISSIONS_PROVISIONING'
} as const;

export type SourceFeatureBeta = typeof SourceFeatureBeta[keyof typeof SourceFeatureBeta];


/**
 * Reference to Management Workgroup for this Source
 * @export
 * @interface SourceManagementWorkgroupBeta
 */
export interface SourceManagementWorkgroupBeta {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceManagementWorkgroupBeta
     */
    'type'?: SourceManagementWorkgroupBetaTypeEnum;
    /**
     * ID of the management workgroup
     * @type {string}
     * @memberof SourceManagementWorkgroupBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of the management workgroup
     * @type {string}
     * @memberof SourceManagementWorkgroupBeta
     */
    'name'?: string;
}

export const SourceManagementWorkgroupBetaTypeEnum = {
    GovernanceGroup: 'GOVERNANCE_GROUP'
} as const;

export type SourceManagementWorkgroupBetaTypeEnum = typeof SourceManagementWorkgroupBetaTypeEnum[keyof typeof SourceManagementWorkgroupBetaTypeEnum];

/**
 * Reference to the ManagerCorrelationRule, only used when a simple filter isn\'t sufficient.
 * @export
 * @interface SourceManagerCorrelationRuleBeta
 */
export interface SourceManagerCorrelationRuleBeta {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceManagerCorrelationRuleBeta
     */
    'type'?: SourceManagerCorrelationRuleBetaTypeEnum;
    /**
     * ID of the rule
     * @type {string}
     * @memberof SourceManagerCorrelationRuleBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of the rule
     * @type {string}
     * @memberof SourceManagerCorrelationRuleBeta
     */
    'name'?: string;
}

export const SourceManagerCorrelationRuleBetaTypeEnum = {
    Rule: 'RULE'
} as const;

export type SourceManagerCorrelationRuleBetaTypeEnum = typeof SourceManagerCorrelationRuleBetaTypeEnum[keyof typeof SourceManagerCorrelationRuleBetaTypeEnum];

/**
 * Reference to an owning Identity Object
 * @export
 * @interface SourceOwnerBeta
 */
export interface SourceOwnerBeta {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceOwnerBeta
     */
    'type'?: SourceOwnerBetaTypeEnum;
    /**
     * ID of the identity
     * @type {string}
     * @memberof SourceOwnerBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of the identity
     * @type {string}
     * @memberof SourceOwnerBeta
     */
    'name'?: string;
}

export const SourceOwnerBetaTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type SourceOwnerBetaTypeEnum = typeof SourceOwnerBetaTypeEnum[keyof typeof SourceOwnerBetaTypeEnum];

/**
 * 
 * @export
 * @interface SourcePasswordPoliciesInnerBeta
 */
export interface SourcePasswordPoliciesInnerBeta {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourcePasswordPoliciesInnerBeta
     */
    'type'?: SourcePasswordPoliciesInnerBetaTypeEnum;
    /**
     * ID of the policy
     * @type {string}
     * @memberof SourcePasswordPoliciesInnerBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of the policy
     * @type {string}
     * @memberof SourcePasswordPoliciesInnerBeta
     */
    'name'?: string;
}

export const SourcePasswordPoliciesInnerBetaTypeEnum = {
    PasswordPolicy: 'PASSWORD_POLICY'
} as const;

export type SourcePasswordPoliciesInnerBetaTypeEnum = typeof SourcePasswordPoliciesInnerBetaTypeEnum[keyof typeof SourcePasswordPoliciesInnerBetaTypeEnum];

/**
 * 
 * @export
 * @interface SourceSchemasInnerBeta
 */
export interface SourceSchemasInnerBeta {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceSchemasInnerBeta
     */
    'type'?: SourceSchemasInnerBetaTypeEnum;
    /**
     * ID of the schema
     * @type {string}
     * @memberof SourceSchemasInnerBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of the schema
     * @type {string}
     * @memberof SourceSchemasInnerBeta
     */
    'name'?: string;
}

export const SourceSchemasInnerBetaTypeEnum = {
    ConnectorSchema: 'CONNECTOR_SCHEMA'
} as const;

export type SourceSchemasInnerBetaTypeEnum = typeof SourceSchemasInnerBetaTypeEnum[keyof typeof SourceSchemasInnerBetaTypeEnum];

/**
 * 
 * @export
 * @interface SourceSyncJobBeta
 */
export interface SourceSyncJobBeta {
    /**
     * Job ID.
     * @type {string}
     * @memberof SourceSyncJobBeta
     */
    'id': string;
    /**
     * The job status.
     * @type {string}
     * @memberof SourceSyncJobBeta
     */
    'status': SourceSyncJobBetaStatusEnum;
    /**
     * 
     * @type {SourceSyncPayloadBeta}
     * @memberof SourceSyncJobBeta
     */
    'payload': SourceSyncPayloadBeta;
}

export const SourceSyncJobBetaStatusEnum = {
    Queued: 'QUEUED',
    InProgress: 'IN_PROGRESS',
    Success: 'SUCCESS',
    Error: 'ERROR'
} as const;

export type SourceSyncJobBetaStatusEnum = typeof SourceSyncJobBetaStatusEnum[keyof typeof SourceSyncJobBetaStatusEnum];

/**
 * 
 * @export
 * @interface SourceSyncPayloadBeta
 */
export interface SourceSyncPayloadBeta {
    /**
     * Payload type.
     * @type {string}
     * @memberof SourceSyncPayloadBeta
     */
    'type': string;
    /**
     * Payload type.
     * @type {string}
     * @memberof SourceSyncPayloadBeta
     */
    'dataJson': string;
}
/**
 * The identity or system that performed the update.
 * @export
 * @interface SourceUpdatedActorBeta
 */
export interface SourceUpdatedActorBeta {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof SourceUpdatedActorBeta
     */
    'type': SourceUpdatedActorBetaTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof SourceUpdatedActorBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof SourceUpdatedActorBeta
     */
    'name': string;
}

export const SourceUpdatedActorBetaTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type SourceUpdatedActorBetaTypeEnum = typeof SourceUpdatedActorBetaTypeEnum[keyof typeof SourceUpdatedActorBetaTypeEnum];

/**
 * 
 * @export
 * @interface SourceUpdatedBeta
 */
export interface SourceUpdatedBeta {
    /**
     * The unique ID of the source.
     * @type {string}
     * @memberof SourceUpdatedBeta
     */
    'id': string;
    /**
     * The user friendly name of the source.
     * @type {string}
     * @memberof SourceUpdatedBeta
     */
    'name': string;
    /**
     * The connection type of the source.
     * @type {string}
     * @memberof SourceUpdatedBeta
     */
    'type': string;
    /**
     * The date and time the source was modified.
     * @type {string}
     * @memberof SourceUpdatedBeta
     */
    'modified': string;
    /**
     * The connector type used to connect to the source.
     * @type {string}
     * @memberof SourceUpdatedBeta
     */
    'connector': string;
    /**
     * 
     * @type {SourceUpdatedActorBeta}
     * @memberof SourceUpdatedBeta
     */
    'actor': SourceUpdatedActorBeta;
}
/**
 * Response model for config export download response.
 * @export
 * @interface SpConfigExportResultsBeta
 */
export interface SpConfigExportResultsBeta {
    /**
     * Current version of the export results object.
     * @type {number}
     * @memberof SpConfigExportResultsBeta
     */
    'version'?: number;
    /**
     * Time the export was completed.
     * @type {string}
     * @memberof SpConfigExportResultsBeta
     */
    'timestamp'?: string;
    /**
     * Name of the tenant where this export originated.
     * @type {string}
     * @memberof SpConfigExportResultsBeta
     */
    'tenant'?: string;
    /**
     * Optional user defined description/name for export job.
     * @type {string}
     * @memberof SpConfigExportResultsBeta
     */
    'description'?: string;
    /**
     * 
     * @type {ExportOptionsBeta}
     * @memberof SpConfigExportResultsBeta
     */
    'options'?: ExportOptionsBeta;
    /**
     * 
     * @type {Array<ConfigObjectBeta>}
     * @memberof SpConfigExportResultsBeta
     */
    'objects'?: Array<ConfigObjectBeta>;
}
/**
 * Response Body for Config Import command.
 * @export
 * @interface SpConfigImportResultsBeta
 */
export interface SpConfigImportResultsBeta {
    /**
     * The results of an object configuration import job.
     * @type {{ [key: string]: ObjectImportResultBeta; }}
     * @memberof SpConfigImportResultsBeta
     */
    'results': { [key: string]: ObjectImportResultBeta; };
    /**
     * If a backup was performed before the import, this will contain the jobId of the backup job. This id can be used to retrieve the json file of the backup export.
     * @type {string}
     * @memberof SpConfigImportResultsBeta
     */
    'exportJobId'?: string;
}
/**
 * 
 * @export
 * @interface SpConfigJobBeta
 */
export interface SpConfigJobBeta {
    /**
     * Unique id assigned to this job.
     * @type {string}
     * @memberof SpConfigJobBeta
     */
    'jobId': string;
    /**
     * Status of the job.
     * @type {string}
     * @memberof SpConfigJobBeta
     */
    'status': SpConfigJobBetaStatusEnum;
    /**
     * Type of the job, either export or import.
     * @type {string}
     * @memberof SpConfigJobBeta
     */
    'type': SpConfigJobBetaTypeEnum;
    /**
     * This message contains additional information about the overall status of the job.
     * @type {string}
     * @memberof SpConfigJobBeta
     */
    'message': string;
    /**
     * Optional user defined description/name for export job.
     * @type {string}
     * @memberof SpConfigJobBeta
     */
    'description': string;
    /**
     * The time until which the artifacts will be available for download.
     * @type {string}
     * @memberof SpConfigJobBeta
     */
    'expiration': string;
    /**
     * The time the job was started.
     * @type {string}
     * @memberof SpConfigJobBeta
     */
    'created': string;
    /**
     * The time of the last update to the job.
     * @type {string}
     * @memberof SpConfigJobBeta
     */
    'modified': string;
    /**
     * The time the job was completed.
     * @type {string}
     * @memberof SpConfigJobBeta
     */
    'completed': string;
}

export const SpConfigJobBetaStatusEnum = {
    NotStarted: 'NOT_STARTED',
    InProgress: 'IN_PROGRESS',
    Complete: 'COMPLETE',
    Cancelled: 'CANCELLED',
    Failed: 'FAILED'
} as const;

export type SpConfigJobBetaStatusEnum = typeof SpConfigJobBetaStatusEnum[keyof typeof SpConfigJobBetaStatusEnum];
export const SpConfigJobBetaTypeEnum = {
    Export: 'EXPORT',
    Import: 'IMPORT'
} as const;

export type SpConfigJobBetaTypeEnum = typeof SpConfigJobBetaTypeEnum[keyof typeof SpConfigJobBetaTypeEnum];

/**
 * Message model for Config Import/Export.
 * @export
 * @interface SpConfigMessageBeta
 */
export interface SpConfigMessageBeta {
    /**
     * Message key.
     * @type {string}
     * @memberof SpConfigMessageBeta
     */
    'key': string;
    /**
     * Message text.
     * @type {string}
     * @memberof SpConfigMessageBeta
     */
    'text': string;
    /**
     * Message details if any, in key:value pairs.
     * @type {{ [key: string]: object; }}
     * @memberof SpConfigMessageBeta
     */
    'details': { [key: string]: object; };
}
/**
 * Response model for get object configuration.
 * @export
 * @interface SpConfigObjectBeta
 */
export interface SpConfigObjectBeta {
    /**
     * The object type this configuration is for.
     * @type {string}
     * @memberof SpConfigObjectBeta
     */
    'objectType'?: string;
    /**
     * 
     * @type {SpConfigUrlBeta}
     * @memberof SpConfigObjectBeta
     */
    'resolveByIdUrl'?: SpConfigUrlBeta;
    /**
     * Url and query parameters to be used to resolve this type of object by name.
     * @type {Array<SpConfigUrlBeta>}
     * @memberof SpConfigObjectBeta
     */
    'resolveByNameUrl'?: Array<SpConfigUrlBeta>;
    /**
     * 
     * @type {SpConfigUrlBeta}
     * @memberof SpConfigObjectBeta
     */
    'exportUrl'?: SpConfigUrlBeta;
    /**
     * Rights needed by the invoker of sp-config/export in order to export this type of object.
     * @type {string}
     * @memberof SpConfigObjectBeta
     */
    'exportRight'?: string;
    /**
     * Pagination limit imposed by the target service for this object type.
     * @type {number}
     * @memberof SpConfigObjectBeta
     */
    'exportLimit'?: number;
    /**
     * 
     * @type {SpConfigUrlBeta}
     * @memberof SpConfigObjectBeta
     */
    'importUrl'?: SpConfigUrlBeta;
    /**
     * Rights needed by the invoker of sp-config/import in order to import this type of object.
     * @type {string}
     * @memberof SpConfigObjectBeta
     */
    'importRight'?: string;
    /**
     * Pagination limit imposed by the target service for this object type.
     * @type {number}
     * @memberof SpConfigObjectBeta
     */
    'importLimit'?: number;
    /**
     * List of json paths within an exported object of this type that represent references that need to be resolved.
     * @type {Array<string>}
     * @memberof SpConfigObjectBeta
     */
    'referenceExtractors'?: Array<string> | null;
    /**
     * If true, this type of object will be JWS signed and cannot be modified before import.
     * @type {boolean}
     * @memberof SpConfigObjectBeta
     */
    'signatureRequired'?: boolean;
}
/**
 * Format of resolver URLs for Object Configurations
 * @export
 * @interface SpConfigUrlBeta
 */
export interface SpConfigUrlBeta {
    /**
     * URL for the target object endpoint.
     * @type {string}
     * @memberof SpConfigUrlBeta
     */
    'url'?: string;
    /**
     * Any query parameters that are needed for the URL.
     * @type {object}
     * @memberof SpConfigUrlBeta
     */
    'query'?: object | null;
}
/**
 * Standard Log4j log level
 * @export
 * @enum {string}
 */

export const StandardLevelBeta = {
    False: 'false',
    Fatal: 'FATAL',
    Error: 'ERROR',
    Warn: 'WARN',
    Info: 'INFO',
    Debug: 'DEBUG',
    Trace: 'TRACE'
} as const;

export type StandardLevelBeta = typeof StandardLevelBeta[keyof typeof StandardLevelBeta];


/**
 * 
 * @export
 * @interface StartInvocationInputBeta
 */
export interface StartInvocationInputBeta {
    /**
     * Trigger ID
     * @type {string}
     * @memberof StartInvocationInputBeta
     */
    'triggerId'?: string;
    /**
     * Trigger input payload. Its schema is defined in the trigger definition.
     * @type {object}
     * @memberof StartInvocationInputBeta
     */
    'input'?: object;
    /**
     * JSON map of invocation metadata
     * @type {object}
     * @memberof StartInvocationInputBeta
     */
    'contentJson'?: object;
}
/**
 * Response model for connection check, configuration test and ping of source connectors.
 * @export
 * @interface StatusResponseBeta
 */
export interface StatusResponseBeta {
    /**
     * ID of the source
     * @type {string}
     * @memberof StatusResponseBeta
     */
    'id'?: string;
    /**
     * Name of the source
     * @type {string}
     * @memberof StatusResponseBeta
     */
    'name'?: string;
    /**
     * The status of the health check.
     * @type {string}
     * @memberof StatusResponseBeta
     */
    'status'?: StatusResponseBetaStatusEnum;
    /**
     * The number of milliseconds spent on the entire request.
     * @type {number}
     * @memberof StatusResponseBeta
     */
    'elapsedMillis'?: number;
    /**
     * The document contains the results of the health check. The schema of this document depends on the type of source used. 
     * @type {object}
     * @memberof StatusResponseBeta
     */
    'details'?: object;
}

export const StatusResponseBetaStatusEnum = {
    Success: 'SUCCESS',
    Failure: 'FAILURE'
} as const;

export type StatusResponseBetaStatusEnum = typeof StatusResponseBetaStatusEnum[keyof typeof StatusResponseBetaStatusEnum];

/**
 * 
 * @export
 * @interface SubscriptionBeta
 */
export interface SubscriptionBeta {
    /**
     * Subscription ID.
     * @type {string}
     * @memberof SubscriptionBeta
     */
    'id': string;
    /**
     * Subscription name.
     * @type {string}
     * @memberof SubscriptionBeta
     */
    'name': string;
    /**
     * Subscription description.
     * @type {string}
     * @memberof SubscriptionBeta
     */
    'description'?: string;
    /**
     * ID of trigger subscribed to.
     * @type {string}
     * @memberof SubscriptionBeta
     */
    'triggerId': string;
    /**
     * Trigger name of trigger subscribed to.
     * @type {string}
     * @memberof SubscriptionBeta
     */
    'triggerName': string;
    /**
     * 
     * @type {SubscriptionTypeBeta}
     * @memberof SubscriptionBeta
     */
    'type': SubscriptionTypeBeta;
    /**
     * Deadline for completing REQUEST_RESPONSE trigger invocation, represented in ISO-8601 duration format.
     * @type {string}
     * @memberof SubscriptionBeta
     */
    'responseDeadline': string;
    /**
     * 
     * @type {HttpConfigBeta}
     * @memberof SubscriptionBeta
     */
    'httpConfig'?: HttpConfigBeta;
    /**
     * 
     * @type {EventBridgeConfigBeta}
     * @memberof SubscriptionBeta
     */
    'eventBridgeConfig'?: EventBridgeConfigBeta;
    /**
     * Whether subscription should receive real-time trigger invocations or not. Test trigger invocations are always enabled regardless of this option.
     * @type {boolean}
     * @memberof SubscriptionBeta
     */
    'enabled': boolean;
    /**
     * JSONPath filter to conditionally invoke trigger when expression evaluates to true.
     * @type {string}
     * @memberof SubscriptionBeta
     */
    'filter'?: string;
}
/**
 * A JSONPatch Operation as defined by [RFC 6902 - JSON Patch](https://tools.ietf.org/html/rfc6902)
 * @export
 * @interface SubscriptionPatchRequestInnerBeta
 */
export interface SubscriptionPatchRequestInnerBeta {
    /**
     * The operation to be performed
     * @type {string}
     * @memberof SubscriptionPatchRequestInnerBeta
     */
    'op': SubscriptionPatchRequestInnerBetaOpEnum;
    /**
     * A string JSON Pointer representing the target path to an element to be affected by the operation
     * @type {string}
     * @memberof SubscriptionPatchRequestInnerBeta
     */
    'path': string;
    /**
     * 
     * @type {JsonPatchOperationValueBeta}
     * @memberof SubscriptionPatchRequestInnerBeta
     */
    'value'?: JsonPatchOperationValueBeta;
}

export const SubscriptionPatchRequestInnerBetaOpEnum = {
    Add: 'add',
    Remove: 'remove',
    Replace: 'replace',
    Move: 'move',
    Copy: 'copy'
} as const;

export type SubscriptionPatchRequestInnerBetaOpEnum = typeof SubscriptionPatchRequestInnerBetaOpEnum[keyof typeof SubscriptionPatchRequestInnerBetaOpEnum];

/**
 * 
 * @export
 * @interface SubscriptionPostRequestBeta
 */
export interface SubscriptionPostRequestBeta {
    /**
     * Subscription name.
     * @type {string}
     * @memberof SubscriptionPostRequestBeta
     */
    'name': string;
    /**
     * Subscription description.
     * @type {string}
     * @memberof SubscriptionPostRequestBeta
     */
    'description'?: string;
    /**
     * ID of trigger subscribed to.
     * @type {string}
     * @memberof SubscriptionPostRequestBeta
     */
    'triggerId': string;
    /**
     * 
     * @type {SubscriptionTypeBeta}
     * @memberof SubscriptionPostRequestBeta
     */
    'type': SubscriptionTypeBeta;
    /**
     * Deadline for completing REQUEST_RESPONSE trigger invocation, represented in ISO-8601 duration format.
     * @type {string}
     * @memberof SubscriptionPostRequestBeta
     */
    'responseDeadline'?: string;
    /**
     * 
     * @type {HttpConfigBeta}
     * @memberof SubscriptionPostRequestBeta
     */
    'httpConfig'?: HttpConfigBeta;
    /**
     * 
     * @type {EventBridgeConfigBeta}
     * @memberof SubscriptionPostRequestBeta
     */
    'eventBridgeConfig'?: EventBridgeConfigBeta;
    /**
     * Whether subscription should receive real-time trigger invocations or not.  Test trigger invocations are always enabled regardless of this option.
     * @type {boolean}
     * @memberof SubscriptionPostRequestBeta
     */
    'enabled'?: boolean;
    /**
     * JSONPath filter to conditionally invoke trigger when expression evaluates to true.
     * @type {string}
     * @memberof SubscriptionPostRequestBeta
     */
    'filter'?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionPutRequestBeta
 */
export interface SubscriptionPutRequestBeta {
    /**
     * Subscription name.
     * @type {string}
     * @memberof SubscriptionPutRequestBeta
     */
    'name'?: string;
    /**
     * Subscription description.
     * @type {string}
     * @memberof SubscriptionPutRequestBeta
     */
    'description'?: string;
    /**
     * 
     * @type {SubscriptionTypeBeta}
     * @memberof SubscriptionPutRequestBeta
     */
    'type'?: SubscriptionTypeBeta;
    /**
     * Deadline for completing REQUEST_RESPONSE trigger invocation, represented in ISO-8601 duration format.
     * @type {string}
     * @memberof SubscriptionPutRequestBeta
     */
    'responseDeadline'?: string;
    /**
     * 
     * @type {HttpConfigBeta}
     * @memberof SubscriptionPutRequestBeta
     */
    'httpConfig'?: HttpConfigBeta;
    /**
     * 
     * @type {EventBridgeConfigBeta}
     * @memberof SubscriptionPutRequestBeta
     */
    'eventBridgeConfig'?: EventBridgeConfigBeta;
    /**
     * Whether subscription should receive real-time trigger invocations or not.  Test trigger invocations are always enabled regardless of this option.
     * @type {boolean}
     * @memberof SubscriptionPutRequestBeta
     */
    'enabled'?: boolean;
    /**
     * JSONPath filter to conditionally invoke trigger when expression evaluates to true.
     * @type {string}
     * @memberof SubscriptionPutRequestBeta
     */
    'filter'?: string;
}
/**
 * Subscription type. **NOTE** If type is EVENTBRIDGE, then eventBridgeConfig is required. If type is HTTP, then httpConfig is required.
 * @export
 * @enum {string}
 */

export const SubscriptionTypeBeta = {
    Http: 'HTTP',
    Eventbridge: 'EVENTBRIDGE',
    Inline: 'INLINE',
    Script: 'SCRIPT',
    Workflow: 'WORKFLOW'
} as const;

export type SubscriptionTypeBeta = typeof SubscriptionTypeBeta[keyof typeof SubscriptionTypeBeta];


/**
 * 
 * @export
 * @interface TaggedObjectBeta
 */
export interface TaggedObjectBeta {
    /**
     * 
     * @type {BaseReferenceDto1Beta}
     * @memberof TaggedObjectBeta
     */
    'objectRef'?: BaseReferenceDto1Beta;
    /**
     * Labels to be applied to an Object
     * @type {Array<string>}
     * @memberof TaggedObjectBeta
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TemplateBulkDeleteDtoBeta
 */
export interface TemplateBulkDeleteDtoBeta {
    /**
     * 
     * @type {string}
     * @memberof TemplateBulkDeleteDtoBeta
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateBulkDeleteDtoBeta
     */
    'medium'?: TemplateBulkDeleteDtoBetaMediumEnum;
    /**
     * The locale for the message text, a BCP 47 language tag.
     * @type {string}
     * @memberof TemplateBulkDeleteDtoBeta
     */
    'locale'?: string;
}

export const TemplateBulkDeleteDtoBetaMediumEnum = {
    Email: 'EMAIL',
    Phone: 'PHONE',
    Sms: 'SMS'
} as const;

export type TemplateBulkDeleteDtoBetaMediumEnum = typeof TemplateBulkDeleteDtoBetaMediumEnum[keyof typeof TemplateBulkDeleteDtoBetaMediumEnum];

/**
 * 
 * @export
 * @interface TemplateDtoBeta
 */
export interface TemplateDtoBeta {
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoBeta
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoBeta
     */
    'name'?: string;
    /**
     * The message medium. More mediums may be added in the future.
     * @type {string}
     * @memberof TemplateDtoBeta
     */
    'medium': TemplateDtoBetaMediumEnum;
    /**
     * The locale for the message text, a BCP 47 language tag.
     * @type {string}
     * @memberof TemplateDtoBeta
     */
    'locale': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoBeta
     */
    'subject'?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoBeta
     */
    'header'?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoBeta
     */
    'body'?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoBeta
     */
    'footer'?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoBeta
     */
    'from'?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoBeta
     */
    'replyTo'?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoBeta
     */
    'description'?: string;
    /**
     * This is auto-generated.
     * @type {string}
     * @memberof TemplateDtoBeta
     */
    'id'?: string;
    /**
     * The time when this template is created. This is auto-generated.
     * @type {string}
     * @memberof TemplateDtoBeta
     */
    'created'?: string;
    /**
     * The time when this template was last modified. This is auto-generated.
     * @type {string}
     * @memberof TemplateDtoBeta
     */
    'modified'?: string;
}

export const TemplateDtoBetaMediumEnum = {
    Email: 'EMAIL',
    Phone: 'PHONE',
    Sms: 'SMS',
    Slack: 'SLACK',
    Teams: 'TEAMS'
} as const;

export type TemplateDtoBetaMediumEnum = typeof TemplateDtoBetaMediumEnum[keyof typeof TemplateDtoBetaMediumEnum];

/**
 * 
 * @export
 * @interface TemplateDtoDefaultBeta
 */
export interface TemplateDtoDefaultBeta {
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoDefaultBeta
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoDefaultBeta
     */
    'name'?: string;
    /**
     * The message medium. More mediums may be added in the future.
     * @type {string}
     * @memberof TemplateDtoDefaultBeta
     */
    'medium'?: TemplateDtoDefaultBetaMediumEnum;
    /**
     * The locale for the message text, a BCP 47 language tag.
     * @type {string}
     * @memberof TemplateDtoDefaultBeta
     */
    'locale'?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoDefaultBeta
     */
    'subject'?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoDefaultBeta
     */
    'header'?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoDefaultBeta
     */
    'body'?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoDefaultBeta
     */
    'footer'?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoDefaultBeta
     */
    'from'?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoDefaultBeta
     */
    'replyTo'?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoDefaultBeta
     */
    'description'?: string;
}

export const TemplateDtoDefaultBetaMediumEnum = {
    Email: 'EMAIL',
    Phone: 'PHONE',
    Sms: 'SMS',
    Slack: 'SLACK',
    Teams: 'TEAMS'
} as const;

export type TemplateDtoDefaultBetaMediumEnum = typeof TemplateDtoDefaultBetaMediumEnum[keyof typeof TemplateDtoDefaultBetaMediumEnum];

/**
 * Details of any tenant-wide Reassignment Configurations (eg. enabled/disabled)
 * @export
 * @interface TenantConfigurationDetailsBeta
 */
export interface TenantConfigurationDetailsBeta {
    /**
     * Flag to determine if Reassignment Configuration is enabled or disabled for a tenant.  When this flag is set to true, Reassignment Configuration is disabled.
     * @type {boolean}
     * @memberof TenantConfigurationDetailsBeta
     */
    'disabled'?: boolean | null;
}
/**
 * Tenant-wide Reassignment Configuration settings
 * @export
 * @interface TenantConfigurationRequestBeta
 */
export interface TenantConfigurationRequestBeta {
    /**
     * 
     * @type {TenantConfigurationDetailsBeta}
     * @memberof TenantConfigurationRequestBeta
     */
    'configDetails'?: TenantConfigurationDetailsBeta;
}
/**
 * Tenant-wide Reassignment Configuration settings
 * @export
 * @interface TenantConfigurationResponseBeta
 */
export interface TenantConfigurationResponseBeta {
    /**
     * 
     * @type {AuditDetailsBeta}
     * @memberof TenantConfigurationResponseBeta
     */
    'auditDetails'?: AuditDetailsBeta;
    /**
     * 
     * @type {TenantConfigurationDetailsBeta}
     * @memberof TenantConfigurationResponseBeta
     */
    'configDetails'?: TenantConfigurationDetailsBeta;
}
/**
 * 
 * @export
 * @interface TestExternalExecuteWorkflow200ResponseBeta
 */
export interface TestExternalExecuteWorkflow200ResponseBeta {
    /**
     * The input that was received
     * @type {object}
     * @memberof TestExternalExecuteWorkflow200ResponseBeta
     */
    'payload'?: object;
}
/**
 * 
 * @export
 * @interface TestExternalExecuteWorkflowRequestBeta
 */
export interface TestExternalExecuteWorkflowRequestBeta {
    /**
     * The test input for the workflow
     * @type {object}
     * @memberof TestExternalExecuteWorkflowRequestBeta
     */
    'input'?: object;
}
/**
 * 
 * @export
 * @interface TestInvocationBeta
 */
export interface TestInvocationBeta {
    /**
     * Trigger ID
     * @type {string}
     * @memberof TestInvocationBeta
     */
    'triggerId': string;
    /**
     * Mock input to use for test invocation.  This must adhere to the input schema defined in the trigger being invoked.  If this property is omitted, then the default trigger sample payload will be sent.
     * @type {object}
     * @memberof TestInvocationBeta
     */
    'input'?: object;
    /**
     * JSON map of invocation metadata.
     * @type {object}
     * @memberof TestInvocationBeta
     */
    'contentJson': object;
    /**
     * Only send the test event to the subscription IDs listed.  If omitted, the test event will be sent to all subscribers.
     * @type {Array<string>}
     * @memberof TestInvocationBeta
     */
    'subscriptionIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TestWorkflow200ResponseBeta
 */
export interface TestWorkflow200ResponseBeta {
    /**
     * The workflow execution id
     * @type {string}
     * @memberof TestWorkflow200ResponseBeta
     */
    'workflowExecutionId'?: string;
}
/**
 * 
 * @export
 * @interface TestWorkflowRequestBeta
 */
export interface TestWorkflowRequestBeta {
    /**
     * The test input for the workflow.
     * @type {object}
     * @memberof TestWorkflowRequestBeta
     */
    'input': object;
}
/**
 * DTO for representing an internally- or customer-defined transform.
 * @export
 * @interface TransformBeta
 */
export interface TransformBeta {
    /**
     * Unique ID of this transform
     * @type {string}
     * @memberof TransformBeta
     */
    'id'?: string;
    /**
     * Unique name of this transform
     * @type {string}
     * @memberof TransformBeta
     */
    'name': string;
    /**
     * The transform type (see [Transformations in IdentityNow Using Seaspray](https://community.sailpoint.com/docs/DOC-4629)).
     * @type {string}
     * @memberof TransformBeta
     */
    'type': string;
    /**
     * Meta-data about the transform. Values in this list are specific to the type of transform to be executed.
     * @type {object}
     * @memberof TransformBeta
     */
    'attributes': object | null;
    /**
     * Indicates whether this is an internal SailPoint-created transform or a customer-created transform
     * @type {boolean}
     * @memberof TransformBeta
     */
    'internal'?: boolean;
}
/**
 * 
 * @export
 * @interface TransformDefinition1AttributesValueBeta
 */
export interface TransformDefinition1AttributesValueBeta {
}
/**
 * 
 * @export
 * @interface TransformDefinition1Beta
 */
export interface TransformDefinition1Beta {
    /**
     * The type of the transform definition.
     * @type {string}
     * @memberof TransformDefinition1Beta
     */
    'type'?: string;
    /**
     * Arbitrary key-value pairs to store any metadata for the object
     * @type {{ [key: string]: TransformDefinition1AttributesValueBeta; }}
     * @memberof TransformDefinition1Beta
     */
    'attributes'?: { [key: string]: TransformDefinition1AttributesValueBeta; };
}
/**
 * 
 * @export
 * @interface TransformDefinitionBeta
 */
export interface TransformDefinitionBeta {
    /**
     * The type of the transform definition.
     * @type {string}
     * @memberof TransformDefinitionBeta
     */
    'type'?: string;
    /**
     * Arbitrary key-value pairs to store any metadata for the object
     * @type {{ [key: string]: any; }}
     * @memberof TransformDefinitionBeta
     */
    'attributes'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface TranslationMessageBeta
 */
export interface TranslationMessageBeta {
    /**
     * The key of the translation message
     * @type {string}
     * @memberof TranslationMessageBeta
     */
    'key'?: string;
    /**
     * The values corresponding to the translation messages
     * @type {Array<string>}
     * @memberof TranslationMessageBeta
     */
    'values'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TriggerBeta
 */
export interface TriggerBeta {
    /**
     * Unique identifier of the trigger.
     * @type {string}
     * @memberof TriggerBeta
     */
    'id': string;
    /**
     * Trigger Name.
     * @type {string}
     * @memberof TriggerBeta
     */
    'name': string;
    /**
     * 
     * @type {TriggerTypeBeta}
     * @memberof TriggerBeta
     */
    'type': TriggerTypeBeta;
    /**
     * Trigger Description.
     * @type {string}
     * @memberof TriggerBeta
     */
    'description'?: string;
    /**
     * The JSON schema of the payload that will be sent by the trigger to the subscribed service.
     * @type {string}
     * @memberof TriggerBeta
     */
    'inputSchema': string;
    /**
     * 
     * @type {TriggerExampleInputBeta}
     * @memberof TriggerBeta
     */
    'exampleInput': TriggerExampleInputBeta;
    /**
     * The JSON schema of the response that will be sent by the subscribed service to the trigger in response to an event.  This only applies to a trigger type of `REQUEST_RESPONSE`.
     * @type {string}
     * @memberof TriggerBeta
     */
    'outputSchema'?: string | null;
    /**
     * 
     * @type {TriggerExampleOutputBeta}
     * @memberof TriggerBeta
     */
    'exampleOutput'?: TriggerExampleOutputBeta | null;
}
/**
 * @type TriggerExampleInputBeta
 * An example of the JSON payload that will be sent by the trigger to the subscribed service.
 * @export
 */
export type TriggerExampleInputBeta = AccessRequestDynamicApproverBeta | AccessRequestPostApprovalBeta | AccessRequestPreApprovalBeta | AccountAggregationCompletedBeta | AccountAttributesChangedBeta | AccountCorrelatedBeta | AccountUncorrelatedBeta | AccountsCollectedForAggregationBeta | CampaignActivatedBeta | CampaignEndedBeta | CampaignGeneratedBeta | CertificationSignedOffBeta | IdentityAttributesChangedBeta | IdentityCreatedBeta | IdentityDeletedBeta | ProvisioningCompletedBeta | SavedSearchCompleteBeta | SourceAccountBeta | SourceCreatedBeta | SourceDeletedBeta | SourceUpdatedBeta | VAClusterStatusChangeEventBeta;

/**
 * @type TriggerExampleOutputBeta
 * An example of the JSON payload that will be sent by the subscribed service to the trigger in response to an event.
 * @export
 */
export type TriggerExampleOutputBeta = AccessRequestDynamicApprover1Beta | AccessRequestPreApproval1Beta;

/**
 * The type of trigger.
 * @export
 * @enum {string}
 */

export const TriggerTypeBeta = {
    RequestResponse: 'REQUEST_RESPONSE',
    FireAndForget: 'FIRE_AND_FORGET'
} as const;

export type TriggerTypeBeta = typeof TriggerTypeBeta[keyof typeof TriggerTypeBeta];


/**
 * 
 * @export
 * @interface UpdatePasswordDictionaryRequestBeta
 */
export interface UpdatePasswordDictionaryRequestBeta {
    /**
     * 
     * @type {any}
     * @memberof UpdatePasswordDictionaryRequestBeta
     */
    'file'?: any;
}
/**
 * The type of ProvisioningPolicy usage.
 * @export
 * @enum {string}
 */

export const UsageTypeBeta = {
    Create: 'CREATE',
    Update: 'UPDATE',
    Delete: 'DELETE',
    Assign: 'ASSIGN',
    Unassign: 'UNASSIGN',
    CreateGroup: 'CREATE_GROUP',
    UpdateGroup: 'UPDATE_GROUP',
    DeleteGroup: 'DELETE_GROUP',
    Register: 'REGISTER',
    CreateIdentity: 'CREATE_IDENTITY',
    UpdateIdentity: 'UPDATE_IDENTITY',
    EditGroup: 'EDIT_GROUP',
    Enable: 'ENABLE',
    Disable: 'DISABLE',
    Unlock: 'UNLOCK',
    ChangePassword: 'CHANGE_PASSWORD'
} as const;

export type UsageTypeBeta = typeof UsageTypeBeta[keyof typeof UsageTypeBeta];


/**
 * 
 * @export
 * @interface V3ConnectorDtoBeta
 */
export interface V3ConnectorDtoBeta {
    /**
     * The connector name
     * @type {string}
     * @memberof V3ConnectorDtoBeta
     */
    'name'?: string;
    /**
     * The connector type
     * @type {string}
     * @memberof V3ConnectorDtoBeta
     */
    'type'?: string;
    /**
     * The connector script name
     * @type {string}
     * @memberof V3ConnectorDtoBeta
     */
    'scriptName'?: string;
    /**
     * The list of features supported by the connector
     * @type {Array<string>}
     * @memberof V3ConnectorDtoBeta
     */
    'features'?: Array<string> | null;
    /**
     * true if the source is a direct connect source
     * @type {boolean}
     * @memberof V3ConnectorDtoBeta
     */
    'directConnect'?: boolean;
    /**
     * Object containing metadata pertinent to the UI to be used
     * @type {object}
     * @memberof V3ConnectorDtoBeta
     */
    'connectorMetadata'?: object;
    /**
     * The connector status
     * @type {string}
     * @memberof V3ConnectorDtoBeta
     */
    'status'?: string;
}
/**
 * Details about the `CLUSTER` or `SOURCE` that initiated this event.
 * @export
 * @interface VAClusterStatusChangeEventApplicationBeta
 */
export interface VAClusterStatusChangeEventApplicationBeta {
    /**
     * The GUID of the application
     * @type {string}
     * @memberof VAClusterStatusChangeEventApplicationBeta
     */
    'id': string;
    /**
     * The name of the application
     * @type {string}
     * @memberof VAClusterStatusChangeEventApplicationBeta
     */
    'name': string;
    /**
     * Custom map of attributes for a source.  This will only be populated if type is `SOURCE` and the source has a proxy.
     * @type {{ [key: string]: any; }}
     * @memberof VAClusterStatusChangeEventApplicationBeta
     */
    'attributes': { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface VAClusterStatusChangeEventBeta
 */
export interface VAClusterStatusChangeEventBeta {
    /**
     * The date and time the status change occurred.
     * @type {string}
     * @memberof VAClusterStatusChangeEventBeta
     */
    'created': string;
    /**
     * The type of the object that initiated this event.
     * @type {object}
     * @memberof VAClusterStatusChangeEventBeta
     */
    'type': VAClusterStatusChangeEventBetaTypeEnum;
    /**
     * 
     * @type {VAClusterStatusChangeEventApplicationBeta}
     * @memberof VAClusterStatusChangeEventBeta
     */
    'application': VAClusterStatusChangeEventApplicationBeta;
    /**
     * 
     * @type {VAClusterStatusChangeEventHealthCheckResultBeta}
     * @memberof VAClusterStatusChangeEventBeta
     */
    'healthCheckResult': VAClusterStatusChangeEventHealthCheckResultBeta;
    /**
     * 
     * @type {VAClusterStatusChangeEventPreviousHealthCheckResultBeta}
     * @memberof VAClusterStatusChangeEventBeta
     */
    'previousHealthCheckResult': VAClusterStatusChangeEventPreviousHealthCheckResultBeta;
}

export const VAClusterStatusChangeEventBetaTypeEnum = {
    Source: 'SOURCE',
    Cluster: 'CLUSTER'
} as const;

export type VAClusterStatusChangeEventBetaTypeEnum = typeof VAClusterStatusChangeEventBetaTypeEnum[keyof typeof VAClusterStatusChangeEventBetaTypeEnum];

/**
 * The results of the most recent health check.
 * @export
 * @interface VAClusterStatusChangeEventHealthCheckResultBeta
 */
export interface VAClusterStatusChangeEventHealthCheckResultBeta {
    /**
     * Detailed message of the result of the health check.
     * @type {string}
     * @memberof VAClusterStatusChangeEventHealthCheckResultBeta
     */
    'message': string;
    /**
     * The type of the health check result.
     * @type {string}
     * @memberof VAClusterStatusChangeEventHealthCheckResultBeta
     */
    'resultType': string;
    /**
     * The status of the health check.
     * @type {object}
     * @memberof VAClusterStatusChangeEventHealthCheckResultBeta
     */
    'status': VAClusterStatusChangeEventHealthCheckResultBetaStatusEnum;
}

export const VAClusterStatusChangeEventHealthCheckResultBetaStatusEnum = {
    Succeeded: 'Succeeded',
    Failed: 'Failed'
} as const;

export type VAClusterStatusChangeEventHealthCheckResultBetaStatusEnum = typeof VAClusterStatusChangeEventHealthCheckResultBetaStatusEnum[keyof typeof VAClusterStatusChangeEventHealthCheckResultBetaStatusEnum];

/**
 * The results of the last health check.
 * @export
 * @interface VAClusterStatusChangeEventPreviousHealthCheckResultBeta
 */
export interface VAClusterStatusChangeEventPreviousHealthCheckResultBeta {
    /**
     * Detailed message of the result of the health check.
     * @type {string}
     * @memberof VAClusterStatusChangeEventPreviousHealthCheckResultBeta
     */
    'message': string;
    /**
     * The type of the health check result.
     * @type {string}
     * @memberof VAClusterStatusChangeEventPreviousHealthCheckResultBeta
     */
    'resultType': string;
    /**
     * The status of the health check.
     * @type {object}
     * @memberof VAClusterStatusChangeEventPreviousHealthCheckResultBeta
     */
    'status': VAClusterStatusChangeEventPreviousHealthCheckResultBetaStatusEnum;
}

export const VAClusterStatusChangeEventPreviousHealthCheckResultBetaStatusEnum = {
    Succeeded: 'Succeeded',
    Failed: 'Failed'
} as const;

export type VAClusterStatusChangeEventPreviousHealthCheckResultBetaStatusEnum = typeof VAClusterStatusChangeEventPreviousHealthCheckResultBetaStatusEnum[keyof typeof VAClusterStatusChangeEventPreviousHealthCheckResultBetaStatusEnum];

/**
 * 
 * @export
 * @interface ValidateFilterInputDtoBeta
 */
export interface ValidateFilterInputDtoBeta {
    /**
     * Mock input to evaluate filter expression against.
     * @type {object}
     * @memberof ValidateFilterInputDtoBeta
     */
    'input': object;
    /**
     * JSONPath filter to conditionally invoke trigger when expression evaluates to true.
     * @type {string}
     * @memberof ValidateFilterInputDtoBeta
     */
    'filter': string;
}
/**
 * 
 * @export
 * @interface ValidateFilterOutputDtoBeta
 */
export interface ValidateFilterOutputDtoBeta {
    /**
     * When this field is true, the filter expression is valid against the input.
     * @type {boolean}
     * @memberof ValidateFilterOutputDtoBeta
     */
    'isValid'?: boolean;
    /**
     * When this field is true, the filter expression is using a valid JSON path.
     * @type {boolean}
     * @memberof ValidateFilterOutputDtoBeta
     */
    'isValidJSONPath'?: boolean;
    /**
     * When this field is true, the filter expression is using an existing path.
     * @type {boolean}
     * @memberof ValidateFilterOutputDtoBeta
     */
    'isPathExist'?: boolean;
}
/**
 * 
 * @export
 * @interface ValueBeta
 */
export interface ValueBeta {
    /**
     * The type of attribute value
     * @type {string}
     * @memberof ValueBeta
     */
    'type'?: string;
    /**
     * The attribute value
     * @type {string}
     * @memberof ValueBeta
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface ViolationContextBeta
 */
export interface ViolationContextBeta {
    /**
     * 
     * @type {ViolationContextPolicyBeta}
     * @memberof ViolationContextBeta
     */
    'policy'?: ViolationContextPolicyBeta;
    /**
     * 
     * @type {ExceptionAccessCriteriaBeta}
     * @memberof ViolationContextBeta
     */
    'conflictingAccessCriteria'?: ExceptionAccessCriteriaBeta;
}
/**
 * 
 * @export
 * @interface ViolationContextPolicyAllOfBeta
 */
export interface ViolationContextPolicyAllOfBeta {
    /**
     * 
     * @type {string}
     * @memberof ViolationContextPolicyAllOfBeta
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ViolationContextPolicyAllOfBeta
     */
    'name'?: string;
}
/**
 * The types of objects supported for SOD violations
 * @export
 * @interface ViolationContextPolicyBeta
 */
export interface ViolationContextPolicyBeta {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof ViolationContextPolicyBeta
     */
    'type'?: ViolationContextPolicyBetaTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof ViolationContextPolicyBeta
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ViolationContextPolicyBeta
     */
    'name'?: string;
}

export const ViolationContextPolicyBetaTypeEnum = {
    Entitlement: 'ENTITLEMENT'
} as const;

export type ViolationContextPolicyBetaTypeEnum = typeof ViolationContextPolicyBetaTypeEnum[keyof typeof ViolationContextPolicyBetaTypeEnum];

/**
 * 
 * @export
 * @interface ViolationOwnerAssignmentConfigBeta
 */
export interface ViolationOwnerAssignmentConfigBeta {
    /**
     * Details about the violations owner. MANAGER - identity\'s manager STATIC - Governance Group or Identity
     * @type {string}
     * @memberof ViolationOwnerAssignmentConfigBeta
     */
    'assignmentRule'?: ViolationOwnerAssignmentConfigBetaAssignmentRuleEnum;
    /**
     * 
     * @type {ViolationOwnerAssignmentConfigOwnerRefBeta}
     * @memberof ViolationOwnerAssignmentConfigBeta
     */
    'ownerRef'?: ViolationOwnerAssignmentConfigOwnerRefBeta;
}

export const ViolationOwnerAssignmentConfigBetaAssignmentRuleEnum = {
    Manager: 'MANAGER',
    Static: 'STATIC',
    Null: 'null'
} as const;

export type ViolationOwnerAssignmentConfigBetaAssignmentRuleEnum = typeof ViolationOwnerAssignmentConfigBetaAssignmentRuleEnum[keyof typeof ViolationOwnerAssignmentConfigBetaAssignmentRuleEnum];

/**
 * 
 * @export
 * @interface ViolationOwnerAssignmentConfigOwnerRefBeta
 */
export interface ViolationOwnerAssignmentConfigOwnerRefBeta {
    /**
     * 
     * @type {DtoTypeBeta}
     * @memberof ViolationOwnerAssignmentConfigOwnerRefBeta
     */
    'type'?: DtoTypeBeta;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof ViolationOwnerAssignmentConfigOwnerRefBeta
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof ViolationOwnerAssignmentConfigOwnerRefBeta
     */
    'name'?: string;
}
/**
 * An object containing a listing of the SOD violation reasons detected by this check.
 * @export
 * @interface ViolationPredictionBeta
 */
export interface ViolationPredictionBeta {
    /**
     * List of Violation Contexts
     * @type {Array<ViolationContextBeta>}
     * @memberof ViolationPredictionBeta
     */
    'violationContexts'?: Array<ViolationContextBeta>;
}
/**
 * 
 * @export
 * @interface VisibilityCriteriaBeta
 */
export interface VisibilityCriteriaBeta {
    /**
     * 
     * @type {ExpressionBeta}
     * @memberof VisibilityCriteriaBeta
     */
    'expression'?: ExpressionBeta;
}
/**
 * 
 * @export
 * @interface WorkItemForwardBeta
 */
export interface WorkItemForwardBeta {
    /**
     * The ID of the identity to forward this work item to.
     * @type {string}
     * @memberof WorkItemForwardBeta
     */
    'targetOwnerId': string;
    /**
     * Comments to send to the target owner
     * @type {string}
     * @memberof WorkItemForwardBeta
     */
    'comment': string;
    /**
     * If true, send a notification to the target owner.
     * @type {boolean}
     * @memberof WorkItemForwardBeta
     */
    'sendNotifications'?: boolean;
}
/**
 * The state of a work item
 * @export
 * @enum {string}
 */

export const WorkItemStateBeta = {
    Finished: 'FINISHED',
    Rejected: 'REJECTED',
    Returned: 'RETURNED',
    Expired: 'EXPIRED',
    Pending: 'PENDING',
    Canceled: 'CANCELED'
} as const;

export type WorkItemStateBeta = typeof WorkItemStateBeta[keyof typeof WorkItemStateBeta];


/**
 * The type of the work item
 * @export
 * @enum {string}
 */

export const WorkItemTypeBeta = {
    Unknown: 'UNKNOWN',
    Generic: 'GENERIC',
    Certification: 'CERTIFICATION',
    Remediation: 'REMEDIATION',
    Delegation: 'DELEGATION',
    Approval: 'APPROVAL',
    Violationreview: 'VIOLATIONREVIEW',
    Form: 'FORM',
    Policyviolation: 'POLICYVIOLATION',
    Challenge: 'CHALLENGE',
    Impactanalysis: 'IMPACTANALYSIS',
    Signoff: 'SIGNOFF',
    Event: 'EVENT',
    Manualaction: 'MANUALACTION',
    Test: 'TEST'
} as const;

export type WorkItemTypeBeta = typeof WorkItemTypeBeta[keyof typeof WorkItemTypeBeta];


/**
 * 
 * @export
 * @interface WorkItemsBeta
 */
export interface WorkItemsBeta {
    /**
     * ID of the work item
     * @type {string}
     * @memberof WorkItemsBeta
     */
    'id'?: string;
    /**
     * ID of the requester
     * @type {string}
     * @memberof WorkItemsBeta
     */
    'requesterId'?: string;
    /**
     * The displayname of the requester
     * @type {string}
     * @memberof WorkItemsBeta
     */
    'requesterDisplayName'?: string;
    /**
     * The ID of the owner
     * @type {string}
     * @memberof WorkItemsBeta
     */
    'ownerId'?: string;
    /**
     * The name of the owner
     * @type {string}
     * @memberof WorkItemsBeta
     */
    'ownerName'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkItemsBeta
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkItemsBeta
     */
    'modified'?: string;
    /**
     * The description of the work item
     * @type {string}
     * @memberof WorkItemsBeta
     */
    'description'?: string;
    /**
     * 
     * @type {WorkItemStateBeta}
     * @memberof WorkItemsBeta
     */
    'state'?: WorkItemStateBeta;
    /**
     * 
     * @type {WorkItemTypeBeta}
     * @memberof WorkItemsBeta
     */
    'type'?: WorkItemTypeBeta;
    /**
     * 
     * @type {RemediationItemDetailsBeta}
     * @memberof WorkItemsBeta
     */
    'remediationItems'?: RemediationItemDetailsBeta;
    /**
     * 
     * @type {ApprovalItemDetailsBeta}
     * @memberof WorkItemsBeta
     */
    'approvalItems'?: ApprovalItemDetailsBeta;
    /**
     * The work item name
     * @type {string}
     * @memberof WorkItemsBeta
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkItemsBeta
     */
    'completed'?: string;
    /**
     * The number of items in the work item
     * @type {number}
     * @memberof WorkItemsBeta
     */
    'numItems'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof WorkItemsBeta
     */
    'errors'?: Array<string>;
}
/**
 * 
 * @export
 * @interface WorkItemsCountBeta
 */
export interface WorkItemsCountBeta {
    /**
     * The count of work items
     * @type {number}
     * @memberof WorkItemsCountBeta
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface WorkItemsSummaryBeta
 */
export interface WorkItemsSummaryBeta {
    /**
     * The count of open work items
     * @type {number}
     * @memberof WorkItemsSummaryBeta
     */
    'open'?: number;
    /**
     * The count of completed work items
     * @type {number}
     * @memberof WorkItemsSummaryBeta
     */
    'completed'?: number;
    /**
     * The count of total work items
     * @type {number}
     * @memberof WorkItemsSummaryBeta
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface WorkflowAllOfBeta
 */
export interface WorkflowAllOfBeta {
    /**
     * Workflow ID. This is a UUID generated upon creation.
     * @type {string}
     * @memberof WorkflowAllOfBeta
     */
    'id'?: string;
    /**
     * The number of times this workflow has been executed
     * @type {number}
     * @memberof WorkflowAllOfBeta
     */
    'executionCount'?: number;
    /**
     * The number of times this workflow has failed during execution
     * @type {number}
     * @memberof WorkflowAllOfBeta
     */
    'failureCount'?: number;
    /**
     * The date and time the workflow was created
     * @type {string}
     * @memberof WorkflowAllOfBeta
     */
    'created'?: string;
    /**
     * The identity that created the workflow.
     * @type {BaseReferenceDto1Beta}
     * @memberof WorkflowAllOfBeta
     */
    'creator'?: BaseReferenceDto1Beta;
}
/**
 * 
 * @export
 * @interface WorkflowBeta
 */
export interface WorkflowBeta {
    /**
     * Workflow ID. This is a UUID generated upon creation.
     * @type {string}
     * @memberof WorkflowBeta
     */
    'id'?: string;
    /**
     * The number of times this workflow has been executed
     * @type {number}
     * @memberof WorkflowBeta
     */
    'executionCount'?: number;
    /**
     * The number of times this workflow has failed during execution
     * @type {number}
     * @memberof WorkflowBeta
     */
    'failureCount'?: number;
    /**
     * The date and time the workflow was created
     * @type {string}
     * @memberof WorkflowBeta
     */
    'created'?: string;
    /**
     * The identity that created the workflow.
     * @type {BaseReferenceDto1Beta}
     * @memberof WorkflowBeta
     */
    'creator'?: BaseReferenceDto1Beta;
    /**
     * The name of the workflow
     * @type {string}
     * @memberof WorkflowBeta
     */
    'name'?: string;
    /**
     * 
     * @type {WorkflowBodyOwnerBeta}
     * @memberof WorkflowBeta
     */
    'owner'?: WorkflowBodyOwnerBeta;
    /**
     * Description of what the workflow accomplishes
     * @type {string}
     * @memberof WorkflowBeta
     */
    'description'?: string;
    /**
     * 
     * @type {WorkflowDefinitionBeta}
     * @memberof WorkflowBeta
     */
    'definition'?: WorkflowDefinitionBeta;
    /**
     * Enable or disable the workflow.  Workflows cannot be created in an enabled state.
     * @type {boolean}
     * @memberof WorkflowBeta
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {WorkflowTriggerBeta}
     * @memberof WorkflowBeta
     */
    'trigger'?: WorkflowTriggerBeta;
}
/**
 * 
 * @export
 * @interface WorkflowBodyBeta
 */
export interface WorkflowBodyBeta {
    /**
     * The name of the workflow
     * @type {string}
     * @memberof WorkflowBodyBeta
     */
    'name'?: string;
    /**
     * 
     * @type {WorkflowBodyOwnerBeta}
     * @memberof WorkflowBodyBeta
     */
    'owner'?: WorkflowBodyOwnerBeta;
    /**
     * Description of what the workflow accomplishes
     * @type {string}
     * @memberof WorkflowBodyBeta
     */
    'description'?: string;
    /**
     * 
     * @type {WorkflowDefinitionBeta}
     * @memberof WorkflowBodyBeta
     */
    'definition'?: WorkflowDefinitionBeta;
    /**
     * Enable or disable the workflow.  Workflows cannot be created in an enabled state.
     * @type {boolean}
     * @memberof WorkflowBodyBeta
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {WorkflowTriggerBeta}
     * @memberof WorkflowBodyBeta
     */
    'trigger'?: WorkflowTriggerBeta;
}
/**
 * The identity that owns the workflow.  The owner\'s permissions in IDN will determine what actions the workflow is allowed to perform.  Ownership can be changed by updating the owner in a PUT or PATCH request.
 * @export
 * @interface WorkflowBodyOwnerBeta
 */
export interface WorkflowBodyOwnerBeta {
    /**
     * The type of object that is referenced
     * @type {string}
     * @memberof WorkflowBodyOwnerBeta
     */
    'type'?: WorkflowBodyOwnerBetaTypeEnum;
    /**
     * The unique ID of the object
     * @type {string}
     * @memberof WorkflowBodyOwnerBeta
     */
    'id'?: string;
    /**
     * The name of the object
     * @type {string}
     * @memberof WorkflowBodyOwnerBeta
     */
    'name'?: string;
}

export const WorkflowBodyOwnerBetaTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type WorkflowBodyOwnerBetaTypeEnum = typeof WorkflowBodyOwnerBetaTypeEnum[keyof typeof WorkflowBodyOwnerBetaTypeEnum];

/**
 * The map of steps that the workflow will execute.
 * @export
 * @interface WorkflowDefinitionBeta
 */
export interface WorkflowDefinitionBeta {
    /**
     * The name of the starting step.
     * @type {string}
     * @memberof WorkflowDefinitionBeta
     */
    'start'?: string;
    /**
     * One or more step objects that comprise this workflow.  Please see the Workflow documentation to see the JSON schema for each step type.
     * @type {{ [key: string]: any; }}
     * @memberof WorkflowDefinitionBeta
     */
    'steps'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface WorkflowExecutionBeta
 */
export interface WorkflowExecutionBeta {
    /**
     * The workflow execution ID
     * @type {string}
     * @memberof WorkflowExecutionBeta
     */
    'id'?: string;
    /**
     * The workflow ID
     * @type {string}
     * @memberof WorkflowExecutionBeta
     */
    'workflowId'?: string;
    /**
     * This backend ID tracks a workflow request in the system. You can provide this ID in a customer support ticket for debugging purposes.
     * @type {string}
     * @memberof WorkflowExecutionBeta
     */
    'requestId'?: string;
    /**
     * The date/time the workflow started
     * @type {string}
     * @memberof WorkflowExecutionBeta
     */
    'startTime'?: string;
    /**
     * The date/time the workflow ended
     * @type {string}
     * @memberof WorkflowExecutionBeta
     */
    'closeTime'?: string;
    /**
     * The workflow execution status
     * @type {string}
     * @memberof WorkflowExecutionBeta
     */
    'status'?: WorkflowExecutionBetaStatusEnum;
}

export const WorkflowExecutionBetaStatusEnum = {
    Completed: 'Completed',
    Failed: 'Failed',
    Canceled: 'Canceled',
    Running: 'Running'
} as const;

export type WorkflowExecutionBetaStatusEnum = typeof WorkflowExecutionBetaStatusEnum[keyof typeof WorkflowExecutionBetaStatusEnum];

/**
 * 
 * @export
 * @interface WorkflowExecutionEventBeta
 */
export interface WorkflowExecutionEventBeta {
    /**
     * The type of event
     * @type {object}
     * @memberof WorkflowExecutionEventBeta
     */
    'type'?: WorkflowExecutionEventBetaTypeEnum;
    /**
     * The date-time when the event occurred
     * @type {string}
     * @memberof WorkflowExecutionEventBeta
     */
    'timestamp'?: string;
    /**
     * Additional attributes associated with the event
     * @type {object}
     * @memberof WorkflowExecutionEventBeta
     */
    'attributes'?: object;
}

export const WorkflowExecutionEventBetaTypeEnum = {
    WorkflowExecutionScheduled: 'WorkflowExecutionScheduled',
    WorkflowExecutionStarted: 'WorkflowExecutionStarted',
    WorkflowExecutionCompleted: 'WorkflowExecutionCompleted',
    WorkflowExecutionFailed: 'WorkflowExecutionFailed',
    WorkflowTaskScheduled: 'WorkflowTaskScheduled',
    WorkflowTaskStarted: 'WorkflowTaskStarted',
    WorkflowTaskCompleted: 'WorkflowTaskCompleted',
    WorkflowTaskFailed: 'WorkflowTaskFailed',
    ActivityTaskScheduled: 'ActivityTaskScheduled',
    ActivityTaskStarted: 'ActivityTaskStarted',
    ActivityTaskCompleted: 'ActivityTaskCompleted',
    ActivityTaskFailed: 'ActivityTaskFailed'
} as const;

export type WorkflowExecutionEventBetaTypeEnum = typeof WorkflowExecutionEventBetaTypeEnum[keyof typeof WorkflowExecutionEventBetaTypeEnum];

/**
 * 
 * @export
 * @interface WorkflowLibraryActionBeta
 */
export interface WorkflowLibraryActionBeta {
    /**
     * Action ID. This is a static namespaced ID for the action
     * @type {string}
     * @memberof WorkflowLibraryActionBeta
     */
    'id'?: string;
    /**
     * Action Name
     * @type {string}
     * @memberof WorkflowLibraryActionBeta
     */
    'name'?: string;
    /**
     * Action type
     * @type {string}
     * @memberof WorkflowLibraryActionBeta
     */
    'type'?: string;
    /**
     * Action Description
     * @type {string}
     * @memberof WorkflowLibraryActionBeta
     */
    'description'?: string;
    /**
     * One or more inputs that the action accepts
     * @type {Array<WorkflowLibraryFormFieldsBeta>}
     * @memberof WorkflowLibraryActionBeta
     */
    'formFields'?: Array<WorkflowLibraryFormFieldsBeta>;
    /**
     * Determines whether the dynamic output schema is returned in place of the action\'s output schema. The dynamic schema lists non-static properties, like properties of a workflow form where each form has different fields. These will be provided dynamically based on available form fields.
     * @type {boolean}
     * @memberof WorkflowLibraryActionBeta
     */
    'isDynamicSchema'?: boolean;
    /**
     * Defines the output schema, if any, that this action produces.
     * @type {object}
     * @memberof WorkflowLibraryActionBeta
     */
    'outputSchema'?: object;
}
/**
 * 
 * @export
 * @interface WorkflowLibraryFormFieldsBeta
 */
export interface WorkflowLibraryFormFieldsBeta {
    /**
     * Describes the form field in the UI
     * @type {string}
     * @memberof WorkflowLibraryFormFieldsBeta
     */
    'helpText'?: string;
    /**
     * A human readable name for this form field in the UI
     * @type {string}
     * @memberof WorkflowLibraryFormFieldsBeta
     */
    'label'?: string;
    /**
     * The name of the input attribute
     * @type {string}
     * @memberof WorkflowLibraryFormFieldsBeta
     */
    'name'?: string;
    /**
     * Denotes if this field is a required attribute
     * @type {boolean}
     * @memberof WorkflowLibraryFormFieldsBeta
     */
    'required'?: boolean;
    /**
     * The type of the form field
     * @type {object}
     * @memberof WorkflowLibraryFormFieldsBeta
     */
    'type'?: WorkflowLibraryFormFieldsBetaTypeEnum;
}

export const WorkflowLibraryFormFieldsBetaTypeEnum = {
    Text: 'text',
    Textarea: 'textarea',
    Boolean: 'boolean',
    Email: 'email',
    Url: 'url',
    Number: 'number',
    Json: 'json',
    Checkbox: 'checkbox',
    Jsonpath: 'jsonpath',
    Select: 'select',
    MultiType: 'multiType',
    Duration: 'duration',
    Toggle: 'toggle',
    IdentityPicker: 'identityPicker',
    GovernanceGroupPicker: 'governanceGroupPicker',
    String: 'string',
    Object: 'object',
    Array: 'array',
    Secret: 'secret',
    KeyValuePairs: 'keyValuePairs',
    EmailPicker: 'emailPicker',
    AdvancedToggle: 'advancedToggle'
} as const;

export type WorkflowLibraryFormFieldsBetaTypeEnum = typeof WorkflowLibraryFormFieldsBetaTypeEnum[keyof typeof WorkflowLibraryFormFieldsBetaTypeEnum];

/**
 * 
 * @export
 * @interface WorkflowLibraryOperatorBeta
 */
export interface WorkflowLibraryOperatorBeta {
    /**
     * Operator ID.
     * @type {string}
     * @memberof WorkflowLibraryOperatorBeta
     */
    'id'?: string;
    /**
     * Operator friendly name
     * @type {string}
     * @memberof WorkflowLibraryOperatorBeta
     */
    'name'?: string;
    /**
     * Operator type
     * @type {string}
     * @memberof WorkflowLibraryOperatorBeta
     */
    'type'?: string;
    /**
     * Description of the operator
     * @type {string}
     * @memberof WorkflowLibraryOperatorBeta
     */
    'description'?: string;
    /**
     * One or more inputs that the operator accepts
     * @type {Array<WorkflowLibraryFormFieldsBeta>}
     * @memberof WorkflowLibraryOperatorBeta
     */
    'formFields'?: Array<WorkflowLibraryFormFieldsBeta>;
}
/**
 * 
 * @export
 * @interface WorkflowLibraryTriggerBeta
 */
export interface WorkflowLibraryTriggerBeta {
    /**
     * Trigger ID. This is a static namespaced ID for the trigger.
     * @type {string}
     * @memberof WorkflowLibraryTriggerBeta
     */
    'id'?: string;
    /**
     * Trigger type
     * @type {object}
     * @memberof WorkflowLibraryTriggerBeta
     */
    'type'?: WorkflowLibraryTriggerBetaTypeEnum;
    /**
     * Trigger Name
     * @type {string}
     * @memberof WorkflowLibraryTriggerBeta
     */
    'name'?: string;
    /**
     * Trigger Description
     * @type {string}
     * @memberof WorkflowLibraryTriggerBeta
     */
    'description'?: string;
    /**
     * Determines whether the dynamic output schema is returned in place of the action\'s output schema. The dynamic schema lists non-static properties, like properties of a workflow form where each form has different fields. These will be provided dynamically based on available form fields.
     * @type {boolean}
     * @memberof WorkflowLibraryTriggerBeta
     */
    'isDynamicSchema'?: boolean;
    /**
     * Example trigger payload if applicable
     * @type {object}
     * @memberof WorkflowLibraryTriggerBeta
     */
    'inputExample'?: object | null;
    /**
     * One or more inputs that the trigger accepts
     * @type {Array<WorkflowLibraryFormFieldsBeta>}
     * @memberof WorkflowLibraryTriggerBeta
     */
    'formFields'?: Array<WorkflowLibraryFormFieldsBeta> | null;
}

export const WorkflowLibraryTriggerBetaTypeEnum = {
    Event: 'EVENT',
    Scheduled: 'SCHEDULED',
    External: 'EXTERNAL'
} as const;

export type WorkflowLibraryTriggerBetaTypeEnum = typeof WorkflowLibraryTriggerBetaTypeEnum[keyof typeof WorkflowLibraryTriggerBetaTypeEnum];

/**
 * 
 * @export
 * @interface WorkflowOAuthClientBeta
 */
export interface WorkflowOAuthClientBeta {
    /**
     * OAuth client ID for the trigger. This is a UUID generated upon creation.
     * @type {string}
     * @memberof WorkflowOAuthClientBeta
     */
    'id'?: string;
    /**
     * OAuthClient secret.
     * @type {string}
     * @memberof WorkflowOAuthClientBeta
     */
    'secret'?: string;
    /**
     * URL for the external trigger to invoke
     * @type {string}
     * @memberof WorkflowOAuthClientBeta
     */
    'url'?: string;
}
/**
 * @type WorkflowTriggerAttributesBeta
 * Workflow Trigger Attributes.
 * @export
 */
export type WorkflowTriggerAttributesBeta = EventAttributesBeta | ExternalAttributesBeta | ScheduledAttributesBeta;

/**
 * The trigger that starts the workflow
 * @export
 * @interface WorkflowTriggerBeta
 */
export interface WorkflowTriggerBeta {
    /**
     * The trigger type
     * @type {string}
     * @memberof WorkflowTriggerBeta
     */
    'type': WorkflowTriggerBetaTypeEnum;
    /**
     * 
     * @type {WorkflowTriggerAttributesBeta}
     * @memberof WorkflowTriggerBeta
     */
    'attributes': WorkflowTriggerAttributesBeta;
}

export const WorkflowTriggerBetaTypeEnum = {
    Event: 'EVENT',
    External: 'EXTERNAL',
    Scheduled: 'SCHEDULED'
} as const;

export type WorkflowTriggerBetaTypeEnum = typeof WorkflowTriggerBetaTypeEnum[keyof typeof WorkflowTriggerBetaTypeEnum];

/**
 * 
 * @export
 * @interface WorkgroupDtoBeta
 */
export interface WorkgroupDtoBeta {
    /**
     * 
     * @type {OwnerBeta}
     * @memberof WorkgroupDtoBeta
     */
    'owner'?: OwnerBeta;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof WorkgroupDtoBeta
     */
    'id'?: string;
    /**
     * Description of the Governance Group
     * @type {string}
     * @memberof WorkgroupDtoBeta
     */
    'description'?: string;
    /**
     * Number of members in the Governance Group.
     * @type {number}
     * @memberof WorkgroupDtoBeta
     */
    'memberCount'?: number;
    /**
     * Number of connections in the Governance Group.
     * @type {number}
     * @memberof WorkgroupDtoBeta
     */
    'connectionCount'?: number;
}

/**
 * AccessProfilesBetaApi - axios parameter creator
 * @export
 */
export const AccessProfilesBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates an Access Profile. A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a token with only ROLE_SUBADMIN or SOURCE_SUBADMIN authority must be associated with the Access Profile\'s Source. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Create an Access Profile
         * @param {AccessProfileBeta} accessProfileBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccessProfile: async (accessProfileBeta: AccessProfileBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessProfileBeta' is not null or undefined
            assertParamExists('createAccessProfile', 'accessProfileBeta', accessProfileBeta)
            const localVarPath = `/access-profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessProfileBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API deletes an existing Access Profile.  The Access Profile must not be in use. If it is, a 400 error is returned.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a SOURCE_SUBADMIN token must be able to administer the Source associated with the Access Profile.
         * @summary Delete the specified Access Profile
         * @param {string} id ID of the Access Profile to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessProfile: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAccessProfile', 'id', id)
            const localVarPath = `/access-profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API initiates a bulk deletion of one or more Access Profiles.  By default, if any of the indicated Access Profiles are in use, no deletions will be performed and the **inUse** field of the response indicates the usages that must be removed first. If the request field **bestEffortOnly** is **true**, however, usages are reported in the **inUse** response field but all other indicated Access Profiles will be deleted.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to delete Access Profiles which are associated with Sources they are able to administer.
         * @summary Delete Access Profile(s)
         * @param {AccessProfileBulkDeleteRequestBeta} accessProfileBulkDeleteRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessProfilesInBulk: async (accessProfileBulkDeleteRequestBeta: AccessProfileBulkDeleteRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessProfileBulkDeleteRequestBeta' is not null or undefined
            assertParamExists('deleteAccessProfilesInBulk', 'accessProfileBulkDeleteRequestBeta', accessProfileBulkDeleteRequestBeta)
            const localVarPath = `/access-profiles/bulk-delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessProfileBulkDeleteRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns an Access Profile by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get an Access Profile
         * @param {string} id ID of the Access Profile
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessProfile: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccessProfile', 'id', id)
            const localVarPath = `/access-profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API lists the Entitlements associated with a given Access Profile  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a token with SOURCE_SUBADMIN authority must have access to the Source associated with the given Access Profile
         * @summary List Access Profile\'s Entitlements
         * @param {string} id ID of the containing Access Profile
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following Entitlement fields and operators: **id**: *eq, in*  **name**: *eq, sw*  **attribute**: *eq, sw*  **value**: *eq, sw*  **created, modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **source.id**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, attribute, value, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessProfileEntitlements: async (id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccessProfileEntitlements', 'id', id)
            const localVarPath = `/access-profiles/{id}/entitlements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of Access Profiles.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary List Access Profiles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN or SOURCE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID.  A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created, modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*  **source.id**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters Access Profiles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Whether or not the response list should contain unsegmented Access Profiles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccessProfiles: async (forSubadmin?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSegmentIds?: string, includeUnsegmented?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (forSubadmin !== undefined) {
                localVarQueryParameter['for-subadmin'] = forSubadmin;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (forSegmentIds !== undefined) {
                localVarQueryParameter['for-segment-ids'] = forSegmentIds;
            }

            if (includeUnsegmented !== undefined) {
                localVarQueryParameter['include-unsegmented'] = includeUnsegmented;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates an existing Access Profile. The following fields are patchable: **name**, **description**, **enabled**, **owner**, **requestable**, **accessRequestConfig**, **revokeRequestConfig**, **segments**, **entitlements**, **provisioningCriteria** A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to patch Access Profiles which are associated with Sources they are able to administer. >  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.  > You can only add or replace **entitlements** that exist on the source that the access profile is attached to. You can use the **list entitlements** endpoint with the **filters** query parameter to get a list of available entitlements on the access profile\'s source.  >  Patching the value of the **requestable** field is only supported for customers enabled with the new Request Center. Otherwise, attempting to modify this field results in a 400 error.
         * @summary Patch a specified Access Profile
         * @param {string} id ID of the Access Profile to patch
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAccessProfile: async (id: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchAccessProfile', 'id', id)
            // verify required parameter 'jsonPatchOperationBeta' is not null or undefined
            assertParamExists('patchAccessProfile', 'jsonPatchOperationBeta', jsonPatchOperationBeta)
            const localVarPath = `/access-profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperationBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessProfilesBetaApi - functional programming interface
 * @export
 */
export const AccessProfilesBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessProfilesBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates an Access Profile. A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a token with only ROLE_SUBADMIN or SOURCE_SUBADMIN authority must be associated with the Access Profile\'s Source. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Create an Access Profile
         * @param {AccessProfileBeta} accessProfileBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createAccessProfile(accessProfileBeta: AccessProfileBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessProfileBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccessProfile(accessProfileBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API deletes an existing Access Profile.  The Access Profile must not be in use. If it is, a 400 error is returned.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a SOURCE_SUBADMIN token must be able to administer the Source associated with the Access Profile.
         * @summary Delete the specified Access Profile
         * @param {string} id ID of the Access Profile to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccessProfile(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccessProfile(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API initiates a bulk deletion of one or more Access Profiles.  By default, if any of the indicated Access Profiles are in use, no deletions will be performed and the **inUse** field of the response indicates the usages that must be removed first. If the request field **bestEffortOnly** is **true**, however, usages are reported in the **inUse** response field but all other indicated Access Profiles will be deleted.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to delete Access Profiles which are associated with Sources they are able to administer.
         * @summary Delete Access Profile(s)
         * @param {AccessProfileBulkDeleteRequestBeta} accessProfileBulkDeleteRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccessProfilesInBulk(accessProfileBulkDeleteRequestBeta: AccessProfileBulkDeleteRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessProfileBulkDeleteResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccessProfilesInBulk(accessProfileBulkDeleteRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns an Access Profile by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get an Access Profile
         * @param {string} id ID of the Access Profile
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessProfile(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessProfileBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessProfile(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API lists the Entitlements associated with a given Access Profile  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a token with SOURCE_SUBADMIN authority must have access to the Source associated with the given Access Profile
         * @summary List Access Profile\'s Entitlements
         * @param {string} id ID of the containing Access Profile
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following Entitlement fields and operators: **id**: *eq, in*  **name**: *eq, sw*  **attribute**: *eq, sw*  **value**: *eq, sw*  **created, modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **source.id**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, attribute, value, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessProfileEntitlements(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EntitlementBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessProfileEntitlements(id, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of Access Profiles.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary List Access Profiles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN or SOURCE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID.  A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created, modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*  **source.id**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters Access Profiles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Whether or not the response list should contain unsegmented Access Profiles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listAccessProfiles(forSubadmin?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSegmentIds?: string, includeUnsegmented?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccessProfileBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccessProfiles(forSubadmin, limit, offset, count, filters, sorters, forSegmentIds, includeUnsegmented, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API updates an existing Access Profile. The following fields are patchable: **name**, **description**, **enabled**, **owner**, **requestable**, **accessRequestConfig**, **revokeRequestConfig**, **segments**, **entitlements**, **provisioningCriteria** A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to patch Access Profiles which are associated with Sources they are able to administer. >  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.  > You can only add or replace **entitlements** that exist on the source that the access profile is attached to. You can use the **list entitlements** endpoint with the **filters** query parameter to get a list of available entitlements on the access profile\'s source.  >  Patching the value of the **requestable** field is only supported for customers enabled with the new Request Center. Otherwise, attempting to modify this field results in a 400 error.
         * @summary Patch a specified Access Profile
         * @param {string} id ID of the Access Profile to patch
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchAccessProfile(id: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessProfileBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAccessProfile(id, jsonPatchOperationBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccessProfilesBetaApi - factory interface
 * @export
 */
export const AccessProfilesBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessProfilesBetaApiFp(configuration)
    return {
        /**
         * This API creates an Access Profile. A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a token with only ROLE_SUBADMIN or SOURCE_SUBADMIN authority must be associated with the Access Profile\'s Source. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Create an Access Profile
         * @param {AccessProfileBeta} accessProfileBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccessProfile(accessProfileBeta: AccessProfileBeta, axiosOptions?: any): AxiosPromise<AccessProfileBeta> {
            return localVarFp.createAccessProfile(accessProfileBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API deletes an existing Access Profile.  The Access Profile must not be in use. If it is, a 400 error is returned.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a SOURCE_SUBADMIN token must be able to administer the Source associated with the Access Profile.
         * @summary Delete the specified Access Profile
         * @param {string} id ID of the Access Profile to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessProfile(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteAccessProfile(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API initiates a bulk deletion of one or more Access Profiles.  By default, if any of the indicated Access Profiles are in use, no deletions will be performed and the **inUse** field of the response indicates the usages that must be removed first. If the request field **bestEffortOnly** is **true**, however, usages are reported in the **inUse** response field but all other indicated Access Profiles will be deleted.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to delete Access Profiles which are associated with Sources they are able to administer.
         * @summary Delete Access Profile(s)
         * @param {AccessProfileBulkDeleteRequestBeta} accessProfileBulkDeleteRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessProfilesInBulk(accessProfileBulkDeleteRequestBeta: AccessProfileBulkDeleteRequestBeta, axiosOptions?: any): AxiosPromise<AccessProfileBulkDeleteResponseBeta> {
            return localVarFp.deleteAccessProfilesInBulk(accessProfileBulkDeleteRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns an Access Profile by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get an Access Profile
         * @param {string} id ID of the Access Profile
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessProfile(id: string, axiosOptions?: any): AxiosPromise<AccessProfileBeta> {
            return localVarFp.getAccessProfile(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API lists the Entitlements associated with a given Access Profile  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a token with SOURCE_SUBADMIN authority must have access to the Source associated with the given Access Profile
         * @summary List Access Profile\'s Entitlements
         * @param {string} id ID of the containing Access Profile
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following Entitlement fields and operators: **id**: *eq, in*  **name**: *eq, sw*  **attribute**: *eq, sw*  **value**: *eq, sw*  **created, modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **source.id**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, attribute, value, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessProfileEntitlements(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<EntitlementBeta>> {
            return localVarFp.getAccessProfileEntitlements(id, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of Access Profiles.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary List Access Profiles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN or SOURCE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID.  A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created, modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*  **source.id**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters Access Profiles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Whether or not the response list should contain unsegmented Access Profiles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccessProfiles(forSubadmin?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSegmentIds?: string, includeUnsegmented?: boolean, axiosOptions?: any): AxiosPromise<Array<AccessProfileBeta>> {
            return localVarFp.listAccessProfiles(forSubadmin, limit, offset, count, filters, sorters, forSegmentIds, includeUnsegmented, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates an existing Access Profile. The following fields are patchable: **name**, **description**, **enabled**, **owner**, **requestable**, **accessRequestConfig**, **revokeRequestConfig**, **segments**, **entitlements**, **provisioningCriteria** A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to patch Access Profiles which are associated with Sources they are able to administer. >  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.  > You can only add or replace **entitlements** that exist on the source that the access profile is attached to. You can use the **list entitlements** endpoint with the **filters** query parameter to get a list of available entitlements on the access profile\'s source.  >  Patching the value of the **requestable** field is only supported for customers enabled with the new Request Center. Otherwise, attempting to modify this field results in a 400 error.
         * @summary Patch a specified Access Profile
         * @param {string} id ID of the Access Profile to patch
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAccessProfile(id: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: any): AxiosPromise<AccessProfileBeta> {
            return localVarFp.patchAccessProfile(id, jsonPatchOperationBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAccessProfile operation in AccessProfilesBetaApi.
 * @export
 * @interface AccessProfilesBetaApiCreateAccessProfileRequest
 */
export interface AccessProfilesBetaApiCreateAccessProfileRequest {
    /**
     * 
     * @type {AccessProfileBeta}
     * @memberof AccessProfilesBetaApiCreateAccessProfile
     */
    readonly accessProfileBeta: AccessProfileBeta
}

/**
 * Request parameters for deleteAccessProfile operation in AccessProfilesBetaApi.
 * @export
 * @interface AccessProfilesBetaApiDeleteAccessProfileRequest
 */
export interface AccessProfilesBetaApiDeleteAccessProfileRequest {
    /**
     * ID of the Access Profile to delete
     * @type {string}
     * @memberof AccessProfilesBetaApiDeleteAccessProfile
     */
    readonly id: string
}

/**
 * Request parameters for deleteAccessProfilesInBulk operation in AccessProfilesBetaApi.
 * @export
 * @interface AccessProfilesBetaApiDeleteAccessProfilesInBulkRequest
 */
export interface AccessProfilesBetaApiDeleteAccessProfilesInBulkRequest {
    /**
     * 
     * @type {AccessProfileBulkDeleteRequestBeta}
     * @memberof AccessProfilesBetaApiDeleteAccessProfilesInBulk
     */
    readonly accessProfileBulkDeleteRequestBeta: AccessProfileBulkDeleteRequestBeta
}

/**
 * Request parameters for getAccessProfile operation in AccessProfilesBetaApi.
 * @export
 * @interface AccessProfilesBetaApiGetAccessProfileRequest
 */
export interface AccessProfilesBetaApiGetAccessProfileRequest {
    /**
     * ID of the Access Profile
     * @type {string}
     * @memberof AccessProfilesBetaApiGetAccessProfile
     */
    readonly id: string
}

/**
 * Request parameters for getAccessProfileEntitlements operation in AccessProfilesBetaApi.
 * @export
 * @interface AccessProfilesBetaApiGetAccessProfileEntitlementsRequest
 */
export interface AccessProfilesBetaApiGetAccessProfileEntitlementsRequest {
    /**
     * ID of the containing Access Profile
     * @type {string}
     * @memberof AccessProfilesBetaApiGetAccessProfileEntitlements
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessProfilesBetaApiGetAccessProfileEntitlements
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessProfilesBetaApiGetAccessProfileEntitlements
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccessProfilesBetaApiGetAccessProfileEntitlements
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following Entitlement fields and operators: **id**: *eq, in*  **name**: *eq, sw*  **attribute**: *eq, sw*  **value**: *eq, sw*  **created, modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **source.id**: *eq, in*
     * @type {string}
     * @memberof AccessProfilesBetaApiGetAccessProfileEntitlements
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, attribute, value, created, modified**
     * @type {string}
     * @memberof AccessProfilesBetaApiGetAccessProfileEntitlements
     */
    readonly sorters?: string
}

/**
 * Request parameters for listAccessProfiles operation in AccessProfilesBetaApi.
 * @export
 * @interface AccessProfilesBetaApiListAccessProfilesRequest
 */
export interface AccessProfilesBetaApiListAccessProfilesRequest {
    /**
     * If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN or SOURCE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID.  A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
     * @type {string}
     * @memberof AccessProfilesBetaApiListAccessProfiles
     */
    readonly forSubadmin?: string

    /**
     * Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessProfilesBetaApiListAccessProfiles
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessProfilesBetaApiListAccessProfiles
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccessProfilesBetaApiListAccessProfiles
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created, modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*  **source.id**: *eq, in*
     * @type {string}
     * @memberof AccessProfilesBetaApiListAccessProfiles
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
     * @type {string}
     * @memberof AccessProfilesBetaApiListAccessProfiles
     */
    readonly sorters?: string

    /**
     * If present and not empty, additionally filters Access Profiles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
     * @type {string}
     * @memberof AccessProfilesBetaApiListAccessProfiles
     */
    readonly forSegmentIds?: string

    /**
     * Whether or not the response list should contain unsegmented Access Profiles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
     * @type {boolean}
     * @memberof AccessProfilesBetaApiListAccessProfiles
     */
    readonly includeUnsegmented?: boolean
}

/**
 * Request parameters for patchAccessProfile operation in AccessProfilesBetaApi.
 * @export
 * @interface AccessProfilesBetaApiPatchAccessProfileRequest
 */
export interface AccessProfilesBetaApiPatchAccessProfileRequest {
    /**
     * ID of the Access Profile to patch
     * @type {string}
     * @memberof AccessProfilesBetaApiPatchAccessProfile
     */
    readonly id: string

    /**
     * 
     * @type {Array<JsonPatchOperationBeta>}
     * @memberof AccessProfilesBetaApiPatchAccessProfile
     */
    readonly jsonPatchOperationBeta: Array<JsonPatchOperationBeta>
}

/**
 * AccessProfilesBetaApi - object-oriented interface
 * @export
 * @class AccessProfilesBetaApi
 * @extends {BaseAPI}
 */
export class AccessProfilesBetaApi extends BaseAPI {
    /**
     * This API creates an Access Profile. A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a token with only ROLE_SUBADMIN or SOURCE_SUBADMIN authority must be associated with the Access Profile\'s Source. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.
     * @summary Create an Access Profile
     * @param {AccessProfilesBetaApiCreateAccessProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesBetaApi
     */
    public createAccessProfile(requestParameters: AccessProfilesBetaApiCreateAccessProfileRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessProfilesBetaApiFp(this.configuration).createAccessProfile(requestParameters.accessProfileBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API deletes an existing Access Profile.  The Access Profile must not be in use. If it is, a 400 error is returned.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a SOURCE_SUBADMIN token must be able to administer the Source associated with the Access Profile.
     * @summary Delete the specified Access Profile
     * @param {AccessProfilesBetaApiDeleteAccessProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesBetaApi
     */
    public deleteAccessProfile(requestParameters: AccessProfilesBetaApiDeleteAccessProfileRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessProfilesBetaApiFp(this.configuration).deleteAccessProfile(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API initiates a bulk deletion of one or more Access Profiles.  By default, if any of the indicated Access Profiles are in use, no deletions will be performed and the **inUse** field of the response indicates the usages that must be removed first. If the request field **bestEffortOnly** is **true**, however, usages are reported in the **inUse** response field but all other indicated Access Profiles will be deleted.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to delete Access Profiles which are associated with Sources they are able to administer.
     * @summary Delete Access Profile(s)
     * @param {AccessProfilesBetaApiDeleteAccessProfilesInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesBetaApi
     */
    public deleteAccessProfilesInBulk(requestParameters: AccessProfilesBetaApiDeleteAccessProfilesInBulkRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessProfilesBetaApiFp(this.configuration).deleteAccessProfilesInBulk(requestParameters.accessProfileBulkDeleteRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns an Access Profile by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Get an Access Profile
     * @param {AccessProfilesBetaApiGetAccessProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesBetaApi
     */
    public getAccessProfile(requestParameters: AccessProfilesBetaApiGetAccessProfileRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessProfilesBetaApiFp(this.configuration).getAccessProfile(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API lists the Entitlements associated with a given Access Profile  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a token with SOURCE_SUBADMIN authority must have access to the Source associated with the given Access Profile
     * @summary List Access Profile\'s Entitlements
     * @param {AccessProfilesBetaApiGetAccessProfileEntitlementsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesBetaApi
     */
    public getAccessProfileEntitlements(requestParameters: AccessProfilesBetaApiGetAccessProfileEntitlementsRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessProfilesBetaApiFp(this.configuration).getAccessProfileEntitlements(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of Access Profiles.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary List Access Profiles
     * @param {AccessProfilesBetaApiListAccessProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesBetaApi
     */
    public listAccessProfiles(requestParameters: AccessProfilesBetaApiListAccessProfilesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccessProfilesBetaApiFp(this.configuration).listAccessProfiles(requestParameters.forSubadmin, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.forSegmentIds, requestParameters.includeUnsegmented, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates an existing Access Profile. The following fields are patchable: **name**, **description**, **enabled**, **owner**, **requestable**, **accessRequestConfig**, **revokeRequestConfig**, **segments**, **entitlements**, **provisioningCriteria** A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to patch Access Profiles which are associated with Sources they are able to administer. >  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.  > You can only add or replace **entitlements** that exist on the source that the access profile is attached to. You can use the **list entitlements** endpoint with the **filters** query parameter to get a list of available entitlements on the access profile\'s source.  >  Patching the value of the **requestable** field is only supported for customers enabled with the new Request Center. Otherwise, attempting to modify this field results in a 400 error.
     * @summary Patch a specified Access Profile
     * @param {AccessProfilesBetaApiPatchAccessProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesBetaApi
     */
    public patchAccessProfile(requestParameters: AccessProfilesBetaApiPatchAccessProfileRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessProfilesBetaApiFp(this.configuration).patchAccessProfile(requestParameters.id, requestParameters.jsonPatchOperationBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccessRequestApprovalsBetaApi - axios parameter creator
 * @export
 */
export const AccessRequestApprovalsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint approves an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Approves an access request approval.
         * @param {string} approvalId The id of the approval.
         * @param {CommentDtoBeta} [commentDtoBeta] Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveAccessRequest: async (approvalId: string, commentDtoBeta?: CommentDtoBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'approvalId' is not null or undefined
            assertParamExists('approveAccessRequest', 'approvalId', approvalId)
            const localVarPath = `/access-request-approvals/{approvalId}/approve`
                .replace(`{${"approvalId"}}`, encodeURIComponent(String(approvalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commentDtoBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint forwards an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Forwards an access request approval to a new owner.
         * @param {string} approvalId The id of the approval.
         * @param {ForwardApprovalDtoBeta} forwardApprovalDtoBeta Information about the forwarded approval.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        forwardAccessRequest: async (approvalId: string, forwardApprovalDtoBeta: ForwardApprovalDtoBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'approvalId' is not null or undefined
            assertParamExists('forwardAccessRequest', 'approvalId', approvalId)
            // verify required parameter 'forwardApprovalDtoBeta' is not null or undefined
            assertParamExists('forwardAccessRequest', 'forwardApprovalDtoBeta', forwardApprovalDtoBeta)
            const localVarPath = `/access-request-approvals/{approvalId}/forward`
                .replace(`{${"approvalId"}}`, encodeURIComponent(String(approvalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forwardApprovalDtoBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns the number of pending, approved and rejected access requests approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Get the number of pending, approved and rejected access requests approvals
         * @param {string} [ownerId] The id of the owner or approver identity of the approvals. If present, the value returns approval summary for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN user can also fetch all the approvals in the org, when owner-id is not used.    * Non ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {string} [fromDate] From date is the date and time from which the results will be shown. It should be in a valid ISO-8601 format  example: from-date&#x3D;2020-03-19T19:59:11Z
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestApprovalSummary: async (ownerId?: string, fromDate?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-request-approvals/approval-summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['owner-id'] = ownerId;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = fromDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns list of completed approvals. See *owner-id* query parameter below for authorization info.
         * @summary Completed Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only completed approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCompletedApprovals: async (ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-request-approvals/completed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['owner-id'] = ownerId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list of pending approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Pending Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only pending approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPendingApprovals: async (ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-request-approvals/pending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['owner-id'] = ownerId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint rejects an access request approval. Only the owner of the approval and admin users are allowed to perform this action.
         * @summary Rejects an access request approval.
         * @param {string} approvalId The id of the approval.
         * @param {CommentDtoBeta} [commentDtoBeta] Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectAccessRequest: async (approvalId: string, commentDtoBeta?: CommentDtoBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'approvalId' is not null or undefined
            assertParamExists('rejectAccessRequest', 'approvalId', approvalId)
            const localVarPath = `/access-request-approvals/{approvalId}/reject`
                .replace(`{${"approvalId"}}`, encodeURIComponent(String(approvalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commentDtoBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessRequestApprovalsBetaApi - functional programming interface
 * @export
 */
export const AccessRequestApprovalsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessRequestApprovalsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint approves an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Approves an access request approval.
         * @param {string} approvalId The id of the approval.
         * @param {CommentDtoBeta} [commentDtoBeta] Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async approveAccessRequest(approvalId: string, commentDtoBeta?: CommentDtoBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveAccessRequest(approvalId, commentDtoBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint forwards an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Forwards an access request approval to a new owner.
         * @param {string} approvalId The id of the approval.
         * @param {ForwardApprovalDtoBeta} forwardApprovalDtoBeta Information about the forwarded approval.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async forwardAccessRequest(approvalId: string, forwardApprovalDtoBeta: ForwardApprovalDtoBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forwardAccessRequest(approvalId, forwardApprovalDtoBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns the number of pending, approved and rejected access requests approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Get the number of pending, approved and rejected access requests approvals
         * @param {string} [ownerId] The id of the owner or approver identity of the approvals. If present, the value returns approval summary for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN user can also fetch all the approvals in the org, when owner-id is not used.    * Non ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {string} [fromDate] From date is the date and time from which the results will be shown. It should be in a valid ISO-8601 format  example: from-date&#x3D;2020-03-19T19:59:11Z
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessRequestApprovalSummary(ownerId?: string, fromDate?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApprovalSummaryBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessRequestApprovalSummary(ownerId, fromDate, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns list of completed approvals. See *owner-id* query parameter below for authorization info.
         * @summary Completed Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only completed approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listCompletedApprovals(ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CompletedApprovalBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCompletedApprovals(ownerId, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list of pending approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Pending Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only pending approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listPendingApprovals(ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PendingApprovalBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPendingApprovals(ownerId, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint rejects an access request approval. Only the owner of the approval and admin users are allowed to perform this action.
         * @summary Rejects an access request approval.
         * @param {string} approvalId The id of the approval.
         * @param {CommentDtoBeta} [commentDtoBeta] Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async rejectAccessRequest(approvalId: string, commentDtoBeta?: CommentDtoBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectAccessRequest(approvalId, commentDtoBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccessRequestApprovalsBetaApi - factory interface
 * @export
 */
export const AccessRequestApprovalsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessRequestApprovalsBetaApiFp(configuration)
    return {
        /**
         * This endpoint approves an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Approves an access request approval.
         * @param {string} approvalId The id of the approval.
         * @param {CommentDtoBeta} [commentDtoBeta] Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveAccessRequest(approvalId: string, commentDtoBeta?: CommentDtoBeta, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.approveAccessRequest(approvalId, commentDtoBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint forwards an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Forwards an access request approval to a new owner.
         * @param {string} approvalId The id of the approval.
         * @param {ForwardApprovalDtoBeta} forwardApprovalDtoBeta Information about the forwarded approval.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        forwardAccessRequest(approvalId: string, forwardApprovalDtoBeta: ForwardApprovalDtoBeta, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.forwardAccessRequest(approvalId, forwardApprovalDtoBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns the number of pending, approved and rejected access requests approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Get the number of pending, approved and rejected access requests approvals
         * @param {string} [ownerId] The id of the owner or approver identity of the approvals. If present, the value returns approval summary for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN user can also fetch all the approvals in the org, when owner-id is not used.    * Non ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {string} [fromDate] From date is the date and time from which the results will be shown. It should be in a valid ISO-8601 format  example: from-date&#x3D;2020-03-19T19:59:11Z
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestApprovalSummary(ownerId?: string, fromDate?: string, axiosOptions?: any): AxiosPromise<ApprovalSummaryBeta> {
            return localVarFp.getAccessRequestApprovalSummary(ownerId, fromDate, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns list of completed approvals. See *owner-id* query parameter below for authorization info.
         * @summary Completed Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only completed approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCompletedApprovals(ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<CompletedApprovalBeta>> {
            return localVarFp.listCompletedApprovals(ownerId, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of pending approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Pending Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only pending approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPendingApprovals(ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<PendingApprovalBeta>> {
            return localVarFp.listPendingApprovals(ownerId, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint rejects an access request approval. Only the owner of the approval and admin users are allowed to perform this action.
         * @summary Rejects an access request approval.
         * @param {string} approvalId The id of the approval.
         * @param {CommentDtoBeta} [commentDtoBeta] Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectAccessRequest(approvalId: string, commentDtoBeta?: CommentDtoBeta, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.rejectAccessRequest(approvalId, commentDtoBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for approveAccessRequest operation in AccessRequestApprovalsBetaApi.
 * @export
 * @interface AccessRequestApprovalsBetaApiApproveAccessRequestRequest
 */
export interface AccessRequestApprovalsBetaApiApproveAccessRequestRequest {
    /**
     * The id of the approval.
     * @type {string}
     * @memberof AccessRequestApprovalsBetaApiApproveAccessRequest
     */
    readonly approvalId: string

    /**
     * Reviewer\&#39;s comment.
     * @type {CommentDtoBeta}
     * @memberof AccessRequestApprovalsBetaApiApproveAccessRequest
     */
    readonly commentDtoBeta?: CommentDtoBeta
}

/**
 * Request parameters for forwardAccessRequest operation in AccessRequestApprovalsBetaApi.
 * @export
 * @interface AccessRequestApprovalsBetaApiForwardAccessRequestRequest
 */
export interface AccessRequestApprovalsBetaApiForwardAccessRequestRequest {
    /**
     * The id of the approval.
     * @type {string}
     * @memberof AccessRequestApprovalsBetaApiForwardAccessRequest
     */
    readonly approvalId: string

    /**
     * Information about the forwarded approval.
     * @type {ForwardApprovalDtoBeta}
     * @memberof AccessRequestApprovalsBetaApiForwardAccessRequest
     */
    readonly forwardApprovalDtoBeta: ForwardApprovalDtoBeta
}

/**
 * Request parameters for getAccessRequestApprovalSummary operation in AccessRequestApprovalsBetaApi.
 * @export
 * @interface AccessRequestApprovalsBetaApiGetAccessRequestApprovalSummaryRequest
 */
export interface AccessRequestApprovalsBetaApiGetAccessRequestApprovalSummaryRequest {
    /**
     * The id of the owner or approver identity of the approvals. If present, the value returns approval summary for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN user can also fetch all the approvals in the org, when owner-id is not used.    * Non ORG_ADMIN users can only specify *me* or pass their own identity ID value.
     * @type {string}
     * @memberof AccessRequestApprovalsBetaApiGetAccessRequestApprovalSummary
     */
    readonly ownerId?: string

    /**
     * From date is the date and time from which the results will be shown. It should be in a valid ISO-8601 format  example: from-date&#x3D;2020-03-19T19:59:11Z
     * @type {string}
     * @memberof AccessRequestApprovalsBetaApiGetAccessRequestApprovalSummary
     */
    readonly fromDate?: string
}

/**
 * Request parameters for listCompletedApprovals operation in AccessRequestApprovalsBetaApi.
 * @export
 * @interface AccessRequestApprovalsBetaApiListCompletedApprovalsRequest
 */
export interface AccessRequestApprovalsBetaApiListCompletedApprovalsRequest {
    /**
     * If present, the value returns only completed approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
     * @type {string}
     * @memberof AccessRequestApprovalsBetaApiListCompletedApprovals
     */
    readonly ownerId?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessRequestApprovalsBetaApiListCompletedApprovals
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessRequestApprovalsBetaApiListCompletedApprovals
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccessRequestApprovalsBetaApiListCompletedApprovals
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le*
     * @type {string}
     * @memberof AccessRequestApprovalsBetaApiListCompletedApprovals
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
     * @type {string}
     * @memberof AccessRequestApprovalsBetaApiListCompletedApprovals
     */
    readonly sorters?: string
}

/**
 * Request parameters for listPendingApprovals operation in AccessRequestApprovalsBetaApi.
 * @export
 * @interface AccessRequestApprovalsBetaApiListPendingApprovalsRequest
 */
export interface AccessRequestApprovalsBetaApiListPendingApprovalsRequest {
    /**
     * If present, the value returns only pending approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
     * @type {string}
     * @memberof AccessRequestApprovalsBetaApiListPendingApprovals
     */
    readonly ownerId?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessRequestApprovalsBetaApiListPendingApprovals
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessRequestApprovalsBetaApiListPendingApprovals
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccessRequestApprovalsBetaApiListPendingApprovals
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le*
     * @type {string}
     * @memberof AccessRequestApprovalsBetaApiListPendingApprovals
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
     * @type {string}
     * @memberof AccessRequestApprovalsBetaApiListPendingApprovals
     */
    readonly sorters?: string
}

/**
 * Request parameters for rejectAccessRequest operation in AccessRequestApprovalsBetaApi.
 * @export
 * @interface AccessRequestApprovalsBetaApiRejectAccessRequestRequest
 */
export interface AccessRequestApprovalsBetaApiRejectAccessRequestRequest {
    /**
     * The id of the approval.
     * @type {string}
     * @memberof AccessRequestApprovalsBetaApiRejectAccessRequest
     */
    readonly approvalId: string

    /**
     * Reviewer\&#39;s comment.
     * @type {CommentDtoBeta}
     * @memberof AccessRequestApprovalsBetaApiRejectAccessRequest
     */
    readonly commentDtoBeta?: CommentDtoBeta
}

/**
 * AccessRequestApprovalsBetaApi - object-oriented interface
 * @export
 * @class AccessRequestApprovalsBetaApi
 * @extends {BaseAPI}
 */
export class AccessRequestApprovalsBetaApi extends BaseAPI {
    /**
     * This endpoint approves an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
     * @summary Approves an access request approval.
     * @param {AccessRequestApprovalsBetaApiApproveAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsBetaApi
     */
    public approveAccessRequest(requestParameters: AccessRequestApprovalsBetaApiApproveAccessRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestApprovalsBetaApiFp(this.configuration).approveAccessRequest(requestParameters.approvalId, requestParameters.commentDtoBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint forwards an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
     * @summary Forwards an access request approval to a new owner.
     * @param {AccessRequestApprovalsBetaApiForwardAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsBetaApi
     */
    public forwardAccessRequest(requestParameters: AccessRequestApprovalsBetaApiForwardAccessRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestApprovalsBetaApiFp(this.configuration).forwardAccessRequest(requestParameters.approvalId, requestParameters.forwardApprovalDtoBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns the number of pending, approved and rejected access requests approvals. See \"owner-id\" query parameter below for authorization info.
     * @summary Get the number of pending, approved and rejected access requests approvals
     * @param {AccessRequestApprovalsBetaApiGetAccessRequestApprovalSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsBetaApi
     */
    public getAccessRequestApprovalSummary(requestParameters: AccessRequestApprovalsBetaApiGetAccessRequestApprovalSummaryRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestApprovalsBetaApiFp(this.configuration).getAccessRequestApprovalSummary(requestParameters.ownerId, requestParameters.fromDate, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns list of completed approvals. See *owner-id* query parameter below for authorization info.
     * @summary Completed Access Request Approvals List
     * @param {AccessRequestApprovalsBetaApiListCompletedApprovalsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsBetaApi
     */
    public listCompletedApprovals(requestParameters: AccessRequestApprovalsBetaApiListCompletedApprovalsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestApprovalsBetaApiFp(this.configuration).listCompletedApprovals(requestParameters.ownerId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list of pending approvals. See \"owner-id\" query parameter below for authorization info.
     * @summary Pending Access Request Approvals List
     * @param {AccessRequestApprovalsBetaApiListPendingApprovalsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsBetaApi
     */
    public listPendingApprovals(requestParameters: AccessRequestApprovalsBetaApiListPendingApprovalsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestApprovalsBetaApiFp(this.configuration).listPendingApprovals(requestParameters.ownerId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint rejects an access request approval. Only the owner of the approval and admin users are allowed to perform this action.
     * @summary Rejects an access request approval.
     * @param {AccessRequestApprovalsBetaApiRejectAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsBetaApi
     */
    public rejectAccessRequest(requestParameters: AccessRequestApprovalsBetaApiRejectAccessRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestApprovalsBetaApiFp(this.configuration).rejectAccessRequest(requestParameters.approvalId, requestParameters.commentDtoBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccessRequestsBetaApi - axios parameter creator
 * @export
 */
export const AccessRequestsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API endpoint cancels a pending access request. An access request can be cancelled only if it has not passed the approval step. Any token with ORG_ADMIN authority or token of the user who originally requested the access request is required to cancel it.
         * @summary Cancel Access Request
         * @param {CancelAccessRequestBeta} cancelAccessRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelAccessRequest: async (cancelAccessRequestBeta: CancelAccessRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cancelAccessRequestBeta' is not null or undefined
            assertParamExists('cancelAccessRequest', 'cancelAccessRequestBeta', cancelAccessRequestBeta)
            const localVarPath = `/access-requests/cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelAccessRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint closes access requests that are stuck in a pending state. It can be used throughout a request\'s lifecycle (even after the approval state, unlike <a href=\"https://developer.sailpoint.com/idn/api/v3/cancel-access-request\">Cancel Access Request</a>). A token with ORG_ADMIN authority is required.  To find pending access requests via the UI, navigate to Search and use this query: status: Pending AND \"Access Request\". Use the Column Chooser to select \"Tracking Number,\" and the Download button to export a CSV containing the Tracking Numbers.  To find pending access requests via the API, use <a href=\"https://developer.sailpoint.com/idn/api/v3/list-account-activities\">List Account Activities</a>.  Input the ids from either source  To track the status of endpoint requests, navigate to Search and use this query: name:\"Close Identity Requests\". Search will include \"Close Identity Requests Started\" audits when requests are initiated, and \"Close Identity Requests Completed\" audits when requests are completed. The completion audit will list the Identity Request IDs that finished in error.  This API triggers the <a href=\"https://developer.sailpoint.com/idn/docs/event-triggers/triggers/provisioning-action-completed\">Provisioning Action Completed</a> event trigger for each access request that is closed. 
         * @summary Close Access Request
         * @param {CloseAccessRequestBeta} closeAccessRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        closeAccessRequest: async (closeAccessRequestBeta: CloseAccessRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'closeAccessRequestBeta' is not null or undefined
            assertParamExists('closeAccessRequest', 'closeAccessRequestBeta', closeAccessRequestBeta)
            const localVarPath = `/access-requests/close`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(closeAccessRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This submits the access request into IdentityNow, where it will follow any IdentityNow approval processes.  Access requests are processed asynchronously by IdentityNow.  A success response from this endpoint means the request has been submitted to IDN and is queued for processing.  Because this endpoint is asynchronous, it will not return an error if you submit duplicate access requests in quick succession, or you submit an access request for access that is already in progress, approved, or rejected. It is best practice to check for any existing access requests that reference the same access items before submitting a new access request.  This can be accomplished by using the [access request status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) or the [pending access request approvals](https://developer.sailpoint.com/idn/api/v3/list-pending-approvals) endpoints.  You can also use the [search API](https://developer.sailpoint.com/idn/api/v3/search) to check the existing access items that an identity has before submitting an access request to ensure you are not requesting access that is already granted.  There are two types of access request:  __GRANT_ACCESS__ * Can be requested for multiple identities in a single request. * Supports self request and request on behalf of other users. Refer to the [Get Access Request Configuration](https://developer.sailpoint.com/idn/api/v3/get-access-request-config) endpoint for request configuration options.   * Allows any authenticated token (except API) to call this endpoint to request to grant access to themselves. Depending on the configuration, a user can request access for others. * Roles, Access Profiles and Entitlements can be requested. * While requesting entitlements, maximum of 25 entitlements and 10 recipients are allowed in a request.   __REVOKE_ACCESS__ * Can only be requested for a single identity at a time. * Does not support self request. Only manager can request to revoke access for their directly managed employees. * If removeDate is specified, then the access will be removed on that date and time only for Roles and Access Profiles. Entitlements are currently unsupported for removeDate. * Roles, Access Profiles, and Entitlements can be requested for revocation. * Revoke requests for entitlements are limited to 1 entitlement per access request currently. * [Roles, Access Profiles] removeDate can be specified if access don\'t have a sunset date or if a revoke access with a removeDate earlier than the current endDate. * Allows a manager to request to revoke access for direct employees. A token with ORG_ADMIN authority can also request to revoke access from anyone.  NOTE: There is no indication to the approver in the IdentityNow UI that the approval request is for a revoke action. Take this into consideration when calling this API.  A token with API authority cannot be used to call this endpoint.  
         * @summary Submit an Access Request
         * @param {AccessRequestBeta} accessRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccessRequest: async (accessRequestBeta: AccessRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessRequestBeta' is not null or undefined
            assertParamExists('createAccessRequest', 'accessRequestBeta', accessRequestBeta)
            const localVarPath = `/access-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns the current access-request configuration.
         * @summary Get Access Request Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestConfig: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-request-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * The Access Request Status API returns a list of access request statuses based on the specified query parameters. Any token with any authority can request their own status. A token with ORG_ADMIN authority is required to call this API to get a list of statuses for other users.
         * @summary Access Request Status
         * @param {string} [requestedFor] Filter the results by the identity for which the requests were made. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] Filter the results by the identity that made the requests. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] Filter the results by the specified identity which is either the requester or target of the requests. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.
         * @param {number} [limit] Max number of results to return.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. Defaults to 0 if not specified.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **accountActivityItemId**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified, accountActivityItemId**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccessRequestStatus: async (requestedFor?: string, requestedBy?: string, regardingIdentity?: string, count?: boolean, limit?: number, offset?: number, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-request-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (requestedFor !== undefined) {
                localVarQueryParameter['requested-for'] = requestedFor;
            }

            if (requestedBy !== undefined) {
                localVarQueryParameter['requested-by'] = requestedBy;
            }

            if (regardingIdentity !== undefined) {
                localVarQueryParameter['regarding-identity'] = regardingIdentity;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint replaces the current access-request configuration. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Access Request Configuration
         * @param {AccessRequestConfigBeta} accessRequestConfigBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateAccessRequestConfig: async (accessRequestConfigBeta: AccessRequestConfigBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessRequestConfigBeta' is not null or undefined
            assertParamExists('updateAccessRequestConfig', 'accessRequestConfigBeta', accessRequestConfigBeta)
            const localVarPath = `/access-request-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessRequestConfigBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessRequestsBetaApi - functional programming interface
 * @export
 */
export const AccessRequestsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessRequestsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This API endpoint cancels a pending access request. An access request can be cancelled only if it has not passed the approval step. Any token with ORG_ADMIN authority or token of the user who originally requested the access request is required to cancel it.
         * @summary Cancel Access Request
         * @param {CancelAccessRequestBeta} cancelAccessRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async cancelAccessRequest(cancelAccessRequestBeta: CancelAccessRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelAccessRequest(cancelAccessRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint closes access requests that are stuck in a pending state. It can be used throughout a request\'s lifecycle (even after the approval state, unlike <a href=\"https://developer.sailpoint.com/idn/api/v3/cancel-access-request\">Cancel Access Request</a>). A token with ORG_ADMIN authority is required.  To find pending access requests via the UI, navigate to Search and use this query: status: Pending AND \"Access Request\". Use the Column Chooser to select \"Tracking Number,\" and the Download button to export a CSV containing the Tracking Numbers.  To find pending access requests via the API, use <a href=\"https://developer.sailpoint.com/idn/api/v3/list-account-activities\">List Account Activities</a>.  Input the ids from either source  To track the status of endpoint requests, navigate to Search and use this query: name:\"Close Identity Requests\". Search will include \"Close Identity Requests Started\" audits when requests are initiated, and \"Close Identity Requests Completed\" audits when requests are completed. The completion audit will list the Identity Request IDs that finished in error.  This API triggers the <a href=\"https://developer.sailpoint.com/idn/docs/event-triggers/triggers/provisioning-action-completed\">Provisioning Action Completed</a> event trigger for each access request that is closed. 
         * @summary Close Access Request
         * @param {CloseAccessRequestBeta} closeAccessRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async closeAccessRequest(closeAccessRequestBeta: CloseAccessRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.closeAccessRequest(closeAccessRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This submits the access request into IdentityNow, where it will follow any IdentityNow approval processes.  Access requests are processed asynchronously by IdentityNow.  A success response from this endpoint means the request has been submitted to IDN and is queued for processing.  Because this endpoint is asynchronous, it will not return an error if you submit duplicate access requests in quick succession, or you submit an access request for access that is already in progress, approved, or rejected. It is best practice to check for any existing access requests that reference the same access items before submitting a new access request.  This can be accomplished by using the [access request status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) or the [pending access request approvals](https://developer.sailpoint.com/idn/api/v3/list-pending-approvals) endpoints.  You can also use the [search API](https://developer.sailpoint.com/idn/api/v3/search) to check the existing access items that an identity has before submitting an access request to ensure you are not requesting access that is already granted.  There are two types of access request:  __GRANT_ACCESS__ * Can be requested for multiple identities in a single request. * Supports self request and request on behalf of other users. Refer to the [Get Access Request Configuration](https://developer.sailpoint.com/idn/api/v3/get-access-request-config) endpoint for request configuration options.   * Allows any authenticated token (except API) to call this endpoint to request to grant access to themselves. Depending on the configuration, a user can request access for others. * Roles, Access Profiles and Entitlements can be requested. * While requesting entitlements, maximum of 25 entitlements and 10 recipients are allowed in a request.   __REVOKE_ACCESS__ * Can only be requested for a single identity at a time. * Does not support self request. Only manager can request to revoke access for their directly managed employees. * If removeDate is specified, then the access will be removed on that date and time only for Roles and Access Profiles. Entitlements are currently unsupported for removeDate. * Roles, Access Profiles, and Entitlements can be requested for revocation. * Revoke requests for entitlements are limited to 1 entitlement per access request currently. * [Roles, Access Profiles] removeDate can be specified if access don\'t have a sunset date or if a revoke access with a removeDate earlier than the current endDate. * Allows a manager to request to revoke access for direct employees. A token with ORG_ADMIN authority can also request to revoke access from anyone.  NOTE: There is no indication to the approver in the IdentityNow UI that the approval request is for a revoke action. Take this into consideration when calling this API.  A token with API authority cannot be used to call this endpoint.  
         * @summary Submit an Access Request
         * @param {AccessRequestBeta} accessRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createAccessRequest(accessRequestBeta: AccessRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccessRequest(accessRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns the current access-request configuration.
         * @summary Get Access Request Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessRequestConfig(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessRequestConfigBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessRequestConfig(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The Access Request Status API returns a list of access request statuses based on the specified query parameters. Any token with any authority can request their own status. A token with ORG_ADMIN authority is required to call this API to get a list of statuses for other users.
         * @summary Access Request Status
         * @param {string} [requestedFor] Filter the results by the identity for which the requests were made. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] Filter the results by the identity that made the requests. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] Filter the results by the specified identity which is either the requester or target of the requests. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.
         * @param {number} [limit] Max number of results to return.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. Defaults to 0 if not specified.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **accountActivityItemId**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified, accountActivityItemId**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listAccessRequestStatus(requestedFor?: string, requestedBy?: string, regardingIdentity?: string, count?: boolean, limit?: number, offset?: number, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RequestedItemStatusBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccessRequestStatus(requestedFor, requestedBy, regardingIdentity, count, limit, offset, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint replaces the current access-request configuration. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Access Request Configuration
         * @param {AccessRequestConfigBeta} accessRequestConfigBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccessRequestConfig(accessRequestConfigBeta: AccessRequestConfigBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessRequestConfigBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccessRequestConfig(accessRequestConfigBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccessRequestsBetaApi - factory interface
 * @export
 */
export const AccessRequestsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessRequestsBetaApiFp(configuration)
    return {
        /**
         * This API endpoint cancels a pending access request. An access request can be cancelled only if it has not passed the approval step. Any token with ORG_ADMIN authority or token of the user who originally requested the access request is required to cancel it.
         * @summary Cancel Access Request
         * @param {CancelAccessRequestBeta} cancelAccessRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelAccessRequest(cancelAccessRequestBeta: CancelAccessRequestBeta, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.cancelAccessRequest(cancelAccessRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint closes access requests that are stuck in a pending state. It can be used throughout a request\'s lifecycle (even after the approval state, unlike <a href=\"https://developer.sailpoint.com/idn/api/v3/cancel-access-request\">Cancel Access Request</a>). A token with ORG_ADMIN authority is required.  To find pending access requests via the UI, navigate to Search and use this query: status: Pending AND \"Access Request\". Use the Column Chooser to select \"Tracking Number,\" and the Download button to export a CSV containing the Tracking Numbers.  To find pending access requests via the API, use <a href=\"https://developer.sailpoint.com/idn/api/v3/list-account-activities\">List Account Activities</a>.  Input the ids from either source  To track the status of endpoint requests, navigate to Search and use this query: name:\"Close Identity Requests\". Search will include \"Close Identity Requests Started\" audits when requests are initiated, and \"Close Identity Requests Completed\" audits when requests are completed. The completion audit will list the Identity Request IDs that finished in error.  This API triggers the <a href=\"https://developer.sailpoint.com/idn/docs/event-triggers/triggers/provisioning-action-completed\">Provisioning Action Completed</a> event trigger for each access request that is closed. 
         * @summary Close Access Request
         * @param {CloseAccessRequestBeta} closeAccessRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        closeAccessRequest(closeAccessRequestBeta: CloseAccessRequestBeta, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.closeAccessRequest(closeAccessRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This submits the access request into IdentityNow, where it will follow any IdentityNow approval processes.  Access requests are processed asynchronously by IdentityNow.  A success response from this endpoint means the request has been submitted to IDN and is queued for processing.  Because this endpoint is asynchronous, it will not return an error if you submit duplicate access requests in quick succession, or you submit an access request for access that is already in progress, approved, or rejected. It is best practice to check for any existing access requests that reference the same access items before submitting a new access request.  This can be accomplished by using the [access request status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) or the [pending access request approvals](https://developer.sailpoint.com/idn/api/v3/list-pending-approvals) endpoints.  You can also use the [search API](https://developer.sailpoint.com/idn/api/v3/search) to check the existing access items that an identity has before submitting an access request to ensure you are not requesting access that is already granted.  There are two types of access request:  __GRANT_ACCESS__ * Can be requested for multiple identities in a single request. * Supports self request and request on behalf of other users. Refer to the [Get Access Request Configuration](https://developer.sailpoint.com/idn/api/v3/get-access-request-config) endpoint for request configuration options.   * Allows any authenticated token (except API) to call this endpoint to request to grant access to themselves. Depending on the configuration, a user can request access for others. * Roles, Access Profiles and Entitlements can be requested. * While requesting entitlements, maximum of 25 entitlements and 10 recipients are allowed in a request.   __REVOKE_ACCESS__ * Can only be requested for a single identity at a time. * Does not support self request. Only manager can request to revoke access for their directly managed employees. * If removeDate is specified, then the access will be removed on that date and time only for Roles and Access Profiles. Entitlements are currently unsupported for removeDate. * Roles, Access Profiles, and Entitlements can be requested for revocation. * Revoke requests for entitlements are limited to 1 entitlement per access request currently. * [Roles, Access Profiles] removeDate can be specified if access don\'t have a sunset date or if a revoke access with a removeDate earlier than the current endDate. * Allows a manager to request to revoke access for direct employees. A token with ORG_ADMIN authority can also request to revoke access from anyone.  NOTE: There is no indication to the approver in the IdentityNow UI that the approval request is for a revoke action. Take this into consideration when calling this API.  A token with API authority cannot be used to call this endpoint.  
         * @summary Submit an Access Request
         * @param {AccessRequestBeta} accessRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccessRequest(accessRequestBeta: AccessRequestBeta, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.createAccessRequest(accessRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns the current access-request configuration.
         * @summary Get Access Request Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestConfig(axiosOptions?: any): AxiosPromise<AccessRequestConfigBeta> {
            return localVarFp.getAccessRequestConfig(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * The Access Request Status API returns a list of access request statuses based on the specified query parameters. Any token with any authority can request their own status. A token with ORG_ADMIN authority is required to call this API to get a list of statuses for other users.
         * @summary Access Request Status
         * @param {string} [requestedFor] Filter the results by the identity for which the requests were made. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] Filter the results by the identity that made the requests. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] Filter the results by the specified identity which is either the requester or target of the requests. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.
         * @param {number} [limit] Max number of results to return.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. Defaults to 0 if not specified.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **accountActivityItemId**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified, accountActivityItemId**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccessRequestStatus(requestedFor?: string, requestedBy?: string, regardingIdentity?: string, count?: boolean, limit?: number, offset?: number, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<RequestedItemStatusBeta>> {
            return localVarFp.listAccessRequestStatus(requestedFor, requestedBy, regardingIdentity, count, limit, offset, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint replaces the current access-request configuration. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Access Request Configuration
         * @param {AccessRequestConfigBeta} accessRequestConfigBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateAccessRequestConfig(accessRequestConfigBeta: AccessRequestConfigBeta, axiosOptions?: any): AxiosPromise<AccessRequestConfigBeta> {
            return localVarFp.updateAccessRequestConfig(accessRequestConfigBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancelAccessRequest operation in AccessRequestsBetaApi.
 * @export
 * @interface AccessRequestsBetaApiCancelAccessRequestRequest
 */
export interface AccessRequestsBetaApiCancelAccessRequestRequest {
    /**
     * 
     * @type {CancelAccessRequestBeta}
     * @memberof AccessRequestsBetaApiCancelAccessRequest
     */
    readonly cancelAccessRequestBeta: CancelAccessRequestBeta
}

/**
 * Request parameters for closeAccessRequest operation in AccessRequestsBetaApi.
 * @export
 * @interface AccessRequestsBetaApiCloseAccessRequestRequest
 */
export interface AccessRequestsBetaApiCloseAccessRequestRequest {
    /**
     * 
     * @type {CloseAccessRequestBeta}
     * @memberof AccessRequestsBetaApiCloseAccessRequest
     */
    readonly closeAccessRequestBeta: CloseAccessRequestBeta
}

/**
 * Request parameters for createAccessRequest operation in AccessRequestsBetaApi.
 * @export
 * @interface AccessRequestsBetaApiCreateAccessRequestRequest
 */
export interface AccessRequestsBetaApiCreateAccessRequestRequest {
    /**
     * 
     * @type {AccessRequestBeta}
     * @memberof AccessRequestsBetaApiCreateAccessRequest
     */
    readonly accessRequestBeta: AccessRequestBeta
}

/**
 * Request parameters for listAccessRequestStatus operation in AccessRequestsBetaApi.
 * @export
 * @interface AccessRequestsBetaApiListAccessRequestStatusRequest
 */
export interface AccessRequestsBetaApiListAccessRequestStatusRequest {
    /**
     * Filter the results by the identity for which the requests were made. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
     * @type {string}
     * @memberof AccessRequestsBetaApiListAccessRequestStatus
     */
    readonly requestedFor?: string

    /**
     * Filter the results by the identity that made the requests. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
     * @type {string}
     * @memberof AccessRequestsBetaApiListAccessRequestStatus
     */
    readonly requestedBy?: string

    /**
     * Filter the results by the specified identity which is either the requester or target of the requests. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
     * @type {string}
     * @memberof AccessRequestsBetaApiListAccessRequestStatus
     */
    readonly regardingIdentity?: string

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.
     * @type {boolean}
     * @memberof AccessRequestsBetaApiListAccessRequestStatus
     */
    readonly count?: boolean

    /**
     * Max number of results to return.
     * @type {number}
     * @memberof AccessRequestsBetaApiListAccessRequestStatus
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. Defaults to 0 if not specified.
     * @type {number}
     * @memberof AccessRequestsBetaApiListAccessRequestStatus
     */
    readonly offset?: number

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **accountActivityItemId**: *eq, in*
     * @type {string}
     * @memberof AccessRequestsBetaApiListAccessRequestStatus
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified, accountActivityItemId**
     * @type {string}
     * @memberof AccessRequestsBetaApiListAccessRequestStatus
     */
    readonly sorters?: string
}

/**
 * Request parameters for updateAccessRequestConfig operation in AccessRequestsBetaApi.
 * @export
 * @interface AccessRequestsBetaApiUpdateAccessRequestConfigRequest
 */
export interface AccessRequestsBetaApiUpdateAccessRequestConfigRequest {
    /**
     * 
     * @type {AccessRequestConfigBeta}
     * @memberof AccessRequestsBetaApiUpdateAccessRequestConfig
     */
    readonly accessRequestConfigBeta: AccessRequestConfigBeta
}

/**
 * AccessRequestsBetaApi - object-oriented interface
 * @export
 * @class AccessRequestsBetaApi
 * @extends {BaseAPI}
 */
export class AccessRequestsBetaApi extends BaseAPI {
    /**
     * This API endpoint cancels a pending access request. An access request can be cancelled only if it has not passed the approval step. Any token with ORG_ADMIN authority or token of the user who originally requested the access request is required to cancel it.
     * @summary Cancel Access Request
     * @param {AccessRequestsBetaApiCancelAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsBetaApi
     */
    public cancelAccessRequest(requestParameters: AccessRequestsBetaApiCancelAccessRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestsBetaApiFp(this.configuration).cancelAccessRequest(requestParameters.cancelAccessRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint closes access requests that are stuck in a pending state. It can be used throughout a request\'s lifecycle (even after the approval state, unlike <a href=\"https://developer.sailpoint.com/idn/api/v3/cancel-access-request\">Cancel Access Request</a>). A token with ORG_ADMIN authority is required.  To find pending access requests via the UI, navigate to Search and use this query: status: Pending AND \"Access Request\". Use the Column Chooser to select \"Tracking Number,\" and the Download button to export a CSV containing the Tracking Numbers.  To find pending access requests via the API, use <a href=\"https://developer.sailpoint.com/idn/api/v3/list-account-activities\">List Account Activities</a>.  Input the ids from either source  To track the status of endpoint requests, navigate to Search and use this query: name:\"Close Identity Requests\". Search will include \"Close Identity Requests Started\" audits when requests are initiated, and \"Close Identity Requests Completed\" audits when requests are completed. The completion audit will list the Identity Request IDs that finished in error.  This API triggers the <a href=\"https://developer.sailpoint.com/idn/docs/event-triggers/triggers/provisioning-action-completed\">Provisioning Action Completed</a> event trigger for each access request that is closed. 
     * @summary Close Access Request
     * @param {AccessRequestsBetaApiCloseAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsBetaApi
     */
    public closeAccessRequest(requestParameters: AccessRequestsBetaApiCloseAccessRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestsBetaApiFp(this.configuration).closeAccessRequest(requestParameters.closeAccessRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This submits the access request into IdentityNow, where it will follow any IdentityNow approval processes.  Access requests are processed asynchronously by IdentityNow.  A success response from this endpoint means the request has been submitted to IDN and is queued for processing.  Because this endpoint is asynchronous, it will not return an error if you submit duplicate access requests in quick succession, or you submit an access request for access that is already in progress, approved, or rejected. It is best practice to check for any existing access requests that reference the same access items before submitting a new access request.  This can be accomplished by using the [access request status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) or the [pending access request approvals](https://developer.sailpoint.com/idn/api/v3/list-pending-approvals) endpoints.  You can also use the [search API](https://developer.sailpoint.com/idn/api/v3/search) to check the existing access items that an identity has before submitting an access request to ensure you are not requesting access that is already granted.  There are two types of access request:  __GRANT_ACCESS__ * Can be requested for multiple identities in a single request. * Supports self request and request on behalf of other users. Refer to the [Get Access Request Configuration](https://developer.sailpoint.com/idn/api/v3/get-access-request-config) endpoint for request configuration options.   * Allows any authenticated token (except API) to call this endpoint to request to grant access to themselves. Depending on the configuration, a user can request access for others. * Roles, Access Profiles and Entitlements can be requested. * While requesting entitlements, maximum of 25 entitlements and 10 recipients are allowed in a request.   __REVOKE_ACCESS__ * Can only be requested for a single identity at a time. * Does not support self request. Only manager can request to revoke access for their directly managed employees. * If removeDate is specified, then the access will be removed on that date and time only for Roles and Access Profiles. Entitlements are currently unsupported for removeDate. * Roles, Access Profiles, and Entitlements can be requested for revocation. * Revoke requests for entitlements are limited to 1 entitlement per access request currently. * [Roles, Access Profiles] removeDate can be specified if access don\'t have a sunset date or if a revoke access with a removeDate earlier than the current endDate. * Allows a manager to request to revoke access for direct employees. A token with ORG_ADMIN authority can also request to revoke access from anyone.  NOTE: There is no indication to the approver in the IdentityNow UI that the approval request is for a revoke action. Take this into consideration when calling this API.  A token with API authority cannot be used to call this endpoint.  
     * @summary Submit an Access Request
     * @param {AccessRequestsBetaApiCreateAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsBetaApi
     */
    public createAccessRequest(requestParameters: AccessRequestsBetaApiCreateAccessRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestsBetaApiFp(this.configuration).createAccessRequest(requestParameters.accessRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns the current access-request configuration.
     * @summary Get Access Request Configuration
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsBetaApi
     */
    public getAccessRequestConfig(axiosOptions?: AxiosRequestConfig) {
        return AccessRequestsBetaApiFp(this.configuration).getAccessRequestConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The Access Request Status API returns a list of access request statuses based on the specified query parameters. Any token with any authority can request their own status. A token with ORG_ADMIN authority is required to call this API to get a list of statuses for other users.
     * @summary Access Request Status
     * @param {AccessRequestsBetaApiListAccessRequestStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsBetaApi
     */
    public listAccessRequestStatus(requestParameters: AccessRequestsBetaApiListAccessRequestStatusRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestsBetaApiFp(this.configuration).listAccessRequestStatus(requestParameters.requestedFor, requestParameters.requestedBy, requestParameters.regardingIdentity, requestParameters.count, requestParameters.limit, requestParameters.offset, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint replaces the current access-request configuration. A token with ORG_ADMIN authority is required to call this API.
     * @summary Update Access Request Configuration
     * @param {AccessRequestsBetaApiUpdateAccessRequestConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsBetaApi
     */
    public updateAccessRequestConfig(requestParameters: AccessRequestsBetaApiUpdateAccessRequestConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestsBetaApiFp(this.configuration).updateAccessRequestConfig(requestParameters.accessRequestConfigBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccountActivitiesBetaApi - axios parameter creator
 * @export
 */
export const AccountActivitiesBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This gets a single account activity by its id.
         * @summary Get Account Activity
         * @param {string} id The account activity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountActivity: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccountActivity', 'id', id)
            const localVarPath = `/account-activities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a collection of account activities that satisfy the given query parameters.
         * @summary List Account Activities
         * @param {string} [requestedFor] The identity that the activity was requested for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] The identity that requested the activity. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] The specified identity will be either the requester or target of the account activity. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {string} [type] The type of account activity.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **type**: *eq, in*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccountActivities: async (requestedFor?: string, requestedBy?: string, regardingIdentity?: string, type?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account-activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (requestedFor !== undefined) {
                localVarQueryParameter['requested-for'] = requestedFor;
            }

            if (requestedBy !== undefined) {
                localVarQueryParameter['requested-by'] = requestedBy;
            }

            if (regardingIdentity !== undefined) {
                localVarQueryParameter['regarding-identity'] = regardingIdentity;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountActivitiesBetaApi - functional programming interface
 * @export
 */
export const AccountActivitiesBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountActivitiesBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This gets a single account activity by its id.
         * @summary Get Account Activity
         * @param {string} id The account activity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountActivity(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CancelableAccountActivityBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountActivity(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a collection of account activities that satisfy the given query parameters.
         * @summary List Account Activities
         * @param {string} [requestedFor] The identity that the activity was requested for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] The identity that requested the activity. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] The specified identity will be either the requester or target of the account activity. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {string} [type] The type of account activity.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **type**: *eq, in*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listAccountActivities(requestedFor?: string, requestedBy?: string, regardingIdentity?: string, type?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CancelableAccountActivityBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccountActivities(requestedFor, requestedBy, regardingIdentity, type, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountActivitiesBetaApi - factory interface
 * @export
 */
export const AccountActivitiesBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountActivitiesBetaApiFp(configuration)
    return {
        /**
         * This gets a single account activity by its id.
         * @summary Get Account Activity
         * @param {string} id The account activity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountActivity(id: string, axiosOptions?: any): AxiosPromise<CancelableAccountActivityBeta> {
            return localVarFp.getAccountActivity(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a collection of account activities that satisfy the given query parameters.
         * @summary List Account Activities
         * @param {string} [requestedFor] The identity that the activity was requested for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] The identity that requested the activity. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] The specified identity will be either the requester or target of the account activity. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {string} [type] The type of account activity.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **type**: *eq, in*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccountActivities(requestedFor?: string, requestedBy?: string, regardingIdentity?: string, type?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<CancelableAccountActivityBeta>> {
            return localVarFp.listAccountActivities(requestedFor, requestedBy, regardingIdentity, type, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAccountActivity operation in AccountActivitiesBetaApi.
 * @export
 * @interface AccountActivitiesBetaApiGetAccountActivityRequest
 */
export interface AccountActivitiesBetaApiGetAccountActivityRequest {
    /**
     * The account activity id
     * @type {string}
     * @memberof AccountActivitiesBetaApiGetAccountActivity
     */
    readonly id: string
}

/**
 * Request parameters for listAccountActivities operation in AccountActivitiesBetaApi.
 * @export
 * @interface AccountActivitiesBetaApiListAccountActivitiesRequest
 */
export interface AccountActivitiesBetaApiListAccountActivitiesRequest {
    /**
     * The identity that the activity was requested for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
     * @type {string}
     * @memberof AccountActivitiesBetaApiListAccountActivities
     */
    readonly requestedFor?: string

    /**
     * The identity that requested the activity. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
     * @type {string}
     * @memberof AccountActivitiesBetaApiListAccountActivities
     */
    readonly requestedBy?: string

    /**
     * The specified identity will be either the requester or target of the account activity. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
     * @type {string}
     * @memberof AccountActivitiesBetaApiListAccountActivities
     */
    readonly regardingIdentity?: string

    /**
     * The type of account activity.
     * @type {string}
     * @memberof AccountActivitiesBetaApiListAccountActivities
     */
    readonly type?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountActivitiesBetaApiListAccountActivities
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountActivitiesBetaApiListAccountActivities
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccountActivitiesBetaApiListAccountActivities
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **type**: *eq, in*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*
     * @type {string}
     * @memberof AccountActivitiesBetaApiListAccountActivities
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified**
     * @type {string}
     * @memberof AccountActivitiesBetaApiListAccountActivities
     */
    readonly sorters?: string
}

/**
 * AccountActivitiesBetaApi - object-oriented interface
 * @export
 * @class AccountActivitiesBetaApi
 * @extends {BaseAPI}
 */
export class AccountActivitiesBetaApi extends BaseAPI {
    /**
     * This gets a single account activity by its id.
     * @summary Get Account Activity
     * @param {AccountActivitiesBetaApiGetAccountActivityRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountActivitiesBetaApi
     */
    public getAccountActivity(requestParameters: AccountActivitiesBetaApiGetAccountActivityRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountActivitiesBetaApiFp(this.configuration).getAccountActivity(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a collection of account activities that satisfy the given query parameters.
     * @summary List Account Activities
     * @param {AccountActivitiesBetaApiListAccountActivitiesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountActivitiesBetaApi
     */
    public listAccountActivities(requestParameters: AccountActivitiesBetaApiListAccountActivitiesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccountActivitiesBetaApiFp(this.configuration).listAccountActivities(requestParameters.requestedFor, requestParameters.requestedBy, requestParameters.regardingIdentity, requestParameters.type, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccountAggregationsBetaApi - axios parameter creator
 * @export
 */
export const AccountAggregationsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API returns the status of an *in-progress* account aggregation, along with the total number of **NEW**, **CHANGED** and **DELETED** accounts found since the previous aggregation, and the number of those accounts that have been processed so far.  Accounts that have not changed since the previous aggregation are not included in **totalAccounts** and **processedAccounts** counts returned by this API. This is distinct from **Accounts Scanned** shown in the Aggregation UI, which indicates total accounts scanned regardless of whether they changed or not.  Since this endpoint reports on the status of an *in-progress* account aggregation, totalAccounts and processedAccounts may change between calls to this endpoint.  *Only available up to an hour after the aggregation completes. May respond with *404 Not Found* after that.*  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN or DASHBOARD authority is required to call this API.
         * @summary In-progress Account Aggregation status
         * @param {string} id The account aggregation id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountAggregationStatus: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccountAggregationStatus', 'id', id)
            const localVarPath = `/account-aggregations/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountAggregationsBetaApi - functional programming interface
 * @export
 */
export const AccountAggregationsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountAggregationsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This API returns the status of an *in-progress* account aggregation, along with the total number of **NEW**, **CHANGED** and **DELETED** accounts found since the previous aggregation, and the number of those accounts that have been processed so far.  Accounts that have not changed since the previous aggregation are not included in **totalAccounts** and **processedAccounts** counts returned by this API. This is distinct from **Accounts Scanned** shown in the Aggregation UI, which indicates total accounts scanned regardless of whether they changed or not.  Since this endpoint reports on the status of an *in-progress* account aggregation, totalAccounts and processedAccounts may change between calls to this endpoint.  *Only available up to an hour after the aggregation completes. May respond with *404 Not Found* after that.*  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN or DASHBOARD authority is required to call this API.
         * @summary In-progress Account Aggregation status
         * @param {string} id The account aggregation id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountAggregationStatus(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountAggregationStatusBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountAggregationStatus(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountAggregationsBetaApi - factory interface
 * @export
 */
export const AccountAggregationsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountAggregationsBetaApiFp(configuration)
    return {
        /**
         * This API returns the status of an *in-progress* account aggregation, along with the total number of **NEW**, **CHANGED** and **DELETED** accounts found since the previous aggregation, and the number of those accounts that have been processed so far.  Accounts that have not changed since the previous aggregation are not included in **totalAccounts** and **processedAccounts** counts returned by this API. This is distinct from **Accounts Scanned** shown in the Aggregation UI, which indicates total accounts scanned regardless of whether they changed or not.  Since this endpoint reports on the status of an *in-progress* account aggregation, totalAccounts and processedAccounts may change between calls to this endpoint.  *Only available up to an hour after the aggregation completes. May respond with *404 Not Found* after that.*  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN or DASHBOARD authority is required to call this API.
         * @summary In-progress Account Aggregation status
         * @param {string} id The account aggregation id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountAggregationStatus(id: string, axiosOptions?: any): AxiosPromise<AccountAggregationStatusBeta> {
            return localVarFp.getAccountAggregationStatus(id, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAccountAggregationStatus operation in AccountAggregationsBetaApi.
 * @export
 * @interface AccountAggregationsBetaApiGetAccountAggregationStatusRequest
 */
export interface AccountAggregationsBetaApiGetAccountAggregationStatusRequest {
    /**
     * The account aggregation id
     * @type {string}
     * @memberof AccountAggregationsBetaApiGetAccountAggregationStatus
     */
    readonly id: string
}

/**
 * AccountAggregationsBetaApi - object-oriented interface
 * @export
 * @class AccountAggregationsBetaApi
 * @extends {BaseAPI}
 */
export class AccountAggregationsBetaApi extends BaseAPI {
    /**
     * This API returns the status of an *in-progress* account aggregation, along with the total number of **NEW**, **CHANGED** and **DELETED** accounts found since the previous aggregation, and the number of those accounts that have been processed so far.  Accounts that have not changed since the previous aggregation are not included in **totalAccounts** and **processedAccounts** counts returned by this API. This is distinct from **Accounts Scanned** shown in the Aggregation UI, which indicates total accounts scanned regardless of whether they changed or not.  Since this endpoint reports on the status of an *in-progress* account aggregation, totalAccounts and processedAccounts may change between calls to this endpoint.  *Only available up to an hour after the aggregation completes. May respond with *404 Not Found* after that.*  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN or DASHBOARD authority is required to call this API.
     * @summary In-progress Account Aggregation status
     * @param {AccountAggregationsBetaApiGetAccountAggregationStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountAggregationsBetaApi
     */
    public getAccountAggregationStatus(requestParameters: AccountAggregationsBetaApiGetAccountAggregationStatusRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountAggregationsBetaApiFp(this.configuration).getAccountAggregationStatus(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccountsBetaApi - axios parameter creator
 * @export
 */
export const AccountsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API submits an account creation task and returns the task ID.   The `sourceId` where this account will be created must be included in the `attributes` object. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Account
         * @param {AccountAttributesCreateBeta} accountAttributesCreateBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (accountAttributesCreateBeta: AccountAttributesCreateBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountAttributesCreateBeta' is not null or undefined
            assertParamExists('createAccount', 'accountAttributesCreateBeta', accountAttributesCreateBeta)
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountAttributesCreateBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits an account delete task and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Account
         * @param {string} id The account ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAccount', 'id', id)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits a task to disable the account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Disable Account
         * @param {string} id The account id
         * @param {AccountToggleRequestBeta} accountToggleRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        disableAccount: async (id: string, accountToggleRequestBeta: AccountToggleRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('disableAccount', 'id', id)
            // verify required parameter 'accountToggleRequestBeta' is not null or undefined
            assertParamExists('disableAccount', 'accountToggleRequestBeta', accountToggleRequestBeta)
            const localVarPath = `/accounts/{id}/disable`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountToggleRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits a task to disable IDN account for a single identity.
         * @summary Disable IDN Account for Identity
         * @param {string} id The identity id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        disableAccountForIdentity: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('disableAccountForIdentity', 'id', id)
            const localVarPath = `/identities-accounts/{id}/disable`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits tasks to disable IDN account for each identity provided in the request body.
         * @summary Disable IDN Accounts for Identities
         * @param {IdentitiesAccountsBulkRequestBeta} identitiesAccountsBulkRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        disableAccountsForIdentities: async (identitiesAccountsBulkRequestBeta: IdentitiesAccountsBulkRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identitiesAccountsBulkRequestBeta' is not null or undefined
            assertParamExists('disableAccountsForIdentities', 'identitiesAccountsBulkRequestBeta', identitiesAccountsBulkRequestBeta)
            const localVarPath = `/identities-accounts/disable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identitiesAccountsBulkRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits a task to enable account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Enable Account
         * @param {string} id The account id
         * @param {AccountToggleRequestBeta} accountToggleRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        enableAccount: async (id: string, accountToggleRequestBeta: AccountToggleRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('enableAccount', 'id', id)
            // verify required parameter 'accountToggleRequestBeta' is not null or undefined
            assertParamExists('enableAccount', 'accountToggleRequestBeta', accountToggleRequestBeta)
            const localVarPath = `/accounts/{id}/enable`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountToggleRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits a task to enable IDN account for a single identity.
         * @summary Enable IDN Account for Identity
         * @param {string} id The identity id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        enableAccountForIdentity: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('enableAccountForIdentity', 'id', id)
            const localVarPath = `/identities-accounts/{id}/enable`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits tasks to enable IDN account for each identity provided in the request body.
         * @summary Enable IDN Accounts for Identities
         * @param {IdentitiesAccountsBulkRequestBeta} identitiesAccountsBulkRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        enableAccountsForIdentities: async (identitiesAccountsBulkRequestBeta: IdentitiesAccountsBulkRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identitiesAccountsBulkRequestBeta' is not null or undefined
            assertParamExists('enableAccountsForIdentities', 'identitiesAccountsBulkRequestBeta', identitiesAccountsBulkRequestBeta)
            const localVarPath = `/identities-accounts/enable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identitiesAccountsBulkRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the details for a single account based on the ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Account Details
         * @param {string} id The account ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccount', 'id', id)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns entitlements of the account.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Account Entitlements
         * @param {string} id The account id
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountEntitlements: async (id: string, offset?: number, limit?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccountEntitlements', 'id', id)
            const localVarPath = `/accounts/{id}/entitlements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This returns a list of accounts.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Accounts List
         * @param {'SLIM' | 'FULL'} [detailLevel] Determines whether Slim, or increased level of detail is provided for each account in the returned list. FULL is the default behavior.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **identityId**: *eq*  **name**: *eq, in*  **nativeIdentity**: *eq, in*  **sourceId**: *eq, in*  **uncorrelated**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **created**, **modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts: async (detailLevel?: 'SLIM' | 'FULL', limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (detailLevel !== undefined) {
                localVarQueryParameter['detailLevel'] = detailLevel;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits an account update task and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Account
         * @param {string} id The account ID
         * @param {AccountAttributesBeta} accountAttributesBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putAccount: async (id: string, accountAttributesBeta: AccountAttributesBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putAccount', 'id', id)
            // verify required parameter 'accountAttributesBeta' is not null or undefined
            assertParamExists('putAccount', 'accountAttributesBeta', accountAttributesBeta)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountAttributesBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API asynchronously reloads the account directly from the connector and performs a one-time aggregation process.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Reload Account
         * @param {string} id The account id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        reloadAccount: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reloadAccount', 'id', id)
            const localVarPath = `/accounts/{id}/reload`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits a task to unlock an account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Unlock Account
         * @param {string} id The account id
         * @param {AccountUnlockRequestBeta} accountUnlockRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        unlockAccount: async (id: string, accountUnlockRequestBeta: AccountUnlockRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unlockAccount', 'id', id)
            // verify required parameter 'accountUnlockRequestBeta' is not null or undefined
            assertParamExists('unlockAccount', 'accountUnlockRequestBeta', accountUnlockRequestBeta)
            const localVarPath = `/accounts/{id}/unlock`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountUnlockRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This updates account details.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Account
         * @param {string} id The account ID
         * @param {Array<object>} requestBody A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: async (id: string, requestBody: Array<object>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAccount', 'id', id)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('updateAccount', 'requestBody', requestBody)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsBetaApi - functional programming interface
 * @export
 */
export const AccountsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This API submits an account creation task and returns the task ID.   The `sourceId` where this account will be created must be included in the `attributes` object. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Account
         * @param {AccountAttributesCreateBeta} accountAttributesCreateBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(accountAttributesCreateBeta: AccountAttributesCreateBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResultBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(accountAttributesCreateBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API submits an account delete task and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Account
         * @param {string} id The account ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccount(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResultBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccount(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API submits a task to disable the account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Disable Account
         * @param {string} id The account id
         * @param {AccountToggleRequestBeta} accountToggleRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async disableAccount(id: string, accountToggleRequestBeta: AccountToggleRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResultBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableAccount(id, accountToggleRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API submits a task to disable IDN account for a single identity.
         * @summary Disable IDN Account for Identity
         * @param {string} id The identity id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async disableAccountForIdentity(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableAccountForIdentity(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API submits tasks to disable IDN account for each identity provided in the request body.
         * @summary Disable IDN Accounts for Identities
         * @param {IdentitiesAccountsBulkRequestBeta} identitiesAccountsBulkRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async disableAccountsForIdentities(identitiesAccountsBulkRequestBeta: IdentitiesAccountsBulkRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BulkIdentitiesAccountsResponseBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableAccountsForIdentities(identitiesAccountsBulkRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API submits a task to enable account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Enable Account
         * @param {string} id The account id
         * @param {AccountToggleRequestBeta} accountToggleRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async enableAccount(id: string, accountToggleRequestBeta: AccountToggleRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResultBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableAccount(id, accountToggleRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API submits a task to enable IDN account for a single identity.
         * @summary Enable IDN Account for Identity
         * @param {string} id The identity id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async enableAccountForIdentity(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableAccountForIdentity(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API submits tasks to enable IDN account for each identity provided in the request body.
         * @summary Enable IDN Accounts for Identities
         * @param {IdentitiesAccountsBulkRequestBeta} identitiesAccountsBulkRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async enableAccountsForIdentities(identitiesAccountsBulkRequestBeta: IdentitiesAccountsBulkRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BulkIdentitiesAccountsResponseBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableAccountsForIdentities(identitiesAccountsBulkRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the details for a single account based on the ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Account Details
         * @param {string} id The account ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns entitlements of the account.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Account Entitlements
         * @param {string} id The account id
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountEntitlements(id: string, offset?: number, limit?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EntitlementBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountEntitlements(id, offset, limit, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This returns a list of accounts.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Accounts List
         * @param {'SLIM' | 'FULL'} [detailLevel] Determines whether Slim, or increased level of detail is provided for each account in the returned list. FULL is the default behavior.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **identityId**: *eq*  **name**: *eq, in*  **nativeIdentity**: *eq, in*  **sourceId**: *eq, in*  **uncorrelated**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **created**, **modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listAccounts(detailLevel?: 'SLIM' | 'FULL', limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListAccounts200ResponseInnerBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccounts(detailLevel, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API submits an account update task and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Account
         * @param {string} id The account ID
         * @param {AccountAttributesBeta} accountAttributesBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putAccount(id: string, accountAttributesBeta: AccountAttributesBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResultBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putAccount(id, accountAttributesBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API asynchronously reloads the account directly from the connector and performs a one-time aggregation process.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Reload Account
         * @param {string} id The account id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async reloadAccount(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResultBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reloadAccount(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API submits a task to unlock an account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Unlock Account
         * @param {string} id The account id
         * @param {AccountUnlockRequestBeta} accountUnlockRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async unlockAccount(id: string, accountUnlockRequestBeta: AccountUnlockRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResultBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlockAccount(id, accountUnlockRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This updates account details.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Account
         * @param {string} id The account ID
         * @param {Array<object>} requestBody A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccount(id: string, requestBody: Array<object>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccount(id, requestBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsBetaApi - factory interface
 * @export
 */
export const AccountsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsBetaApiFp(configuration)
    return {
        /**
         * This API submits an account creation task and returns the task ID.   The `sourceId` where this account will be created must be included in the `attributes` object. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Account
         * @param {AccountAttributesCreateBeta} accountAttributesCreateBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(accountAttributesCreateBeta: AccountAttributesCreateBeta, axiosOptions?: any): AxiosPromise<AccountsAsyncResultBeta> {
            return localVarFp.createAccount(accountAttributesCreateBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API submits an account delete task and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Account
         * @param {string} id The account ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(id: string, axiosOptions?: any): AxiosPromise<AccountsAsyncResultBeta> {
            return localVarFp.deleteAccount(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API submits a task to disable the account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Disable Account
         * @param {string} id The account id
         * @param {AccountToggleRequestBeta} accountToggleRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        disableAccount(id: string, accountToggleRequestBeta: AccountToggleRequestBeta, axiosOptions?: any): AxiosPromise<AccountsAsyncResultBeta> {
            return localVarFp.disableAccount(id, accountToggleRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API submits a task to disable IDN account for a single identity.
         * @summary Disable IDN Account for Identity
         * @param {string} id The identity id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        disableAccountForIdentity(id: string, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.disableAccountForIdentity(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API submits tasks to disable IDN account for each identity provided in the request body.
         * @summary Disable IDN Accounts for Identities
         * @param {IdentitiesAccountsBulkRequestBeta} identitiesAccountsBulkRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        disableAccountsForIdentities(identitiesAccountsBulkRequestBeta: IdentitiesAccountsBulkRequestBeta, axiosOptions?: any): AxiosPromise<Array<BulkIdentitiesAccountsResponseBeta>> {
            return localVarFp.disableAccountsForIdentities(identitiesAccountsBulkRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API submits a task to enable account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Enable Account
         * @param {string} id The account id
         * @param {AccountToggleRequestBeta} accountToggleRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        enableAccount(id: string, accountToggleRequestBeta: AccountToggleRequestBeta, axiosOptions?: any): AxiosPromise<AccountsAsyncResultBeta> {
            return localVarFp.enableAccount(id, accountToggleRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API submits a task to enable IDN account for a single identity.
         * @summary Enable IDN Account for Identity
         * @param {string} id The identity id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        enableAccountForIdentity(id: string, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.enableAccountForIdentity(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API submits tasks to enable IDN account for each identity provided in the request body.
         * @summary Enable IDN Accounts for Identities
         * @param {IdentitiesAccountsBulkRequestBeta} identitiesAccountsBulkRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        enableAccountsForIdentities(identitiesAccountsBulkRequestBeta: IdentitiesAccountsBulkRequestBeta, axiosOptions?: any): AxiosPromise<Array<BulkIdentitiesAccountsResponseBeta>> {
            return localVarFp.enableAccountsForIdentities(identitiesAccountsBulkRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the details for a single account based on the ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Account Details
         * @param {string} id The account ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(id: string, axiosOptions?: any): AxiosPromise<AccountBeta> {
            return localVarFp.getAccount(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns entitlements of the account.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Account Entitlements
         * @param {string} id The account id
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountEntitlements(id: string, offset?: number, limit?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<EntitlementBeta>> {
            return localVarFp.getAccountEntitlements(id, offset, limit, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This returns a list of accounts.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Accounts List
         * @param {'SLIM' | 'FULL'} [detailLevel] Determines whether Slim, or increased level of detail is provided for each account in the returned list. FULL is the default behavior.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **identityId**: *eq*  **name**: *eq, in*  **nativeIdentity**: *eq, in*  **sourceId**: *eq, in*  **uncorrelated**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **created**, **modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts(detailLevel?: 'SLIM' | 'FULL', limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<ListAccounts200ResponseInnerBeta>> {
            return localVarFp.listAccounts(detailLevel, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API submits an account update task and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Account
         * @param {string} id The account ID
         * @param {AccountAttributesBeta} accountAttributesBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putAccount(id: string, accountAttributesBeta: AccountAttributesBeta, axiosOptions?: any): AxiosPromise<AccountsAsyncResultBeta> {
            return localVarFp.putAccount(id, accountAttributesBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API asynchronously reloads the account directly from the connector and performs a one-time aggregation process.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Reload Account
         * @param {string} id The account id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        reloadAccount(id: string, axiosOptions?: any): AxiosPromise<AccountsAsyncResultBeta> {
            return localVarFp.reloadAccount(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API submits a task to unlock an account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Unlock Account
         * @param {string} id The account id
         * @param {AccountUnlockRequestBeta} accountUnlockRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        unlockAccount(id: string, accountUnlockRequestBeta: AccountUnlockRequestBeta, axiosOptions?: any): AxiosPromise<AccountsAsyncResultBeta> {
            return localVarFp.unlockAccount(id, accountUnlockRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This updates account details.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Account
         * @param {string} id The account ID
         * @param {Array<object>} requestBody A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(id: string, requestBody: Array<object>, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.updateAccount(id, requestBody, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAccount operation in AccountsBetaApi.
 * @export
 * @interface AccountsBetaApiCreateAccountRequest
 */
export interface AccountsBetaApiCreateAccountRequest {
    /**
     * 
     * @type {AccountAttributesCreateBeta}
     * @memberof AccountsBetaApiCreateAccount
     */
    readonly accountAttributesCreateBeta: AccountAttributesCreateBeta
}

/**
 * Request parameters for deleteAccount operation in AccountsBetaApi.
 * @export
 * @interface AccountsBetaApiDeleteAccountRequest
 */
export interface AccountsBetaApiDeleteAccountRequest {
    /**
     * The account ID
     * @type {string}
     * @memberof AccountsBetaApiDeleteAccount
     */
    readonly id: string
}

/**
 * Request parameters for disableAccount operation in AccountsBetaApi.
 * @export
 * @interface AccountsBetaApiDisableAccountRequest
 */
export interface AccountsBetaApiDisableAccountRequest {
    /**
     * The account id
     * @type {string}
     * @memberof AccountsBetaApiDisableAccount
     */
    readonly id: string

    /**
     * 
     * @type {AccountToggleRequestBeta}
     * @memberof AccountsBetaApiDisableAccount
     */
    readonly accountToggleRequestBeta: AccountToggleRequestBeta
}

/**
 * Request parameters for disableAccountForIdentity operation in AccountsBetaApi.
 * @export
 * @interface AccountsBetaApiDisableAccountForIdentityRequest
 */
export interface AccountsBetaApiDisableAccountForIdentityRequest {
    /**
     * The identity id.
     * @type {string}
     * @memberof AccountsBetaApiDisableAccountForIdentity
     */
    readonly id: string
}

/**
 * Request parameters for disableAccountsForIdentities operation in AccountsBetaApi.
 * @export
 * @interface AccountsBetaApiDisableAccountsForIdentitiesRequest
 */
export interface AccountsBetaApiDisableAccountsForIdentitiesRequest {
    /**
     * 
     * @type {IdentitiesAccountsBulkRequestBeta}
     * @memberof AccountsBetaApiDisableAccountsForIdentities
     */
    readonly identitiesAccountsBulkRequestBeta: IdentitiesAccountsBulkRequestBeta
}

/**
 * Request parameters for enableAccount operation in AccountsBetaApi.
 * @export
 * @interface AccountsBetaApiEnableAccountRequest
 */
export interface AccountsBetaApiEnableAccountRequest {
    /**
     * The account id
     * @type {string}
     * @memberof AccountsBetaApiEnableAccount
     */
    readonly id: string

    /**
     * 
     * @type {AccountToggleRequestBeta}
     * @memberof AccountsBetaApiEnableAccount
     */
    readonly accountToggleRequestBeta: AccountToggleRequestBeta
}

/**
 * Request parameters for enableAccountForIdentity operation in AccountsBetaApi.
 * @export
 * @interface AccountsBetaApiEnableAccountForIdentityRequest
 */
export interface AccountsBetaApiEnableAccountForIdentityRequest {
    /**
     * The identity id.
     * @type {string}
     * @memberof AccountsBetaApiEnableAccountForIdentity
     */
    readonly id: string
}

/**
 * Request parameters for enableAccountsForIdentities operation in AccountsBetaApi.
 * @export
 * @interface AccountsBetaApiEnableAccountsForIdentitiesRequest
 */
export interface AccountsBetaApiEnableAccountsForIdentitiesRequest {
    /**
     * 
     * @type {IdentitiesAccountsBulkRequestBeta}
     * @memberof AccountsBetaApiEnableAccountsForIdentities
     */
    readonly identitiesAccountsBulkRequestBeta: IdentitiesAccountsBulkRequestBeta
}

/**
 * Request parameters for getAccount operation in AccountsBetaApi.
 * @export
 * @interface AccountsBetaApiGetAccountRequest
 */
export interface AccountsBetaApiGetAccountRequest {
    /**
     * The account ID
     * @type {string}
     * @memberof AccountsBetaApiGetAccount
     */
    readonly id: string
}

/**
 * Request parameters for getAccountEntitlements operation in AccountsBetaApi.
 * @export
 * @interface AccountsBetaApiGetAccountEntitlementsRequest
 */
export interface AccountsBetaApiGetAccountEntitlementsRequest {
    /**
     * The account id
     * @type {string}
     * @memberof AccountsBetaApiGetAccountEntitlements
     */
    readonly id: string

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountsBetaApiGetAccountEntitlements
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountsBetaApiGetAccountEntitlements
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccountsBetaApiGetAccountEntitlements
     */
    readonly count?: boolean
}

/**
 * Request parameters for listAccounts operation in AccountsBetaApi.
 * @export
 * @interface AccountsBetaApiListAccountsRequest
 */
export interface AccountsBetaApiListAccountsRequest {
    /**
     * Determines whether Slim, or increased level of detail is provided for each account in the returned list. FULL is the default behavior.
     * @type {'SLIM' | 'FULL'}
     * @memberof AccountsBetaApiListAccounts
     */
    readonly detailLevel?: 'SLIM' | 'FULL'

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountsBetaApiListAccounts
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountsBetaApiListAccounts
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccountsBetaApiListAccounts
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **identityId**: *eq*  **name**: *eq, in*  **nativeIdentity**: *eq, in*  **sourceId**: *eq, in*  **uncorrelated**: *eq*
     * @type {string}
     * @memberof AccountsBetaApiListAccounts
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **created**, **modified**
     * @type {string}
     * @memberof AccountsBetaApiListAccounts
     */
    readonly sorters?: string
}

/**
 * Request parameters for putAccount operation in AccountsBetaApi.
 * @export
 * @interface AccountsBetaApiPutAccountRequest
 */
export interface AccountsBetaApiPutAccountRequest {
    /**
     * The account ID
     * @type {string}
     * @memberof AccountsBetaApiPutAccount
     */
    readonly id: string

    /**
     * 
     * @type {AccountAttributesBeta}
     * @memberof AccountsBetaApiPutAccount
     */
    readonly accountAttributesBeta: AccountAttributesBeta
}

/**
 * Request parameters for reloadAccount operation in AccountsBetaApi.
 * @export
 * @interface AccountsBetaApiReloadAccountRequest
 */
export interface AccountsBetaApiReloadAccountRequest {
    /**
     * The account id
     * @type {string}
     * @memberof AccountsBetaApiReloadAccount
     */
    readonly id: string
}

/**
 * Request parameters for unlockAccount operation in AccountsBetaApi.
 * @export
 * @interface AccountsBetaApiUnlockAccountRequest
 */
export interface AccountsBetaApiUnlockAccountRequest {
    /**
     * The account id
     * @type {string}
     * @memberof AccountsBetaApiUnlockAccount
     */
    readonly id: string

    /**
     * 
     * @type {AccountUnlockRequestBeta}
     * @memberof AccountsBetaApiUnlockAccount
     */
    readonly accountUnlockRequestBeta: AccountUnlockRequestBeta
}

/**
 * Request parameters for updateAccount operation in AccountsBetaApi.
 * @export
 * @interface AccountsBetaApiUpdateAccountRequest
 */
export interface AccountsBetaApiUpdateAccountRequest {
    /**
     * The account ID
     * @type {string}
     * @memberof AccountsBetaApiUpdateAccount
     */
    readonly id: string

    /**
     * A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
     * @type {Array<object>}
     * @memberof AccountsBetaApiUpdateAccount
     */
    readonly requestBody: Array<object>
}

/**
 * AccountsBetaApi - object-oriented interface
 * @export
 * @class AccountsBetaApi
 * @extends {BaseAPI}
 */
export class AccountsBetaApi extends BaseAPI {
    /**
     * This API submits an account creation task and returns the task ID.   The `sourceId` where this account will be created must be included in the `attributes` object. A token with ORG_ADMIN authority is required to call this API.
     * @summary Create Account
     * @param {AccountsBetaApiCreateAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsBetaApi
     */
    public createAccount(requestParameters: AccountsBetaApiCreateAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsBetaApiFp(this.configuration).createAccount(requestParameters.accountAttributesCreateBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits an account delete task and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Delete Account
     * @param {AccountsBetaApiDeleteAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsBetaApi
     */
    public deleteAccount(requestParameters: AccountsBetaApiDeleteAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsBetaApiFp(this.configuration).deleteAccount(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits a task to disable the account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Disable Account
     * @param {AccountsBetaApiDisableAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsBetaApi
     */
    public disableAccount(requestParameters: AccountsBetaApiDisableAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsBetaApiFp(this.configuration).disableAccount(requestParameters.id, requestParameters.accountToggleRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits a task to disable IDN account for a single identity.
     * @summary Disable IDN Account for Identity
     * @param {AccountsBetaApiDisableAccountForIdentityRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsBetaApi
     */
    public disableAccountForIdentity(requestParameters: AccountsBetaApiDisableAccountForIdentityRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsBetaApiFp(this.configuration).disableAccountForIdentity(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits tasks to disable IDN account for each identity provided in the request body.
     * @summary Disable IDN Accounts for Identities
     * @param {AccountsBetaApiDisableAccountsForIdentitiesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsBetaApi
     */
    public disableAccountsForIdentities(requestParameters: AccountsBetaApiDisableAccountsForIdentitiesRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsBetaApiFp(this.configuration).disableAccountsForIdentities(requestParameters.identitiesAccountsBulkRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits a task to enable account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Enable Account
     * @param {AccountsBetaApiEnableAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsBetaApi
     */
    public enableAccount(requestParameters: AccountsBetaApiEnableAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsBetaApiFp(this.configuration).enableAccount(requestParameters.id, requestParameters.accountToggleRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits a task to enable IDN account for a single identity.
     * @summary Enable IDN Account for Identity
     * @param {AccountsBetaApiEnableAccountForIdentityRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsBetaApi
     */
    public enableAccountForIdentity(requestParameters: AccountsBetaApiEnableAccountForIdentityRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsBetaApiFp(this.configuration).enableAccountForIdentity(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits tasks to enable IDN account for each identity provided in the request body.
     * @summary Enable IDN Accounts for Identities
     * @param {AccountsBetaApiEnableAccountsForIdentitiesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsBetaApi
     */
    public enableAccountsForIdentities(requestParameters: AccountsBetaApiEnableAccountsForIdentitiesRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsBetaApiFp(this.configuration).enableAccountsForIdentities(requestParameters.identitiesAccountsBulkRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the details for a single account based on the ID.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Account Details
     * @param {AccountsBetaApiGetAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsBetaApi
     */
    public getAccount(requestParameters: AccountsBetaApiGetAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsBetaApiFp(this.configuration).getAccount(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns entitlements of the account.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Account Entitlements
     * @param {AccountsBetaApiGetAccountEntitlementsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsBetaApi
     */
    public getAccountEntitlements(requestParameters: AccountsBetaApiGetAccountEntitlementsRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsBetaApiFp(this.configuration).getAccountEntitlements(requestParameters.id, requestParameters.offset, requestParameters.limit, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns a list of accounts.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Accounts List
     * @param {AccountsBetaApiListAccountsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsBetaApi
     */
    public listAccounts(requestParameters: AccountsBetaApiListAccountsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccountsBetaApiFp(this.configuration).listAccounts(requestParameters.detailLevel, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits an account update task and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Update Account
     * @param {AccountsBetaApiPutAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsBetaApi
     */
    public putAccount(requestParameters: AccountsBetaApiPutAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsBetaApiFp(this.configuration).putAccount(requestParameters.id, requestParameters.accountAttributesBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API asynchronously reloads the account directly from the connector and performs a one-time aggregation process.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Reload Account
     * @param {AccountsBetaApiReloadAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsBetaApi
     */
    public reloadAccount(requestParameters: AccountsBetaApiReloadAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsBetaApiFp(this.configuration).reloadAccount(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits a task to unlock an account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Unlock Account
     * @param {AccountsBetaApiUnlockAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsBetaApi
     */
    public unlockAccount(requestParameters: AccountsBetaApiUnlockAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsBetaApiFp(this.configuration).unlockAccount(requestParameters.id, requestParameters.accountUnlockRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This updates account details.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Update Account
     * @param {AccountsBetaApiUpdateAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsBetaApi
     */
    public updateAccount(requestParameters: AccountsBetaApiUpdateAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsBetaApiFp(this.configuration).updateAccount(requestParameters.id, requestParameters.requestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CertificationCampaignsBetaApi - axios parameter creator
 * @export
 */
export const CertificationCampaignsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * :::caution  This endpoint will run successfully for any campaigns that are **past due**.  This endpoint will return a content error if the campaign is **not past due**.  :::  Completes a certification campaign. This is provided to admins so that they can complete a certification even if all items have not been completed.  Requires roles of CERT_ADMIN and ORG_ADMIN 
         * @summary Complete a Campaign
         * @param {string} id The campaign id
         * @param {CompleteCampaignOptionsBeta} [completeCampaignOptionsBeta] Optional. Default behavior is for the campaign to auto-approve upon completion, unless autoCompleteAction&#x3D;REVOKE
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        completeCampaign: async (id: string, completeCampaignOptionsBeta?: CompleteCampaignOptionsBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('completeCampaign', 'id', id)
            const localVarPath = `/campaigns/{id}/complete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completeCampaignOptionsBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Creates a new Certification Campaign with the information provided in the request body.
         * @summary Create a campaign
         * @param {CampaignBeta} campaignBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createCampaign: async (campaignBeta: CampaignBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignBeta' is not null or undefined
            assertParamExists('createCampaign', 'campaignBeta', campaignBeta)
            const localVarPath = `/campaigns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaignBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a Campaign Template
         * @param {CampaignTemplateBeta} campaignTemplateBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCampaignTemplate: async (campaignTemplateBeta: CampaignTemplateBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignTemplateBeta' is not null or undefined
            assertParamExists('createCampaignTemplate', 'campaignTemplateBeta', campaignTemplateBeta)
            const localVarPath = `/campaign-templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaignTemplateBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes a campaign template by ID.
         * @summary Delete a Campaign Template
         * @param {string} id The ID of the campaign template being deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaignTemplate: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCampaignTemplate', 'id', id)
            const localVarPath = `/campaign-templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes the schedule for a campaign template. Returns a 404 if there is no schedule set.
         * @summary Deletes a Campaign Template\'s Schedule
         * @param {string} id The ID of the campaign template whose schedule is being deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaignTemplateSchedule: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCampaignTemplateSchedule', 'id', id)
            const localVarPath = `/campaign-templates/{id}/schedule`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes campaigns whose Ids are specified in the provided list of campaign Ids. Authorized callers must be an ORG_ADMIN or a CERT_ADMIN.
         * @summary Deletes Campaigns
         * @param {DeleteCampaignsRequestBeta} deleteCampaignsRequestBeta The ids of the campaigns to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaigns: async (deleteCampaignsRequestBeta: DeleteCampaignsRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteCampaignsRequestBeta' is not null or undefined
            assertParamExists('deleteCampaigns', 'deleteCampaignsRequestBeta', deleteCampaignsRequestBeta)
            const localVarPath = `/campaigns/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteCampaignsRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Generates a new campaign from a campaign template. The campaign object contained in the template has special formatting applied to its name and description fields in order to determine the generated campaign\'s name/description. Placeholders in those fields are formatted with the current date and time upon generation. Placeholders consist of a percent sign followed by a letter indicating what should be inserted; for example, \"%Y\" will insert the current year; a campaign template named \"Campaign for %y\" would generate a campaign called \"Campaign for 2020\" (assuming the year at generation time is 2020). Valid placeholders are the date/time conversion suffix characters supported by [java.util.Formatter](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). Requires roles ORG_ADMIN.
         * @summary Generate a Campaign from Template
         * @param {string} id The ID of the campaign template to use for generation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        generateCampaignTemplate: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('generateCampaignTemplate', 'id', id)
            const localVarPath = `/campaign-templates/{id}/generate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Gets campaigns and returns them in a list. Can provide increased level of detail for each campaign if provided the correct query.
         * @summary List Campaigns
         * @param {'SLIM' | 'FULL'} [detail] Determines whether slim, or increased level of detail is provided for each campaign in the returned list. Slim is the default behavior.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **status**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**, **created**
         * @param {*} [axiosOptions] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getActiveCampaigns: async (detail?: 'SLIM' | 'FULL', limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/campaigns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (detail !== undefined) {
                localVarQueryParameter['detail'] = detail;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Retrieves information for an existing campaign using the campaign\'s ID. Authorized callers must be a reviewer for this campaign, an ORG_ADMIN, or a CERT_ADMIN.
         * @summary Get a campaign
         * @param {string} id The ID of the campaign to be retrieved
         * @param {*} [axiosOptions] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getCampaign: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCampaign', 'id', id)
            const localVarPath = `/campaigns/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Fetches all reports for a certification campaign by campaign ID. Requires roles of CERT_ADMIN, DASHBOARD, ORG_ADMIN and REPORT_ADMIN
         * @summary Get Campaign Reports
         * @param {string} id The ID of the campaign for which reports are being fetched.
         * @param {*} [axiosOptions] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getCampaignReports: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCampaignReports', 'id', id)
            const localVarPath = `/campaigns/{id}/reports`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Fetches configuration for campaign reports. Currently it includes only one element - identity attributes defined as custom report columns. Requires roles of CERT_ADMIN and ORG_ADMIN.
         * @summary Get Campaign Reports Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignReportsConfig: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/campaigns/reports-configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Fetches a campaign template by ID.
         * @summary Get a Campaign Template
         * @param {string} id The desired campaign template\&#39;s ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignTemplate: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCampaignTemplate', 'id', id)
            const localVarPath = `/campaign-templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Gets the schedule for a campaign template. Returns a 404 if there is no schedule set.
         * @summary Gets a Campaign Template\'s Schedule
         * @param {string} id The ID of the campaign template whose schedule is being fetched.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignTemplateSchedule: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCampaignTemplateSchedule', 'id', id)
            const localVarPath = `/campaign-templates/{id}/schedule`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Campaign Templates
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields: **name, id**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCampaignTemplates: async (limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/campaign-templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API reassigns the specified certifications from one identity to another. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Reassign Certifications
         * @param {string} id The certification campaign ID
         * @param {AdminReviewReassignBeta} adminReviewReassignBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        move: async (id: string, adminReviewReassignBeta: AdminReviewReassignBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('move', 'id', id)
            // verify required parameter 'adminReviewReassignBeta' is not null or undefined
            assertParamExists('move', 'adminReviewReassignBeta', adminReviewReassignBeta)
            const localVarPath = `/campaigns/{id}/reassign`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminReviewReassignBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Allows updating individual fields on a campaign template using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @summary Update a Campaign Template
         * @param {string} id The ID of the campaign template being modified.
         * @param {Array<object>} requestBody A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * deadlineDuration * campaign (all fields that are allowed during create) 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchCampaignTemplate: async (id: string, requestBody: Array<object>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchCampaignTemplate', 'id', id)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('patchCampaignTemplate', 'requestBody', requestBody)
            const localVarPath = `/campaign-templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Kicks off remediation scan task for a certification campaign. Requires roles of CERT_ADMIN and ORG_ADMIN
         * @summary Run Campaign Remediation Scan
         * @param {string} id The ID of the campaign for which remediation scan is being run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        runCampaignRemediationScan: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('runCampaignRemediationScan', 'id', id)
            const localVarPath = `/campaigns/{id}/run-remediation-scan`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Runs a report for a certification campaign. Requires the following roles: CERT_ADMIN, DASHBOARD, ORG_ADMIN and REPORT_ADMIN.
         * @summary Run Campaign Report
         * @param {string} id The ID of the campaign for which report is being run.
         * @param {ReportTypeBeta} type The type of the report to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        runCampaignReport: async (id: string, type: ReportTypeBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('runCampaignReport', 'id', id)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('runCampaignReport', 'type', type)
            const localVarPath = `/campaigns/{id}/run-report/{type}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Overwrites configuration for campaign reports. Requires roles CERT_ADMIN and ORG_ADMIN.
         * @summary Set Campaign Reports Configuration
         * @param {CampaignReportsConfigBeta} campaignReportsConfigBeta Campaign Report Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setCampaignReportsConfig: async (campaignReportsConfigBeta: CampaignReportsConfigBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignReportsConfigBeta' is not null or undefined
            assertParamExists('setCampaignReportsConfig', 'campaignReportsConfigBeta', campaignReportsConfigBeta)
            const localVarPath = `/campaigns/reports-configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaignReportsConfigBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Sets the schedule for a campaign template. If a schedule already exists, it will be overwritten with the new one.
         * @summary Sets a Campaign Template\'s Schedule
         * @param {string} id The ID of the campaign template being scheduled.
         * @param {ScheduleBeta} [scheduleBeta] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setCampaignTemplateSchedule: async (id: string, scheduleBeta?: ScheduleBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setCampaignTemplateSchedule', 'id', id)
            const localVarPath = `/campaign-templates/{id}/schedule`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scheduleBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Submits a job to activate the campaign with the given Id. The campaign must be staged. Requires roles of CERT_ADMIN and ORG_ADMIN
         * @summary Activate a Campaign
         * @param {string} id The campaign id
         * @param {ActivateCampaignOptionsBeta} [activateCampaignOptionsBeta] Optional. If no timezone is specified, the standard UTC timezone is used (i.e. UTC+00:00). Although this can take any timezone, the intended value is the caller\&#39;s timezone. The activation time calculated from the given timezone may cause the campaign deadline time to be modified, but it will remain within the original date. The timezone must be in a valid ISO 8601 format.
         * @param {*} [axiosOptions] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        startCampaign: async (id: string, activateCampaignOptionsBeta?: ActivateCampaignOptionsBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startCampaign', 'id', id)
            const localVarPath = `/campaigns/{id}/activate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activateCampaignOptionsBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Allows updating individual fields on a campaign using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @summary Update a Campaign
         * @param {string} id The ID of the campaign template being modified.
         * @param {Array<object>} requestBody A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The fields that can be patched differ based on the status of the campaign.  In the *STAGED* status, the following fields can be patched: * name * description * recommendationsEnabled * deadline * emailNotificationEnabled * autoRevokeAllowed  In the *ACTIVE* status, the following fields can be patched: * deadline 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateCampaign: async (id: string, requestBody: Array<object>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCampaign', 'id', id)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('updateCampaign', 'requestBody', requestBody)
            const localVarPath = `/campaigns/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * CertificationCampaignsBetaApi - functional programming interface
 * @export
 */
export const CertificationCampaignsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CertificationCampaignsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * :::caution  This endpoint will run successfully for any campaigns that are **past due**.  This endpoint will return a content error if the campaign is **not past due**.  :::  Completes a certification campaign. This is provided to admins so that they can complete a certification even if all items have not been completed.  Requires roles of CERT_ADMIN and ORG_ADMIN 
         * @summary Complete a Campaign
         * @param {string} id The campaign id
         * @param {CompleteCampaignOptionsBeta} [completeCampaignOptionsBeta] Optional. Default behavior is for the campaign to auto-approve upon completion, unless autoCompleteAction&#x3D;REVOKE
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async completeCampaign(id: string, completeCampaignOptionsBeta?: CompleteCampaignOptionsBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeCampaign(id, completeCampaignOptionsBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new Certification Campaign with the information provided in the request body.
         * @summary Create a campaign
         * @param {CampaignBeta} campaignBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async createCampaign(campaignBeta: CampaignBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCampaign(campaignBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a Campaign Template
         * @param {CampaignTemplateBeta} campaignTemplateBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createCampaignTemplate(campaignTemplateBeta: CampaignTemplateBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignTemplateBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCampaignTemplate(campaignTemplateBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a campaign template by ID.
         * @summary Delete a Campaign Template
         * @param {string} id The ID of the campaign template being deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCampaignTemplate(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCampaignTemplate(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the schedule for a campaign template. Returns a 404 if there is no schedule set.
         * @summary Deletes a Campaign Template\'s Schedule
         * @param {string} id The ID of the campaign template whose schedule is being deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCampaignTemplateSchedule(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCampaignTemplateSchedule(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes campaigns whose Ids are specified in the provided list of campaign Ids. Authorized callers must be an ORG_ADMIN or a CERT_ADMIN.
         * @summary Deletes Campaigns
         * @param {DeleteCampaignsRequestBeta} deleteCampaignsRequestBeta The ids of the campaigns to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCampaigns(deleteCampaignsRequestBeta: DeleteCampaignsRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCampaigns(deleteCampaignsRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generates a new campaign from a campaign template. The campaign object contained in the template has special formatting applied to its name and description fields in order to determine the generated campaign\'s name/description. Placeholders in those fields are formatted with the current date and time upon generation. Placeholders consist of a percent sign followed by a letter indicating what should be inserted; for example, \"%Y\" will insert the current year; a campaign template named \"Campaign for %y\" would generate a campaign called \"Campaign for 2020\" (assuming the year at generation time is 2020). Valid placeholders are the date/time conversion suffix characters supported by [java.util.Formatter](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). Requires roles ORG_ADMIN.
         * @summary Generate a Campaign from Template
         * @param {string} id The ID of the campaign template to use for generation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async generateCampaignTemplate(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignReferenceBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateCampaignTemplate(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets campaigns and returns them in a list. Can provide increased level of detail for each campaign if provided the correct query.
         * @summary List Campaigns
         * @param {'SLIM' | 'FULL'} [detail] Determines whether slim, or increased level of detail is provided for each campaign in the returned list. Slim is the default behavior.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **status**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**, **created**
         * @param {*} [axiosOptions] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getActiveCampaigns(detail?: 'SLIM' | 'FULL', limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetActiveCampaigns200ResponseInnerBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveCampaigns(detail, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves information for an existing campaign using the campaign\'s ID. Authorized callers must be a reviewer for this campaign, an ORG_ADMIN, or a CERT_ADMIN.
         * @summary Get a campaign
         * @param {string} id The ID of the campaign to be retrieved
         * @param {*} [axiosOptions] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getCampaign(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SlimcampaignBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaign(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches all reports for a certification campaign by campaign ID. Requires roles of CERT_ADMIN, DASHBOARD, ORG_ADMIN and REPORT_ADMIN
         * @summary Get Campaign Reports
         * @param {string} id The ID of the campaign for which reports are being fetched.
         * @param {*} [axiosOptions] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getCampaignReports(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CampaignReportBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaignReports(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches configuration for campaign reports. Currently it includes only one element - identity attributes defined as custom report columns. Requires roles of CERT_ADMIN and ORG_ADMIN.
         * @summary Get Campaign Reports Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaignReportsConfig(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignReportsConfigBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaignReportsConfig(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches a campaign template by ID.
         * @summary Get a Campaign Template
         * @param {string} id The desired campaign template\&#39;s ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaignTemplate(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignTemplateBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaignTemplate(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the schedule for a campaign template. Returns a 404 if there is no schedule set.
         * @summary Gets a Campaign Template\'s Schedule
         * @param {string} id The ID of the campaign template whose schedule is being fetched.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaignTemplateSchedule(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaignTemplateSchedule(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Campaign Templates
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields: **name, id**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listCampaignTemplates(limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CampaignTemplateBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCampaignTemplates(limit, offset, count, sorters, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API reassigns the specified certifications from one identity to another. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Reassign Certifications
         * @param {string} id The certification campaign ID
         * @param {AdminReviewReassignBeta} adminReviewReassignBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async move(id: string, adminReviewReassignBeta: AdminReviewReassignBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CertificationTaskBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.move(id, adminReviewReassignBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allows updating individual fields on a campaign template using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @summary Update a Campaign Template
         * @param {string} id The ID of the campaign template being modified.
         * @param {Array<object>} requestBody A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * deadlineDuration * campaign (all fields that are allowed during create) 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchCampaignTemplate(id: string, requestBody: Array<object>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignTemplateBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchCampaignTemplate(id, requestBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Kicks off remediation scan task for a certification campaign. Requires roles of CERT_ADMIN and ORG_ADMIN
         * @summary Run Campaign Remediation Scan
         * @param {string} id The ID of the campaign for which remediation scan is being run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async runCampaignRemediationScan(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runCampaignRemediationScan(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Runs a report for a certification campaign. Requires the following roles: CERT_ADMIN, DASHBOARD, ORG_ADMIN and REPORT_ADMIN.
         * @summary Run Campaign Report
         * @param {string} id The ID of the campaign for which report is being run.
         * @param {ReportTypeBeta} type The type of the report to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async runCampaignReport(id: string, type: ReportTypeBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runCampaignReport(id, type, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Overwrites configuration for campaign reports. Requires roles CERT_ADMIN and ORG_ADMIN.
         * @summary Set Campaign Reports Configuration
         * @param {CampaignReportsConfigBeta} campaignReportsConfigBeta Campaign Report Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setCampaignReportsConfig(campaignReportsConfigBeta: CampaignReportsConfigBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignReportsConfigBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setCampaignReportsConfig(campaignReportsConfigBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets the schedule for a campaign template. If a schedule already exists, it will be overwritten with the new one.
         * @summary Sets a Campaign Template\'s Schedule
         * @param {string} id The ID of the campaign template being scheduled.
         * @param {ScheduleBeta} [scheduleBeta] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setCampaignTemplateSchedule(id: string, scheduleBeta?: ScheduleBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setCampaignTemplateSchedule(id, scheduleBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Submits a job to activate the campaign with the given Id. The campaign must be staged. Requires roles of CERT_ADMIN and ORG_ADMIN
         * @summary Activate a Campaign
         * @param {string} id The campaign id
         * @param {ActivateCampaignOptionsBeta} [activateCampaignOptionsBeta] Optional. If no timezone is specified, the standard UTC timezone is used (i.e. UTC+00:00). Although this can take any timezone, the intended value is the caller\&#39;s timezone. The activation time calculated from the given timezone may cause the campaign deadline time to be modified, but it will remain within the original date. The timezone must be in a valid ISO 8601 format.
         * @param {*} [axiosOptions] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async startCampaign(id: string, activateCampaignOptionsBeta?: ActivateCampaignOptionsBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startCampaign(id, activateCampaignOptionsBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allows updating individual fields on a campaign using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @summary Update a Campaign
         * @param {string} id The ID of the campaign template being modified.
         * @param {Array<object>} requestBody A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The fields that can be patched differ based on the status of the campaign.  In the *STAGED* status, the following fields can be patched: * name * description * recommendationsEnabled * deadline * emailNotificationEnabled * autoRevokeAllowed  In the *ACTIVE* status, the following fields can be patched: * deadline 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateCampaign(id: string, requestBody: Array<object>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SlimcampaignBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCampaign(id, requestBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CertificationCampaignsBetaApi - factory interface
 * @export
 */
export const CertificationCampaignsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CertificationCampaignsBetaApiFp(configuration)
    return {
        /**
         * :::caution  This endpoint will run successfully for any campaigns that are **past due**.  This endpoint will return a content error if the campaign is **not past due**.  :::  Completes a certification campaign. This is provided to admins so that they can complete a certification even if all items have not been completed.  Requires roles of CERT_ADMIN and ORG_ADMIN 
         * @summary Complete a Campaign
         * @param {string} id The campaign id
         * @param {CompleteCampaignOptionsBeta} [completeCampaignOptionsBeta] Optional. Default behavior is for the campaign to auto-approve upon completion, unless autoCompleteAction&#x3D;REVOKE
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        completeCampaign(id: string, completeCampaignOptionsBeta?: CompleteCampaignOptionsBeta, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.completeCampaign(id, completeCampaignOptionsBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new Certification Campaign with the information provided in the request body.
         * @summary Create a campaign
         * @param {CampaignBeta} campaignBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createCampaign(campaignBeta: CampaignBeta, axiosOptions?: any): AxiosPromise<CampaignBeta> {
            return localVarFp.createCampaign(campaignBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a Campaign Template
         * @param {CampaignTemplateBeta} campaignTemplateBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCampaignTemplate(campaignTemplateBeta: CampaignTemplateBeta, axiosOptions?: any): AxiosPromise<CampaignTemplateBeta> {
            return localVarFp.createCampaignTemplate(campaignTemplateBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a campaign template by ID.
         * @summary Delete a Campaign Template
         * @param {string} id The ID of the campaign template being deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaignTemplate(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteCampaignTemplate(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the schedule for a campaign template. Returns a 404 if there is no schedule set.
         * @summary Deletes a Campaign Template\'s Schedule
         * @param {string} id The ID of the campaign template whose schedule is being deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaignTemplateSchedule(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteCampaignTemplateSchedule(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Deletes campaigns whose Ids are specified in the provided list of campaign Ids. Authorized callers must be an ORG_ADMIN or a CERT_ADMIN.
         * @summary Deletes Campaigns
         * @param {DeleteCampaignsRequestBeta} deleteCampaignsRequestBeta The ids of the campaigns to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaigns(deleteCampaignsRequestBeta: DeleteCampaignsRequestBeta, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.deleteCampaigns(deleteCampaignsRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Generates a new campaign from a campaign template. The campaign object contained in the template has special formatting applied to its name and description fields in order to determine the generated campaign\'s name/description. Placeholders in those fields are formatted with the current date and time upon generation. Placeholders consist of a percent sign followed by a letter indicating what should be inserted; for example, \"%Y\" will insert the current year; a campaign template named \"Campaign for %y\" would generate a campaign called \"Campaign for 2020\" (assuming the year at generation time is 2020). Valid placeholders are the date/time conversion suffix characters supported by [java.util.Formatter](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). Requires roles ORG_ADMIN.
         * @summary Generate a Campaign from Template
         * @param {string} id The ID of the campaign template to use for generation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        generateCampaignTemplate(id: string, axiosOptions?: any): AxiosPromise<CampaignReferenceBeta> {
            return localVarFp.generateCampaignTemplate(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Gets campaigns and returns them in a list. Can provide increased level of detail for each campaign if provided the correct query.
         * @summary List Campaigns
         * @param {'SLIM' | 'FULL'} [detail] Determines whether slim, or increased level of detail is provided for each campaign in the returned list. Slim is the default behavior.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **status**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**, **created**
         * @param {*} [axiosOptions] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getActiveCampaigns(detail?: 'SLIM' | 'FULL', limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<GetActiveCampaigns200ResponseInnerBeta>> {
            return localVarFp.getActiveCampaigns(detail, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves information for an existing campaign using the campaign\'s ID. Authorized callers must be a reviewer for this campaign, an ORG_ADMIN, or a CERT_ADMIN.
         * @summary Get a campaign
         * @param {string} id The ID of the campaign to be retrieved
         * @param {*} [axiosOptions] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getCampaign(id: string, axiosOptions?: any): AxiosPromise<SlimcampaignBeta> {
            return localVarFp.getCampaign(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Fetches all reports for a certification campaign by campaign ID. Requires roles of CERT_ADMIN, DASHBOARD, ORG_ADMIN and REPORT_ADMIN
         * @summary Get Campaign Reports
         * @param {string} id The ID of the campaign for which reports are being fetched.
         * @param {*} [axiosOptions] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getCampaignReports(id: string, axiosOptions?: any): AxiosPromise<Array<CampaignReportBeta>> {
            return localVarFp.getCampaignReports(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Fetches configuration for campaign reports. Currently it includes only one element - identity attributes defined as custom report columns. Requires roles of CERT_ADMIN and ORG_ADMIN.
         * @summary Get Campaign Reports Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignReportsConfig(axiosOptions?: any): AxiosPromise<CampaignReportsConfigBeta> {
            return localVarFp.getCampaignReportsConfig(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a campaign template by ID.
         * @summary Get a Campaign Template
         * @param {string} id The desired campaign template\&#39;s ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignTemplate(id: string, axiosOptions?: any): AxiosPromise<CampaignTemplateBeta> {
            return localVarFp.getCampaignTemplate(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Gets the schedule for a campaign template. Returns a 404 if there is no schedule set.
         * @summary Gets a Campaign Template\'s Schedule
         * @param {string} id The ID of the campaign template whose schedule is being fetched.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignTemplateSchedule(id: string, axiosOptions?: any): AxiosPromise<ScheduleBeta> {
            return localVarFp.getCampaignTemplateSchedule(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Campaign Templates
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields: **name, id**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCampaignTemplates(limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: any): AxiosPromise<Array<CampaignTemplateBeta>> {
            return localVarFp.listCampaignTemplates(limit, offset, count, sorters, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API reassigns the specified certifications from one identity to another. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Reassign Certifications
         * @param {string} id The certification campaign ID
         * @param {AdminReviewReassignBeta} adminReviewReassignBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        move(id: string, adminReviewReassignBeta: AdminReviewReassignBeta, axiosOptions?: any): AxiosPromise<CertificationTaskBeta> {
            return localVarFp.move(id, adminReviewReassignBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Allows updating individual fields on a campaign template using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @summary Update a Campaign Template
         * @param {string} id The ID of the campaign template being modified.
         * @param {Array<object>} requestBody A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * deadlineDuration * campaign (all fields that are allowed during create) 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchCampaignTemplate(id: string, requestBody: Array<object>, axiosOptions?: any): AxiosPromise<CampaignTemplateBeta> {
            return localVarFp.patchCampaignTemplate(id, requestBody, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Kicks off remediation scan task for a certification campaign. Requires roles of CERT_ADMIN and ORG_ADMIN
         * @summary Run Campaign Remediation Scan
         * @param {string} id The ID of the campaign for which remediation scan is being run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        runCampaignRemediationScan(id: string, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.runCampaignRemediationScan(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Runs a report for a certification campaign. Requires the following roles: CERT_ADMIN, DASHBOARD, ORG_ADMIN and REPORT_ADMIN.
         * @summary Run Campaign Report
         * @param {string} id The ID of the campaign for which report is being run.
         * @param {ReportTypeBeta} type The type of the report to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        runCampaignReport(id: string, type: ReportTypeBeta, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.runCampaignReport(id, type, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Overwrites configuration for campaign reports. Requires roles CERT_ADMIN and ORG_ADMIN.
         * @summary Set Campaign Reports Configuration
         * @param {CampaignReportsConfigBeta} campaignReportsConfigBeta Campaign Report Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setCampaignReportsConfig(campaignReportsConfigBeta: CampaignReportsConfigBeta, axiosOptions?: any): AxiosPromise<CampaignReportsConfigBeta> {
            return localVarFp.setCampaignReportsConfig(campaignReportsConfigBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Sets the schedule for a campaign template. If a schedule already exists, it will be overwritten with the new one.
         * @summary Sets a Campaign Template\'s Schedule
         * @param {string} id The ID of the campaign template being scheduled.
         * @param {ScheduleBeta} [scheduleBeta] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setCampaignTemplateSchedule(id: string, scheduleBeta?: ScheduleBeta, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.setCampaignTemplateSchedule(id, scheduleBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Submits a job to activate the campaign with the given Id. The campaign must be staged. Requires roles of CERT_ADMIN and ORG_ADMIN
         * @summary Activate a Campaign
         * @param {string} id The campaign id
         * @param {ActivateCampaignOptionsBeta} [activateCampaignOptionsBeta] Optional. If no timezone is specified, the standard UTC timezone is used (i.e. UTC+00:00). Although this can take any timezone, the intended value is the caller\&#39;s timezone. The activation time calculated from the given timezone may cause the campaign deadline time to be modified, but it will remain within the original date. The timezone must be in a valid ISO 8601 format.
         * @param {*} [axiosOptions] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        startCampaign(id: string, activateCampaignOptionsBeta?: ActivateCampaignOptionsBeta, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.startCampaign(id, activateCampaignOptionsBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Allows updating individual fields on a campaign using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @summary Update a Campaign
         * @param {string} id The ID of the campaign template being modified.
         * @param {Array<object>} requestBody A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The fields that can be patched differ based on the status of the campaign.  In the *STAGED* status, the following fields can be patched: * name * description * recommendationsEnabled * deadline * emailNotificationEnabled * autoRevokeAllowed  In the *ACTIVE* status, the following fields can be patched: * deadline 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateCampaign(id: string, requestBody: Array<object>, axiosOptions?: any): AxiosPromise<SlimcampaignBeta> {
            return localVarFp.updateCampaign(id, requestBody, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for completeCampaign operation in CertificationCampaignsBetaApi.
 * @export
 * @interface CertificationCampaignsBetaApiCompleteCampaignRequest
 */
export interface CertificationCampaignsBetaApiCompleteCampaignRequest {
    /**
     * The campaign id
     * @type {string}
     * @memberof CertificationCampaignsBetaApiCompleteCampaign
     */
    readonly id: string

    /**
     * Optional. Default behavior is for the campaign to auto-approve upon completion, unless autoCompleteAction&#x3D;REVOKE
     * @type {CompleteCampaignOptionsBeta}
     * @memberof CertificationCampaignsBetaApiCompleteCampaign
     */
    readonly completeCampaignOptionsBeta?: CompleteCampaignOptionsBeta
}

/**
 * Request parameters for createCampaign operation in CertificationCampaignsBetaApi.
 * @export
 * @interface CertificationCampaignsBetaApiCreateCampaignRequest
 */
export interface CertificationCampaignsBetaApiCreateCampaignRequest {
    /**
     * 
     * @type {CampaignBeta}
     * @memberof CertificationCampaignsBetaApiCreateCampaign
     */
    readonly campaignBeta: CampaignBeta
}

/**
 * Request parameters for createCampaignTemplate operation in CertificationCampaignsBetaApi.
 * @export
 * @interface CertificationCampaignsBetaApiCreateCampaignTemplateRequest
 */
export interface CertificationCampaignsBetaApiCreateCampaignTemplateRequest {
    /**
     * 
     * @type {CampaignTemplateBeta}
     * @memberof CertificationCampaignsBetaApiCreateCampaignTemplate
     */
    readonly campaignTemplateBeta: CampaignTemplateBeta
}

/**
 * Request parameters for deleteCampaignTemplate operation in CertificationCampaignsBetaApi.
 * @export
 * @interface CertificationCampaignsBetaApiDeleteCampaignTemplateRequest
 */
export interface CertificationCampaignsBetaApiDeleteCampaignTemplateRequest {
    /**
     * The ID of the campaign template being deleted.
     * @type {string}
     * @memberof CertificationCampaignsBetaApiDeleteCampaignTemplate
     */
    readonly id: string
}

/**
 * Request parameters for deleteCampaignTemplateSchedule operation in CertificationCampaignsBetaApi.
 * @export
 * @interface CertificationCampaignsBetaApiDeleteCampaignTemplateScheduleRequest
 */
export interface CertificationCampaignsBetaApiDeleteCampaignTemplateScheduleRequest {
    /**
     * The ID of the campaign template whose schedule is being deleted.
     * @type {string}
     * @memberof CertificationCampaignsBetaApiDeleteCampaignTemplateSchedule
     */
    readonly id: string
}

/**
 * Request parameters for deleteCampaigns operation in CertificationCampaignsBetaApi.
 * @export
 * @interface CertificationCampaignsBetaApiDeleteCampaignsRequest
 */
export interface CertificationCampaignsBetaApiDeleteCampaignsRequest {
    /**
     * The ids of the campaigns to delete.
     * @type {DeleteCampaignsRequestBeta}
     * @memberof CertificationCampaignsBetaApiDeleteCampaigns
     */
    readonly deleteCampaignsRequestBeta: DeleteCampaignsRequestBeta
}

/**
 * Request parameters for generateCampaignTemplate operation in CertificationCampaignsBetaApi.
 * @export
 * @interface CertificationCampaignsBetaApiGenerateCampaignTemplateRequest
 */
export interface CertificationCampaignsBetaApiGenerateCampaignTemplateRequest {
    /**
     * The ID of the campaign template to use for generation.
     * @type {string}
     * @memberof CertificationCampaignsBetaApiGenerateCampaignTemplate
     */
    readonly id: string
}

/**
 * Request parameters for getActiveCampaigns operation in CertificationCampaignsBetaApi.
 * @export
 * @interface CertificationCampaignsBetaApiGetActiveCampaignsRequest
 */
export interface CertificationCampaignsBetaApiGetActiveCampaignsRequest {
    /**
     * Determines whether slim, or increased level of detail is provided for each campaign in the returned list. Slim is the default behavior.
     * @type {'SLIM' | 'FULL'}
     * @memberof CertificationCampaignsBetaApiGetActiveCampaigns
     */
    readonly detail?: 'SLIM' | 'FULL'

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationCampaignsBetaApiGetActiveCampaigns
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationCampaignsBetaApiGetActiveCampaigns
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationCampaignsBetaApiGetActiveCampaigns
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **status**: *eq, in*
     * @type {string}
     * @memberof CertificationCampaignsBetaApiGetActiveCampaigns
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**, **created**
     * @type {string}
     * @memberof CertificationCampaignsBetaApiGetActiveCampaigns
     */
    readonly sorters?: string
}

/**
 * Request parameters for getCampaign operation in CertificationCampaignsBetaApi.
 * @export
 * @interface CertificationCampaignsBetaApiGetCampaignRequest
 */
export interface CertificationCampaignsBetaApiGetCampaignRequest {
    /**
     * The ID of the campaign to be retrieved
     * @type {string}
     * @memberof CertificationCampaignsBetaApiGetCampaign
     */
    readonly id: string
}

/**
 * Request parameters for getCampaignReports operation in CertificationCampaignsBetaApi.
 * @export
 * @interface CertificationCampaignsBetaApiGetCampaignReportsRequest
 */
export interface CertificationCampaignsBetaApiGetCampaignReportsRequest {
    /**
     * The ID of the campaign for which reports are being fetched.
     * @type {string}
     * @memberof CertificationCampaignsBetaApiGetCampaignReports
     */
    readonly id: string
}

/**
 * Request parameters for getCampaignTemplate operation in CertificationCampaignsBetaApi.
 * @export
 * @interface CertificationCampaignsBetaApiGetCampaignTemplateRequest
 */
export interface CertificationCampaignsBetaApiGetCampaignTemplateRequest {
    /**
     * The desired campaign template\&#39;s ID.
     * @type {string}
     * @memberof CertificationCampaignsBetaApiGetCampaignTemplate
     */
    readonly id: string
}

/**
 * Request parameters for getCampaignTemplateSchedule operation in CertificationCampaignsBetaApi.
 * @export
 * @interface CertificationCampaignsBetaApiGetCampaignTemplateScheduleRequest
 */
export interface CertificationCampaignsBetaApiGetCampaignTemplateScheduleRequest {
    /**
     * The ID of the campaign template whose schedule is being fetched.
     * @type {string}
     * @memberof CertificationCampaignsBetaApiGetCampaignTemplateSchedule
     */
    readonly id: string
}

/**
 * Request parameters for listCampaignTemplates operation in CertificationCampaignsBetaApi.
 * @export
 * @interface CertificationCampaignsBetaApiListCampaignTemplatesRequest
 */
export interface CertificationCampaignsBetaApiListCampaignTemplatesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationCampaignsBetaApiListCampaignTemplates
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationCampaignsBetaApiListCampaignTemplates
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationCampaignsBetaApiListCampaignTemplates
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
     * @type {string}
     * @memberof CertificationCampaignsBetaApiListCampaignTemplates
     */
    readonly sorters?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields: **name, id**
     * @type {string}
     * @memberof CertificationCampaignsBetaApiListCampaignTemplates
     */
    readonly filters?: string
}

/**
 * Request parameters for move operation in CertificationCampaignsBetaApi.
 * @export
 * @interface CertificationCampaignsBetaApiMoveRequest
 */
export interface CertificationCampaignsBetaApiMoveRequest {
    /**
     * The certification campaign ID
     * @type {string}
     * @memberof CertificationCampaignsBetaApiMove
     */
    readonly id: string

    /**
     * 
     * @type {AdminReviewReassignBeta}
     * @memberof CertificationCampaignsBetaApiMove
     */
    readonly adminReviewReassignBeta: AdminReviewReassignBeta
}

/**
 * Request parameters for patchCampaignTemplate operation in CertificationCampaignsBetaApi.
 * @export
 * @interface CertificationCampaignsBetaApiPatchCampaignTemplateRequest
 */
export interface CertificationCampaignsBetaApiPatchCampaignTemplateRequest {
    /**
     * The ID of the campaign template being modified.
     * @type {string}
     * @memberof CertificationCampaignsBetaApiPatchCampaignTemplate
     */
    readonly id: string

    /**
     * A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * deadlineDuration * campaign (all fields that are allowed during create) 
     * @type {Array<object>}
     * @memberof CertificationCampaignsBetaApiPatchCampaignTemplate
     */
    readonly requestBody: Array<object>
}

/**
 * Request parameters for runCampaignRemediationScan operation in CertificationCampaignsBetaApi.
 * @export
 * @interface CertificationCampaignsBetaApiRunCampaignRemediationScanRequest
 */
export interface CertificationCampaignsBetaApiRunCampaignRemediationScanRequest {
    /**
     * The ID of the campaign for which remediation scan is being run.
     * @type {string}
     * @memberof CertificationCampaignsBetaApiRunCampaignRemediationScan
     */
    readonly id: string
}

/**
 * Request parameters for runCampaignReport operation in CertificationCampaignsBetaApi.
 * @export
 * @interface CertificationCampaignsBetaApiRunCampaignReportRequest
 */
export interface CertificationCampaignsBetaApiRunCampaignReportRequest {
    /**
     * The ID of the campaign for which report is being run.
     * @type {string}
     * @memberof CertificationCampaignsBetaApiRunCampaignReport
     */
    readonly id: string

    /**
     * The type of the report to run.
     * @type {ReportTypeBeta}
     * @memberof CertificationCampaignsBetaApiRunCampaignReport
     */
    readonly type: ReportTypeBeta
}

/**
 * Request parameters for setCampaignReportsConfig operation in CertificationCampaignsBetaApi.
 * @export
 * @interface CertificationCampaignsBetaApiSetCampaignReportsConfigRequest
 */
export interface CertificationCampaignsBetaApiSetCampaignReportsConfigRequest {
    /**
     * Campaign Report Configuration
     * @type {CampaignReportsConfigBeta}
     * @memberof CertificationCampaignsBetaApiSetCampaignReportsConfig
     */
    readonly campaignReportsConfigBeta: CampaignReportsConfigBeta
}

/**
 * Request parameters for setCampaignTemplateSchedule operation in CertificationCampaignsBetaApi.
 * @export
 * @interface CertificationCampaignsBetaApiSetCampaignTemplateScheduleRequest
 */
export interface CertificationCampaignsBetaApiSetCampaignTemplateScheduleRequest {
    /**
     * The ID of the campaign template being scheduled.
     * @type {string}
     * @memberof CertificationCampaignsBetaApiSetCampaignTemplateSchedule
     */
    readonly id: string

    /**
     * 
     * @type {ScheduleBeta}
     * @memberof CertificationCampaignsBetaApiSetCampaignTemplateSchedule
     */
    readonly scheduleBeta?: ScheduleBeta
}

/**
 * Request parameters for startCampaign operation in CertificationCampaignsBetaApi.
 * @export
 * @interface CertificationCampaignsBetaApiStartCampaignRequest
 */
export interface CertificationCampaignsBetaApiStartCampaignRequest {
    /**
     * The campaign id
     * @type {string}
     * @memberof CertificationCampaignsBetaApiStartCampaign
     */
    readonly id: string

    /**
     * Optional. If no timezone is specified, the standard UTC timezone is used (i.e. UTC+00:00). Although this can take any timezone, the intended value is the caller\&#39;s timezone. The activation time calculated from the given timezone may cause the campaign deadline time to be modified, but it will remain within the original date. The timezone must be in a valid ISO 8601 format.
     * @type {ActivateCampaignOptionsBeta}
     * @memberof CertificationCampaignsBetaApiStartCampaign
     */
    readonly activateCampaignOptionsBeta?: ActivateCampaignOptionsBeta
}

/**
 * Request parameters for updateCampaign operation in CertificationCampaignsBetaApi.
 * @export
 * @interface CertificationCampaignsBetaApiUpdateCampaignRequest
 */
export interface CertificationCampaignsBetaApiUpdateCampaignRequest {
    /**
     * The ID of the campaign template being modified.
     * @type {string}
     * @memberof CertificationCampaignsBetaApiUpdateCampaign
     */
    readonly id: string

    /**
     * A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The fields that can be patched differ based on the status of the campaign.  In the *STAGED* status, the following fields can be patched: * name * description * recommendationsEnabled * deadline * emailNotificationEnabled * autoRevokeAllowed  In the *ACTIVE* status, the following fields can be patched: * deadline 
     * @type {Array<object>}
     * @memberof CertificationCampaignsBetaApiUpdateCampaign
     */
    readonly requestBody: Array<object>
}

/**
 * CertificationCampaignsBetaApi - object-oriented interface
 * @export
 * @class CertificationCampaignsBetaApi
 * @extends {BaseAPI}
 */
export class CertificationCampaignsBetaApi extends BaseAPI {
    /**
     * :::caution  This endpoint will run successfully for any campaigns that are **past due**.  This endpoint will return a content error if the campaign is **not past due**.  :::  Completes a certification campaign. This is provided to admins so that they can complete a certification even if all items have not been completed.  Requires roles of CERT_ADMIN and ORG_ADMIN 
     * @summary Complete a Campaign
     * @param {CertificationCampaignsBetaApiCompleteCampaignRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsBetaApi
     */
    public completeCampaign(requestParameters: CertificationCampaignsBetaApiCompleteCampaignRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsBetaApiFp(this.configuration).completeCampaign(requestParameters.id, requestParameters.completeCampaignOptionsBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new Certification Campaign with the information provided in the request body.
     * @summary Create a campaign
     * @param {CertificationCampaignsBetaApiCreateCampaignRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof CertificationCampaignsBetaApi
     */
    public createCampaign(requestParameters: CertificationCampaignsBetaApiCreateCampaignRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsBetaApiFp(this.configuration).createCampaign(requestParameters.campaignBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a Campaign Template
     * @param {CertificationCampaignsBetaApiCreateCampaignTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsBetaApi
     */
    public createCampaignTemplate(requestParameters: CertificationCampaignsBetaApiCreateCampaignTemplateRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsBetaApiFp(this.configuration).createCampaignTemplate(requestParameters.campaignTemplateBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a campaign template by ID.
     * @summary Delete a Campaign Template
     * @param {CertificationCampaignsBetaApiDeleteCampaignTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsBetaApi
     */
    public deleteCampaignTemplate(requestParameters: CertificationCampaignsBetaApiDeleteCampaignTemplateRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsBetaApiFp(this.configuration).deleteCampaignTemplate(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the schedule for a campaign template. Returns a 404 if there is no schedule set.
     * @summary Deletes a Campaign Template\'s Schedule
     * @param {CertificationCampaignsBetaApiDeleteCampaignTemplateScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsBetaApi
     */
    public deleteCampaignTemplateSchedule(requestParameters: CertificationCampaignsBetaApiDeleteCampaignTemplateScheduleRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsBetaApiFp(this.configuration).deleteCampaignTemplateSchedule(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes campaigns whose Ids are specified in the provided list of campaign Ids. Authorized callers must be an ORG_ADMIN or a CERT_ADMIN.
     * @summary Deletes Campaigns
     * @param {CertificationCampaignsBetaApiDeleteCampaignsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsBetaApi
     */
    public deleteCampaigns(requestParameters: CertificationCampaignsBetaApiDeleteCampaignsRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsBetaApiFp(this.configuration).deleteCampaigns(requestParameters.deleteCampaignsRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a new campaign from a campaign template. The campaign object contained in the template has special formatting applied to its name and description fields in order to determine the generated campaign\'s name/description. Placeholders in those fields are formatted with the current date and time upon generation. Placeholders consist of a percent sign followed by a letter indicating what should be inserted; for example, \"%Y\" will insert the current year; a campaign template named \"Campaign for %y\" would generate a campaign called \"Campaign for 2020\" (assuming the year at generation time is 2020). Valid placeholders are the date/time conversion suffix characters supported by [java.util.Formatter](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). Requires roles ORG_ADMIN.
     * @summary Generate a Campaign from Template
     * @param {CertificationCampaignsBetaApiGenerateCampaignTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsBetaApi
     */
    public generateCampaignTemplate(requestParameters: CertificationCampaignsBetaApiGenerateCampaignTemplateRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsBetaApiFp(this.configuration).generateCampaignTemplate(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets campaigns and returns them in a list. Can provide increased level of detail for each campaign if provided the correct query.
     * @summary List Campaigns
     * @param {CertificationCampaignsBetaApiGetActiveCampaignsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof CertificationCampaignsBetaApi
     */
    public getActiveCampaigns(requestParameters: CertificationCampaignsBetaApiGetActiveCampaignsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsBetaApiFp(this.configuration).getActiveCampaigns(requestParameters.detail, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves information for an existing campaign using the campaign\'s ID. Authorized callers must be a reviewer for this campaign, an ORG_ADMIN, or a CERT_ADMIN.
     * @summary Get a campaign
     * @param {CertificationCampaignsBetaApiGetCampaignRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof CertificationCampaignsBetaApi
     */
    public getCampaign(requestParameters: CertificationCampaignsBetaApiGetCampaignRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsBetaApiFp(this.configuration).getCampaign(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches all reports for a certification campaign by campaign ID. Requires roles of CERT_ADMIN, DASHBOARD, ORG_ADMIN and REPORT_ADMIN
     * @summary Get Campaign Reports
     * @param {CertificationCampaignsBetaApiGetCampaignReportsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof CertificationCampaignsBetaApi
     */
    public getCampaignReports(requestParameters: CertificationCampaignsBetaApiGetCampaignReportsRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsBetaApiFp(this.configuration).getCampaignReports(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches configuration for campaign reports. Currently it includes only one element - identity attributes defined as custom report columns. Requires roles of CERT_ADMIN and ORG_ADMIN.
     * @summary Get Campaign Reports Configuration
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsBetaApi
     */
    public getCampaignReportsConfig(axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsBetaApiFp(this.configuration).getCampaignReportsConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches a campaign template by ID.
     * @summary Get a Campaign Template
     * @param {CertificationCampaignsBetaApiGetCampaignTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsBetaApi
     */
    public getCampaignTemplate(requestParameters: CertificationCampaignsBetaApiGetCampaignTemplateRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsBetaApiFp(this.configuration).getCampaignTemplate(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the schedule for a campaign template. Returns a 404 if there is no schedule set.
     * @summary Gets a Campaign Template\'s Schedule
     * @param {CertificationCampaignsBetaApiGetCampaignTemplateScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsBetaApi
     */
    public getCampaignTemplateSchedule(requestParameters: CertificationCampaignsBetaApiGetCampaignTemplateScheduleRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsBetaApiFp(this.configuration).getCampaignTemplateSchedule(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Campaign Templates
     * @param {CertificationCampaignsBetaApiListCampaignTemplatesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsBetaApi
     */
    public listCampaignTemplates(requestParameters: CertificationCampaignsBetaApiListCampaignTemplatesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsBetaApiFp(this.configuration).listCampaignTemplates(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API reassigns the specified certifications from one identity to another. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
     * @summary Reassign Certifications
     * @param {CertificationCampaignsBetaApiMoveRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof CertificationCampaignsBetaApi
     */
    public move(requestParameters: CertificationCampaignsBetaApiMoveRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsBetaApiFp(this.configuration).move(requestParameters.id, requestParameters.adminReviewReassignBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows updating individual fields on a campaign template using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
     * @summary Update a Campaign Template
     * @param {CertificationCampaignsBetaApiPatchCampaignTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsBetaApi
     */
    public patchCampaignTemplate(requestParameters: CertificationCampaignsBetaApiPatchCampaignTemplateRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsBetaApiFp(this.configuration).patchCampaignTemplate(requestParameters.id, requestParameters.requestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kicks off remediation scan task for a certification campaign. Requires roles of CERT_ADMIN and ORG_ADMIN
     * @summary Run Campaign Remediation Scan
     * @param {CertificationCampaignsBetaApiRunCampaignRemediationScanRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsBetaApi
     */
    public runCampaignRemediationScan(requestParameters: CertificationCampaignsBetaApiRunCampaignRemediationScanRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsBetaApiFp(this.configuration).runCampaignRemediationScan(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Runs a report for a certification campaign. Requires the following roles: CERT_ADMIN, DASHBOARD, ORG_ADMIN and REPORT_ADMIN.
     * @summary Run Campaign Report
     * @param {CertificationCampaignsBetaApiRunCampaignReportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsBetaApi
     */
    public runCampaignReport(requestParameters: CertificationCampaignsBetaApiRunCampaignReportRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsBetaApiFp(this.configuration).runCampaignReport(requestParameters.id, requestParameters.type, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Overwrites configuration for campaign reports. Requires roles CERT_ADMIN and ORG_ADMIN.
     * @summary Set Campaign Reports Configuration
     * @param {CertificationCampaignsBetaApiSetCampaignReportsConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsBetaApi
     */
    public setCampaignReportsConfig(requestParameters: CertificationCampaignsBetaApiSetCampaignReportsConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsBetaApiFp(this.configuration).setCampaignReportsConfig(requestParameters.campaignReportsConfigBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets the schedule for a campaign template. If a schedule already exists, it will be overwritten with the new one.
     * @summary Sets a Campaign Template\'s Schedule
     * @param {CertificationCampaignsBetaApiSetCampaignTemplateScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsBetaApi
     */
    public setCampaignTemplateSchedule(requestParameters: CertificationCampaignsBetaApiSetCampaignTemplateScheduleRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsBetaApiFp(this.configuration).setCampaignTemplateSchedule(requestParameters.id, requestParameters.scheduleBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submits a job to activate the campaign with the given Id. The campaign must be staged. Requires roles of CERT_ADMIN and ORG_ADMIN
     * @summary Activate a Campaign
     * @param {CertificationCampaignsBetaApiStartCampaignRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof CertificationCampaignsBetaApi
     */
    public startCampaign(requestParameters: CertificationCampaignsBetaApiStartCampaignRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsBetaApiFp(this.configuration).startCampaign(requestParameters.id, requestParameters.activateCampaignOptionsBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows updating individual fields on a campaign using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
     * @summary Update a Campaign
     * @param {CertificationCampaignsBetaApiUpdateCampaignRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsBetaApi
     */
    public updateCampaign(requestParameters: CertificationCampaignsBetaApiUpdateCampaignRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsBetaApiFp(this.configuration).updateCampaign(requestParameters.id, requestParameters.requestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CertificationsBetaApi - axios parameter creator
 * @export
 */
export const CertificationsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API returns the permissions associated with an entitlement certification item based on the certification item\'s ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Permissions for Entitlement Certification Item
         * @param {string} certificationId The certification ID
         * @param {string} itemId The certification item ID
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Supported fields and primitive operators:  **target**: *eq, sw*  **rights**: *ca*  Supported composite operators:  *and, or*  All field values (second filter operands) are case-insensitive for this API.  Only a single *and* or *or* composite filter operator may be used. It must also be used between a target filter and a rights filter, not between 2 filters for the same field. For example,  The following is valid: *?filters&#x3D;rights+ca+(%22CREATE%22)+and+target+eq+%22SYS.OBJAUTH2%22*  The following is invalid: *?filters&#x3D;rights+ca+(%22CREATE%22)+and+rights+ca+(%SELECT%22)*
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityCertificationItemPermissions: async (certificationId: string, itemId: string, filters?: string, limit?: number, offset?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'certificationId' is not null or undefined
            assertParamExists('getIdentityCertificationItemPermissions', 'certificationId', certificationId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getIdentityCertificationItemPermissions', 'itemId', itemId)
            const localVarPath = `/certifications/{certificationId}/access-review-items/{itemId}/permissions`
                .replace(`{${"certificationId"}}`, encodeURIComponent(String(certificationId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the status of all pending (`QUEUED` or `IN_PROGRESS`) tasks for an identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Pending Certification Tasks
         * @param {string} id The identity campaign certification ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityCertificationPendingTasks: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentityCertificationPendingTasks', 'id', id)
            const localVarPath = `/certifications/{id}/tasks-pending`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the status of a certification task. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Certification Task Status
         * @param {string} id The identity campaign certification ID
         * @param {string} taskId The certification task ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityCertificationTaskStatus: async (id: string, taskId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentityCertificationTaskStatus', 'id', id)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getIdentityCertificationTaskStatus', 'taskId', taskId)
            const localVarPath = `/certifications/{id}/tasks/{taskId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of reviewers for the certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary List of Reviewers for the certification
         * @param {string} id The certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators (Filtering is done by reviewer\&#39;s fields):  **id**: *eq, in*  **name**: *eq, sw*  **email**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCertificationReviewers: async (id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listCertificationReviewers', 'id', id)
            const localVarPath = `/certifications/{id}/reviewers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API initiates a task to reassign up to 500 identities or items in an identity campaign certification to another reviewer. The `certification-tasks` API can be used to get an updated status on the task and determine when the reassignment is complete. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Reassign Certifications Asynchronously
         * @param {string} id The identity campaign certification ID
         * @param {ReviewReassignBeta} reviewReassignBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        reassignIdentityCertsAsync: async (id: string, reviewReassignBeta: ReviewReassignBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reassignIdentityCertsAsync', 'id', id)
            // verify required parameter 'reviewReassignBeta' is not null or undefined
            assertParamExists('reassignIdentityCertsAsync', 'reviewReassignBeta', reviewReassignBeta)
            const localVarPath = `/certifications/{id}/reassign-async`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reviewReassignBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * CertificationsBetaApi - functional programming interface
 * @export
 */
export const CertificationsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CertificationsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This API returns the permissions associated with an entitlement certification item based on the certification item\'s ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Permissions for Entitlement Certification Item
         * @param {string} certificationId The certification ID
         * @param {string} itemId The certification item ID
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Supported fields and primitive operators:  **target**: *eq, sw*  **rights**: *ca*  Supported composite operators:  *and, or*  All field values (second filter operands) are case-insensitive for this API.  Only a single *and* or *or* composite filter operator may be used. It must also be used between a target filter and a rights filter, not between 2 filters for the same field. For example,  The following is valid: *?filters&#x3D;rights+ca+(%22CREATE%22)+and+target+eq+%22SYS.OBJAUTH2%22*  The following is invalid: *?filters&#x3D;rights+ca+(%22CREATE%22)+and+rights+ca+(%SELECT%22)*
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityCertificationItemPermissions(certificationId: string, itemId: string, filters?: string, limit?: number, offset?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PermissionDtoBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityCertificationItemPermissions(certificationId, itemId, filters, limit, offset, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the status of all pending (`QUEUED` or `IN_PROGRESS`) tasks for an identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Pending Certification Tasks
         * @param {string} id The identity campaign certification ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityCertificationPendingTasks(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentityCertificationTaskBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityCertificationPendingTasks(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the status of a certification task. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Certification Task Status
         * @param {string} id The identity campaign certification ID
         * @param {string} taskId The certification task ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityCertificationTaskStatus(id: string, taskId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityCertificationTaskBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityCertificationTaskStatus(id, taskId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of reviewers for the certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary List of Reviewers for the certification
         * @param {string} id The certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators (Filtering is done by reviewer\&#39;s fields):  **id**: *eq, in*  **name**: *eq, sw*  **email**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listCertificationReviewers(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentityReferenceWithNameAndEmailBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCertificationReviewers(id, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API initiates a task to reassign up to 500 identities or items in an identity campaign certification to another reviewer. The `certification-tasks` API can be used to get an updated status on the task and determine when the reassignment is complete. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Reassign Certifications Asynchronously
         * @param {string} id The identity campaign certification ID
         * @param {ReviewReassignBeta} reviewReassignBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async reassignIdentityCertsAsync(id: string, reviewReassignBeta: ReviewReassignBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityCertificationTaskBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reassignIdentityCertsAsync(id, reviewReassignBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CertificationsBetaApi - factory interface
 * @export
 */
export const CertificationsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CertificationsBetaApiFp(configuration)
    return {
        /**
         * This API returns the permissions associated with an entitlement certification item based on the certification item\'s ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Permissions for Entitlement Certification Item
         * @param {string} certificationId The certification ID
         * @param {string} itemId The certification item ID
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Supported fields and primitive operators:  **target**: *eq, sw*  **rights**: *ca*  Supported composite operators:  *and, or*  All field values (second filter operands) are case-insensitive for this API.  Only a single *and* or *or* composite filter operator may be used. It must also be used between a target filter and a rights filter, not between 2 filters for the same field. For example,  The following is valid: *?filters&#x3D;rights+ca+(%22CREATE%22)+and+target+eq+%22SYS.OBJAUTH2%22*  The following is invalid: *?filters&#x3D;rights+ca+(%22CREATE%22)+and+rights+ca+(%SELECT%22)*
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityCertificationItemPermissions(certificationId: string, itemId: string, filters?: string, limit?: number, offset?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<PermissionDtoBeta>> {
            return localVarFp.getIdentityCertificationItemPermissions(certificationId, itemId, filters, limit, offset, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the status of all pending (`QUEUED` or `IN_PROGRESS`) tasks for an identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Pending Certification Tasks
         * @param {string} id The identity campaign certification ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityCertificationPendingTasks(id: string, axiosOptions?: any): AxiosPromise<Array<IdentityCertificationTaskBeta>> {
            return localVarFp.getIdentityCertificationPendingTasks(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the status of a certification task. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Certification Task Status
         * @param {string} id The identity campaign certification ID
         * @param {string} taskId The certification task ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityCertificationTaskStatus(id: string, taskId: string, axiosOptions?: any): AxiosPromise<IdentityCertificationTaskBeta> {
            return localVarFp.getIdentityCertificationTaskStatus(id, taskId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of reviewers for the certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary List of Reviewers for the certification
         * @param {string} id The certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators (Filtering is done by reviewer\&#39;s fields):  **id**: *eq, in*  **name**: *eq, sw*  **email**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCertificationReviewers(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<IdentityReferenceWithNameAndEmailBeta>> {
            return localVarFp.listCertificationReviewers(id, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API initiates a task to reassign up to 500 identities or items in an identity campaign certification to another reviewer. The `certification-tasks` API can be used to get an updated status on the task and determine when the reassignment is complete. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Reassign Certifications Asynchronously
         * @param {string} id The identity campaign certification ID
         * @param {ReviewReassignBeta} reviewReassignBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        reassignIdentityCertsAsync(id: string, reviewReassignBeta: ReviewReassignBeta, axiosOptions?: any): AxiosPromise<IdentityCertificationTaskBeta> {
            return localVarFp.reassignIdentityCertsAsync(id, reviewReassignBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getIdentityCertificationItemPermissions operation in CertificationsBetaApi.
 * @export
 * @interface CertificationsBetaApiGetIdentityCertificationItemPermissionsRequest
 */
export interface CertificationsBetaApiGetIdentityCertificationItemPermissionsRequest {
    /**
     * The certification ID
     * @type {string}
     * @memberof CertificationsBetaApiGetIdentityCertificationItemPermissions
     */
    readonly certificationId: string

    /**
     * The certification item ID
     * @type {string}
     * @memberof CertificationsBetaApiGetIdentityCertificationItemPermissions
     */
    readonly itemId: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Supported fields and primitive operators:  **target**: *eq, sw*  **rights**: *ca*  Supported composite operators:  *and, or*  All field values (second filter operands) are case-insensitive for this API.  Only a single *and* or *or* composite filter operator may be used. It must also be used between a target filter and a rights filter, not between 2 filters for the same field. For example,  The following is valid: *?filters&#x3D;rights+ca+(%22CREATE%22)+and+target+eq+%22SYS.OBJAUTH2%22*  The following is invalid: *?filters&#x3D;rights+ca+(%22CREATE%22)+and+rights+ca+(%SELECT%22)*
     * @type {string}
     * @memberof CertificationsBetaApiGetIdentityCertificationItemPermissions
     */
    readonly filters?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsBetaApiGetIdentityCertificationItemPermissions
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsBetaApiGetIdentityCertificationItemPermissions
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationsBetaApiGetIdentityCertificationItemPermissions
     */
    readonly count?: boolean
}

/**
 * Request parameters for getIdentityCertificationPendingTasks operation in CertificationsBetaApi.
 * @export
 * @interface CertificationsBetaApiGetIdentityCertificationPendingTasksRequest
 */
export interface CertificationsBetaApiGetIdentityCertificationPendingTasksRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationsBetaApiGetIdentityCertificationPendingTasks
     */
    readonly id: string
}

/**
 * Request parameters for getIdentityCertificationTaskStatus operation in CertificationsBetaApi.
 * @export
 * @interface CertificationsBetaApiGetIdentityCertificationTaskStatusRequest
 */
export interface CertificationsBetaApiGetIdentityCertificationTaskStatusRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationsBetaApiGetIdentityCertificationTaskStatus
     */
    readonly id: string

    /**
     * The certification task ID
     * @type {string}
     * @memberof CertificationsBetaApiGetIdentityCertificationTaskStatus
     */
    readonly taskId: string
}

/**
 * Request parameters for listCertificationReviewers operation in CertificationsBetaApi.
 * @export
 * @interface CertificationsBetaApiListCertificationReviewersRequest
 */
export interface CertificationsBetaApiListCertificationReviewersRequest {
    /**
     * The certification ID
     * @type {string}
     * @memberof CertificationsBetaApiListCertificationReviewers
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsBetaApiListCertificationReviewers
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsBetaApiListCertificationReviewers
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationsBetaApiListCertificationReviewers
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators (Filtering is done by reviewer\&#39;s fields):  **id**: *eq, in*  **name**: *eq, sw*  **email**: *eq, sw*
     * @type {string}
     * @memberof CertificationsBetaApiListCertificationReviewers
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, email**
     * @type {string}
     * @memberof CertificationsBetaApiListCertificationReviewers
     */
    readonly sorters?: string
}

/**
 * Request parameters for reassignIdentityCertsAsync operation in CertificationsBetaApi.
 * @export
 * @interface CertificationsBetaApiReassignIdentityCertsAsyncRequest
 */
export interface CertificationsBetaApiReassignIdentityCertsAsyncRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationsBetaApiReassignIdentityCertsAsync
     */
    readonly id: string

    /**
     * 
     * @type {ReviewReassignBeta}
     * @memberof CertificationsBetaApiReassignIdentityCertsAsync
     */
    readonly reviewReassignBeta: ReviewReassignBeta
}

/**
 * CertificationsBetaApi - object-oriented interface
 * @export
 * @class CertificationsBetaApi
 * @extends {BaseAPI}
 */
export class CertificationsBetaApi extends BaseAPI {
    /**
     * This API returns the permissions associated with an entitlement certification item based on the certification item\'s ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary Permissions for Entitlement Certification Item
     * @param {CertificationsBetaApiGetIdentityCertificationItemPermissionsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsBetaApi
     */
    public getIdentityCertificationItemPermissions(requestParameters: CertificationsBetaApiGetIdentityCertificationItemPermissionsRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsBetaApiFp(this.configuration).getIdentityCertificationItemPermissions(requestParameters.certificationId, requestParameters.itemId, requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the status of all pending (`QUEUED` or `IN_PROGRESS`) tasks for an identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary Pending Certification Tasks
     * @param {CertificationsBetaApiGetIdentityCertificationPendingTasksRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsBetaApi
     */
    public getIdentityCertificationPendingTasks(requestParameters: CertificationsBetaApiGetIdentityCertificationPendingTasksRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsBetaApiFp(this.configuration).getIdentityCertificationPendingTasks(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the status of a certification task. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary Certification Task Status
     * @param {CertificationsBetaApiGetIdentityCertificationTaskStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsBetaApi
     */
    public getIdentityCertificationTaskStatus(requestParameters: CertificationsBetaApiGetIdentityCertificationTaskStatusRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsBetaApiFp(this.configuration).getIdentityCertificationTaskStatus(requestParameters.id, requestParameters.taskId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of reviewers for the certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary List of Reviewers for the certification
     * @param {CertificationsBetaApiListCertificationReviewersRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsBetaApi
     */
    public listCertificationReviewers(requestParameters: CertificationsBetaApiListCertificationReviewersRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsBetaApiFp(this.configuration).listCertificationReviewers(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API initiates a task to reassign up to 500 identities or items in an identity campaign certification to another reviewer. The `certification-tasks` API can be used to get an updated status on the task and determine when the reassignment is complete. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary Reassign Certifications Asynchronously
     * @param {CertificationsBetaApiReassignIdentityCertsAsyncRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsBetaApi
     */
    public reassignIdentityCertsAsync(requestParameters: CertificationsBetaApiReassignIdentityCertsAsyncRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsBetaApiFp(this.configuration).reassignIdentityCertsAsync(requestParameters.id, requestParameters.reviewReassignBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConnectorRuleManagementBetaApi - axios parameter creator
 * @export
 */
export const ConnectorRuleManagementBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new connector rule. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Connector Rule
         * @param {ConnectorRuleCreateRequestBeta} connectorRuleCreateRequestBeta The connector rule to create
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createConnectorRule: async (connectorRuleCreateRequestBeta: ConnectorRuleCreateRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorRuleCreateRequestBeta' is not null or undefined
            assertParamExists('createConnectorRule', 'connectorRuleCreateRequestBeta', connectorRuleCreateRequestBeta)
            const localVarPath = `/connector-rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectorRuleCreateRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes the connector rule specified by the given ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete a Connector-Rule
         * @param {string} id ID of the connector rule to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnectorRule: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteConnectorRule', 'id', id)
            const localVarPath = `/connector-rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Returns the connector rule specified by ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Connector-Rule by ID
         * @param {string} id ID of the connector rule to retrieve
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorRule: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getConnectorRule', 'id', id)
            const localVarPath = `/connector-rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of connector rules. A token with ORG_ADMIN authority is required to call this API.
         * @summary List Connector Rules
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorRuleList: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/connector-rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing connector rule with the one provided in the request body. Note that the fields \'id\', \'name\', and \'type\' are immutable. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update a Connector Rule
         * @param {string} id ID of the connector rule to update
         * @param {ConnectorRuleUpdateRequestBeta} [connectorRuleUpdateRequestBeta] The connector rule with updated data
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateConnectorRule: async (id: string, connectorRuleUpdateRequestBeta?: ConnectorRuleUpdateRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateConnectorRule', 'id', id)
            const localVarPath = `/connector-rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectorRuleUpdateRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of issues within the code to fix, if any. A token with ORG_ADMIN authority is required to call this API.
         * @summary Validate Connector Rule
         * @param {SourceCodeBeta} sourceCodeBeta The code to validate
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        validateConnectorRule: async (sourceCodeBeta: SourceCodeBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceCodeBeta' is not null or undefined
            assertParamExists('validateConnectorRule', 'sourceCodeBeta', sourceCodeBeta)
            const localVarPath = `/connector-rules/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceCodeBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectorRuleManagementBetaApi - functional programming interface
 * @export
 */
export const ConnectorRuleManagementBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectorRuleManagementBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new connector rule. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Connector Rule
         * @param {ConnectorRuleCreateRequestBeta} connectorRuleCreateRequestBeta The connector rule to create
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createConnectorRule(connectorRuleCreateRequestBeta: ConnectorRuleCreateRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorRuleResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConnectorRule(connectorRuleCreateRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the connector rule specified by the given ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete a Connector-Rule
         * @param {string} id ID of the connector rule to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConnectorRule(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConnectorRule(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the connector rule specified by ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Connector-Rule by ID
         * @param {string} id ID of the connector rule to retrieve
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectorRule(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorRuleResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectorRule(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of connector rules. A token with ORG_ADMIN authority is required to call this API.
         * @summary List Connector Rules
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectorRuleList(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConnectorRuleResponseBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectorRuleList(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates an existing connector rule with the one provided in the request body. Note that the fields \'id\', \'name\', and \'type\' are immutable. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update a Connector Rule
         * @param {string} id ID of the connector rule to update
         * @param {ConnectorRuleUpdateRequestBeta} [connectorRuleUpdateRequestBeta] The connector rule with updated data
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateConnectorRule(id: string, connectorRuleUpdateRequestBeta?: ConnectorRuleUpdateRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorRuleResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConnectorRule(id, connectorRuleUpdateRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of issues within the code to fix, if any. A token with ORG_ADMIN authority is required to call this API.
         * @summary Validate Connector Rule
         * @param {SourceCodeBeta} sourceCodeBeta The code to validate
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async validateConnectorRule(sourceCodeBeta: SourceCodeBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorRuleValidationResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateConnectorRule(sourceCodeBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConnectorRuleManagementBetaApi - factory interface
 * @export
 */
export const ConnectorRuleManagementBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectorRuleManagementBetaApiFp(configuration)
    return {
        /**
         * Creates a new connector rule. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Connector Rule
         * @param {ConnectorRuleCreateRequestBeta} connectorRuleCreateRequestBeta The connector rule to create
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createConnectorRule(connectorRuleCreateRequestBeta: ConnectorRuleCreateRequestBeta, axiosOptions?: any): AxiosPromise<ConnectorRuleResponseBeta> {
            return localVarFp.createConnectorRule(connectorRuleCreateRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the connector rule specified by the given ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete a Connector-Rule
         * @param {string} id ID of the connector rule to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnectorRule(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteConnectorRule(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Returns the connector rule specified by ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Connector-Rule by ID
         * @param {string} id ID of the connector rule to retrieve
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorRule(id: string, axiosOptions?: any): AxiosPromise<ConnectorRuleResponseBeta> {
            return localVarFp.getConnectorRule(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of connector rules. A token with ORG_ADMIN authority is required to call this API.
         * @summary List Connector Rules
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorRuleList(axiosOptions?: any): AxiosPromise<Array<ConnectorRuleResponseBeta>> {
            return localVarFp.getConnectorRuleList(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing connector rule with the one provided in the request body. Note that the fields \'id\', \'name\', and \'type\' are immutable. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update a Connector Rule
         * @param {string} id ID of the connector rule to update
         * @param {ConnectorRuleUpdateRequestBeta} [connectorRuleUpdateRequestBeta] The connector rule with updated data
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateConnectorRule(id: string, connectorRuleUpdateRequestBeta?: ConnectorRuleUpdateRequestBeta, axiosOptions?: any): AxiosPromise<ConnectorRuleResponseBeta> {
            return localVarFp.updateConnectorRule(id, connectorRuleUpdateRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of issues within the code to fix, if any. A token with ORG_ADMIN authority is required to call this API.
         * @summary Validate Connector Rule
         * @param {SourceCodeBeta} sourceCodeBeta The code to validate
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        validateConnectorRule(sourceCodeBeta: SourceCodeBeta, axiosOptions?: any): AxiosPromise<ConnectorRuleValidationResponseBeta> {
            return localVarFp.validateConnectorRule(sourceCodeBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createConnectorRule operation in ConnectorRuleManagementBetaApi.
 * @export
 * @interface ConnectorRuleManagementBetaApiCreateConnectorRuleRequest
 */
export interface ConnectorRuleManagementBetaApiCreateConnectorRuleRequest {
    /**
     * The connector rule to create
     * @type {ConnectorRuleCreateRequestBeta}
     * @memberof ConnectorRuleManagementBetaApiCreateConnectorRule
     */
    readonly connectorRuleCreateRequestBeta: ConnectorRuleCreateRequestBeta
}

/**
 * Request parameters for deleteConnectorRule operation in ConnectorRuleManagementBetaApi.
 * @export
 * @interface ConnectorRuleManagementBetaApiDeleteConnectorRuleRequest
 */
export interface ConnectorRuleManagementBetaApiDeleteConnectorRuleRequest {
    /**
     * ID of the connector rule to delete
     * @type {string}
     * @memberof ConnectorRuleManagementBetaApiDeleteConnectorRule
     */
    readonly id: string
}

/**
 * Request parameters for getConnectorRule operation in ConnectorRuleManagementBetaApi.
 * @export
 * @interface ConnectorRuleManagementBetaApiGetConnectorRuleRequest
 */
export interface ConnectorRuleManagementBetaApiGetConnectorRuleRequest {
    /**
     * ID of the connector rule to retrieve
     * @type {string}
     * @memberof ConnectorRuleManagementBetaApiGetConnectorRule
     */
    readonly id: string
}

/**
 * Request parameters for updateConnectorRule operation in ConnectorRuleManagementBetaApi.
 * @export
 * @interface ConnectorRuleManagementBetaApiUpdateConnectorRuleRequest
 */
export interface ConnectorRuleManagementBetaApiUpdateConnectorRuleRequest {
    /**
     * ID of the connector rule to update
     * @type {string}
     * @memberof ConnectorRuleManagementBetaApiUpdateConnectorRule
     */
    readonly id: string

    /**
     * The connector rule with updated data
     * @type {ConnectorRuleUpdateRequestBeta}
     * @memberof ConnectorRuleManagementBetaApiUpdateConnectorRule
     */
    readonly connectorRuleUpdateRequestBeta?: ConnectorRuleUpdateRequestBeta
}

/**
 * Request parameters for validateConnectorRule operation in ConnectorRuleManagementBetaApi.
 * @export
 * @interface ConnectorRuleManagementBetaApiValidateConnectorRuleRequest
 */
export interface ConnectorRuleManagementBetaApiValidateConnectorRuleRequest {
    /**
     * The code to validate
     * @type {SourceCodeBeta}
     * @memberof ConnectorRuleManagementBetaApiValidateConnectorRule
     */
    readonly sourceCodeBeta: SourceCodeBeta
}

/**
 * ConnectorRuleManagementBetaApi - object-oriented interface
 * @export
 * @class ConnectorRuleManagementBetaApi
 * @extends {BaseAPI}
 */
export class ConnectorRuleManagementBetaApi extends BaseAPI {
    /**
     * Creates a new connector rule. A token with ORG_ADMIN authority is required to call this API.
     * @summary Create Connector Rule
     * @param {ConnectorRuleManagementBetaApiCreateConnectorRuleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorRuleManagementBetaApi
     */
    public createConnectorRule(requestParameters: ConnectorRuleManagementBetaApiCreateConnectorRuleRequest, axiosOptions?: AxiosRequestConfig) {
        return ConnectorRuleManagementBetaApiFp(this.configuration).createConnectorRule(requestParameters.connectorRuleCreateRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the connector rule specified by the given ID. A token with ORG_ADMIN authority is required to call this API.
     * @summary Delete a Connector-Rule
     * @param {ConnectorRuleManagementBetaApiDeleteConnectorRuleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorRuleManagementBetaApi
     */
    public deleteConnectorRule(requestParameters: ConnectorRuleManagementBetaApiDeleteConnectorRuleRequest, axiosOptions?: AxiosRequestConfig) {
        return ConnectorRuleManagementBetaApiFp(this.configuration).deleteConnectorRule(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the connector rule specified by ID. A token with ORG_ADMIN authority is required to call this API.
     * @summary Connector-Rule by ID
     * @param {ConnectorRuleManagementBetaApiGetConnectorRuleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorRuleManagementBetaApi
     */
    public getConnectorRule(requestParameters: ConnectorRuleManagementBetaApiGetConnectorRuleRequest, axiosOptions?: AxiosRequestConfig) {
        return ConnectorRuleManagementBetaApiFp(this.configuration).getConnectorRule(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of connector rules. A token with ORG_ADMIN authority is required to call this API.
     * @summary List Connector Rules
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorRuleManagementBetaApi
     */
    public getConnectorRuleList(axiosOptions?: AxiosRequestConfig) {
        return ConnectorRuleManagementBetaApiFp(this.configuration).getConnectorRuleList(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing connector rule with the one provided in the request body. Note that the fields \'id\', \'name\', and \'type\' are immutable. A token with ORG_ADMIN authority is required to call this API.
     * @summary Update a Connector Rule
     * @param {ConnectorRuleManagementBetaApiUpdateConnectorRuleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorRuleManagementBetaApi
     */
    public updateConnectorRule(requestParameters: ConnectorRuleManagementBetaApiUpdateConnectorRuleRequest, axiosOptions?: AxiosRequestConfig) {
        return ConnectorRuleManagementBetaApiFp(this.configuration).updateConnectorRule(requestParameters.id, requestParameters.connectorRuleUpdateRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of issues within the code to fix, if any. A token with ORG_ADMIN authority is required to call this API.
     * @summary Validate Connector Rule
     * @param {ConnectorRuleManagementBetaApiValidateConnectorRuleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorRuleManagementBetaApi
     */
    public validateConnectorRule(requestParameters: ConnectorRuleManagementBetaApiValidateConnectorRuleRequest, axiosOptions?: AxiosRequestConfig) {
        return ConnectorRuleManagementBetaApiFp(this.configuration).validateConnectorRule(requestParameters.sourceCodeBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConnectorsBetaApi - axios parameter creator
 * @export
 */
export const ConnectorsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches list of connectors that have \'RELEASED\' status using filtering and pagination. A token with ORG_ADMIN authority is required to call this API.
         * @summary Gets connector list
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators:  **name**: *sw*  **type**: *eq*  **directConnect**: *eq*  **category**: *eq*  **features**: *ca*
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'} [locale] The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorList: async (filters?: string, limit?: number, offset?: number, count?: boolean, locale?: 'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl', axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectorsBetaApi - functional programming interface
 * @export
 */
export const ConnectorsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectorsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Fetches list of connectors that have \'RELEASED\' status using filtering and pagination. A token with ORG_ADMIN authority is required to call this API.
         * @summary Gets connector list
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators:  **name**: *sw*  **type**: *eq*  **directConnect**: *eq*  **category**: *eq*  **features**: *ca*
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'} [locale] The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectorList(filters?: string, limit?: number, offset?: number, count?: boolean, locale?: 'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl', axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V3ConnectorDtoBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectorList(filters, limit, offset, count, locale, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConnectorsBetaApi - factory interface
 * @export
 */
export const ConnectorsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectorsBetaApiFp(configuration)
    return {
        /**
         * Fetches list of connectors that have \'RELEASED\' status using filtering and pagination. A token with ORG_ADMIN authority is required to call this API.
         * @summary Gets connector list
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators:  **name**: *sw*  **type**: *eq*  **directConnect**: *eq*  **category**: *eq*  **features**: *ca*
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'} [locale] The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorList(filters?: string, limit?: number, offset?: number, count?: boolean, locale?: 'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl', axiosOptions?: any): AxiosPromise<Array<V3ConnectorDtoBeta>> {
            return localVarFp.getConnectorList(filters, limit, offset, count, locale, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getConnectorList operation in ConnectorsBetaApi.
 * @export
 * @interface ConnectorsBetaApiGetConnectorListRequest
 */
export interface ConnectorsBetaApiGetConnectorListRequest {
    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators:  **name**: *sw*  **type**: *eq*  **directConnect**: *eq*  **category**: *eq*  **features**: *ca*
     * @type {string}
     * @memberof ConnectorsBetaApiGetConnectorList
     */
    readonly filters?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ConnectorsBetaApiGetConnectorList
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ConnectorsBetaApiGetConnectorList
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof ConnectorsBetaApiGetConnectorList
     */
    readonly count?: boolean

    /**
     * The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
     * @type {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'}
     * @memberof ConnectorsBetaApiGetConnectorList
     */
    readonly locale?: 'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'
}

/**
 * ConnectorsBetaApi - object-oriented interface
 * @export
 * @class ConnectorsBetaApi
 * @extends {BaseAPI}
 */
export class ConnectorsBetaApi extends BaseAPI {
    /**
     * Fetches list of connectors that have \'RELEASED\' status using filtering and pagination. A token with ORG_ADMIN authority is required to call this API.
     * @summary Gets connector list
     * @param {ConnectorsBetaApiGetConnectorListRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsBetaApi
     */
    public getConnectorList(requestParameters: ConnectorsBetaApiGetConnectorListRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return ConnectorsBetaApiFp(this.configuration).getConnectorList(requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.locale, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomFormsBetaApi - axios parameter creator
 * @export
 */
export const CustomFormsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a form definition.
         * @param {CreateFormDefinitionRequestBeta} [body] Body is the request payload to create form definition request
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createFormDefinition: async (body?: CreateFormDefinitionRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/form-definitions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate JSON Schema dynamically.
         * @param {FormDefinitionDynamicSchemaRequestBeta} [body] Body is the request payload to create a form definition dynamic schema
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createFormDefinitionDynamicSchema: async (body?: FormDefinitionDynamicSchemaRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/form-definitions/forms-action-dynamic-schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a form instance.
         * @param {CreateFormInstanceRequestBeta} [body] Body is the request payload to create a form instance
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createFormInstance: async (body?: CreateFormInstanceRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/form-instances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Parameter `{formDefinitionID}` should match a form definition ID.
         * @summary Deletes a form definition.
         * @param {string} formDefinitionID Form definition ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteFormDefinition: async (formDefinitionID: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'formDefinitionID' is not null or undefined
            assertParamExists('deleteFormDefinition', 'formDefinitionID', formDefinitionID)
            const localVarPath = `/form-definitions/{formDefinitionID}`
                .replace(`{${"formDefinitionID"}}`, encodeURIComponent(String(formDefinitionID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * No parameters required.
         * @summary List form definitions by tenant.
         * @param {number} [offset] Offset  Integer specifying the offset of the first result from the beginning of the collection. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results). The offset value is record-based, not page-based, and the index starts at 0.
         * @param {number} [limit] Limit  Integer specifying the maximum number of records to return in a single API call. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results). If it is not specified, a default limit is used.
         * @param {string} [filters] Filters  Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: &lt;b&gt;name&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;description&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;created&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;modified&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt;
         * @param {string} [sorters] Sorters  Item will be sorted in the returned array if the sorters expression evaluates to true for that item. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters/#sorting-results). Sorting is supported for the following fields: &lt;b&gt;name&lt;/b&gt; &lt;b&gt;description&lt;/b&gt; &lt;b&gt;created&lt;/b&gt; &lt;b&gt;modified&lt;/b&gt;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportFormDefinitionsByTenant: async (offset?: number, limit?: number, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/form-definitions/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Parameter `{formDefinitionID}` should match a form definition ID.
         * @summary Return a form definition.
         * @param {string} formDefinitionID Form definition ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getFormDefinitionByKey: async (formDefinitionID: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'formDefinitionID' is not null or undefined
            assertParamExists('getFormDefinitionByKey', 'formDefinitionID', formDefinitionID)
            const localVarPath = `/form-definitions/{formDefinitionID}`
                .replace(`{${"formDefinitionID"}}`, encodeURIComponent(String(formDefinitionID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Parameter `{formInstanceID}` should match a form instance ID.
         * @summary Returns a form instance.
         * @param {string} formInstanceID Form instance ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getFormInstanceByKey: async (formInstanceID: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'formInstanceID' is not null or undefined
            assertParamExists('getFormInstanceByKey', 'formInstanceID', formInstanceID)
            const localVarPath = `/form-instances/{formInstanceID}`
                .replace(`{${"formInstanceID"}}`, encodeURIComponent(String(formInstanceID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import form definitions from export.
         * @param {Array<ExportFormDefinitionsByTenant200ResponseInnerBeta>} [body] Body is the request payload to import form definitions
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importFormDefinitions: async (body?: Array<ExportFormDefinitionsByTenant200ResponseInnerBeta>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/form-definitions/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Parameter `{formDefinitionID}` should match a form definition ID.
         * @summary Patch a form definition.
         * @param {string} formDefinitionID Form definition ID
         * @param {Array<{ [key: string]: object; }>} [body] Body is the request payload to patch a form definition, check: https://jsonpatch.com
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchFormDefinition: async (formDefinitionID: string, body?: Array<{ [key: string]: object; }>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'formDefinitionID' is not null or undefined
            assertParamExists('patchFormDefinition', 'formDefinitionID', formDefinitionID)
            const localVarPath = `/form-definitions/{formDefinitionID}`
                .replace(`{${"formDefinitionID"}}`, encodeURIComponent(String(formDefinitionID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Parameter `{formInstanceID}` should match a form instance ID.
         * @summary Patch a form instance.
         * @param {string} formInstanceID Form instance ID
         * @param {Array<{ [key: string]: object; }>} [body] Body is the request payload to patch a form instance, check: https://jsonpatch.com
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchFormInstance: async (formInstanceID: string, body?: Array<{ [key: string]: object; }>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'formInstanceID' is not null or undefined
            assertParamExists('patchFormInstance', 'formInstanceID', formInstanceID)
            const localVarPath = `/form-instances/{formInstanceID}`
                .replace(`{${"formInstanceID"}}`, encodeURIComponent(String(formInstanceID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * No parameters required.
         * @summary Export form definitions by tenant.
         * @param {number} [offset] Offset  Integer specifying the offset of the first result from the beginning of the collection. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results). The offset value is record-based, not page-based, and the index starts at 0.
         * @param {number} [limit] Limit  Integer specifying the maximum number of records to return in a single API call. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results). If it is not specified, a default limit is used.
         * @param {string} [filters] Filters  Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: &lt;b&gt;name&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;description&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;created&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;modified&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt;
         * @param {string} [sorters] Sorters  Item will be sorted in the returned array if the sorters expression evaluates to true for that item. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters/#sorting-results). Sorting is supported for the following fields: &lt;b&gt;name&lt;/b&gt; &lt;b&gt;description&lt;/b&gt; &lt;b&gt;created&lt;/b&gt; &lt;b&gt;modified&lt;/b&gt;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchFormDefinitionsByTenant: async (offset?: number, limit?: number, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/form-definitions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Parameter `{formInstanceID}` should match a form instance ID. Parameter `{formElementID}` should match a form element ID at the data source configuration.
         * @summary Retrieves dynamic data by element.
         * @param {string} formInstanceID Form instance ID
         * @param {string} formElementID Form element ID
         * @param {number} [limit] Limit  Integer specifying the maximum number of records to return in a single API call. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results). If it is not specified, a default limit is used.
         * @param {string} [filters] Filters  Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: &lt;b&gt;value&lt;/b&gt;: &lt;i&gt;eq, ne, in&lt;/i&gt; &lt;b&gt;label&lt;/b&gt;: &lt;i&gt;eq, ne, in&lt;/i&gt; &lt;b&gt;subLabel&lt;/b&gt;: &lt;i&gt;eq, ne, in&lt;/i&gt;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchFormElementDataByElementID: async (formInstanceID: string, formElementID: string, limit?: number, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'formInstanceID' is not null or undefined
            assertParamExists('searchFormElementDataByElementID', 'formInstanceID', formInstanceID)
            // verify required parameter 'formElementID' is not null or undefined
            assertParamExists('searchFormElementDataByElementID', 'formElementID', formElementID)
            const localVarPath = `/form-instances/{formInstanceID}/data-source/{formElementID}`
                .replace(`{${"formInstanceID"}}`, encodeURIComponent(String(formInstanceID)))
                .replace(`{${"formElementID"}}`, encodeURIComponent(String(formElementID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * No parameters required.
         * @summary List form instances by tenant.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchFormInstancesByTenant: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/form-instances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * No parameters required.
         * @summary List predefined select options.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchPreDefinedSelectOptions: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/form-definitions/predefined-select-options`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Preview form definition data source.
         * @param {string} formDefinitionID Form definition ID
         * @param {number} [limit] Limit  Integer specifying the maximum number of records to return in a single API call. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results). If it is not specified, a default limit is used.
         * @param {string} [filters] Filters  Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: &lt;b&gt;value&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;label&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;subLabel&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt;
         * @param {string} [query] Query  String specifying to query against
         * @param {FormElementPreviewRequestBeta} [formElementPreviewRequestBeta] Body is the request payload to create a form definition dynamic schema
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        showPreviewDataSource: async (formDefinitionID: string, limit?: number, filters?: string, query?: string, formElementPreviewRequestBeta?: FormElementPreviewRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'formDefinitionID' is not null or undefined
            assertParamExists('showPreviewDataSource', 'formDefinitionID', formDefinitionID)
            const localVarPath = `/form-definitions/{formDefinitionID}/data-source`
                .replace(`{${"formDefinitionID"}}`, encodeURIComponent(String(formDefinitionID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(formElementPreviewRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomFormsBetaApi - functional programming interface
 * @export
 */
export const CustomFormsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomFormsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates a form definition.
         * @param {CreateFormDefinitionRequestBeta} [body] Body is the request payload to create form definition request
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createFormDefinition(body?: CreateFormDefinitionRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormDefinitionResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFormDefinition(body, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generate JSON Schema dynamically.
         * @param {FormDefinitionDynamicSchemaRequestBeta} [body] Body is the request payload to create a form definition dynamic schema
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createFormDefinitionDynamicSchema(body?: FormDefinitionDynamicSchemaRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormDefinitionDynamicSchemaResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFormDefinitionDynamicSchema(body, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a form instance.
         * @param {CreateFormInstanceRequestBeta} [body] Body is the request payload to create a form instance
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createFormInstance(body?: CreateFormInstanceRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormInstanceResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFormInstance(body, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Parameter `{formDefinitionID}` should match a form definition ID.
         * @summary Deletes a form definition.
         * @param {string} formDefinitionID Form definition ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFormDefinition(formDefinitionID: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFormDefinition(formDefinitionID, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * No parameters required.
         * @summary List form definitions by tenant.
         * @param {number} [offset] Offset  Integer specifying the offset of the first result from the beginning of the collection. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results). The offset value is record-based, not page-based, and the index starts at 0.
         * @param {number} [limit] Limit  Integer specifying the maximum number of records to return in a single API call. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results). If it is not specified, a default limit is used.
         * @param {string} [filters] Filters  Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: &lt;b&gt;name&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;description&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;created&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;modified&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt;
         * @param {string} [sorters] Sorters  Item will be sorted in the returned array if the sorters expression evaluates to true for that item. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters/#sorting-results). Sorting is supported for the following fields: &lt;b&gt;name&lt;/b&gt; &lt;b&gt;description&lt;/b&gt; &lt;b&gt;created&lt;/b&gt; &lt;b&gt;modified&lt;/b&gt;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async exportFormDefinitionsByTenant(offset?: number, limit?: number, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExportFormDefinitionsByTenant200ResponseInnerBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportFormDefinitionsByTenant(offset, limit, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Parameter `{formDefinitionID}` should match a form definition ID.
         * @summary Return a form definition.
         * @param {string} formDefinitionID Form definition ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getFormDefinitionByKey(formDefinitionID: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormDefinitionResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFormDefinitionByKey(formDefinitionID, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Parameter `{formInstanceID}` should match a form instance ID.
         * @summary Returns a form instance.
         * @param {string} formInstanceID Form instance ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getFormInstanceByKey(formInstanceID: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormInstanceResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFormInstanceByKey(formInstanceID, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Import form definitions from export.
         * @param {Array<ExportFormDefinitionsByTenant200ResponseInnerBeta>} [body] Body is the request payload to import form definitions
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async importFormDefinitions(body?: Array<ExportFormDefinitionsByTenant200ResponseInnerBeta>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportFormDefinitions202ResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importFormDefinitions(body, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Parameter `{formDefinitionID}` should match a form definition ID.
         * @summary Patch a form definition.
         * @param {string} formDefinitionID Form definition ID
         * @param {Array<{ [key: string]: object; }>} [body] Body is the request payload to patch a form definition, check: https://jsonpatch.com
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchFormDefinition(formDefinitionID: string, body?: Array<{ [key: string]: object; }>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormDefinitionResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchFormDefinition(formDefinitionID, body, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Parameter `{formInstanceID}` should match a form instance ID.
         * @summary Patch a form instance.
         * @param {string} formInstanceID Form instance ID
         * @param {Array<{ [key: string]: object; }>} [body] Body is the request payload to patch a form instance, check: https://jsonpatch.com
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchFormInstance(formInstanceID: string, body?: Array<{ [key: string]: object; }>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormInstanceResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchFormInstance(formInstanceID, body, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * No parameters required.
         * @summary Export form definitions by tenant.
         * @param {number} [offset] Offset  Integer specifying the offset of the first result from the beginning of the collection. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results). The offset value is record-based, not page-based, and the index starts at 0.
         * @param {number} [limit] Limit  Integer specifying the maximum number of records to return in a single API call. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results). If it is not specified, a default limit is used.
         * @param {string} [filters] Filters  Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: &lt;b&gt;name&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;description&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;created&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;modified&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt;
         * @param {string} [sorters] Sorters  Item will be sorted in the returned array if the sorters expression evaluates to true for that item. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters/#sorting-results). Sorting is supported for the following fields: &lt;b&gt;name&lt;/b&gt; &lt;b&gt;description&lt;/b&gt; &lt;b&gt;created&lt;/b&gt; &lt;b&gt;modified&lt;/b&gt;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async searchFormDefinitionsByTenant(offset?: number, limit?: number, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListFormDefinitionsByTenantResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchFormDefinitionsByTenant(offset, limit, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Parameter `{formInstanceID}` should match a form instance ID. Parameter `{formElementID}` should match a form element ID at the data source configuration.
         * @summary Retrieves dynamic data by element.
         * @param {string} formInstanceID Form instance ID
         * @param {string} formElementID Form element ID
         * @param {number} [limit] Limit  Integer specifying the maximum number of records to return in a single API call. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results). If it is not specified, a default limit is used.
         * @param {string} [filters] Filters  Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: &lt;b&gt;value&lt;/b&gt;: &lt;i&gt;eq, ne, in&lt;/i&gt; &lt;b&gt;label&lt;/b&gt;: &lt;i&gt;eq, ne, in&lt;/i&gt; &lt;b&gt;subLabel&lt;/b&gt;: &lt;i&gt;eq, ne, in&lt;/i&gt;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async searchFormElementDataByElementID(formInstanceID: string, formElementID: string, limit?: number, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListFormElementDataByElementIDResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchFormElementDataByElementID(formInstanceID, formElementID, limit, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * No parameters required.
         * @summary List form instances by tenant.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async searchFormInstancesByTenant(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListFormInstancesByTenantResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchFormInstancesByTenant(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * No parameters required.
         * @summary List predefined select options.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async searchPreDefinedSelectOptions(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPredefinedSelectOptionsResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPreDefinedSelectOptions(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Preview form definition data source.
         * @param {string} formDefinitionID Form definition ID
         * @param {number} [limit] Limit  Integer specifying the maximum number of records to return in a single API call. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results). If it is not specified, a default limit is used.
         * @param {string} [filters] Filters  Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: &lt;b&gt;value&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;label&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;subLabel&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt;
         * @param {string} [query] Query  String specifying to query against
         * @param {FormElementPreviewRequestBeta} [formElementPreviewRequestBeta] Body is the request payload to create a form definition dynamic schema
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async showPreviewDataSource(formDefinitionID: string, limit?: number, filters?: string, query?: string, formElementPreviewRequestBeta?: FormElementPreviewRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PreviewDataSourceResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showPreviewDataSource(formDefinitionID, limit, filters, query, formElementPreviewRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomFormsBetaApi - factory interface
 * @export
 */
export const CustomFormsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomFormsBetaApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates a form definition.
         * @param {CreateFormDefinitionRequestBeta} [body] Body is the request payload to create form definition request
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createFormDefinition(body?: CreateFormDefinitionRequestBeta, axiosOptions?: any): AxiosPromise<FormDefinitionResponseBeta> {
            return localVarFp.createFormDefinition(body, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate JSON Schema dynamically.
         * @param {FormDefinitionDynamicSchemaRequestBeta} [body] Body is the request payload to create a form definition dynamic schema
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createFormDefinitionDynamicSchema(body?: FormDefinitionDynamicSchemaRequestBeta, axiosOptions?: any): AxiosPromise<FormDefinitionDynamicSchemaResponseBeta> {
            return localVarFp.createFormDefinitionDynamicSchema(body, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a form instance.
         * @param {CreateFormInstanceRequestBeta} [body] Body is the request payload to create a form instance
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createFormInstance(body?: CreateFormInstanceRequestBeta, axiosOptions?: any): AxiosPromise<FormInstanceResponseBeta> {
            return localVarFp.createFormInstance(body, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Parameter `{formDefinitionID}` should match a form definition ID.
         * @summary Deletes a form definition.
         * @param {string} formDefinitionID Form definition ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteFormDefinition(formDefinitionID: string, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.deleteFormDefinition(formDefinitionID, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * No parameters required.
         * @summary List form definitions by tenant.
         * @param {number} [offset] Offset  Integer specifying the offset of the first result from the beginning of the collection. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results). The offset value is record-based, not page-based, and the index starts at 0.
         * @param {number} [limit] Limit  Integer specifying the maximum number of records to return in a single API call. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results). If it is not specified, a default limit is used.
         * @param {string} [filters] Filters  Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: &lt;b&gt;name&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;description&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;created&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;modified&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt;
         * @param {string} [sorters] Sorters  Item will be sorted in the returned array if the sorters expression evaluates to true for that item. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters/#sorting-results). Sorting is supported for the following fields: &lt;b&gt;name&lt;/b&gt; &lt;b&gt;description&lt;/b&gt; &lt;b&gt;created&lt;/b&gt; &lt;b&gt;modified&lt;/b&gt;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportFormDefinitionsByTenant(offset?: number, limit?: number, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<ExportFormDefinitionsByTenant200ResponseInnerBeta>> {
            return localVarFp.exportFormDefinitionsByTenant(offset, limit, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Parameter `{formDefinitionID}` should match a form definition ID.
         * @summary Return a form definition.
         * @param {string} formDefinitionID Form definition ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getFormDefinitionByKey(formDefinitionID: string, axiosOptions?: any): AxiosPromise<FormDefinitionResponseBeta> {
            return localVarFp.getFormDefinitionByKey(formDefinitionID, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Parameter `{formInstanceID}` should match a form instance ID.
         * @summary Returns a form instance.
         * @param {string} formInstanceID Form instance ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getFormInstanceByKey(formInstanceID: string, axiosOptions?: any): AxiosPromise<FormInstanceResponseBeta> {
            return localVarFp.getFormInstanceByKey(formInstanceID, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Import form definitions from export.
         * @param {Array<ExportFormDefinitionsByTenant200ResponseInnerBeta>} [body] Body is the request payload to import form definitions
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importFormDefinitions(body?: Array<ExportFormDefinitionsByTenant200ResponseInnerBeta>, axiosOptions?: any): AxiosPromise<ImportFormDefinitions202ResponseBeta> {
            return localVarFp.importFormDefinitions(body, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Parameter `{formDefinitionID}` should match a form definition ID.
         * @summary Patch a form definition.
         * @param {string} formDefinitionID Form definition ID
         * @param {Array<{ [key: string]: object; }>} [body] Body is the request payload to patch a form definition, check: https://jsonpatch.com
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchFormDefinition(formDefinitionID: string, body?: Array<{ [key: string]: object; }>, axiosOptions?: any): AxiosPromise<FormDefinitionResponseBeta> {
            return localVarFp.patchFormDefinition(formDefinitionID, body, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Parameter `{formInstanceID}` should match a form instance ID.
         * @summary Patch a form instance.
         * @param {string} formInstanceID Form instance ID
         * @param {Array<{ [key: string]: object; }>} [body] Body is the request payload to patch a form instance, check: https://jsonpatch.com
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchFormInstance(formInstanceID: string, body?: Array<{ [key: string]: object; }>, axiosOptions?: any): AxiosPromise<FormInstanceResponseBeta> {
            return localVarFp.patchFormInstance(formInstanceID, body, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * No parameters required.
         * @summary Export form definitions by tenant.
         * @param {number} [offset] Offset  Integer specifying the offset of the first result from the beginning of the collection. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results). The offset value is record-based, not page-based, and the index starts at 0.
         * @param {number} [limit] Limit  Integer specifying the maximum number of records to return in a single API call. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results). If it is not specified, a default limit is used.
         * @param {string} [filters] Filters  Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: &lt;b&gt;name&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;description&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;created&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;modified&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt;
         * @param {string} [sorters] Sorters  Item will be sorted in the returned array if the sorters expression evaluates to true for that item. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters/#sorting-results). Sorting is supported for the following fields: &lt;b&gt;name&lt;/b&gt; &lt;b&gt;description&lt;/b&gt; &lt;b&gt;created&lt;/b&gt; &lt;b&gt;modified&lt;/b&gt;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchFormDefinitionsByTenant(offset?: number, limit?: number, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<ListFormDefinitionsByTenantResponseBeta> {
            return localVarFp.searchFormDefinitionsByTenant(offset, limit, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Parameter `{formInstanceID}` should match a form instance ID. Parameter `{formElementID}` should match a form element ID at the data source configuration.
         * @summary Retrieves dynamic data by element.
         * @param {string} formInstanceID Form instance ID
         * @param {string} formElementID Form element ID
         * @param {number} [limit] Limit  Integer specifying the maximum number of records to return in a single API call. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results). If it is not specified, a default limit is used.
         * @param {string} [filters] Filters  Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: &lt;b&gt;value&lt;/b&gt;: &lt;i&gt;eq, ne, in&lt;/i&gt; &lt;b&gt;label&lt;/b&gt;: &lt;i&gt;eq, ne, in&lt;/i&gt; &lt;b&gt;subLabel&lt;/b&gt;: &lt;i&gt;eq, ne, in&lt;/i&gt;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchFormElementDataByElementID(formInstanceID: string, formElementID: string, limit?: number, filters?: string, axiosOptions?: any): AxiosPromise<ListFormElementDataByElementIDResponseBeta> {
            return localVarFp.searchFormElementDataByElementID(formInstanceID, formElementID, limit, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * No parameters required.
         * @summary List form instances by tenant.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchFormInstancesByTenant(axiosOptions?: any): AxiosPromise<ListFormInstancesByTenantResponseBeta> {
            return localVarFp.searchFormInstancesByTenant(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * No parameters required.
         * @summary List predefined select options.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchPreDefinedSelectOptions(axiosOptions?: any): AxiosPromise<ListPredefinedSelectOptionsResponseBeta> {
            return localVarFp.searchPreDefinedSelectOptions(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Preview form definition data source.
         * @param {string} formDefinitionID Form definition ID
         * @param {number} [limit] Limit  Integer specifying the maximum number of records to return in a single API call. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results). If it is not specified, a default limit is used.
         * @param {string} [filters] Filters  Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: &lt;b&gt;value&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;label&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;subLabel&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt;
         * @param {string} [query] Query  String specifying to query against
         * @param {FormElementPreviewRequestBeta} [formElementPreviewRequestBeta] Body is the request payload to create a form definition dynamic schema
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        showPreviewDataSource(formDefinitionID: string, limit?: number, filters?: string, query?: string, formElementPreviewRequestBeta?: FormElementPreviewRequestBeta, axiosOptions?: any): AxiosPromise<PreviewDataSourceResponseBeta> {
            return localVarFp.showPreviewDataSource(formDefinitionID, limit, filters, query, formElementPreviewRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createFormDefinition operation in CustomFormsBetaApi.
 * @export
 * @interface CustomFormsBetaApiCreateFormDefinitionRequest
 */
export interface CustomFormsBetaApiCreateFormDefinitionRequest {
    /**
     * Body is the request payload to create form definition request
     * @type {CreateFormDefinitionRequestBeta}
     * @memberof CustomFormsBetaApiCreateFormDefinition
     */
    readonly body?: CreateFormDefinitionRequestBeta
}

/**
 * Request parameters for createFormDefinitionDynamicSchema operation in CustomFormsBetaApi.
 * @export
 * @interface CustomFormsBetaApiCreateFormDefinitionDynamicSchemaRequest
 */
export interface CustomFormsBetaApiCreateFormDefinitionDynamicSchemaRequest {
    /**
     * Body is the request payload to create a form definition dynamic schema
     * @type {FormDefinitionDynamicSchemaRequestBeta}
     * @memberof CustomFormsBetaApiCreateFormDefinitionDynamicSchema
     */
    readonly body?: FormDefinitionDynamicSchemaRequestBeta
}

/**
 * Request parameters for createFormInstance operation in CustomFormsBetaApi.
 * @export
 * @interface CustomFormsBetaApiCreateFormInstanceRequest
 */
export interface CustomFormsBetaApiCreateFormInstanceRequest {
    /**
     * Body is the request payload to create a form instance
     * @type {CreateFormInstanceRequestBeta}
     * @memberof CustomFormsBetaApiCreateFormInstance
     */
    readonly body?: CreateFormInstanceRequestBeta
}

/**
 * Request parameters for deleteFormDefinition operation in CustomFormsBetaApi.
 * @export
 * @interface CustomFormsBetaApiDeleteFormDefinitionRequest
 */
export interface CustomFormsBetaApiDeleteFormDefinitionRequest {
    /**
     * Form definition ID
     * @type {string}
     * @memberof CustomFormsBetaApiDeleteFormDefinition
     */
    readonly formDefinitionID: string
}

/**
 * Request parameters for exportFormDefinitionsByTenant operation in CustomFormsBetaApi.
 * @export
 * @interface CustomFormsBetaApiExportFormDefinitionsByTenantRequest
 */
export interface CustomFormsBetaApiExportFormDefinitionsByTenantRequest {
    /**
     * Offset  Integer specifying the offset of the first result from the beginning of the collection. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results). The offset value is record-based, not page-based, and the index starts at 0.
     * @type {number}
     * @memberof CustomFormsBetaApiExportFormDefinitionsByTenant
     */
    readonly offset?: number

    /**
     * Limit  Integer specifying the maximum number of records to return in a single API call. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results). If it is not specified, a default limit is used.
     * @type {number}
     * @memberof CustomFormsBetaApiExportFormDefinitionsByTenant
     */
    readonly limit?: number

    /**
     * Filters  Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: &lt;b&gt;name&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;description&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;created&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;modified&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt;
     * @type {string}
     * @memberof CustomFormsBetaApiExportFormDefinitionsByTenant
     */
    readonly filters?: string

    /**
     * Sorters  Item will be sorted in the returned array if the sorters expression evaluates to true for that item. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters/#sorting-results). Sorting is supported for the following fields: &lt;b&gt;name&lt;/b&gt; &lt;b&gt;description&lt;/b&gt; &lt;b&gt;created&lt;/b&gt; &lt;b&gt;modified&lt;/b&gt;
     * @type {string}
     * @memberof CustomFormsBetaApiExportFormDefinitionsByTenant
     */
    readonly sorters?: string
}

/**
 * Request parameters for getFormDefinitionByKey operation in CustomFormsBetaApi.
 * @export
 * @interface CustomFormsBetaApiGetFormDefinitionByKeyRequest
 */
export interface CustomFormsBetaApiGetFormDefinitionByKeyRequest {
    /**
     * Form definition ID
     * @type {string}
     * @memberof CustomFormsBetaApiGetFormDefinitionByKey
     */
    readonly formDefinitionID: string
}

/**
 * Request parameters for getFormInstanceByKey operation in CustomFormsBetaApi.
 * @export
 * @interface CustomFormsBetaApiGetFormInstanceByKeyRequest
 */
export interface CustomFormsBetaApiGetFormInstanceByKeyRequest {
    /**
     * Form instance ID
     * @type {string}
     * @memberof CustomFormsBetaApiGetFormInstanceByKey
     */
    readonly formInstanceID: string
}

/**
 * Request parameters for importFormDefinitions operation in CustomFormsBetaApi.
 * @export
 * @interface CustomFormsBetaApiImportFormDefinitionsRequest
 */
export interface CustomFormsBetaApiImportFormDefinitionsRequest {
    /**
     * Body is the request payload to import form definitions
     * @type {Array<ExportFormDefinitionsByTenant200ResponseInnerBeta>}
     * @memberof CustomFormsBetaApiImportFormDefinitions
     */
    readonly body?: Array<ExportFormDefinitionsByTenant200ResponseInnerBeta>
}

/**
 * Request parameters for patchFormDefinition operation in CustomFormsBetaApi.
 * @export
 * @interface CustomFormsBetaApiPatchFormDefinitionRequest
 */
export interface CustomFormsBetaApiPatchFormDefinitionRequest {
    /**
     * Form definition ID
     * @type {string}
     * @memberof CustomFormsBetaApiPatchFormDefinition
     */
    readonly formDefinitionID: string

    /**
     * Body is the request payload to patch a form definition, check: https://jsonpatch.com
     * @type {Array<{ [key: string]: object; }>}
     * @memberof CustomFormsBetaApiPatchFormDefinition
     */
    readonly body?: Array<{ [key: string]: object; }>
}

/**
 * Request parameters for patchFormInstance operation in CustomFormsBetaApi.
 * @export
 * @interface CustomFormsBetaApiPatchFormInstanceRequest
 */
export interface CustomFormsBetaApiPatchFormInstanceRequest {
    /**
     * Form instance ID
     * @type {string}
     * @memberof CustomFormsBetaApiPatchFormInstance
     */
    readonly formInstanceID: string

    /**
     * Body is the request payload to patch a form instance, check: https://jsonpatch.com
     * @type {Array<{ [key: string]: object; }>}
     * @memberof CustomFormsBetaApiPatchFormInstance
     */
    readonly body?: Array<{ [key: string]: object; }>
}

/**
 * Request parameters for searchFormDefinitionsByTenant operation in CustomFormsBetaApi.
 * @export
 * @interface CustomFormsBetaApiSearchFormDefinitionsByTenantRequest
 */
export interface CustomFormsBetaApiSearchFormDefinitionsByTenantRequest {
    /**
     * Offset  Integer specifying the offset of the first result from the beginning of the collection. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results). The offset value is record-based, not page-based, and the index starts at 0.
     * @type {number}
     * @memberof CustomFormsBetaApiSearchFormDefinitionsByTenant
     */
    readonly offset?: number

    /**
     * Limit  Integer specifying the maximum number of records to return in a single API call. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results). If it is not specified, a default limit is used.
     * @type {number}
     * @memberof CustomFormsBetaApiSearchFormDefinitionsByTenant
     */
    readonly limit?: number

    /**
     * Filters  Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: &lt;b&gt;name&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;description&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;created&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;modified&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt;
     * @type {string}
     * @memberof CustomFormsBetaApiSearchFormDefinitionsByTenant
     */
    readonly filters?: string

    /**
     * Sorters  Item will be sorted in the returned array if the sorters expression evaluates to true for that item. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters/#sorting-results). Sorting is supported for the following fields: &lt;b&gt;name&lt;/b&gt; &lt;b&gt;description&lt;/b&gt; &lt;b&gt;created&lt;/b&gt; &lt;b&gt;modified&lt;/b&gt;
     * @type {string}
     * @memberof CustomFormsBetaApiSearchFormDefinitionsByTenant
     */
    readonly sorters?: string
}

/**
 * Request parameters for searchFormElementDataByElementID operation in CustomFormsBetaApi.
 * @export
 * @interface CustomFormsBetaApiSearchFormElementDataByElementIDRequest
 */
export interface CustomFormsBetaApiSearchFormElementDataByElementIDRequest {
    /**
     * Form instance ID
     * @type {string}
     * @memberof CustomFormsBetaApiSearchFormElementDataByElementID
     */
    readonly formInstanceID: string

    /**
     * Form element ID
     * @type {string}
     * @memberof CustomFormsBetaApiSearchFormElementDataByElementID
     */
    readonly formElementID: string

    /**
     * Limit  Integer specifying the maximum number of records to return in a single API call. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results). If it is not specified, a default limit is used.
     * @type {number}
     * @memberof CustomFormsBetaApiSearchFormElementDataByElementID
     */
    readonly limit?: number

    /**
     * Filters  Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: &lt;b&gt;value&lt;/b&gt;: &lt;i&gt;eq, ne, in&lt;/i&gt; &lt;b&gt;label&lt;/b&gt;: &lt;i&gt;eq, ne, in&lt;/i&gt; &lt;b&gt;subLabel&lt;/b&gt;: &lt;i&gt;eq, ne, in&lt;/i&gt;
     * @type {string}
     * @memberof CustomFormsBetaApiSearchFormElementDataByElementID
     */
    readonly filters?: string
}

/**
 * Request parameters for showPreviewDataSource operation in CustomFormsBetaApi.
 * @export
 * @interface CustomFormsBetaApiShowPreviewDataSourceRequest
 */
export interface CustomFormsBetaApiShowPreviewDataSourceRequest {
    /**
     * Form definition ID
     * @type {string}
     * @memberof CustomFormsBetaApiShowPreviewDataSource
     */
    readonly formDefinitionID: string

    /**
     * Limit  Integer specifying the maximum number of records to return in a single API call. The standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results). If it is not specified, a default limit is used.
     * @type {number}
     * @memberof CustomFormsBetaApiShowPreviewDataSource
     */
    readonly limit?: number

    /**
     * Filters  Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: &lt;b&gt;value&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;label&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt; &lt;b&gt;subLabel&lt;/b&gt;: &lt;i&gt;eq, gt, sw, in&lt;/i&gt;
     * @type {string}
     * @memberof CustomFormsBetaApiShowPreviewDataSource
     */
    readonly filters?: string

    /**
     * Query  String specifying to query against
     * @type {string}
     * @memberof CustomFormsBetaApiShowPreviewDataSource
     */
    readonly query?: string

    /**
     * Body is the request payload to create a form definition dynamic schema
     * @type {FormElementPreviewRequestBeta}
     * @memberof CustomFormsBetaApiShowPreviewDataSource
     */
    readonly formElementPreviewRequestBeta?: FormElementPreviewRequestBeta
}

/**
 * CustomFormsBetaApi - object-oriented interface
 * @export
 * @class CustomFormsBetaApi
 * @extends {BaseAPI}
 */
export class CustomFormsBetaApi extends BaseAPI {
    /**
     * 
     * @summary Creates a form definition.
     * @param {CustomFormsBetaApiCreateFormDefinitionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFormsBetaApi
     */
    public createFormDefinition(requestParameters: CustomFormsBetaApiCreateFormDefinitionRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return CustomFormsBetaApiFp(this.configuration).createFormDefinition(requestParameters.body, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate JSON Schema dynamically.
     * @param {CustomFormsBetaApiCreateFormDefinitionDynamicSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFormsBetaApi
     */
    public createFormDefinitionDynamicSchema(requestParameters: CustomFormsBetaApiCreateFormDefinitionDynamicSchemaRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return CustomFormsBetaApiFp(this.configuration).createFormDefinitionDynamicSchema(requestParameters.body, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a form instance.
     * @param {CustomFormsBetaApiCreateFormInstanceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFormsBetaApi
     */
    public createFormInstance(requestParameters: CustomFormsBetaApiCreateFormInstanceRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return CustomFormsBetaApiFp(this.configuration).createFormInstance(requestParameters.body, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Parameter `{formDefinitionID}` should match a form definition ID.
     * @summary Deletes a form definition.
     * @param {CustomFormsBetaApiDeleteFormDefinitionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFormsBetaApi
     */
    public deleteFormDefinition(requestParameters: CustomFormsBetaApiDeleteFormDefinitionRequest, axiosOptions?: AxiosRequestConfig) {
        return CustomFormsBetaApiFp(this.configuration).deleteFormDefinition(requestParameters.formDefinitionID, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * No parameters required.
     * @summary List form definitions by tenant.
     * @param {CustomFormsBetaApiExportFormDefinitionsByTenantRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFormsBetaApi
     */
    public exportFormDefinitionsByTenant(requestParameters: CustomFormsBetaApiExportFormDefinitionsByTenantRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return CustomFormsBetaApiFp(this.configuration).exportFormDefinitionsByTenant(requestParameters.offset, requestParameters.limit, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Parameter `{formDefinitionID}` should match a form definition ID.
     * @summary Return a form definition.
     * @param {CustomFormsBetaApiGetFormDefinitionByKeyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFormsBetaApi
     */
    public getFormDefinitionByKey(requestParameters: CustomFormsBetaApiGetFormDefinitionByKeyRequest, axiosOptions?: AxiosRequestConfig) {
        return CustomFormsBetaApiFp(this.configuration).getFormDefinitionByKey(requestParameters.formDefinitionID, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Parameter `{formInstanceID}` should match a form instance ID.
     * @summary Returns a form instance.
     * @param {CustomFormsBetaApiGetFormInstanceByKeyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFormsBetaApi
     */
    public getFormInstanceByKey(requestParameters: CustomFormsBetaApiGetFormInstanceByKeyRequest, axiosOptions?: AxiosRequestConfig) {
        return CustomFormsBetaApiFp(this.configuration).getFormInstanceByKey(requestParameters.formInstanceID, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Import form definitions from export.
     * @param {CustomFormsBetaApiImportFormDefinitionsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFormsBetaApi
     */
    public importFormDefinitions(requestParameters: CustomFormsBetaApiImportFormDefinitionsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return CustomFormsBetaApiFp(this.configuration).importFormDefinitions(requestParameters.body, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Parameter `{formDefinitionID}` should match a form definition ID.
     * @summary Patch a form definition.
     * @param {CustomFormsBetaApiPatchFormDefinitionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFormsBetaApi
     */
    public patchFormDefinition(requestParameters: CustomFormsBetaApiPatchFormDefinitionRequest, axiosOptions?: AxiosRequestConfig) {
        return CustomFormsBetaApiFp(this.configuration).patchFormDefinition(requestParameters.formDefinitionID, requestParameters.body, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Parameter `{formInstanceID}` should match a form instance ID.
     * @summary Patch a form instance.
     * @param {CustomFormsBetaApiPatchFormInstanceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFormsBetaApi
     */
    public patchFormInstance(requestParameters: CustomFormsBetaApiPatchFormInstanceRequest, axiosOptions?: AxiosRequestConfig) {
        return CustomFormsBetaApiFp(this.configuration).patchFormInstance(requestParameters.formInstanceID, requestParameters.body, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * No parameters required.
     * @summary Export form definitions by tenant.
     * @param {CustomFormsBetaApiSearchFormDefinitionsByTenantRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFormsBetaApi
     */
    public searchFormDefinitionsByTenant(requestParameters: CustomFormsBetaApiSearchFormDefinitionsByTenantRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return CustomFormsBetaApiFp(this.configuration).searchFormDefinitionsByTenant(requestParameters.offset, requestParameters.limit, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Parameter `{formInstanceID}` should match a form instance ID. Parameter `{formElementID}` should match a form element ID at the data source configuration.
     * @summary Retrieves dynamic data by element.
     * @param {CustomFormsBetaApiSearchFormElementDataByElementIDRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFormsBetaApi
     */
    public searchFormElementDataByElementID(requestParameters: CustomFormsBetaApiSearchFormElementDataByElementIDRequest, axiosOptions?: AxiosRequestConfig) {
        return CustomFormsBetaApiFp(this.configuration).searchFormElementDataByElementID(requestParameters.formInstanceID, requestParameters.formElementID, requestParameters.limit, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * No parameters required.
     * @summary List form instances by tenant.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFormsBetaApi
     */
    public searchFormInstancesByTenant(axiosOptions?: AxiosRequestConfig) {
        return CustomFormsBetaApiFp(this.configuration).searchFormInstancesByTenant(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * No parameters required.
     * @summary List predefined select options.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFormsBetaApi
     */
    public searchPreDefinedSelectOptions(axiosOptions?: AxiosRequestConfig) {
        return CustomFormsBetaApiFp(this.configuration).searchPreDefinedSelectOptions(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Preview form definition data source.
     * @param {CustomFormsBetaApiShowPreviewDataSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFormsBetaApi
     */
    public showPreviewDataSource(requestParameters: CustomFormsBetaApiShowPreviewDataSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return CustomFormsBetaApiFp(this.configuration).showPreviewDataSource(requestParameters.formDefinitionID, requestParameters.limit, requestParameters.filters, requestParameters.query, requestParameters.formElementPreviewRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomPasswordInstructionsBetaApi - axios parameter creator
 * @export
 */
export const CustomPasswordInstructionsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates the custom password instructions for the specified page ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Custom Password Instructions
         * @param {CustomPasswordInstructionBeta} customPasswordInstructionBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCustomPasswordInstructions: async (customPasswordInstructionBeta: CustomPasswordInstructionBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customPasswordInstructionBeta' is not null or undefined
            assertParamExists('createCustomPasswordInstructions', 'customPasswordInstructionBeta', customPasswordInstructionBeta)
            const localVarPath = `/custom-password-instructions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customPasswordInstructionBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API delete the custom password instructions for the specified page ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Custom Password Instructions by page ID
         * @param {'change-password:enter-password' | 'change-password:finish' | 'flow-selection:select' | 'forget-username:user-email' | 'mfa:enter-code' | 'mfa:enter-kba' | 'mfa:select' | 'reset-password:enter-password' | 'reset-password:enter-username' | 'reset-password:finish' | 'unlock-account:enter-username' | 'unlock-account:finish'} pageId The page ID of custom password instructions to delete.
         * @param {string} [locale] The locale for the custom instructions, a BCP47 language tag. The default value is \\\&quot;default\\\&quot;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomPasswordInstructions: async (pageId: 'change-password:enter-password' | 'change-password:finish' | 'flow-selection:select' | 'forget-username:user-email' | 'mfa:enter-code' | 'mfa:enter-kba' | 'mfa:select' | 'reset-password:enter-password' | 'reset-password:enter-username' | 'reset-password:finish' | 'unlock-account:enter-username' | 'unlock-account:finish', locale?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('deleteCustomPasswordInstructions', 'pageId', pageId)
            const localVarPath = `/custom-password-instructions/{pageId}`
                .replace(`{${"pageId"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the custom password instructions for the specified page ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Custom Password Instructions by Page ID
         * @param {'change-password:enter-password' | 'change-password:finish' | 'flow-selection:select' | 'forget-username:user-email' | 'mfa:enter-code' | 'mfa:enter-kba' | 'mfa:select' | 'reset-password:enter-password' | 'reset-password:enter-username' | 'reset-password:finish' | 'unlock-account:enter-username' | 'unlock-account:finish'} pageId The page ID of custom password instructions to query.
         * @param {string} [locale] The locale for the custom instructions, a BCP47 language tag. The default value is \\\&quot;default\\\&quot;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCustomPasswordInstructions: async (pageId: 'change-password:enter-password' | 'change-password:finish' | 'flow-selection:select' | 'forget-username:user-email' | 'mfa:enter-code' | 'mfa:enter-kba' | 'mfa:select' | 'reset-password:enter-password' | 'reset-password:enter-username' | 'reset-password:finish' | 'unlock-account:enter-username' | 'unlock-account:finish', locale?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('getCustomPasswordInstructions', 'pageId', pageId)
            const localVarPath = `/custom-password-instructions/{pageId}`
                .replace(`{${"pageId"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomPasswordInstructionsBetaApi - functional programming interface
 * @export
 */
export const CustomPasswordInstructionsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomPasswordInstructionsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates the custom password instructions for the specified page ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Custom Password Instructions
         * @param {CustomPasswordInstructionBeta} customPasswordInstructionBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomPasswordInstructions(customPasswordInstructionBeta: CustomPasswordInstructionBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomPasswordInstructionBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomPasswordInstructions(customPasswordInstructionBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API delete the custom password instructions for the specified page ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Custom Password Instructions by page ID
         * @param {'change-password:enter-password' | 'change-password:finish' | 'flow-selection:select' | 'forget-username:user-email' | 'mfa:enter-code' | 'mfa:enter-kba' | 'mfa:select' | 'reset-password:enter-password' | 'reset-password:enter-username' | 'reset-password:finish' | 'unlock-account:enter-username' | 'unlock-account:finish'} pageId The page ID of custom password instructions to delete.
         * @param {string} [locale] The locale for the custom instructions, a BCP47 language tag. The default value is \\\&quot;default\\\&quot;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomPasswordInstructions(pageId: 'change-password:enter-password' | 'change-password:finish' | 'flow-selection:select' | 'forget-username:user-email' | 'mfa:enter-code' | 'mfa:enter-kba' | 'mfa:select' | 'reset-password:enter-password' | 'reset-password:enter-username' | 'reset-password:finish' | 'unlock-account:enter-username' | 'unlock-account:finish', locale?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomPasswordInstructions(pageId, locale, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the custom password instructions for the specified page ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Custom Password Instructions by Page ID
         * @param {'change-password:enter-password' | 'change-password:finish' | 'flow-selection:select' | 'forget-username:user-email' | 'mfa:enter-code' | 'mfa:enter-kba' | 'mfa:select' | 'reset-password:enter-password' | 'reset-password:enter-username' | 'reset-password:finish' | 'unlock-account:enter-username' | 'unlock-account:finish'} pageId The page ID of custom password instructions to query.
         * @param {string} [locale] The locale for the custom instructions, a BCP47 language tag. The default value is \\\&quot;default\\\&quot;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomPasswordInstructions(pageId: 'change-password:enter-password' | 'change-password:finish' | 'flow-selection:select' | 'forget-username:user-email' | 'mfa:enter-code' | 'mfa:enter-kba' | 'mfa:select' | 'reset-password:enter-password' | 'reset-password:enter-username' | 'reset-password:finish' | 'unlock-account:enter-username' | 'unlock-account:finish', locale?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomPasswordInstructionBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomPasswordInstructions(pageId, locale, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomPasswordInstructionsBetaApi - factory interface
 * @export
 */
export const CustomPasswordInstructionsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomPasswordInstructionsBetaApiFp(configuration)
    return {
        /**
         * This API creates the custom password instructions for the specified page ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Custom Password Instructions
         * @param {CustomPasswordInstructionBeta} customPasswordInstructionBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCustomPasswordInstructions(customPasswordInstructionBeta: CustomPasswordInstructionBeta, axiosOptions?: any): AxiosPromise<CustomPasswordInstructionBeta> {
            return localVarFp.createCustomPasswordInstructions(customPasswordInstructionBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API delete the custom password instructions for the specified page ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Custom Password Instructions by page ID
         * @param {'change-password:enter-password' | 'change-password:finish' | 'flow-selection:select' | 'forget-username:user-email' | 'mfa:enter-code' | 'mfa:enter-kba' | 'mfa:select' | 'reset-password:enter-password' | 'reset-password:enter-username' | 'reset-password:finish' | 'unlock-account:enter-username' | 'unlock-account:finish'} pageId The page ID of custom password instructions to delete.
         * @param {string} [locale] The locale for the custom instructions, a BCP47 language tag. The default value is \\\&quot;default\\\&quot;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomPasswordInstructions(pageId: 'change-password:enter-password' | 'change-password:finish' | 'flow-selection:select' | 'forget-username:user-email' | 'mfa:enter-code' | 'mfa:enter-kba' | 'mfa:select' | 'reset-password:enter-password' | 'reset-password:enter-username' | 'reset-password:finish' | 'unlock-account:enter-username' | 'unlock-account:finish', locale?: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteCustomPasswordInstructions(pageId, locale, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the custom password instructions for the specified page ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Custom Password Instructions by Page ID
         * @param {'change-password:enter-password' | 'change-password:finish' | 'flow-selection:select' | 'forget-username:user-email' | 'mfa:enter-code' | 'mfa:enter-kba' | 'mfa:select' | 'reset-password:enter-password' | 'reset-password:enter-username' | 'reset-password:finish' | 'unlock-account:enter-username' | 'unlock-account:finish'} pageId The page ID of custom password instructions to query.
         * @param {string} [locale] The locale for the custom instructions, a BCP47 language tag. The default value is \\\&quot;default\\\&quot;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCustomPasswordInstructions(pageId: 'change-password:enter-password' | 'change-password:finish' | 'flow-selection:select' | 'forget-username:user-email' | 'mfa:enter-code' | 'mfa:enter-kba' | 'mfa:select' | 'reset-password:enter-password' | 'reset-password:enter-username' | 'reset-password:finish' | 'unlock-account:enter-username' | 'unlock-account:finish', locale?: string, axiosOptions?: any): AxiosPromise<CustomPasswordInstructionBeta> {
            return localVarFp.getCustomPasswordInstructions(pageId, locale, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCustomPasswordInstructions operation in CustomPasswordInstructionsBetaApi.
 * @export
 * @interface CustomPasswordInstructionsBetaApiCreateCustomPasswordInstructionsRequest
 */
export interface CustomPasswordInstructionsBetaApiCreateCustomPasswordInstructionsRequest {
    /**
     * 
     * @type {CustomPasswordInstructionBeta}
     * @memberof CustomPasswordInstructionsBetaApiCreateCustomPasswordInstructions
     */
    readonly customPasswordInstructionBeta: CustomPasswordInstructionBeta
}

/**
 * Request parameters for deleteCustomPasswordInstructions operation in CustomPasswordInstructionsBetaApi.
 * @export
 * @interface CustomPasswordInstructionsBetaApiDeleteCustomPasswordInstructionsRequest
 */
export interface CustomPasswordInstructionsBetaApiDeleteCustomPasswordInstructionsRequest {
    /**
     * The page ID of custom password instructions to delete.
     * @type {'change-password:enter-password' | 'change-password:finish' | 'flow-selection:select' | 'forget-username:user-email' | 'mfa:enter-code' | 'mfa:enter-kba' | 'mfa:select' | 'reset-password:enter-password' | 'reset-password:enter-username' | 'reset-password:finish' | 'unlock-account:enter-username' | 'unlock-account:finish'}
     * @memberof CustomPasswordInstructionsBetaApiDeleteCustomPasswordInstructions
     */
    readonly pageId: 'change-password:enter-password' | 'change-password:finish' | 'flow-selection:select' | 'forget-username:user-email' | 'mfa:enter-code' | 'mfa:enter-kba' | 'mfa:select' | 'reset-password:enter-password' | 'reset-password:enter-username' | 'reset-password:finish' | 'unlock-account:enter-username' | 'unlock-account:finish'

    /**
     * The locale for the custom instructions, a BCP47 language tag. The default value is \\\&quot;default\\\&quot;.
     * @type {string}
     * @memberof CustomPasswordInstructionsBetaApiDeleteCustomPasswordInstructions
     */
    readonly locale?: string
}

/**
 * Request parameters for getCustomPasswordInstructions operation in CustomPasswordInstructionsBetaApi.
 * @export
 * @interface CustomPasswordInstructionsBetaApiGetCustomPasswordInstructionsRequest
 */
export interface CustomPasswordInstructionsBetaApiGetCustomPasswordInstructionsRequest {
    /**
     * The page ID of custom password instructions to query.
     * @type {'change-password:enter-password' | 'change-password:finish' | 'flow-selection:select' | 'forget-username:user-email' | 'mfa:enter-code' | 'mfa:enter-kba' | 'mfa:select' | 'reset-password:enter-password' | 'reset-password:enter-username' | 'reset-password:finish' | 'unlock-account:enter-username' | 'unlock-account:finish'}
     * @memberof CustomPasswordInstructionsBetaApiGetCustomPasswordInstructions
     */
    readonly pageId: 'change-password:enter-password' | 'change-password:finish' | 'flow-selection:select' | 'forget-username:user-email' | 'mfa:enter-code' | 'mfa:enter-kba' | 'mfa:select' | 'reset-password:enter-password' | 'reset-password:enter-username' | 'reset-password:finish' | 'unlock-account:enter-username' | 'unlock-account:finish'

    /**
     * The locale for the custom instructions, a BCP47 language tag. The default value is \\\&quot;default\\\&quot;.
     * @type {string}
     * @memberof CustomPasswordInstructionsBetaApiGetCustomPasswordInstructions
     */
    readonly locale?: string
}

/**
 * CustomPasswordInstructionsBetaApi - object-oriented interface
 * @export
 * @class CustomPasswordInstructionsBetaApi
 * @extends {BaseAPI}
 */
export class CustomPasswordInstructionsBetaApi extends BaseAPI {
    /**
     * This API creates the custom password instructions for the specified page ID. A token with ORG_ADMIN authority is required to call this API.
     * @summary Create Custom Password Instructions
     * @param {CustomPasswordInstructionsBetaApiCreateCustomPasswordInstructionsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomPasswordInstructionsBetaApi
     */
    public createCustomPasswordInstructions(requestParameters: CustomPasswordInstructionsBetaApiCreateCustomPasswordInstructionsRequest, axiosOptions?: AxiosRequestConfig) {
        return CustomPasswordInstructionsBetaApiFp(this.configuration).createCustomPasswordInstructions(requestParameters.customPasswordInstructionBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API delete the custom password instructions for the specified page ID. A token with ORG_ADMIN authority is required to call this API.
     * @summary Delete Custom Password Instructions by page ID
     * @param {CustomPasswordInstructionsBetaApiDeleteCustomPasswordInstructionsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomPasswordInstructionsBetaApi
     */
    public deleteCustomPasswordInstructions(requestParameters: CustomPasswordInstructionsBetaApiDeleteCustomPasswordInstructionsRequest, axiosOptions?: AxiosRequestConfig) {
        return CustomPasswordInstructionsBetaApiFp(this.configuration).deleteCustomPasswordInstructions(requestParameters.pageId, requestParameters.locale, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the custom password instructions for the specified page ID. A token with ORG_ADMIN authority is required to call this API.
     * @summary Get Custom Password Instructions by Page ID
     * @param {CustomPasswordInstructionsBetaApiGetCustomPasswordInstructionsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomPasswordInstructionsBetaApi
     */
    public getCustomPasswordInstructions(requestParameters: CustomPasswordInstructionsBetaApiGetCustomPasswordInstructionsRequest, axiosOptions?: AxiosRequestConfig) {
        return CustomPasswordInstructionsBetaApiFp(this.configuration).getCustomPasswordInstructions(requestParameters.pageId, requestParameters.locale, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EntitlementsBetaApi - axios parameter creator
 * @export
 */
export const EntitlementsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API returns an entitlement by its ID.
         * @summary Get an entitlement
         * @param {string} id The entitlement ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getEntitlement: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEntitlement', 'id', id)
            const localVarPath = `/entitlements/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the entitlement request config for a specified entitlement.
         * @summary Get Entitlement Request Config
         * @param {string} id Entitlement Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getEntitlementRequestConfig: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEntitlementRequestConfig', 'id', id)
            const localVarPath = `/entitlements/{id}/entitlement-request-config`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of all child entitlements of a given entitlement.
         * @summary List of entitlements children
         * @param {string} id Entitlement Id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **id, name, created, modified, type, attribute, value, source.id**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw*  **type**: *eq, in*  **attribute**: *eq, in*  **value**: *eq, in, sw*  **source.id**: *eq, in*  **requestable**: *eq* **created**: *gt, lt, ge, le* **modified**: *gt, lt, ge, le*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listEntitlementChildren: async (id: string, limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listEntitlementChildren', 'id', id)
            const localVarPath = `/entitlements/{id}/children`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of all parent entitlements of a given entitlement.
         * @summary List of entitlements parents
         * @param {string} id Entitlement Id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **id, name, created, modified, type, attribute, value, source.id**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw*  **type**: *eq, in*  **attribute**: *eq, in*  **value**: *eq, in, sw*  **source.id**: *eq, in*  **requestable**: *eq* **created**: *gt, lt, ge, le* **modified**: *gt, lt, ge, le*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listEntitlementParents: async (id: string, limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listEntitlementParents', 'id', id)
            const localVarPath = `/entitlements/{id}/parents`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of entitlements.  This API can be used in one of the two following ways: either getting entitlements for a specific **account-id**, or getting via use of **filters** (those two options are exclusive).  Any authenticated token can call this API.
         * @summary Gets a list of entitlements.
         * @param {string} [accountId] The account ID. If specified, returns only entitlements associated with the given Account. Cannot be specified with the **filters**, **segmented-for-identity**, **for-segment-ids**, or **include-unsegmented** param(s).
         * @param {string} [segmentedForIdentity] If present and not empty, additionally filters Entitlements to those which are assigned to the Segment(s) which are visible to the Identity with the specified ID. By convention, the value **me** can stand in for the current user\&#39;s Identity ID. Cannot be specified with the **account-id** or **for-segment-ids** param(s). It is also illegal to specify a value that refers to a different user\&#39;s Identity.
         * @param {string} [forSegmentIds] If present and not empty, additionally filters Access Profiles to those which are assigned to the Segment(s) with the specified IDs. Cannot be specified with the **account-id** or **segmented-for-identity** param(s).
         * @param {boolean} [includeUnsegmented] Whether or not the response list should contain unsegmented Entitlements. If **for-segment-ids** and **segmented-for-identity** are both absent or empty, specifying **include-unsegmented&#x3D;false** results in an error.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **id, name, created, modified, type, attribute, value, source.id**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw*  **type**: *eq, in*  **attribute**: *eq, in*  **value**: *eq, in, sw*  **source.id**: *eq, in*  **requestable**: *eq* **created**: *gt, lt, ge, le* **modified**: *gt, lt, ge, le*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listEntitlements: async (accountId?: string, segmentedForIdentity?: string, forSegmentIds?: string, includeUnsegmented?: boolean, offset?: number, limit?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/entitlements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (accountId !== undefined) {
                localVarQueryParameter['account-id'] = accountId;
            }

            if (segmentedForIdentity !== undefined) {
                localVarQueryParameter['segmented-for-identity'] = segmentedForIdentity;
            }

            if (forSegmentIds !== undefined) {
                localVarQueryParameter['for-segment-ids'] = forSegmentIds;
            }

            if (includeUnsegmented !== undefined) {
                localVarQueryParameter['include-unsegmented'] = includeUnsegmented;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates an existing entitlement using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.  The following fields are patchable: **requestable**, **privileged**, **segments**, **owner**, **name**, **description**.  When you\'re patching owner, only owner type and owner id must be provided. Owner name is optional, and it won\'t be modified. If the owner name is provided, it should correspond to the real name. The only owner type currently supported is IDENTITY.  A token with ORG_ADMIN or SOURCE_ADMIN authority is required to call this API.
         * @summary Patch an entitlement
         * @param {string} id ID of the entitlement to patch
         * @param {Array<JsonPatchOperationBeta>} [jsonPatchOperationBeta] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchEntitlement: async (id: string, jsonPatchOperationBeta?: Array<JsonPatchOperationBeta>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchEntitlement', 'id', id)
            const localVarPath = `/entitlements/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperationBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API replaces the entitlement request config for a specified entitlement.
         * @summary Replace Entitlement Request Config
         * @param {string} id Entitlement ID
         * @param {EntitlementRequestConfigBeta} entitlementRequestConfigBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putEntitlementRequestConfig: async (id: string, entitlementRequestConfigBeta: EntitlementRequestConfigBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putEntitlementRequestConfig', 'id', id)
            // verify required parameter 'entitlementRequestConfigBeta' is not null or undefined
            assertParamExists('putEntitlementRequestConfig', 'entitlementRequestConfigBeta', entitlementRequestConfigBeta)
            const localVarPath = `/entitlements/{id}/entitlement-request-config`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(entitlementRequestConfigBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API applies an update to every entitlement of the list.  The number of entitlements to update is limited to 50 items maximum.  The JsonPatch update follows the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. allowed operations : **{ \"op\": \"replace\", \"path\": \"/privileged\", \"value\": boolean }**  **{ \"op\": \"replace\", \"path\": \"/requestable\",\"value\": boolean }**   A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Bulk update an entitlement list
         * @param {EntitlementBulkUpdateRequestBeta} entitlementBulkUpdateRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateEntitlementsInBulk: async (entitlementBulkUpdateRequestBeta: EntitlementBulkUpdateRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entitlementBulkUpdateRequestBeta' is not null or undefined
            assertParamExists('updateEntitlementsInBulk', 'entitlementBulkUpdateRequestBeta', entitlementBulkUpdateRequestBeta)
            const localVarPath = `/entitlements/bulk-update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(entitlementBulkUpdateRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntitlementsBetaApi - functional programming interface
 * @export
 */
export const EntitlementsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EntitlementsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This API returns an entitlement by its ID.
         * @summary Get an entitlement
         * @param {string} id The entitlement ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getEntitlement(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntitlementBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntitlement(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the entitlement request config for a specified entitlement.
         * @summary Get Entitlement Request Config
         * @param {string} id Entitlement Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getEntitlementRequestConfig(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntitlementRequestConfigBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntitlementRequestConfig(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of all child entitlements of a given entitlement.
         * @summary List of entitlements children
         * @param {string} id Entitlement Id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **id, name, created, modified, type, attribute, value, source.id**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw*  **type**: *eq, in*  **attribute**: *eq, in*  **value**: *eq, in, sw*  **source.id**: *eq, in*  **requestable**: *eq* **created**: *gt, lt, ge, le* **modified**: *gt, lt, ge, le*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listEntitlementChildren(id: string, limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EntitlementBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEntitlementChildren(id, limit, offset, count, sorters, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of all parent entitlements of a given entitlement.
         * @summary List of entitlements parents
         * @param {string} id Entitlement Id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **id, name, created, modified, type, attribute, value, source.id**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw*  **type**: *eq, in*  **attribute**: *eq, in*  **value**: *eq, in, sw*  **source.id**: *eq, in*  **requestable**: *eq* **created**: *gt, lt, ge, le* **modified**: *gt, lt, ge, le*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listEntitlementParents(id: string, limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EntitlementBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEntitlementParents(id, limit, offset, count, sorters, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of entitlements.  This API can be used in one of the two following ways: either getting entitlements for a specific **account-id**, or getting via use of **filters** (those two options are exclusive).  Any authenticated token can call this API.
         * @summary Gets a list of entitlements.
         * @param {string} [accountId] The account ID. If specified, returns only entitlements associated with the given Account. Cannot be specified with the **filters**, **segmented-for-identity**, **for-segment-ids**, or **include-unsegmented** param(s).
         * @param {string} [segmentedForIdentity] If present and not empty, additionally filters Entitlements to those which are assigned to the Segment(s) which are visible to the Identity with the specified ID. By convention, the value **me** can stand in for the current user\&#39;s Identity ID. Cannot be specified with the **account-id** or **for-segment-ids** param(s). It is also illegal to specify a value that refers to a different user\&#39;s Identity.
         * @param {string} [forSegmentIds] If present and not empty, additionally filters Access Profiles to those which are assigned to the Segment(s) with the specified IDs. Cannot be specified with the **account-id** or **segmented-for-identity** param(s).
         * @param {boolean} [includeUnsegmented] Whether or not the response list should contain unsegmented Entitlements. If **for-segment-ids** and **segmented-for-identity** are both absent or empty, specifying **include-unsegmented&#x3D;false** results in an error.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **id, name, created, modified, type, attribute, value, source.id**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw*  **type**: *eq, in*  **attribute**: *eq, in*  **value**: *eq, in, sw*  **source.id**: *eq, in*  **requestable**: *eq* **created**: *gt, lt, ge, le* **modified**: *gt, lt, ge, le*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listEntitlements(accountId?: string, segmentedForIdentity?: string, forSegmentIds?: string, includeUnsegmented?: boolean, offset?: number, limit?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EntitlementBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEntitlements(accountId, segmentedForIdentity, forSegmentIds, includeUnsegmented, offset, limit, count, sorters, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API updates an existing entitlement using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.  The following fields are patchable: **requestable**, **privileged**, **segments**, **owner**, **name**, **description**.  When you\'re patching owner, only owner type and owner id must be provided. Owner name is optional, and it won\'t be modified. If the owner name is provided, it should correspond to the real name. The only owner type currently supported is IDENTITY.  A token with ORG_ADMIN or SOURCE_ADMIN authority is required to call this API.
         * @summary Patch an entitlement
         * @param {string} id ID of the entitlement to patch
         * @param {Array<JsonPatchOperationBeta>} [jsonPatchOperationBeta] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntitlement(id: string, jsonPatchOperationBeta?: Array<JsonPatchOperationBeta>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntitlementBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntitlement(id, jsonPatchOperationBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API replaces the entitlement request config for a specified entitlement.
         * @summary Replace Entitlement Request Config
         * @param {string} id Entitlement ID
         * @param {EntitlementRequestConfigBeta} entitlementRequestConfigBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putEntitlementRequestConfig(id: string, entitlementRequestConfigBeta: EntitlementRequestConfigBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntitlementRequestConfigBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putEntitlementRequestConfig(id, entitlementRequestConfigBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API applies an update to every entitlement of the list.  The number of entitlements to update is limited to 50 items maximum.  The JsonPatch update follows the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. allowed operations : **{ \"op\": \"replace\", \"path\": \"/privileged\", \"value\": boolean }**  **{ \"op\": \"replace\", \"path\": \"/requestable\",\"value\": boolean }**   A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Bulk update an entitlement list
         * @param {EntitlementBulkUpdateRequestBeta} entitlementBulkUpdateRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntitlementsInBulk(entitlementBulkUpdateRequestBeta: EntitlementBulkUpdateRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntitlementsInBulk(entitlementBulkUpdateRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EntitlementsBetaApi - factory interface
 * @export
 */
export const EntitlementsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EntitlementsBetaApiFp(configuration)
    return {
        /**
         * This API returns an entitlement by its ID.
         * @summary Get an entitlement
         * @param {string} id The entitlement ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getEntitlement(id: string, axiosOptions?: any): AxiosPromise<EntitlementBeta> {
            return localVarFp.getEntitlement(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the entitlement request config for a specified entitlement.
         * @summary Get Entitlement Request Config
         * @param {string} id Entitlement Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getEntitlementRequestConfig(id: string, axiosOptions?: any): AxiosPromise<EntitlementRequestConfigBeta> {
            return localVarFp.getEntitlementRequestConfig(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of all child entitlements of a given entitlement.
         * @summary List of entitlements children
         * @param {string} id Entitlement Id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **id, name, created, modified, type, attribute, value, source.id**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw*  **type**: *eq, in*  **attribute**: *eq, in*  **value**: *eq, in, sw*  **source.id**: *eq, in*  **requestable**: *eq* **created**: *gt, lt, ge, le* **modified**: *gt, lt, ge, le*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listEntitlementChildren(id: string, limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: any): AxiosPromise<Array<EntitlementBeta>> {
            return localVarFp.listEntitlementChildren(id, limit, offset, count, sorters, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of all parent entitlements of a given entitlement.
         * @summary List of entitlements parents
         * @param {string} id Entitlement Id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **id, name, created, modified, type, attribute, value, source.id**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw*  **type**: *eq, in*  **attribute**: *eq, in*  **value**: *eq, in, sw*  **source.id**: *eq, in*  **requestable**: *eq* **created**: *gt, lt, ge, le* **modified**: *gt, lt, ge, le*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listEntitlementParents(id: string, limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: any): AxiosPromise<Array<EntitlementBeta>> {
            return localVarFp.listEntitlementParents(id, limit, offset, count, sorters, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of entitlements.  This API can be used in one of the two following ways: either getting entitlements for a specific **account-id**, or getting via use of **filters** (those two options are exclusive).  Any authenticated token can call this API.
         * @summary Gets a list of entitlements.
         * @param {string} [accountId] The account ID. If specified, returns only entitlements associated with the given Account. Cannot be specified with the **filters**, **segmented-for-identity**, **for-segment-ids**, or **include-unsegmented** param(s).
         * @param {string} [segmentedForIdentity] If present and not empty, additionally filters Entitlements to those which are assigned to the Segment(s) which are visible to the Identity with the specified ID. By convention, the value **me** can stand in for the current user\&#39;s Identity ID. Cannot be specified with the **account-id** or **for-segment-ids** param(s). It is also illegal to specify a value that refers to a different user\&#39;s Identity.
         * @param {string} [forSegmentIds] If present and not empty, additionally filters Access Profiles to those which are assigned to the Segment(s) with the specified IDs. Cannot be specified with the **account-id** or **segmented-for-identity** param(s).
         * @param {boolean} [includeUnsegmented] Whether or not the response list should contain unsegmented Entitlements. If **for-segment-ids** and **segmented-for-identity** are both absent or empty, specifying **include-unsegmented&#x3D;false** results in an error.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **id, name, created, modified, type, attribute, value, source.id**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw*  **type**: *eq, in*  **attribute**: *eq, in*  **value**: *eq, in, sw*  **source.id**: *eq, in*  **requestable**: *eq* **created**: *gt, lt, ge, le* **modified**: *gt, lt, ge, le*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listEntitlements(accountId?: string, segmentedForIdentity?: string, forSegmentIds?: string, includeUnsegmented?: boolean, offset?: number, limit?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: any): AxiosPromise<Array<EntitlementBeta>> {
            return localVarFp.listEntitlements(accountId, segmentedForIdentity, forSegmentIds, includeUnsegmented, offset, limit, count, sorters, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates an existing entitlement using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.  The following fields are patchable: **requestable**, **privileged**, **segments**, **owner**, **name**, **description**.  When you\'re patching owner, only owner type and owner id must be provided. Owner name is optional, and it won\'t be modified. If the owner name is provided, it should correspond to the real name. The only owner type currently supported is IDENTITY.  A token with ORG_ADMIN or SOURCE_ADMIN authority is required to call this API.
         * @summary Patch an entitlement
         * @param {string} id ID of the entitlement to patch
         * @param {Array<JsonPatchOperationBeta>} [jsonPatchOperationBeta] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchEntitlement(id: string, jsonPatchOperationBeta?: Array<JsonPatchOperationBeta>, axiosOptions?: any): AxiosPromise<EntitlementBeta> {
            return localVarFp.patchEntitlement(id, jsonPatchOperationBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API replaces the entitlement request config for a specified entitlement.
         * @summary Replace Entitlement Request Config
         * @param {string} id Entitlement ID
         * @param {EntitlementRequestConfigBeta} entitlementRequestConfigBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putEntitlementRequestConfig(id: string, entitlementRequestConfigBeta: EntitlementRequestConfigBeta, axiosOptions?: any): AxiosPromise<EntitlementRequestConfigBeta> {
            return localVarFp.putEntitlementRequestConfig(id, entitlementRequestConfigBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API applies an update to every entitlement of the list.  The number of entitlements to update is limited to 50 items maximum.  The JsonPatch update follows the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. allowed operations : **{ \"op\": \"replace\", \"path\": \"/privileged\", \"value\": boolean }**  **{ \"op\": \"replace\", \"path\": \"/requestable\",\"value\": boolean }**   A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Bulk update an entitlement list
         * @param {EntitlementBulkUpdateRequestBeta} entitlementBulkUpdateRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateEntitlementsInBulk(entitlementBulkUpdateRequestBeta: EntitlementBulkUpdateRequestBeta, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.updateEntitlementsInBulk(entitlementBulkUpdateRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getEntitlement operation in EntitlementsBetaApi.
 * @export
 * @interface EntitlementsBetaApiGetEntitlementRequest
 */
export interface EntitlementsBetaApiGetEntitlementRequest {
    /**
     * The entitlement ID
     * @type {string}
     * @memberof EntitlementsBetaApiGetEntitlement
     */
    readonly id: string
}

/**
 * Request parameters for getEntitlementRequestConfig operation in EntitlementsBetaApi.
 * @export
 * @interface EntitlementsBetaApiGetEntitlementRequestConfigRequest
 */
export interface EntitlementsBetaApiGetEntitlementRequestConfigRequest {
    /**
     * Entitlement Id
     * @type {string}
     * @memberof EntitlementsBetaApiGetEntitlementRequestConfig
     */
    readonly id: string
}

/**
 * Request parameters for listEntitlementChildren operation in EntitlementsBetaApi.
 * @export
 * @interface EntitlementsBetaApiListEntitlementChildrenRequest
 */
export interface EntitlementsBetaApiListEntitlementChildrenRequest {
    /**
     * Entitlement Id
     * @type {string}
     * @memberof EntitlementsBetaApiListEntitlementChildren
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof EntitlementsBetaApiListEntitlementChildren
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof EntitlementsBetaApiListEntitlementChildren
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof EntitlementsBetaApiListEntitlementChildren
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **id, name, created, modified, type, attribute, value, source.id**
     * @type {string}
     * @memberof EntitlementsBetaApiListEntitlementChildren
     */
    readonly sorters?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw*  **type**: *eq, in*  **attribute**: *eq, in*  **value**: *eq, in, sw*  **source.id**: *eq, in*  **requestable**: *eq* **created**: *gt, lt, ge, le* **modified**: *gt, lt, ge, le*
     * @type {string}
     * @memberof EntitlementsBetaApiListEntitlementChildren
     */
    readonly filters?: string
}

/**
 * Request parameters for listEntitlementParents operation in EntitlementsBetaApi.
 * @export
 * @interface EntitlementsBetaApiListEntitlementParentsRequest
 */
export interface EntitlementsBetaApiListEntitlementParentsRequest {
    /**
     * Entitlement Id
     * @type {string}
     * @memberof EntitlementsBetaApiListEntitlementParents
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof EntitlementsBetaApiListEntitlementParents
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof EntitlementsBetaApiListEntitlementParents
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof EntitlementsBetaApiListEntitlementParents
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **id, name, created, modified, type, attribute, value, source.id**
     * @type {string}
     * @memberof EntitlementsBetaApiListEntitlementParents
     */
    readonly sorters?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw*  **type**: *eq, in*  **attribute**: *eq, in*  **value**: *eq, in, sw*  **source.id**: *eq, in*  **requestable**: *eq* **created**: *gt, lt, ge, le* **modified**: *gt, lt, ge, le*
     * @type {string}
     * @memberof EntitlementsBetaApiListEntitlementParents
     */
    readonly filters?: string
}

/**
 * Request parameters for listEntitlements operation in EntitlementsBetaApi.
 * @export
 * @interface EntitlementsBetaApiListEntitlementsRequest
 */
export interface EntitlementsBetaApiListEntitlementsRequest {
    /**
     * The account ID. If specified, returns only entitlements associated with the given Account. Cannot be specified with the **filters**, **segmented-for-identity**, **for-segment-ids**, or **include-unsegmented** param(s).
     * @type {string}
     * @memberof EntitlementsBetaApiListEntitlements
     */
    readonly accountId?: string

    /**
     * If present and not empty, additionally filters Entitlements to those which are assigned to the Segment(s) which are visible to the Identity with the specified ID. By convention, the value **me** can stand in for the current user\&#39;s Identity ID. Cannot be specified with the **account-id** or **for-segment-ids** param(s). It is also illegal to specify a value that refers to a different user\&#39;s Identity.
     * @type {string}
     * @memberof EntitlementsBetaApiListEntitlements
     */
    readonly segmentedForIdentity?: string

    /**
     * If present and not empty, additionally filters Access Profiles to those which are assigned to the Segment(s) with the specified IDs. Cannot be specified with the **account-id** or **segmented-for-identity** param(s).
     * @type {string}
     * @memberof EntitlementsBetaApiListEntitlements
     */
    readonly forSegmentIds?: string

    /**
     * Whether or not the response list should contain unsegmented Entitlements. If **for-segment-ids** and **segmented-for-identity** are both absent or empty, specifying **include-unsegmented&#x3D;false** results in an error.
     * @type {boolean}
     * @memberof EntitlementsBetaApiListEntitlements
     */
    readonly includeUnsegmented?: boolean

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof EntitlementsBetaApiListEntitlements
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof EntitlementsBetaApiListEntitlements
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof EntitlementsBetaApiListEntitlements
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **id, name, created, modified, type, attribute, value, source.id**
     * @type {string}
     * @memberof EntitlementsBetaApiListEntitlements
     */
    readonly sorters?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw*  **type**: *eq, in*  **attribute**: *eq, in*  **value**: *eq, in, sw*  **source.id**: *eq, in*  **requestable**: *eq* **created**: *gt, lt, ge, le* **modified**: *gt, lt, ge, le*
     * @type {string}
     * @memberof EntitlementsBetaApiListEntitlements
     */
    readonly filters?: string
}

/**
 * Request parameters for patchEntitlement operation in EntitlementsBetaApi.
 * @export
 * @interface EntitlementsBetaApiPatchEntitlementRequest
 */
export interface EntitlementsBetaApiPatchEntitlementRequest {
    /**
     * ID of the entitlement to patch
     * @type {string}
     * @memberof EntitlementsBetaApiPatchEntitlement
     */
    readonly id: string

    /**
     * 
     * @type {Array<JsonPatchOperationBeta>}
     * @memberof EntitlementsBetaApiPatchEntitlement
     */
    readonly jsonPatchOperationBeta?: Array<JsonPatchOperationBeta>
}

/**
 * Request parameters for putEntitlementRequestConfig operation in EntitlementsBetaApi.
 * @export
 * @interface EntitlementsBetaApiPutEntitlementRequestConfigRequest
 */
export interface EntitlementsBetaApiPutEntitlementRequestConfigRequest {
    /**
     * Entitlement ID
     * @type {string}
     * @memberof EntitlementsBetaApiPutEntitlementRequestConfig
     */
    readonly id: string

    /**
     * 
     * @type {EntitlementRequestConfigBeta}
     * @memberof EntitlementsBetaApiPutEntitlementRequestConfig
     */
    readonly entitlementRequestConfigBeta: EntitlementRequestConfigBeta
}

/**
 * Request parameters for updateEntitlementsInBulk operation in EntitlementsBetaApi.
 * @export
 * @interface EntitlementsBetaApiUpdateEntitlementsInBulkRequest
 */
export interface EntitlementsBetaApiUpdateEntitlementsInBulkRequest {
    /**
     * 
     * @type {EntitlementBulkUpdateRequestBeta}
     * @memberof EntitlementsBetaApiUpdateEntitlementsInBulk
     */
    readonly entitlementBulkUpdateRequestBeta: EntitlementBulkUpdateRequestBeta
}

/**
 * EntitlementsBetaApi - object-oriented interface
 * @export
 * @class EntitlementsBetaApi
 * @extends {BaseAPI}
 */
export class EntitlementsBetaApi extends BaseAPI {
    /**
     * This API returns an entitlement by its ID.
     * @summary Get an entitlement
     * @param {EntitlementsBetaApiGetEntitlementRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementsBetaApi
     */
    public getEntitlement(requestParameters: EntitlementsBetaApiGetEntitlementRequest, axiosOptions?: AxiosRequestConfig) {
        return EntitlementsBetaApiFp(this.configuration).getEntitlement(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the entitlement request config for a specified entitlement.
     * @summary Get Entitlement Request Config
     * @param {EntitlementsBetaApiGetEntitlementRequestConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementsBetaApi
     */
    public getEntitlementRequestConfig(requestParameters: EntitlementsBetaApiGetEntitlementRequestConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return EntitlementsBetaApiFp(this.configuration).getEntitlementRequestConfig(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of all child entitlements of a given entitlement.
     * @summary List of entitlements children
     * @param {EntitlementsBetaApiListEntitlementChildrenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementsBetaApi
     */
    public listEntitlementChildren(requestParameters: EntitlementsBetaApiListEntitlementChildrenRequest, axiosOptions?: AxiosRequestConfig) {
        return EntitlementsBetaApiFp(this.configuration).listEntitlementChildren(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of all parent entitlements of a given entitlement.
     * @summary List of entitlements parents
     * @param {EntitlementsBetaApiListEntitlementParentsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementsBetaApi
     */
    public listEntitlementParents(requestParameters: EntitlementsBetaApiListEntitlementParentsRequest, axiosOptions?: AxiosRequestConfig) {
        return EntitlementsBetaApiFp(this.configuration).listEntitlementParents(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of entitlements.  This API can be used in one of the two following ways: either getting entitlements for a specific **account-id**, or getting via use of **filters** (those two options are exclusive).  Any authenticated token can call this API.
     * @summary Gets a list of entitlements.
     * @param {EntitlementsBetaApiListEntitlementsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementsBetaApi
     */
    public listEntitlements(requestParameters: EntitlementsBetaApiListEntitlementsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return EntitlementsBetaApiFp(this.configuration).listEntitlements(requestParameters.accountId, requestParameters.segmentedForIdentity, requestParameters.forSegmentIds, requestParameters.includeUnsegmented, requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.sorters, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates an existing entitlement using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.  The following fields are patchable: **requestable**, **privileged**, **segments**, **owner**, **name**, **description**.  When you\'re patching owner, only owner type and owner id must be provided. Owner name is optional, and it won\'t be modified. If the owner name is provided, it should correspond to the real name. The only owner type currently supported is IDENTITY.  A token with ORG_ADMIN or SOURCE_ADMIN authority is required to call this API.
     * @summary Patch an entitlement
     * @param {EntitlementsBetaApiPatchEntitlementRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementsBetaApi
     */
    public patchEntitlement(requestParameters: EntitlementsBetaApiPatchEntitlementRequest, axiosOptions?: AxiosRequestConfig) {
        return EntitlementsBetaApiFp(this.configuration).patchEntitlement(requestParameters.id, requestParameters.jsonPatchOperationBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API replaces the entitlement request config for a specified entitlement.
     * @summary Replace Entitlement Request Config
     * @param {EntitlementsBetaApiPutEntitlementRequestConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementsBetaApi
     */
    public putEntitlementRequestConfig(requestParameters: EntitlementsBetaApiPutEntitlementRequestConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return EntitlementsBetaApiFp(this.configuration).putEntitlementRequestConfig(requestParameters.id, requestParameters.entitlementRequestConfigBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API applies an update to every entitlement of the list.  The number of entitlements to update is limited to 50 items maximum.  The JsonPatch update follows the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. allowed operations : **{ \"op\": \"replace\", \"path\": \"/privileged\", \"value\": boolean }**  **{ \"op\": \"replace\", \"path\": \"/requestable\",\"value\": boolean }**   A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Bulk update an entitlement list
     * @param {EntitlementsBetaApiUpdateEntitlementsInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementsBetaApi
     */
    public updateEntitlementsInBulk(requestParameters: EntitlementsBetaApiUpdateEntitlementsInBulkRequest, axiosOptions?: AxiosRequestConfig) {
        return EntitlementsBetaApiFp(this.configuration).updateEntitlementsInBulk(requestParameters.entitlementBulkUpdateRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GovernanceGroupsBetaApi - axios parameter creator
 * @export
 */
export const GovernanceGroupsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates a new Governance Group.
         * @summary Create a new Governance Group.
         * @param {WorkgroupDtoBeta} workgroupDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createWorkgroup: async (workgroupDtoBeta: WorkgroupDtoBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workgroupDtoBeta' is not null or undefined
            assertParamExists('createWorkgroup', 'workgroupDtoBeta', workgroupDtoBeta)
            const localVarPath = `/workgroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workgroupDtoBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns an Governance Groups by its ID.
         * @summary Get an Governance Groups
         * @param {string} id ID of the Governance Groups
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkgroup: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWorkgroup', 'id', id)
            const localVarPath = `/workgroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns list of Governance Groups
         * @summary List Governance Groups
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **name, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkgroups: async (offset?: number, limit?: number, count?: boolean, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/workgroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * GovernanceGroupsBetaApi - functional programming interface
 * @export
 */
export const GovernanceGroupsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GovernanceGroupsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates a new Governance Group.
         * @summary Create a new Governance Group.
         * @param {WorkgroupDtoBeta} workgroupDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkgroup(workgroupDtoBeta: WorkgroupDtoBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkgroupDtoBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkgroup(workgroupDtoBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns an Governance Groups by its ID.
         * @summary Get an Governance Groups
         * @param {string} id ID of the Governance Groups
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkgroup(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkgroupDtoBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkgroup(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns list of Governance Groups
         * @summary List Governance Groups
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **name, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkgroups(offset?: number, limit?: number, count?: boolean, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkgroupDtoBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkgroups(offset, limit, count, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GovernanceGroupsBetaApi - factory interface
 * @export
 */
export const GovernanceGroupsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GovernanceGroupsBetaApiFp(configuration)
    return {
        /**
         * This API creates a new Governance Group.
         * @summary Create a new Governance Group.
         * @param {WorkgroupDtoBeta} workgroupDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createWorkgroup(workgroupDtoBeta: WorkgroupDtoBeta, axiosOptions?: any): AxiosPromise<WorkgroupDtoBeta> {
            return localVarFp.createWorkgroup(workgroupDtoBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns an Governance Groups by its ID.
         * @summary Get an Governance Groups
         * @param {string} id ID of the Governance Groups
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkgroup(id: string, axiosOptions?: any): AxiosPromise<WorkgroupDtoBeta> {
            return localVarFp.getWorkgroup(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns list of Governance Groups
         * @summary List Governance Groups
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **name, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkgroups(offset?: number, limit?: number, count?: boolean, sorters?: string, axiosOptions?: any): AxiosPromise<Array<WorkgroupDtoBeta>> {
            return localVarFp.listWorkgroups(offset, limit, count, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createWorkgroup operation in GovernanceGroupsBetaApi.
 * @export
 * @interface GovernanceGroupsBetaApiCreateWorkgroupRequest
 */
export interface GovernanceGroupsBetaApiCreateWorkgroupRequest {
    /**
     * 
     * @type {WorkgroupDtoBeta}
     * @memberof GovernanceGroupsBetaApiCreateWorkgroup
     */
    readonly workgroupDtoBeta: WorkgroupDtoBeta
}

/**
 * Request parameters for getWorkgroup operation in GovernanceGroupsBetaApi.
 * @export
 * @interface GovernanceGroupsBetaApiGetWorkgroupRequest
 */
export interface GovernanceGroupsBetaApiGetWorkgroupRequest {
    /**
     * ID of the Governance Groups
     * @type {string}
     * @memberof GovernanceGroupsBetaApiGetWorkgroup
     */
    readonly id: string
}

/**
 * Request parameters for listWorkgroups operation in GovernanceGroupsBetaApi.
 * @export
 * @interface GovernanceGroupsBetaApiListWorkgroupsRequest
 */
export interface GovernanceGroupsBetaApiListWorkgroupsRequest {
    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof GovernanceGroupsBetaApiListWorkgroups
     */
    readonly offset?: number

    /**
     * Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof GovernanceGroupsBetaApiListWorkgroups
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof GovernanceGroupsBetaApiListWorkgroups
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **name, created, modified**
     * @type {string}
     * @memberof GovernanceGroupsBetaApiListWorkgroups
     */
    readonly sorters?: string
}

/**
 * GovernanceGroupsBetaApi - object-oriented interface
 * @export
 * @class GovernanceGroupsBetaApi
 * @extends {BaseAPI}
 */
export class GovernanceGroupsBetaApi extends BaseAPI {
    /**
     * This API creates a new Governance Group.
     * @summary Create a new Governance Group.
     * @param {GovernanceGroupsBetaApiCreateWorkgroupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceGroupsBetaApi
     */
    public createWorkgroup(requestParameters: GovernanceGroupsBetaApiCreateWorkgroupRequest, axiosOptions?: AxiosRequestConfig) {
        return GovernanceGroupsBetaApiFp(this.configuration).createWorkgroup(requestParameters.workgroupDtoBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns an Governance Groups by its ID.
     * @summary Get an Governance Groups
     * @param {GovernanceGroupsBetaApiGetWorkgroupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceGroupsBetaApi
     */
    public getWorkgroup(requestParameters: GovernanceGroupsBetaApiGetWorkgroupRequest, axiosOptions?: AxiosRequestConfig) {
        return GovernanceGroupsBetaApiFp(this.configuration).getWorkgroup(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns list of Governance Groups
     * @summary List Governance Groups
     * @param {GovernanceGroupsBetaApiListWorkgroupsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceGroupsBetaApi
     */
    public listWorkgroups(requestParameters: GovernanceGroupsBetaApiListWorkgroupsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return GovernanceGroupsBetaApiFp(this.configuration).listWorkgroups(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IAIAccessRequestRecommendationsBetaApi - axios parameter creator
 * @export
 */
export const IAIAccessRequestRecommendationsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API ignores a recommended access request item. Once an item is ignored, it will be marked as ignored=true if it is still a recommended item. The consumer can decide to hide ignored recommendations.
         * @summary Notification of Ignored Access Request Recommendations
         * @param {AccessRequestRecommendationActionItemDtoBeta} accessRequestRecommendationActionItemDtoBeta The recommended access item to ignore for an identity.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        addAccessRequestRecommendationsIgnoredItem: async (accessRequestRecommendationActionItemDtoBeta: AccessRequestRecommendationActionItemDtoBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessRequestRecommendationActionItemDtoBeta' is not null or undefined
            assertParamExists('addAccessRequestRecommendationsIgnoredItem', 'accessRequestRecommendationActionItemDtoBeta', accessRequestRecommendationActionItemDtoBeta)
            const localVarPath = `/ai-access-request-recommendations/ignored-items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessRequestRecommendationActionItemDtoBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API consumes a notification that a recommended access request item was requested. This API does not actually make the request, it is just a notification. This will help provide feedback in order to improve our recommendations.
         * @summary Notification of Requested Access Request Recommendations
         * @param {AccessRequestRecommendationActionItemDtoBeta} accessRequestRecommendationActionItemDtoBeta The recommended access item that was requested for an identity.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        addAccessRequestRecommendationsRequestedItem: async (accessRequestRecommendationActionItemDtoBeta: AccessRequestRecommendationActionItemDtoBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessRequestRecommendationActionItemDtoBeta' is not null or undefined
            assertParamExists('addAccessRequestRecommendationsRequestedItem', 'accessRequestRecommendationActionItemDtoBeta', accessRequestRecommendationActionItemDtoBeta)
            const localVarPath = `/ai-access-request-recommendations/requested-items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessRequestRecommendationActionItemDtoBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API consumes a notification that a recommended access request item was viewed. Future recommendations with this item will be marked with viewed=true. This can be useful for the consumer to determine if there are any new/unviewed recommendations.
         * @summary Notification of Viewed Access Request Recommendations
         * @param {AccessRequestRecommendationActionItemDtoBeta} accessRequestRecommendationActionItemDtoBeta The recommended access that was viewed for an identity.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        addAccessRequestRecommendationsViewedItem: async (accessRequestRecommendationActionItemDtoBeta: AccessRequestRecommendationActionItemDtoBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessRequestRecommendationActionItemDtoBeta' is not null or undefined
            assertParamExists('addAccessRequestRecommendationsViewedItem', 'accessRequestRecommendationActionItemDtoBeta', accessRequestRecommendationActionItemDtoBeta)
            const localVarPath = `/ai-access-request-recommendations/viewed-items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessRequestRecommendationActionItemDtoBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API consumes a notification that a set of recommended access request item were viewed. Future recommendations with these items will be marked with viewed=true. This can be useful for the consumer to determine if there are any new/unviewed recommendations.
         * @summary Notification of Viewed Access Request Recommendations in Bulk
         * @param {Array<AccessRequestRecommendationActionItemDtoBeta>} accessRequestRecommendationActionItemDtoBeta The recommended access items that were viewed for an identity.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        addAccessRequestRecommendationsViewedItems: async (accessRequestRecommendationActionItemDtoBeta: Array<AccessRequestRecommendationActionItemDtoBeta>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessRequestRecommendationActionItemDtoBeta' is not null or undefined
            assertParamExists('addAccessRequestRecommendationsViewedItems', 'accessRequestRecommendationActionItemDtoBeta', accessRequestRecommendationActionItemDtoBeta)
            const localVarPath = `/ai-access-request-recommendations/viewed-items/bulk-create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessRequestRecommendationActionItemDtoBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the access request recommendations for the specified identity. The default identity is *me* which indicates the current user.
         * @summary Identity Access Request Recommendations
         * @param {string} [identityId] Get access request recommendations for an identityId. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [includeTranslationMessages] If *true* it will populate a list of translation messages in the response.
         * @param {string} [filters] Filter recommendations using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **access.name**: *co*  **access.type**: *eq, in*  **access.description**: *co*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.name, access.type**  By default the recommendations are sorted by highest confidence first.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestRecommendations: async (identityId?: string, limit?: number, offset?: number, count?: boolean, includeTranslationMessages?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ai-access-request-recommendations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (identityId !== undefined) {
                localVarQueryParameter['identity-id'] = identityId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (includeTranslationMessages !== undefined) {
                localVarQueryParameter['include-translation-messages'] = includeTranslationMessages;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the list of ignored access request recommendations.
         * @summary List of Ignored Access Request Recommendations
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter recommendations using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **access.id**: *eq, in*  **access.type**: *eq, in*  **identityId**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.id, access.type, identityId, timestamp**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestRecommendationsIgnoredItems: async (limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ai-access-request-recommendations/ignored-items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of requested access request recommendations.
         * @summary List of Requested Access Request Recommendations
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter recommendations using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **access.id**: *eq, in*  **access.type**: *eq, in*  **identityId**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.id, access.type, identityId, timestamp**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestRecommendationsRequestedItems: async (limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ai-access-request-recommendations/requested-items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the list of viewed access request recommendations.
         * @summary List of Viewed Access Request Recommendations
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter recommendations using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **access.id**: *eq, in*  **access.type**: *eq, in*  **identityId**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.id, access.type, identityId, timestamp**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestRecommendationsViewedItems: async (limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ai-access-request-recommendations/viewed-items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * The getMessageCatalogs API returns message catalog based on the language headers in the requested object.
         * @summary Get Message catalogs
         * @param {'recommender' | 'access-request-recommender'} catalogId The ID of the message catalog.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getMessageCatalogs: async (catalogId: 'recommender' | 'access-request-recommender', axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogId' is not null or undefined
            assertParamExists('getMessageCatalogs', 'catalogId', catalogId)
            const localVarPath = `/translation-catalogs/{catalog-id}`
                .replace(`{${"catalog-id"}}`, encodeURIComponent(String(catalogId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * IAIAccessRequestRecommendationsBetaApi - functional programming interface
 * @export
 */
export const IAIAccessRequestRecommendationsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IAIAccessRequestRecommendationsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This API ignores a recommended access request item. Once an item is ignored, it will be marked as ignored=true if it is still a recommended item. The consumer can decide to hide ignored recommendations.
         * @summary Notification of Ignored Access Request Recommendations
         * @param {AccessRequestRecommendationActionItemDtoBeta} accessRequestRecommendationActionItemDtoBeta The recommended access item to ignore for an identity.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async addAccessRequestRecommendationsIgnoredItem(accessRequestRecommendationActionItemDtoBeta: AccessRequestRecommendationActionItemDtoBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessRequestRecommendationActionItemResponseDtoBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAccessRequestRecommendationsIgnoredItem(accessRequestRecommendationActionItemDtoBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API consumes a notification that a recommended access request item was requested. This API does not actually make the request, it is just a notification. This will help provide feedback in order to improve our recommendations.
         * @summary Notification of Requested Access Request Recommendations
         * @param {AccessRequestRecommendationActionItemDtoBeta} accessRequestRecommendationActionItemDtoBeta The recommended access item that was requested for an identity.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async addAccessRequestRecommendationsRequestedItem(accessRequestRecommendationActionItemDtoBeta: AccessRequestRecommendationActionItemDtoBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessRequestRecommendationActionItemResponseDtoBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAccessRequestRecommendationsRequestedItem(accessRequestRecommendationActionItemDtoBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API consumes a notification that a recommended access request item was viewed. Future recommendations with this item will be marked with viewed=true. This can be useful for the consumer to determine if there are any new/unviewed recommendations.
         * @summary Notification of Viewed Access Request Recommendations
         * @param {AccessRequestRecommendationActionItemDtoBeta} accessRequestRecommendationActionItemDtoBeta The recommended access that was viewed for an identity.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async addAccessRequestRecommendationsViewedItem(accessRequestRecommendationActionItemDtoBeta: AccessRequestRecommendationActionItemDtoBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessRequestRecommendationActionItemResponseDtoBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAccessRequestRecommendationsViewedItem(accessRequestRecommendationActionItemDtoBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API consumes a notification that a set of recommended access request item were viewed. Future recommendations with these items will be marked with viewed=true. This can be useful for the consumer to determine if there are any new/unviewed recommendations.
         * @summary Notification of Viewed Access Request Recommendations in Bulk
         * @param {Array<AccessRequestRecommendationActionItemDtoBeta>} accessRequestRecommendationActionItemDtoBeta The recommended access items that were viewed for an identity.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async addAccessRequestRecommendationsViewedItems(accessRequestRecommendationActionItemDtoBeta: Array<AccessRequestRecommendationActionItemDtoBeta>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccessRequestRecommendationActionItemResponseDtoBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAccessRequestRecommendationsViewedItems(accessRequestRecommendationActionItemDtoBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the access request recommendations for the specified identity. The default identity is *me* which indicates the current user.
         * @summary Identity Access Request Recommendations
         * @param {string} [identityId] Get access request recommendations for an identityId. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [includeTranslationMessages] If *true* it will populate a list of translation messages in the response.
         * @param {string} [filters] Filter recommendations using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **access.name**: *co*  **access.type**: *eq, in*  **access.description**: *co*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.name, access.type**  By default the recommendations are sorted by highest confidence first.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessRequestRecommendations(identityId?: string, limit?: number, offset?: number, count?: boolean, includeTranslationMessages?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccessRequestRecommendationItemDetailBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessRequestRecommendations(identityId, limit, offset, count, includeTranslationMessages, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the list of ignored access request recommendations.
         * @summary List of Ignored Access Request Recommendations
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter recommendations using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **access.id**: *eq, in*  **access.type**: *eq, in*  **identityId**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.id, access.type, identityId, timestamp**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessRequestRecommendationsIgnoredItems(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccessRequestRecommendationActionItemResponseDtoBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessRequestRecommendationsIgnoredItems(limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of requested access request recommendations.
         * @summary List of Requested Access Request Recommendations
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter recommendations using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **access.id**: *eq, in*  **access.type**: *eq, in*  **identityId**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.id, access.type, identityId, timestamp**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessRequestRecommendationsRequestedItems(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccessRequestRecommendationActionItemResponseDtoBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessRequestRecommendationsRequestedItems(limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the list of viewed access request recommendations.
         * @summary List of Viewed Access Request Recommendations
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter recommendations using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **access.id**: *eq, in*  **access.type**: *eq, in*  **identityId**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.id, access.type, identityId, timestamp**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessRequestRecommendationsViewedItems(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccessRequestRecommendationActionItemResponseDtoBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessRequestRecommendationsViewedItems(limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The getMessageCatalogs API returns message catalog based on the language headers in the requested object.
         * @summary Get Message catalogs
         * @param {'recommender' | 'access-request-recommender'} catalogId The ID of the message catalog.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getMessageCatalogs(catalogId: 'recommender' | 'access-request-recommender', axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MessageCatalogDtoBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessageCatalogs(catalogId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IAIAccessRequestRecommendationsBetaApi - factory interface
 * @export
 */
export const IAIAccessRequestRecommendationsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IAIAccessRequestRecommendationsBetaApiFp(configuration)
    return {
        /**
         * This API ignores a recommended access request item. Once an item is ignored, it will be marked as ignored=true if it is still a recommended item. The consumer can decide to hide ignored recommendations.
         * @summary Notification of Ignored Access Request Recommendations
         * @param {AccessRequestRecommendationActionItemDtoBeta} accessRequestRecommendationActionItemDtoBeta The recommended access item to ignore for an identity.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        addAccessRequestRecommendationsIgnoredItem(accessRequestRecommendationActionItemDtoBeta: AccessRequestRecommendationActionItemDtoBeta, axiosOptions?: any): AxiosPromise<AccessRequestRecommendationActionItemResponseDtoBeta> {
            return localVarFp.addAccessRequestRecommendationsIgnoredItem(accessRequestRecommendationActionItemDtoBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API consumes a notification that a recommended access request item was requested. This API does not actually make the request, it is just a notification. This will help provide feedback in order to improve our recommendations.
         * @summary Notification of Requested Access Request Recommendations
         * @param {AccessRequestRecommendationActionItemDtoBeta} accessRequestRecommendationActionItemDtoBeta The recommended access item that was requested for an identity.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        addAccessRequestRecommendationsRequestedItem(accessRequestRecommendationActionItemDtoBeta: AccessRequestRecommendationActionItemDtoBeta, axiosOptions?: any): AxiosPromise<AccessRequestRecommendationActionItemResponseDtoBeta> {
            return localVarFp.addAccessRequestRecommendationsRequestedItem(accessRequestRecommendationActionItemDtoBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API consumes a notification that a recommended access request item was viewed. Future recommendations with this item will be marked with viewed=true. This can be useful for the consumer to determine if there are any new/unviewed recommendations.
         * @summary Notification of Viewed Access Request Recommendations
         * @param {AccessRequestRecommendationActionItemDtoBeta} accessRequestRecommendationActionItemDtoBeta The recommended access that was viewed for an identity.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        addAccessRequestRecommendationsViewedItem(accessRequestRecommendationActionItemDtoBeta: AccessRequestRecommendationActionItemDtoBeta, axiosOptions?: any): AxiosPromise<AccessRequestRecommendationActionItemResponseDtoBeta> {
            return localVarFp.addAccessRequestRecommendationsViewedItem(accessRequestRecommendationActionItemDtoBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API consumes a notification that a set of recommended access request item were viewed. Future recommendations with these items will be marked with viewed=true. This can be useful for the consumer to determine if there are any new/unviewed recommendations.
         * @summary Notification of Viewed Access Request Recommendations in Bulk
         * @param {Array<AccessRequestRecommendationActionItemDtoBeta>} accessRequestRecommendationActionItemDtoBeta The recommended access items that were viewed for an identity.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        addAccessRequestRecommendationsViewedItems(accessRequestRecommendationActionItemDtoBeta: Array<AccessRequestRecommendationActionItemDtoBeta>, axiosOptions?: any): AxiosPromise<Array<AccessRequestRecommendationActionItemResponseDtoBeta>> {
            return localVarFp.addAccessRequestRecommendationsViewedItems(accessRequestRecommendationActionItemDtoBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the access request recommendations for the specified identity. The default identity is *me* which indicates the current user.
         * @summary Identity Access Request Recommendations
         * @param {string} [identityId] Get access request recommendations for an identityId. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [includeTranslationMessages] If *true* it will populate a list of translation messages in the response.
         * @param {string} [filters] Filter recommendations using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **access.name**: *co*  **access.type**: *eq, in*  **access.description**: *co*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.name, access.type**  By default the recommendations are sorted by highest confidence first.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestRecommendations(identityId?: string, limit?: number, offset?: number, count?: boolean, includeTranslationMessages?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<AccessRequestRecommendationItemDetailBeta>> {
            return localVarFp.getAccessRequestRecommendations(identityId, limit, offset, count, includeTranslationMessages, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the list of ignored access request recommendations.
         * @summary List of Ignored Access Request Recommendations
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter recommendations using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **access.id**: *eq, in*  **access.type**: *eq, in*  **identityId**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.id, access.type, identityId, timestamp**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestRecommendationsIgnoredItems(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<AccessRequestRecommendationActionItemResponseDtoBeta>> {
            return localVarFp.getAccessRequestRecommendationsIgnoredItems(limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of requested access request recommendations.
         * @summary List of Requested Access Request Recommendations
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter recommendations using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **access.id**: *eq, in*  **access.type**: *eq, in*  **identityId**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.id, access.type, identityId, timestamp**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestRecommendationsRequestedItems(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<AccessRequestRecommendationActionItemResponseDtoBeta>> {
            return localVarFp.getAccessRequestRecommendationsRequestedItems(limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the list of viewed access request recommendations.
         * @summary List of Viewed Access Request Recommendations
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter recommendations using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **access.id**: *eq, in*  **access.type**: *eq, in*  **identityId**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.id, access.type, identityId, timestamp**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestRecommendationsViewedItems(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<AccessRequestRecommendationActionItemResponseDtoBeta>> {
            return localVarFp.getAccessRequestRecommendationsViewedItems(limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * The getMessageCatalogs API returns message catalog based on the language headers in the requested object.
         * @summary Get Message catalogs
         * @param {'recommender' | 'access-request-recommender'} catalogId The ID of the message catalog.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getMessageCatalogs(catalogId: 'recommender' | 'access-request-recommender', axiosOptions?: any): AxiosPromise<Array<MessageCatalogDtoBeta>> {
            return localVarFp.getMessageCatalogs(catalogId, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addAccessRequestRecommendationsIgnoredItem operation in IAIAccessRequestRecommendationsBetaApi.
 * @export
 * @interface IAIAccessRequestRecommendationsBetaApiAddAccessRequestRecommendationsIgnoredItemRequest
 */
export interface IAIAccessRequestRecommendationsBetaApiAddAccessRequestRecommendationsIgnoredItemRequest {
    /**
     * The recommended access item to ignore for an identity.
     * @type {AccessRequestRecommendationActionItemDtoBeta}
     * @memberof IAIAccessRequestRecommendationsBetaApiAddAccessRequestRecommendationsIgnoredItem
     */
    readonly accessRequestRecommendationActionItemDtoBeta: AccessRequestRecommendationActionItemDtoBeta
}

/**
 * Request parameters for addAccessRequestRecommendationsRequestedItem operation in IAIAccessRequestRecommendationsBetaApi.
 * @export
 * @interface IAIAccessRequestRecommendationsBetaApiAddAccessRequestRecommendationsRequestedItemRequest
 */
export interface IAIAccessRequestRecommendationsBetaApiAddAccessRequestRecommendationsRequestedItemRequest {
    /**
     * The recommended access item that was requested for an identity.
     * @type {AccessRequestRecommendationActionItemDtoBeta}
     * @memberof IAIAccessRequestRecommendationsBetaApiAddAccessRequestRecommendationsRequestedItem
     */
    readonly accessRequestRecommendationActionItemDtoBeta: AccessRequestRecommendationActionItemDtoBeta
}

/**
 * Request parameters for addAccessRequestRecommendationsViewedItem operation in IAIAccessRequestRecommendationsBetaApi.
 * @export
 * @interface IAIAccessRequestRecommendationsBetaApiAddAccessRequestRecommendationsViewedItemRequest
 */
export interface IAIAccessRequestRecommendationsBetaApiAddAccessRequestRecommendationsViewedItemRequest {
    /**
     * The recommended access that was viewed for an identity.
     * @type {AccessRequestRecommendationActionItemDtoBeta}
     * @memberof IAIAccessRequestRecommendationsBetaApiAddAccessRequestRecommendationsViewedItem
     */
    readonly accessRequestRecommendationActionItemDtoBeta: AccessRequestRecommendationActionItemDtoBeta
}

/**
 * Request parameters for addAccessRequestRecommendationsViewedItems operation in IAIAccessRequestRecommendationsBetaApi.
 * @export
 * @interface IAIAccessRequestRecommendationsBetaApiAddAccessRequestRecommendationsViewedItemsRequest
 */
export interface IAIAccessRequestRecommendationsBetaApiAddAccessRequestRecommendationsViewedItemsRequest {
    /**
     * The recommended access items that were viewed for an identity.
     * @type {Array<AccessRequestRecommendationActionItemDtoBeta>}
     * @memberof IAIAccessRequestRecommendationsBetaApiAddAccessRequestRecommendationsViewedItems
     */
    readonly accessRequestRecommendationActionItemDtoBeta: Array<AccessRequestRecommendationActionItemDtoBeta>
}

/**
 * Request parameters for getAccessRequestRecommendations operation in IAIAccessRequestRecommendationsBetaApi.
 * @export
 * @interface IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendationsRequest
 */
export interface IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendationsRequest {
    /**
     * Get access request recommendations for an identityId. *me* indicates the current user.
     * @type {string}
     * @memberof IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendations
     */
    readonly identityId?: string

    /**
     * Max number of results to return.
     * @type {number}
     * @memberof IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendations
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendations
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendations
     */
    readonly count?: boolean

    /**
     * If *true* it will populate a list of translation messages in the response.
     * @type {boolean}
     * @memberof IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendations
     */
    readonly includeTranslationMessages?: boolean

    /**
     * Filter recommendations using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **access.name**: *co*  **access.type**: *eq, in*  **access.description**: *co*
     * @type {string}
     * @memberof IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendations
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.name, access.type**  By default the recommendations are sorted by highest confidence first.
     * @type {string}
     * @memberof IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendations
     */
    readonly sorters?: string
}

/**
 * Request parameters for getAccessRequestRecommendationsIgnoredItems operation in IAIAccessRequestRecommendationsBetaApi.
 * @export
 * @interface IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendationsIgnoredItemsRequest
 */
export interface IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendationsIgnoredItemsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendationsIgnoredItems
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendationsIgnoredItems
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendationsIgnoredItems
     */
    readonly count?: boolean

    /**
     * Filter recommendations using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **access.id**: *eq, in*  **access.type**: *eq, in*  **identityId**: *eq, in*
     * @type {string}
     * @memberof IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendationsIgnoredItems
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.id, access.type, identityId, timestamp**
     * @type {string}
     * @memberof IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendationsIgnoredItems
     */
    readonly sorters?: string
}

/**
 * Request parameters for getAccessRequestRecommendationsRequestedItems operation in IAIAccessRequestRecommendationsBetaApi.
 * @export
 * @interface IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendationsRequestedItemsRequest
 */
export interface IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendationsRequestedItemsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendationsRequestedItems
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendationsRequestedItems
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendationsRequestedItems
     */
    readonly count?: boolean

    /**
     * Filter recommendations using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **access.id**: *eq, in*  **access.type**: *eq, in*  **identityId**: *eq, in*
     * @type {string}
     * @memberof IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendationsRequestedItems
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.id, access.type, identityId, timestamp**
     * @type {string}
     * @memberof IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendationsRequestedItems
     */
    readonly sorters?: string
}

/**
 * Request parameters for getAccessRequestRecommendationsViewedItems operation in IAIAccessRequestRecommendationsBetaApi.
 * @export
 * @interface IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendationsViewedItemsRequest
 */
export interface IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendationsViewedItemsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendationsViewedItems
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendationsViewedItems
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendationsViewedItems
     */
    readonly count?: boolean

    /**
     * Filter recommendations using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **access.id**: *eq, in*  **access.type**: *eq, in*  **identityId**: *eq, in*
     * @type {string}
     * @memberof IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendationsViewedItems
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.id, access.type, identityId, timestamp**
     * @type {string}
     * @memberof IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendationsViewedItems
     */
    readonly sorters?: string
}

/**
 * Request parameters for getMessageCatalogs operation in IAIAccessRequestRecommendationsBetaApi.
 * @export
 * @interface IAIAccessRequestRecommendationsBetaApiGetMessageCatalogsRequest
 */
export interface IAIAccessRequestRecommendationsBetaApiGetMessageCatalogsRequest {
    /**
     * The ID of the message catalog.
     * @type {'recommender' | 'access-request-recommender'}
     * @memberof IAIAccessRequestRecommendationsBetaApiGetMessageCatalogs
     */
    readonly catalogId: 'recommender' | 'access-request-recommender'
}

/**
 * IAIAccessRequestRecommendationsBetaApi - object-oriented interface
 * @export
 * @class IAIAccessRequestRecommendationsBetaApi
 * @extends {BaseAPI}
 */
export class IAIAccessRequestRecommendationsBetaApi extends BaseAPI {
    /**
     * This API ignores a recommended access request item. Once an item is ignored, it will be marked as ignored=true if it is still a recommended item. The consumer can decide to hide ignored recommendations.
     * @summary Notification of Ignored Access Request Recommendations
     * @param {IAIAccessRequestRecommendationsBetaApiAddAccessRequestRecommendationsIgnoredItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIAccessRequestRecommendationsBetaApi
     */
    public addAccessRequestRecommendationsIgnoredItem(requestParameters: IAIAccessRequestRecommendationsBetaApiAddAccessRequestRecommendationsIgnoredItemRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIAccessRequestRecommendationsBetaApiFp(this.configuration).addAccessRequestRecommendationsIgnoredItem(requestParameters.accessRequestRecommendationActionItemDtoBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API consumes a notification that a recommended access request item was requested. This API does not actually make the request, it is just a notification. This will help provide feedback in order to improve our recommendations.
     * @summary Notification of Requested Access Request Recommendations
     * @param {IAIAccessRequestRecommendationsBetaApiAddAccessRequestRecommendationsRequestedItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIAccessRequestRecommendationsBetaApi
     */
    public addAccessRequestRecommendationsRequestedItem(requestParameters: IAIAccessRequestRecommendationsBetaApiAddAccessRequestRecommendationsRequestedItemRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIAccessRequestRecommendationsBetaApiFp(this.configuration).addAccessRequestRecommendationsRequestedItem(requestParameters.accessRequestRecommendationActionItemDtoBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API consumes a notification that a recommended access request item was viewed. Future recommendations with this item will be marked with viewed=true. This can be useful for the consumer to determine if there are any new/unviewed recommendations.
     * @summary Notification of Viewed Access Request Recommendations
     * @param {IAIAccessRequestRecommendationsBetaApiAddAccessRequestRecommendationsViewedItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIAccessRequestRecommendationsBetaApi
     */
    public addAccessRequestRecommendationsViewedItem(requestParameters: IAIAccessRequestRecommendationsBetaApiAddAccessRequestRecommendationsViewedItemRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIAccessRequestRecommendationsBetaApiFp(this.configuration).addAccessRequestRecommendationsViewedItem(requestParameters.accessRequestRecommendationActionItemDtoBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API consumes a notification that a set of recommended access request item were viewed. Future recommendations with these items will be marked with viewed=true. This can be useful for the consumer to determine if there are any new/unviewed recommendations.
     * @summary Notification of Viewed Access Request Recommendations in Bulk
     * @param {IAIAccessRequestRecommendationsBetaApiAddAccessRequestRecommendationsViewedItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIAccessRequestRecommendationsBetaApi
     */
    public addAccessRequestRecommendationsViewedItems(requestParameters: IAIAccessRequestRecommendationsBetaApiAddAccessRequestRecommendationsViewedItemsRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIAccessRequestRecommendationsBetaApiFp(this.configuration).addAccessRequestRecommendationsViewedItems(requestParameters.accessRequestRecommendationActionItemDtoBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the access request recommendations for the specified identity. The default identity is *me* which indicates the current user.
     * @summary Identity Access Request Recommendations
     * @param {IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIAccessRequestRecommendationsBetaApi
     */
    public getAccessRequestRecommendations(requestParameters: IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendationsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return IAIAccessRequestRecommendationsBetaApiFp(this.configuration).getAccessRequestRecommendations(requestParameters.identityId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.includeTranslationMessages, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the list of ignored access request recommendations.
     * @summary List of Ignored Access Request Recommendations
     * @param {IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendationsIgnoredItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIAccessRequestRecommendationsBetaApi
     */
    public getAccessRequestRecommendationsIgnoredItems(requestParameters: IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendationsIgnoredItemsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return IAIAccessRequestRecommendationsBetaApiFp(this.configuration).getAccessRequestRecommendationsIgnoredItems(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of requested access request recommendations.
     * @summary List of Requested Access Request Recommendations
     * @param {IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendationsRequestedItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIAccessRequestRecommendationsBetaApi
     */
    public getAccessRequestRecommendationsRequestedItems(requestParameters: IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendationsRequestedItemsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return IAIAccessRequestRecommendationsBetaApiFp(this.configuration).getAccessRequestRecommendationsRequestedItems(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the list of viewed access request recommendations.
     * @summary List of Viewed Access Request Recommendations
     * @param {IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendationsViewedItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIAccessRequestRecommendationsBetaApi
     */
    public getAccessRequestRecommendationsViewedItems(requestParameters: IAIAccessRequestRecommendationsBetaApiGetAccessRequestRecommendationsViewedItemsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return IAIAccessRequestRecommendationsBetaApiFp(this.configuration).getAccessRequestRecommendationsViewedItems(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The getMessageCatalogs API returns message catalog based on the language headers in the requested object.
     * @summary Get Message catalogs
     * @param {IAIAccessRequestRecommendationsBetaApiGetMessageCatalogsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIAccessRequestRecommendationsBetaApi
     */
    public getMessageCatalogs(requestParameters: IAIAccessRequestRecommendationsBetaApiGetMessageCatalogsRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIAccessRequestRecommendationsBetaApiFp(this.configuration).getMessageCatalogs(requestParameters.catalogId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IAICommonAccessBetaApi - axios parameter creator
 * @export
 */
export const IAICommonAccessBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API is used to add roles/access profiles to the list of common access for a customer. Requires authorization scope of iai:access-modeling:create
         * @summary Create common access items
         * @param {CommonAccessItemRequestBeta} commonAccessItemRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCommonAccess: async (commonAccessItemRequestBeta: CommonAccessItemRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commonAccessItemRequestBeta' is not null or undefined
            assertParamExists('createCommonAccess', 'commonAccessItemRequestBeta', commonAccessItemRequestBeta)
            const localVarPath = `/common-access`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commonAccessItemRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns the current common access for a customer. The returned items can be filtered and sorted. Requires authorization scope of iai:access-modeling:read
         * @summary Get a paginated list of common access
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407)  Filtering is supported for the following fields and operators:  **status**: *eq* \&quot;CONFIRMED\&quot; or \&quot;DENIED\&quot; **reviewedByUser** *eq* true or false **access.id**: *eq* \&quot;id\&quot; **access.type**: *eq* \&quot;ROLE\&quot; or \&quot;ACCESS_PROFILE\&quot; **access.name**: *sw* \&quot;Administrator\&quot; **access.description**: *sw* \&quot;admin\&quot;
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407)  Sorting is supported for the following fields: **access.name,status**  By default the common access items are sorted by name, ascending.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCommonAccess: async (offset?: number, limit?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/common-access`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This submits an update request to the common access application. At this time there are no parameters. Requires authorization scope of iai:access-modeling:update
         * @summary Bulk update common access status
         * @param {Array<CommonAccessIDStatusBeta>} commonAccessIDStatusBeta Confirm or deny in bulk the common access ids that are (or aren\&#39;t) common access
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateCommonAccessStatusInBulk: async (commonAccessIDStatusBeta: Array<CommonAccessIDStatusBeta>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commonAccessIDStatusBeta' is not null or undefined
            assertParamExists('updateCommonAccessStatusInBulk', 'commonAccessIDStatusBeta', commonAccessIDStatusBeta)
            const localVarPath = `/common-access/update-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commonAccessIDStatusBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * IAICommonAccessBetaApi - functional programming interface
 * @export
 */
export const IAICommonAccessBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IAICommonAccessBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This API is used to add roles/access profiles to the list of common access for a customer. Requires authorization scope of iai:access-modeling:create
         * @summary Create common access items
         * @param {CommonAccessItemRequestBeta} commonAccessItemRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createCommonAccess(commonAccessItemRequestBeta: CommonAccessItemRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonAccessItemResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCommonAccess(commonAccessItemRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns the current common access for a customer. The returned items can be filtered and sorted. Requires authorization scope of iai:access-modeling:read
         * @summary Get a paginated list of common access
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407)  Filtering is supported for the following fields and operators:  **status**: *eq* \&quot;CONFIRMED\&quot; or \&quot;DENIED\&quot; **reviewedByUser** *eq* true or false **access.id**: *eq* \&quot;id\&quot; **access.type**: *eq* \&quot;ROLE\&quot; or \&quot;ACCESS_PROFILE\&quot; **access.name**: *sw* \&quot;Administrator\&quot; **access.description**: *sw* \&quot;admin\&quot;
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407)  Sorting is supported for the following fields: **access.name,status**  By default the common access items are sorted by name, ascending.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCommonAccess(offset?: number, limit?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommonAccessResponseBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommonAccess(offset, limit, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This submits an update request to the common access application. At this time there are no parameters. Requires authorization scope of iai:access-modeling:update
         * @summary Bulk update common access status
         * @param {Array<CommonAccessIDStatusBeta>} commonAccessIDStatusBeta Confirm or deny in bulk the common access ids that are (or aren\&#39;t) common access
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateCommonAccessStatusInBulk(commonAccessIDStatusBeta: Array<CommonAccessIDStatusBeta>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCommonAccessStatusInBulk(commonAccessIDStatusBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IAICommonAccessBetaApi - factory interface
 * @export
 */
export const IAICommonAccessBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IAICommonAccessBetaApiFp(configuration)
    return {
        /**
         * This API is used to add roles/access profiles to the list of common access for a customer. Requires authorization scope of iai:access-modeling:create
         * @summary Create common access items
         * @param {CommonAccessItemRequestBeta} commonAccessItemRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCommonAccess(commonAccessItemRequestBeta: CommonAccessItemRequestBeta, axiosOptions?: any): AxiosPromise<CommonAccessItemResponseBeta> {
            return localVarFp.createCommonAccess(commonAccessItemRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns the current common access for a customer. The returned items can be filtered and sorted. Requires authorization scope of iai:access-modeling:read
         * @summary Get a paginated list of common access
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407)  Filtering is supported for the following fields and operators:  **status**: *eq* \&quot;CONFIRMED\&quot; or \&quot;DENIED\&quot; **reviewedByUser** *eq* true or false **access.id**: *eq* \&quot;id\&quot; **access.type**: *eq* \&quot;ROLE\&quot; or \&quot;ACCESS_PROFILE\&quot; **access.name**: *sw* \&quot;Administrator\&quot; **access.description**: *sw* \&quot;admin\&quot;
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407)  Sorting is supported for the following fields: **access.name,status**  By default the common access items are sorted by name, ascending.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCommonAccess(offset?: number, limit?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<CommonAccessResponseBeta>> {
            return localVarFp.getCommonAccess(offset, limit, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This submits an update request to the common access application. At this time there are no parameters. Requires authorization scope of iai:access-modeling:update
         * @summary Bulk update common access status
         * @param {Array<CommonAccessIDStatusBeta>} commonAccessIDStatusBeta Confirm or deny in bulk the common access ids that are (or aren\&#39;t) common access
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateCommonAccessStatusInBulk(commonAccessIDStatusBeta: Array<CommonAccessIDStatusBeta>, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.updateCommonAccessStatusInBulk(commonAccessIDStatusBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCommonAccess operation in IAICommonAccessBetaApi.
 * @export
 * @interface IAICommonAccessBetaApiCreateCommonAccessRequest
 */
export interface IAICommonAccessBetaApiCreateCommonAccessRequest {
    /**
     * 
     * @type {CommonAccessItemRequestBeta}
     * @memberof IAICommonAccessBetaApiCreateCommonAccess
     */
    readonly commonAccessItemRequestBeta: CommonAccessItemRequestBeta
}

/**
 * Request parameters for getCommonAccess operation in IAICommonAccessBetaApi.
 * @export
 * @interface IAICommonAccessBetaApiGetCommonAccessRequest
 */
export interface IAICommonAccessBetaApiGetCommonAccessRequest {
    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IAICommonAccessBetaApiGetCommonAccess
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IAICommonAccessBetaApiGetCommonAccess
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IAICommonAccessBetaApiGetCommonAccess
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407)  Filtering is supported for the following fields and operators:  **status**: *eq* \&quot;CONFIRMED\&quot; or \&quot;DENIED\&quot; **reviewedByUser** *eq* true or false **access.id**: *eq* \&quot;id\&quot; **access.type**: *eq* \&quot;ROLE\&quot; or \&quot;ACCESS_PROFILE\&quot; **access.name**: *sw* \&quot;Administrator\&quot; **access.description**: *sw* \&quot;admin\&quot;
     * @type {string}
     * @memberof IAICommonAccessBetaApiGetCommonAccess
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407)  Sorting is supported for the following fields: **access.name,status**  By default the common access items are sorted by name, ascending.
     * @type {string}
     * @memberof IAICommonAccessBetaApiGetCommonAccess
     */
    readonly sorters?: string
}

/**
 * Request parameters for updateCommonAccessStatusInBulk operation in IAICommonAccessBetaApi.
 * @export
 * @interface IAICommonAccessBetaApiUpdateCommonAccessStatusInBulkRequest
 */
export interface IAICommonAccessBetaApiUpdateCommonAccessStatusInBulkRequest {
    /**
     * Confirm or deny in bulk the common access ids that are (or aren\&#39;t) common access
     * @type {Array<CommonAccessIDStatusBeta>}
     * @memberof IAICommonAccessBetaApiUpdateCommonAccessStatusInBulk
     */
    readonly commonAccessIDStatusBeta: Array<CommonAccessIDStatusBeta>
}

/**
 * IAICommonAccessBetaApi - object-oriented interface
 * @export
 * @class IAICommonAccessBetaApi
 * @extends {BaseAPI}
 */
export class IAICommonAccessBetaApi extends BaseAPI {
    /**
     * This API is used to add roles/access profiles to the list of common access for a customer. Requires authorization scope of iai:access-modeling:create
     * @summary Create common access items
     * @param {IAICommonAccessBetaApiCreateCommonAccessRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAICommonAccessBetaApi
     */
    public createCommonAccess(requestParameters: IAICommonAccessBetaApiCreateCommonAccessRequest, axiosOptions?: AxiosRequestConfig) {
        return IAICommonAccessBetaApiFp(this.configuration).createCommonAccess(requestParameters.commonAccessItemRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns the current common access for a customer. The returned items can be filtered and sorted. Requires authorization scope of iai:access-modeling:read
     * @summary Get a paginated list of common access
     * @param {IAICommonAccessBetaApiGetCommonAccessRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAICommonAccessBetaApi
     */
    public getCommonAccess(requestParameters: IAICommonAccessBetaApiGetCommonAccessRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return IAICommonAccessBetaApiFp(this.configuration).getCommonAccess(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This submits an update request to the common access application. At this time there are no parameters. Requires authorization scope of iai:access-modeling:update
     * @summary Bulk update common access status
     * @param {IAICommonAccessBetaApiUpdateCommonAccessStatusInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAICommonAccessBetaApi
     */
    public updateCommonAccessStatusInBulk(requestParameters: IAICommonAccessBetaApiUpdateCommonAccessStatusInBulkRequest, axiosOptions?: AxiosRequestConfig) {
        return IAICommonAccessBetaApiFp(this.configuration).updateCommonAccessStatusInBulk(requestParameters.commonAccessIDStatusBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IAIOutliersBetaApi - axios parameter creator
 * @export
 */
export const IAIOutliersBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API exports a list of ignored outliers to a CSV as well as list of non-ignored outliers to a CSV. These two CSVs will be zipped and exported Columns will include: identityID, type, firstDetectionDate, latestDetectionDate, ignored, & attributes (defined set of identity attributes) Requires authorization scope of \'iai:outliers-management:read\'
         * @summary IAI Identity Outliers Export
         * @param {'LOW_SIMILARITY' | 'STRUCTURAL'} [type] Type of the identity outliers snapshot to filter on
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportOutliersZip: async (type?: 'LOW_SIMILARITY' | 'STRUCTURAL', axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/outliers/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API receives a summary containing: the number of identities that customer has, the number of outliers, and the type of outlier Requires authorization scope of \'iai:outliers-management:read\'
         * @summary IAI Identity Outliers Summary
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {'LOW_SIMILARITY' | 'STRUCTURAL'} [type] Type of the identity outliers snapshot to filter on
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following field and operators:  **snapshotDate**: *ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following field: **snapshotDate**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityOutlierSnapshots: async (limit?: number, offset?: number, type?: 'LOW_SIMILARITY' | 'STRUCTURAL', filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/outlier-summaries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API receives a list of outliers, containing data such as: identityId, outlier type, detection dates, identity attributes, if identity is ignore, and certification information Requires authorization scope of \'iai:outliers-management:read\'
         * @summary IAI Get Identity Outliers
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {'LOW_SIMILARITY' | 'STRUCTURAL'} [type] Type of the identity outliers snapshot to filter on
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following Entitlement fields and operators: **attributes**: *eq, sw, co, in*  **firstDetectionDate**: *ge, le*  **certStatus**: *eq*  **ignored**: *eq*  **score**: *ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **firstDetectionDate, attributes, score**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityOutliers: async (limit?: number, offset?: number, count?: boolean, type?: 'LOW_SIMILARITY' | 'STRUCTURAL', filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/outliers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a most recent snapshot of each outlier type, each containing: the number of identities that customer has, the number of outliers, and the type of outlier Requires authorization scope of \'iai:outliers-management:read\'
         * @summary IAI Identity Outliers Latest Summary
         * @param {'LOW_SIMILARITY' | 'STRUCTURAL'} [type] Type of the identity outliers snapshot to filter on
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLatestIdentityOutlierSnapshots: async (type?: 'LOW_SIMILARITY' | 'STRUCTURAL', axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/outlier-summaries/latest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a summary of a contributing feature for an identity outlier. The object contains: contributing feature name (translated text or message key), identity outlier display name, feature values, feature definition and explanation (translated text or message key), peer display name and identityId, access item reference, translation messages object Requires authorization scope of \'iai:outliers-management:read\'
         * @summary Get identity outlier contibuting feature summary
         * @param {string} outlierFeatureId Contributing feature id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getOutlierContributingFeatureSummary: async (outlierFeatureId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'outlierFeatureId' is not null or undefined
            assertParamExists('getOutlierContributingFeatureSummary', 'outlierFeatureId', outlierFeatureId)
            const localVarPath = `/outlier-feature-summaries/{outlierFeatureId}`
                .replace(`{${"outlierFeatureId"}}`, encodeURIComponent(String(outlierFeatureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of contributing feature objects for a single outlier. The object contains: feature name, feature value type, value, importance, display name (translated text or message key), description (translated text or message key), translation messages object Requires authorization scope of \'iai:outliers-management:read\'
         * @summary Get identity outlier\'s contibuting features
         * @param {string} outlierId The outlier id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [includeTranslationMessages] Whether or not to include translation messages object in returned response
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **importance**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPeerGroupOutliersContributingFeatures: async (outlierId: string, limit?: number, offset?: number, count?: boolean, includeTranslationMessages?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'outlierId' is not null or undefined
            assertParamExists('getPeerGroupOutliersContributingFeatures', 'outlierId', outlierId)
            const localVarPath = `/outliers/{outlierId}/contributing-features`
                .replace(`{${"outlierId"}}`, encodeURIComponent(String(outlierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (includeTranslationMessages !== undefined) {
                localVarQueryParameter['include-translation-messages'] = includeTranslationMessages;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API receives a list of IdentityIDs in the request, changes the outliers to be ignored--returning a 204 if successful. Requires authorization scope of \'iai:outliers-management:update\'
         * @summary IAI Identity Outliers Ignore
         * @param {Array<string>} requestBody 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        ignoreIdentityOutliers: async (requestBody: Array<string>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('ignoreIdentityOutliers', 'requestBody', requestBody)
            const localVarPath = `/outliers/ignore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of the enriched access items associated with each feature filtered by the access item type  The object contains: accessItemId, display name (translated text or message key), description (translated text or message key), accessType, sourceName, extremelyRare Requires authorization scope of \'iai:outliers-management:read\'
         * @summary Gets a list of access items associated with each identity outlier contributing feature
         * @param {string} outlierId The outlier id
         * @param {'radical_entitlement_count' | 'entitlement_count' | 'max_jaccard_similarity' | 'mean_max_bundle_concurrency' | 'single_entitlement_bundle_count' | 'peerless_score'} contributingFeatureName The name of contributing feature
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [accessType] The type of access item for the identity outlier contributing feature. If not provided, it returns all
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **displayName**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listOutliersContributingFeatureAccessItems: async (outlierId: string, contributingFeatureName: 'radical_entitlement_count' | 'entitlement_count' | 'max_jaccard_similarity' | 'mean_max_bundle_concurrency' | 'single_entitlement_bundle_count' | 'peerless_score', limit?: number, offset?: number, count?: boolean, accessType?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'outlierId' is not null or undefined
            assertParamExists('listOutliersContributingFeatureAccessItems', 'outlierId', outlierId)
            // verify required parameter 'contributingFeatureName' is not null or undefined
            assertParamExists('listOutliersContributingFeatureAccessItems', 'contributingFeatureName', contributingFeatureName)
            const localVarPath = `/outliers/{outlierId}/feature-details/{contributingFeatureName}/access-items`
                .replace(`{${"outlierId"}}`, encodeURIComponent(String(outlierId)))
                .replace(`{${"contributingFeatureName"}}`, encodeURIComponent(String(contributingFeatureName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (accessType !== undefined) {
                localVarQueryParameter['accessType'] = accessType;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API receives a list of IdentityIDs in the request, changes the outliers to be un-ignored--returning a 204 if successful. Requires authorization scope of \'iai:outliers-management:update\'
         * @summary IAI Identity Outliers Unignore
         * @param {Array<string>} requestBody 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        unIgnoreIdentityOutliers: async (requestBody: Array<string>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('unIgnoreIdentityOutliers', 'requestBody', requestBody)
            const localVarPath = `/outliers/unignore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * IAIOutliersBetaApi - functional programming interface
 * @export
 */
export const IAIOutliersBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IAIOutliersBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This API exports a list of ignored outliers to a CSV as well as list of non-ignored outliers to a CSV. These two CSVs will be zipped and exported Columns will include: identityID, type, firstDetectionDate, latestDetectionDate, ignored, & attributes (defined set of identity attributes) Requires authorization scope of \'iai:outliers-management:read\'
         * @summary IAI Identity Outliers Export
         * @param {'LOW_SIMILARITY' | 'STRUCTURAL'} [type] Type of the identity outliers snapshot to filter on
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async exportOutliersZip(type?: 'LOW_SIMILARITY' | 'STRUCTURAL', axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportOutliersZip(type, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API receives a summary containing: the number of identities that customer has, the number of outliers, and the type of outlier Requires authorization scope of \'iai:outliers-management:read\'
         * @summary IAI Identity Outliers Summary
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {'LOW_SIMILARITY' | 'STRUCTURAL'} [type] Type of the identity outliers snapshot to filter on
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following field and operators:  **snapshotDate**: *ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following field: **snapshotDate**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityOutlierSnapshots(limit?: number, offset?: number, type?: 'LOW_SIMILARITY' | 'STRUCTURAL', filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OutlierSummaryBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityOutlierSnapshots(limit, offset, type, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API receives a list of outliers, containing data such as: identityId, outlier type, detection dates, identity attributes, if identity is ignore, and certification information Requires authorization scope of \'iai:outliers-management:read\'
         * @summary IAI Get Identity Outliers
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {'LOW_SIMILARITY' | 'STRUCTURAL'} [type] Type of the identity outliers snapshot to filter on
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following Entitlement fields and operators: **attributes**: *eq, sw, co, in*  **firstDetectionDate**: *ge, le*  **certStatus**: *eq*  **ignored**: *eq*  **score**: *ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **firstDetectionDate, attributes, score**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityOutliers(limit?: number, offset?: number, count?: boolean, type?: 'LOW_SIMILARITY' | 'STRUCTURAL', filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OutlierBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityOutliers(limit, offset, count, type, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a most recent snapshot of each outlier type, each containing: the number of identities that customer has, the number of outliers, and the type of outlier Requires authorization scope of \'iai:outliers-management:read\'
         * @summary IAI Identity Outliers Latest Summary
         * @param {'LOW_SIMILARITY' | 'STRUCTURAL'} [type] Type of the identity outliers snapshot to filter on
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestIdentityOutlierSnapshots(type?: 'LOW_SIMILARITY' | 'STRUCTURAL', axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LatestOutlierSummaryBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestIdentityOutlierSnapshots(type, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a summary of a contributing feature for an identity outlier. The object contains: contributing feature name (translated text or message key), identity outlier display name, feature values, feature definition and explanation (translated text or message key), peer display name and identityId, access item reference, translation messages object Requires authorization scope of \'iai:outliers-management:read\'
         * @summary Get identity outlier contibuting feature summary
         * @param {string} outlierFeatureId Contributing feature id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getOutlierContributingFeatureSummary(outlierFeatureId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OutlierFeatureSummaryBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOutlierContributingFeatureSummary(outlierFeatureId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of contributing feature objects for a single outlier. The object contains: feature name, feature value type, value, importance, display name (translated text or message key), description (translated text or message key), translation messages object Requires authorization scope of \'iai:outliers-management:read\'
         * @summary Get identity outlier\'s contibuting features
         * @param {string} outlierId The outlier id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [includeTranslationMessages] Whether or not to include translation messages object in returned response
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **importance**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPeerGroupOutliersContributingFeatures(outlierId: string, limit?: number, offset?: number, count?: boolean, includeTranslationMessages?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OutlierContributingFeatureBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPeerGroupOutliersContributingFeatures(outlierId, limit, offset, count, includeTranslationMessages, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API receives a list of IdentityIDs in the request, changes the outliers to be ignored--returning a 204 if successful. Requires authorization scope of \'iai:outliers-management:update\'
         * @summary IAI Identity Outliers Ignore
         * @param {Array<string>} requestBody 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async ignoreIdentityOutliers(requestBody: Array<string>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ignoreIdentityOutliers(requestBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of the enriched access items associated with each feature filtered by the access item type  The object contains: accessItemId, display name (translated text or message key), description (translated text or message key), accessType, sourceName, extremelyRare Requires authorization scope of \'iai:outliers-management:read\'
         * @summary Gets a list of access items associated with each identity outlier contributing feature
         * @param {string} outlierId The outlier id
         * @param {'radical_entitlement_count' | 'entitlement_count' | 'max_jaccard_similarity' | 'mean_max_bundle_concurrency' | 'single_entitlement_bundle_count' | 'peerless_score'} contributingFeatureName The name of contributing feature
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [accessType] The type of access item for the identity outlier contributing feature. If not provided, it returns all
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **displayName**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listOutliersContributingFeatureAccessItems(outlierId: string, contributingFeatureName: 'radical_entitlement_count' | 'entitlement_count' | 'max_jaccard_similarity' | 'mean_max_bundle_concurrency' | 'single_entitlement_bundle_count' | 'peerless_score', limit?: number, offset?: number, count?: boolean, accessType?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OutliersContributingFeatureAccessItemsBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOutliersContributingFeatureAccessItems(outlierId, contributingFeatureName, limit, offset, count, accessType, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API receives a list of IdentityIDs in the request, changes the outliers to be un-ignored--returning a 204 if successful. Requires authorization scope of \'iai:outliers-management:update\'
         * @summary IAI Identity Outliers Unignore
         * @param {Array<string>} requestBody 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async unIgnoreIdentityOutliers(requestBody: Array<string>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unIgnoreIdentityOutliers(requestBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IAIOutliersBetaApi - factory interface
 * @export
 */
export const IAIOutliersBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IAIOutliersBetaApiFp(configuration)
    return {
        /**
         * This API exports a list of ignored outliers to a CSV as well as list of non-ignored outliers to a CSV. These two CSVs will be zipped and exported Columns will include: identityID, type, firstDetectionDate, latestDetectionDate, ignored, & attributes (defined set of identity attributes) Requires authorization scope of \'iai:outliers-management:read\'
         * @summary IAI Identity Outliers Export
         * @param {'LOW_SIMILARITY' | 'STRUCTURAL'} [type] Type of the identity outliers snapshot to filter on
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportOutliersZip(type?: 'LOW_SIMILARITY' | 'STRUCTURAL', axiosOptions?: any): AxiosPromise<any> {
            return localVarFp.exportOutliersZip(type, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API receives a summary containing: the number of identities that customer has, the number of outliers, and the type of outlier Requires authorization scope of \'iai:outliers-management:read\'
         * @summary IAI Identity Outliers Summary
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {'LOW_SIMILARITY' | 'STRUCTURAL'} [type] Type of the identity outliers snapshot to filter on
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following field and operators:  **snapshotDate**: *ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following field: **snapshotDate**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityOutlierSnapshots(limit?: number, offset?: number, type?: 'LOW_SIMILARITY' | 'STRUCTURAL', filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<OutlierSummaryBeta>> {
            return localVarFp.getIdentityOutlierSnapshots(limit, offset, type, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API receives a list of outliers, containing data such as: identityId, outlier type, detection dates, identity attributes, if identity is ignore, and certification information Requires authorization scope of \'iai:outliers-management:read\'
         * @summary IAI Get Identity Outliers
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {'LOW_SIMILARITY' | 'STRUCTURAL'} [type] Type of the identity outliers snapshot to filter on
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following Entitlement fields and operators: **attributes**: *eq, sw, co, in*  **firstDetectionDate**: *ge, le*  **certStatus**: *eq*  **ignored**: *eq*  **score**: *ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **firstDetectionDate, attributes, score**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityOutliers(limit?: number, offset?: number, count?: boolean, type?: 'LOW_SIMILARITY' | 'STRUCTURAL', filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<OutlierBeta>> {
            return localVarFp.getIdentityOutliers(limit, offset, count, type, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a most recent snapshot of each outlier type, each containing: the number of identities that customer has, the number of outliers, and the type of outlier Requires authorization scope of \'iai:outliers-management:read\'
         * @summary IAI Identity Outliers Latest Summary
         * @param {'LOW_SIMILARITY' | 'STRUCTURAL'} [type] Type of the identity outliers snapshot to filter on
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLatestIdentityOutlierSnapshots(type?: 'LOW_SIMILARITY' | 'STRUCTURAL', axiosOptions?: any): AxiosPromise<Array<LatestOutlierSummaryBeta>> {
            return localVarFp.getLatestIdentityOutlierSnapshots(type, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a summary of a contributing feature for an identity outlier. The object contains: contributing feature name (translated text or message key), identity outlier display name, feature values, feature definition and explanation (translated text or message key), peer display name and identityId, access item reference, translation messages object Requires authorization scope of \'iai:outliers-management:read\'
         * @summary Get identity outlier contibuting feature summary
         * @param {string} outlierFeatureId Contributing feature id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getOutlierContributingFeatureSummary(outlierFeatureId: string, axiosOptions?: any): AxiosPromise<OutlierFeatureSummaryBeta> {
            return localVarFp.getOutlierContributingFeatureSummary(outlierFeatureId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of contributing feature objects for a single outlier. The object contains: feature name, feature value type, value, importance, display name (translated text or message key), description (translated text or message key), translation messages object Requires authorization scope of \'iai:outliers-management:read\'
         * @summary Get identity outlier\'s contibuting features
         * @param {string} outlierId The outlier id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [includeTranslationMessages] Whether or not to include translation messages object in returned response
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **importance**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPeerGroupOutliersContributingFeatures(outlierId: string, limit?: number, offset?: number, count?: boolean, includeTranslationMessages?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<OutlierContributingFeatureBeta>> {
            return localVarFp.getPeerGroupOutliersContributingFeatures(outlierId, limit, offset, count, includeTranslationMessages, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API receives a list of IdentityIDs in the request, changes the outliers to be ignored--returning a 204 if successful. Requires authorization scope of \'iai:outliers-management:update\'
         * @summary IAI Identity Outliers Ignore
         * @param {Array<string>} requestBody 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        ignoreIdentityOutliers(requestBody: Array<string>, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.ignoreIdentityOutliers(requestBody, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of the enriched access items associated with each feature filtered by the access item type  The object contains: accessItemId, display name (translated text or message key), description (translated text or message key), accessType, sourceName, extremelyRare Requires authorization scope of \'iai:outliers-management:read\'
         * @summary Gets a list of access items associated with each identity outlier contributing feature
         * @param {string} outlierId The outlier id
         * @param {'radical_entitlement_count' | 'entitlement_count' | 'max_jaccard_similarity' | 'mean_max_bundle_concurrency' | 'single_entitlement_bundle_count' | 'peerless_score'} contributingFeatureName The name of contributing feature
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [accessType] The type of access item for the identity outlier contributing feature. If not provided, it returns all
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **displayName**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listOutliersContributingFeatureAccessItems(outlierId: string, contributingFeatureName: 'radical_entitlement_count' | 'entitlement_count' | 'max_jaccard_similarity' | 'mean_max_bundle_concurrency' | 'single_entitlement_bundle_count' | 'peerless_score', limit?: number, offset?: number, count?: boolean, accessType?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<OutliersContributingFeatureAccessItemsBeta>> {
            return localVarFp.listOutliersContributingFeatureAccessItems(outlierId, contributingFeatureName, limit, offset, count, accessType, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API receives a list of IdentityIDs in the request, changes the outliers to be un-ignored--returning a 204 if successful. Requires authorization scope of \'iai:outliers-management:update\'
         * @summary IAI Identity Outliers Unignore
         * @param {Array<string>} requestBody 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        unIgnoreIdentityOutliers(requestBody: Array<string>, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.unIgnoreIdentityOutliers(requestBody, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for exportOutliersZip operation in IAIOutliersBetaApi.
 * @export
 * @interface IAIOutliersBetaApiExportOutliersZipRequest
 */
export interface IAIOutliersBetaApiExportOutliersZipRequest {
    /**
     * Type of the identity outliers snapshot to filter on
     * @type {'LOW_SIMILARITY' | 'STRUCTURAL'}
     * @memberof IAIOutliersBetaApiExportOutliersZip
     */
    readonly type?: 'LOW_SIMILARITY' | 'STRUCTURAL'
}

/**
 * Request parameters for getIdentityOutlierSnapshots operation in IAIOutliersBetaApi.
 * @export
 * @interface IAIOutliersBetaApiGetIdentityOutlierSnapshotsRequest
 */
export interface IAIOutliersBetaApiGetIdentityOutlierSnapshotsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IAIOutliersBetaApiGetIdentityOutlierSnapshots
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IAIOutliersBetaApiGetIdentityOutlierSnapshots
     */
    readonly offset?: number

    /**
     * Type of the identity outliers snapshot to filter on
     * @type {'LOW_SIMILARITY' | 'STRUCTURAL'}
     * @memberof IAIOutliersBetaApiGetIdentityOutlierSnapshots
     */
    readonly type?: 'LOW_SIMILARITY' | 'STRUCTURAL'

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following field and operators:  **snapshotDate**: *ge, le*
     * @type {string}
     * @memberof IAIOutliersBetaApiGetIdentityOutlierSnapshots
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following field: **snapshotDate**
     * @type {string}
     * @memberof IAIOutliersBetaApiGetIdentityOutlierSnapshots
     */
    readonly sorters?: string
}

/**
 * Request parameters for getIdentityOutliers operation in IAIOutliersBetaApi.
 * @export
 * @interface IAIOutliersBetaApiGetIdentityOutliersRequest
 */
export interface IAIOutliersBetaApiGetIdentityOutliersRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IAIOutliersBetaApiGetIdentityOutliers
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IAIOutliersBetaApiGetIdentityOutliers
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IAIOutliersBetaApiGetIdentityOutliers
     */
    readonly count?: boolean

    /**
     * Type of the identity outliers snapshot to filter on
     * @type {'LOW_SIMILARITY' | 'STRUCTURAL'}
     * @memberof IAIOutliersBetaApiGetIdentityOutliers
     */
    readonly type?: 'LOW_SIMILARITY' | 'STRUCTURAL'

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following Entitlement fields and operators: **attributes**: *eq, sw, co, in*  **firstDetectionDate**: *ge, le*  **certStatus**: *eq*  **ignored**: *eq*  **score**: *ge, le*
     * @type {string}
     * @memberof IAIOutliersBetaApiGetIdentityOutliers
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **firstDetectionDate, attributes, score**
     * @type {string}
     * @memberof IAIOutliersBetaApiGetIdentityOutliers
     */
    readonly sorters?: string
}

/**
 * Request parameters for getLatestIdentityOutlierSnapshots operation in IAIOutliersBetaApi.
 * @export
 * @interface IAIOutliersBetaApiGetLatestIdentityOutlierSnapshotsRequest
 */
export interface IAIOutliersBetaApiGetLatestIdentityOutlierSnapshotsRequest {
    /**
     * Type of the identity outliers snapshot to filter on
     * @type {'LOW_SIMILARITY' | 'STRUCTURAL'}
     * @memberof IAIOutliersBetaApiGetLatestIdentityOutlierSnapshots
     */
    readonly type?: 'LOW_SIMILARITY' | 'STRUCTURAL'
}

/**
 * Request parameters for getOutlierContributingFeatureSummary operation in IAIOutliersBetaApi.
 * @export
 * @interface IAIOutliersBetaApiGetOutlierContributingFeatureSummaryRequest
 */
export interface IAIOutliersBetaApiGetOutlierContributingFeatureSummaryRequest {
    /**
     * Contributing feature id
     * @type {string}
     * @memberof IAIOutliersBetaApiGetOutlierContributingFeatureSummary
     */
    readonly outlierFeatureId: string
}

/**
 * Request parameters for getPeerGroupOutliersContributingFeatures operation in IAIOutliersBetaApi.
 * @export
 * @interface IAIOutliersBetaApiGetPeerGroupOutliersContributingFeaturesRequest
 */
export interface IAIOutliersBetaApiGetPeerGroupOutliersContributingFeaturesRequest {
    /**
     * The outlier id
     * @type {string}
     * @memberof IAIOutliersBetaApiGetPeerGroupOutliersContributingFeatures
     */
    readonly outlierId: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IAIOutliersBetaApiGetPeerGroupOutliersContributingFeatures
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IAIOutliersBetaApiGetPeerGroupOutliersContributingFeatures
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IAIOutliersBetaApiGetPeerGroupOutliersContributingFeatures
     */
    readonly count?: boolean

    /**
     * Whether or not to include translation messages object in returned response
     * @type {string}
     * @memberof IAIOutliersBetaApiGetPeerGroupOutliersContributingFeatures
     */
    readonly includeTranslationMessages?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **importance**
     * @type {string}
     * @memberof IAIOutliersBetaApiGetPeerGroupOutliersContributingFeatures
     */
    readonly sorters?: string
}

/**
 * Request parameters for ignoreIdentityOutliers operation in IAIOutliersBetaApi.
 * @export
 * @interface IAIOutliersBetaApiIgnoreIdentityOutliersRequest
 */
export interface IAIOutliersBetaApiIgnoreIdentityOutliersRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof IAIOutliersBetaApiIgnoreIdentityOutliers
     */
    readonly requestBody: Array<string>
}

/**
 * Request parameters for listOutliersContributingFeatureAccessItems operation in IAIOutliersBetaApi.
 * @export
 * @interface IAIOutliersBetaApiListOutliersContributingFeatureAccessItemsRequest
 */
export interface IAIOutliersBetaApiListOutliersContributingFeatureAccessItemsRequest {
    /**
     * The outlier id
     * @type {string}
     * @memberof IAIOutliersBetaApiListOutliersContributingFeatureAccessItems
     */
    readonly outlierId: string

    /**
     * The name of contributing feature
     * @type {'radical_entitlement_count' | 'entitlement_count' | 'max_jaccard_similarity' | 'mean_max_bundle_concurrency' | 'single_entitlement_bundle_count' | 'peerless_score'}
     * @memberof IAIOutliersBetaApiListOutliersContributingFeatureAccessItems
     */
    readonly contributingFeatureName: 'radical_entitlement_count' | 'entitlement_count' | 'max_jaccard_similarity' | 'mean_max_bundle_concurrency' | 'single_entitlement_bundle_count' | 'peerless_score'

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IAIOutliersBetaApiListOutliersContributingFeatureAccessItems
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IAIOutliersBetaApiListOutliersContributingFeatureAccessItems
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IAIOutliersBetaApiListOutliersContributingFeatureAccessItems
     */
    readonly count?: boolean

    /**
     * The type of access item for the identity outlier contributing feature. If not provided, it returns all
     * @type {string}
     * @memberof IAIOutliersBetaApiListOutliersContributingFeatureAccessItems
     */
    readonly accessType?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **displayName**
     * @type {string}
     * @memberof IAIOutliersBetaApiListOutliersContributingFeatureAccessItems
     */
    readonly sorters?: string
}

/**
 * Request parameters for unIgnoreIdentityOutliers operation in IAIOutliersBetaApi.
 * @export
 * @interface IAIOutliersBetaApiUnIgnoreIdentityOutliersRequest
 */
export interface IAIOutliersBetaApiUnIgnoreIdentityOutliersRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof IAIOutliersBetaApiUnIgnoreIdentityOutliers
     */
    readonly requestBody: Array<string>
}

/**
 * IAIOutliersBetaApi - object-oriented interface
 * @export
 * @class IAIOutliersBetaApi
 * @extends {BaseAPI}
 */
export class IAIOutliersBetaApi extends BaseAPI {
    /**
     * This API exports a list of ignored outliers to a CSV as well as list of non-ignored outliers to a CSV. These two CSVs will be zipped and exported Columns will include: identityID, type, firstDetectionDate, latestDetectionDate, ignored, & attributes (defined set of identity attributes) Requires authorization scope of \'iai:outliers-management:read\'
     * @summary IAI Identity Outliers Export
     * @param {IAIOutliersBetaApiExportOutliersZipRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIOutliersBetaApi
     */
    public exportOutliersZip(requestParameters: IAIOutliersBetaApiExportOutliersZipRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return IAIOutliersBetaApiFp(this.configuration).exportOutliersZip(requestParameters.type, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API receives a summary containing: the number of identities that customer has, the number of outliers, and the type of outlier Requires authorization scope of \'iai:outliers-management:read\'
     * @summary IAI Identity Outliers Summary
     * @param {IAIOutliersBetaApiGetIdentityOutlierSnapshotsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIOutliersBetaApi
     */
    public getIdentityOutlierSnapshots(requestParameters: IAIOutliersBetaApiGetIdentityOutlierSnapshotsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return IAIOutliersBetaApiFp(this.configuration).getIdentityOutlierSnapshots(requestParameters.limit, requestParameters.offset, requestParameters.type, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API receives a list of outliers, containing data such as: identityId, outlier type, detection dates, identity attributes, if identity is ignore, and certification information Requires authorization scope of \'iai:outliers-management:read\'
     * @summary IAI Get Identity Outliers
     * @param {IAIOutliersBetaApiGetIdentityOutliersRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIOutliersBetaApi
     */
    public getIdentityOutliers(requestParameters: IAIOutliersBetaApiGetIdentityOutliersRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return IAIOutliersBetaApiFp(this.configuration).getIdentityOutliers(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.type, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a most recent snapshot of each outlier type, each containing: the number of identities that customer has, the number of outliers, and the type of outlier Requires authorization scope of \'iai:outliers-management:read\'
     * @summary IAI Identity Outliers Latest Summary
     * @param {IAIOutliersBetaApiGetLatestIdentityOutlierSnapshotsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIOutliersBetaApi
     */
    public getLatestIdentityOutlierSnapshots(requestParameters: IAIOutliersBetaApiGetLatestIdentityOutlierSnapshotsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return IAIOutliersBetaApiFp(this.configuration).getLatestIdentityOutlierSnapshots(requestParameters.type, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a summary of a contributing feature for an identity outlier. The object contains: contributing feature name (translated text or message key), identity outlier display name, feature values, feature definition and explanation (translated text or message key), peer display name and identityId, access item reference, translation messages object Requires authorization scope of \'iai:outliers-management:read\'
     * @summary Get identity outlier contibuting feature summary
     * @param {IAIOutliersBetaApiGetOutlierContributingFeatureSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIOutliersBetaApi
     */
    public getOutlierContributingFeatureSummary(requestParameters: IAIOutliersBetaApiGetOutlierContributingFeatureSummaryRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIOutliersBetaApiFp(this.configuration).getOutlierContributingFeatureSummary(requestParameters.outlierFeatureId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of contributing feature objects for a single outlier. The object contains: feature name, feature value type, value, importance, display name (translated text or message key), description (translated text or message key), translation messages object Requires authorization scope of \'iai:outliers-management:read\'
     * @summary Get identity outlier\'s contibuting features
     * @param {IAIOutliersBetaApiGetPeerGroupOutliersContributingFeaturesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIOutliersBetaApi
     */
    public getPeerGroupOutliersContributingFeatures(requestParameters: IAIOutliersBetaApiGetPeerGroupOutliersContributingFeaturesRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIOutliersBetaApiFp(this.configuration).getPeerGroupOutliersContributingFeatures(requestParameters.outlierId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.includeTranslationMessages, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API receives a list of IdentityIDs in the request, changes the outliers to be ignored--returning a 204 if successful. Requires authorization scope of \'iai:outliers-management:update\'
     * @summary IAI Identity Outliers Ignore
     * @param {IAIOutliersBetaApiIgnoreIdentityOutliersRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIOutliersBetaApi
     */
    public ignoreIdentityOutliers(requestParameters: IAIOutliersBetaApiIgnoreIdentityOutliersRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIOutliersBetaApiFp(this.configuration).ignoreIdentityOutliers(requestParameters.requestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of the enriched access items associated with each feature filtered by the access item type  The object contains: accessItemId, display name (translated text or message key), description (translated text or message key), accessType, sourceName, extremelyRare Requires authorization scope of \'iai:outliers-management:read\'
     * @summary Gets a list of access items associated with each identity outlier contributing feature
     * @param {IAIOutliersBetaApiListOutliersContributingFeatureAccessItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIOutliersBetaApi
     */
    public listOutliersContributingFeatureAccessItems(requestParameters: IAIOutliersBetaApiListOutliersContributingFeatureAccessItemsRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIOutliersBetaApiFp(this.configuration).listOutliersContributingFeatureAccessItems(requestParameters.outlierId, requestParameters.contributingFeatureName, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.accessType, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API receives a list of IdentityIDs in the request, changes the outliers to be un-ignored--returning a 204 if successful. Requires authorization scope of \'iai:outliers-management:update\'
     * @summary IAI Identity Outliers Unignore
     * @param {IAIOutliersBetaApiUnIgnoreIdentityOutliersRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIOutliersBetaApi
     */
    public unIgnoreIdentityOutliers(requestParameters: IAIOutliersBetaApiUnIgnoreIdentityOutliersRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIOutliersBetaApiFp(this.configuration).unIgnoreIdentityOutliers(requestParameters.requestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IAIPeerGroupStrategiesBetaApi - axios parameter creator
 * @export
 */
export const IAIPeerGroupStrategiesBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * -- Deprecated : See \'IAI Outliers\' This API will be used by Identity Governance systems to identify identities that are not included in an organization\'s peer groups. By default, 250 identities are returned. You can specify between 1 and 1000 number of identities that can be returned.
         * @summary Identity Outliers List
         * @param {string} strategy The strategy used to create peer groups. Currently, \&#39;entitlement\&#39; is supported.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getPeerGroupOutliers: async (strategy: string, limit?: number, offset?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'strategy' is not null or undefined
            assertParamExists('getPeerGroupOutliers', 'strategy', strategy)
            const localVarPath = `/peer-group-strategies/{strategy}/identity-outliers`
                .replace(`{${"strategy"}}`, encodeURIComponent(String(strategy)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * IAIPeerGroupStrategiesBetaApi - functional programming interface
 * @export
 */
export const IAIPeerGroupStrategiesBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IAIPeerGroupStrategiesBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * -- Deprecated : See \'IAI Outliers\' This API will be used by Identity Governance systems to identify identities that are not included in an organization\'s peer groups. By default, 250 identities are returned. You can specify between 1 and 1000 number of identities that can be returned.
         * @summary Identity Outliers List
         * @param {string} strategy The strategy used to create peer groups. Currently, \&#39;entitlement\&#39; is supported.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getPeerGroupOutliers(strategy: string, limit?: number, offset?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PeerGroupMemberBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPeerGroupOutliers(strategy, limit, offset, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IAIPeerGroupStrategiesBetaApi - factory interface
 * @export
 */
export const IAIPeerGroupStrategiesBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IAIPeerGroupStrategiesBetaApiFp(configuration)
    return {
        /**
         * -- Deprecated : See \'IAI Outliers\' This API will be used by Identity Governance systems to identify identities that are not included in an organization\'s peer groups. By default, 250 identities are returned. You can specify between 1 and 1000 number of identities that can be returned.
         * @summary Identity Outliers List
         * @param {string} strategy The strategy used to create peer groups. Currently, \&#39;entitlement\&#39; is supported.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getPeerGroupOutliers(strategy: string, limit?: number, offset?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<PeerGroupMemberBeta>> {
            return localVarFp.getPeerGroupOutliers(strategy, limit, offset, count, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getPeerGroupOutliers operation in IAIPeerGroupStrategiesBetaApi.
 * @export
 * @interface IAIPeerGroupStrategiesBetaApiGetPeerGroupOutliersRequest
 */
export interface IAIPeerGroupStrategiesBetaApiGetPeerGroupOutliersRequest {
    /**
     * The strategy used to create peer groups. Currently, \&#39;entitlement\&#39; is supported.
     * @type {string}
     * @memberof IAIPeerGroupStrategiesBetaApiGetPeerGroupOutliers
     */
    readonly strategy: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IAIPeerGroupStrategiesBetaApiGetPeerGroupOutliers
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IAIPeerGroupStrategiesBetaApiGetPeerGroupOutliers
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IAIPeerGroupStrategiesBetaApiGetPeerGroupOutliers
     */
    readonly count?: boolean
}

/**
 * IAIPeerGroupStrategiesBetaApi - object-oriented interface
 * @export
 * @class IAIPeerGroupStrategiesBetaApi
 * @extends {BaseAPI}
 */
export class IAIPeerGroupStrategiesBetaApi extends BaseAPI {
    /**
     * -- Deprecated : See \'IAI Outliers\' This API will be used by Identity Governance systems to identify identities that are not included in an organization\'s peer groups. By default, 250 identities are returned. You can specify between 1 and 1000 number of identities that can be returned.
     * @summary Identity Outliers List
     * @param {IAIPeerGroupStrategiesBetaApiGetPeerGroupOutliersRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof IAIPeerGroupStrategiesBetaApi
     */
    public getPeerGroupOutliers(requestParameters: IAIPeerGroupStrategiesBetaApiGetPeerGroupOutliersRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIPeerGroupStrategiesBetaApiFp(this.configuration).getPeerGroupOutliers(requestParameters.strategy, requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IAIRecommendationsBetaApi - axios parameter creator
 * @export
 */
export const IAIRecommendationsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The getMessageCatalogs API returns message catalog based on the language headers in the requested object.
         * @summary Get Message catalogs
         * @param {'recommender' | 'access-request-recommender'} catalogId The ID of the message catalog.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getMessageCatalogs: async (catalogId: 'recommender' | 'access-request-recommender', axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogId' is not null or undefined
            assertParamExists('getMessageCatalogs', 'catalogId', catalogId)
            const localVarPath = `/translation-catalogs/{catalog-id}`
                .replace(`{${"catalog-id"}}`, encodeURIComponent(String(catalogId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * The getRecommendations API returns recommendations based on the requested object. The recommendations are invoked by IdentityIQ and IdentityNow plug-ins that retrieve recommendations based on the performed calculations.
         * @summary Returns a Recommendation Based on Object
         * @param {RecommendationRequestDtoBeta} recommendationRequestDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendations: async (recommendationRequestDtoBeta: RecommendationRequestDtoBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recommendationRequestDtoBeta' is not null or undefined
            assertParamExists('getRecommendations', 'recommendationRequestDtoBeta', recommendationRequestDtoBeta)
            const localVarPath = `/recommendations/request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recommendationRequestDtoBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Retrieves configuration attributes used by certification recommendations.
         * @summary Get certification recommendation config values
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendationsConfig: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/recommendations/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Updates configuration attributes used by certification recommendations.
         * @summary Update certification recommendation config values
         * @param {RecommendationConfigDtoBeta} recommendationConfigDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateRecommendationsConfig: async (recommendationConfigDtoBeta: RecommendationConfigDtoBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recommendationConfigDtoBeta' is not null or undefined
            assertParamExists('updateRecommendationsConfig', 'recommendationConfigDtoBeta', recommendationConfigDtoBeta)
            const localVarPath = `/recommendations/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recommendationConfigDtoBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * IAIRecommendationsBetaApi - functional programming interface
 * @export
 */
export const IAIRecommendationsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IAIRecommendationsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * The getMessageCatalogs API returns message catalog based on the language headers in the requested object.
         * @summary Get Message catalogs
         * @param {'recommender' | 'access-request-recommender'} catalogId The ID of the message catalog.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getMessageCatalogs(catalogId: 'recommender' | 'access-request-recommender', axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MessageCatalogDtoBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessageCatalogs(catalogId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The getRecommendations API returns recommendations based on the requested object. The recommendations are invoked by IdentityIQ and IdentityNow plug-ins that retrieve recommendations based on the performed calculations.
         * @summary Returns a Recommendation Based on Object
         * @param {RecommendationRequestDtoBeta} recommendationRequestDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getRecommendations(recommendationRequestDtoBeta: RecommendationRequestDtoBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecommendationResponseDtoBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecommendations(recommendationRequestDtoBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves configuration attributes used by certification recommendations.
         * @summary Get certification recommendation config values
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getRecommendationsConfig(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecommendationConfigDtoBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecommendationsConfig(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates configuration attributes used by certification recommendations.
         * @summary Update certification recommendation config values
         * @param {RecommendationConfigDtoBeta} recommendationConfigDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateRecommendationsConfig(recommendationConfigDtoBeta: RecommendationConfigDtoBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecommendationConfigDtoBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRecommendationsConfig(recommendationConfigDtoBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IAIRecommendationsBetaApi - factory interface
 * @export
 */
export const IAIRecommendationsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IAIRecommendationsBetaApiFp(configuration)
    return {
        /**
         * The getMessageCatalogs API returns message catalog based on the language headers in the requested object.
         * @summary Get Message catalogs
         * @param {'recommender' | 'access-request-recommender'} catalogId The ID of the message catalog.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getMessageCatalogs(catalogId: 'recommender' | 'access-request-recommender', axiosOptions?: any): AxiosPromise<Array<MessageCatalogDtoBeta>> {
            return localVarFp.getMessageCatalogs(catalogId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * The getRecommendations API returns recommendations based on the requested object. The recommendations are invoked by IdentityIQ and IdentityNow plug-ins that retrieve recommendations based on the performed calculations.
         * @summary Returns a Recommendation Based on Object
         * @param {RecommendationRequestDtoBeta} recommendationRequestDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendations(recommendationRequestDtoBeta: RecommendationRequestDtoBeta, axiosOptions?: any): AxiosPromise<RecommendationResponseDtoBeta> {
            return localVarFp.getRecommendations(recommendationRequestDtoBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves configuration attributes used by certification recommendations.
         * @summary Get certification recommendation config values
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendationsConfig(axiosOptions?: any): AxiosPromise<RecommendationConfigDtoBeta> {
            return localVarFp.getRecommendationsConfig(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Updates configuration attributes used by certification recommendations.
         * @summary Update certification recommendation config values
         * @param {RecommendationConfigDtoBeta} recommendationConfigDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateRecommendationsConfig(recommendationConfigDtoBeta: RecommendationConfigDtoBeta, axiosOptions?: any): AxiosPromise<RecommendationConfigDtoBeta> {
            return localVarFp.updateRecommendationsConfig(recommendationConfigDtoBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getMessageCatalogs operation in IAIRecommendationsBetaApi.
 * @export
 * @interface IAIRecommendationsBetaApiGetMessageCatalogsRequest
 */
export interface IAIRecommendationsBetaApiGetMessageCatalogsRequest {
    /**
     * The ID of the message catalog.
     * @type {'recommender' | 'access-request-recommender'}
     * @memberof IAIRecommendationsBetaApiGetMessageCatalogs
     */
    readonly catalogId: 'recommender' | 'access-request-recommender'
}

/**
 * Request parameters for getRecommendations operation in IAIRecommendationsBetaApi.
 * @export
 * @interface IAIRecommendationsBetaApiGetRecommendationsRequest
 */
export interface IAIRecommendationsBetaApiGetRecommendationsRequest {
    /**
     * 
     * @type {RecommendationRequestDtoBeta}
     * @memberof IAIRecommendationsBetaApiGetRecommendations
     */
    readonly recommendationRequestDtoBeta: RecommendationRequestDtoBeta
}

/**
 * Request parameters for updateRecommendationsConfig operation in IAIRecommendationsBetaApi.
 * @export
 * @interface IAIRecommendationsBetaApiUpdateRecommendationsConfigRequest
 */
export interface IAIRecommendationsBetaApiUpdateRecommendationsConfigRequest {
    /**
     * 
     * @type {RecommendationConfigDtoBeta}
     * @memberof IAIRecommendationsBetaApiUpdateRecommendationsConfig
     */
    readonly recommendationConfigDtoBeta: RecommendationConfigDtoBeta
}

/**
 * IAIRecommendationsBetaApi - object-oriented interface
 * @export
 * @class IAIRecommendationsBetaApi
 * @extends {BaseAPI}
 */
export class IAIRecommendationsBetaApi extends BaseAPI {
    /**
     * The getMessageCatalogs API returns message catalog based on the language headers in the requested object.
     * @summary Get Message catalogs
     * @param {IAIRecommendationsBetaApiGetMessageCatalogsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIRecommendationsBetaApi
     */
    public getMessageCatalogs(requestParameters: IAIRecommendationsBetaApiGetMessageCatalogsRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIRecommendationsBetaApiFp(this.configuration).getMessageCatalogs(requestParameters.catalogId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The getRecommendations API returns recommendations based on the requested object. The recommendations are invoked by IdentityIQ and IdentityNow plug-ins that retrieve recommendations based on the performed calculations.
     * @summary Returns a Recommendation Based on Object
     * @param {IAIRecommendationsBetaApiGetRecommendationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIRecommendationsBetaApi
     */
    public getRecommendations(requestParameters: IAIRecommendationsBetaApiGetRecommendationsRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIRecommendationsBetaApiFp(this.configuration).getRecommendations(requestParameters.recommendationRequestDtoBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves configuration attributes used by certification recommendations.
     * @summary Get certification recommendation config values
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIRecommendationsBetaApi
     */
    public getRecommendationsConfig(axiosOptions?: AxiosRequestConfig) {
        return IAIRecommendationsBetaApiFp(this.configuration).getRecommendationsConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates configuration attributes used by certification recommendations.
     * @summary Update certification recommendation config values
     * @param {IAIRecommendationsBetaApiUpdateRecommendationsConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIRecommendationsBetaApi
     */
    public updateRecommendationsConfig(requestParameters: IAIRecommendationsBetaApiUpdateRecommendationsConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIRecommendationsBetaApiFp(this.configuration).updateRecommendationsConfig(requestParameters.recommendationConfigDtoBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IAIRoleMiningBetaApi - axios parameter creator
 * @export
 */
export const IAIRoleMiningBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This method starts a job to provision a potential role
         * @summary Create request to provision a potential role into an actual role.
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {number} [minEntitlementPopularity] Minimum popularity required for an entitlement to be included in the provisioned role.
         * @param {boolean} [includeCommonAccess] Boolean determining whether common access entitlements will be included in the provisioned role.
         * @param {RoleMiningPotentialRoleProvisionRequestBeta} [roleMiningPotentialRoleProvisionRequestBeta] Required information to create a new role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPotentialRoleProvisionRequest: async (sessionId: string, potentialRoleId: string, minEntitlementPopularity?: number, includeCommonAccess?: boolean, roleMiningPotentialRoleProvisionRequestBeta?: RoleMiningPotentialRoleProvisionRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('createPotentialRoleProvisionRequest', 'sessionId', sessionId)
            // verify required parameter 'potentialRoleId' is not null or undefined
            assertParamExists('createPotentialRoleProvisionRequest', 'potentialRoleId', potentialRoleId)
            const localVarPath = `/role-mining-sessions/{sessionId}/potential-roles/{potentialRoleId}/provision`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"potentialRoleId"}}`, encodeURIComponent(String(potentialRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (minEntitlementPopularity !== undefined) {
                localVarQueryParameter['min-entitlement-popularity'] = minEntitlementPopularity;
            }

            if (includeCommonAccess !== undefined) {
                localVarQueryParameter['include-common-access'] = includeCommonAccess;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleMiningPotentialRoleProvisionRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This submits a create role mining session request to the role mining application.
         * @summary Create a role mining session
         * @param {RoleMiningSessionDtoBeta} roleMiningSessionDtoBeta Role mining session parameters
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createRoleMiningSessions: async (roleMiningSessionDtoBeta: RoleMiningSessionDtoBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleMiningSessionDtoBeta' is not null or undefined
            assertParamExists('createRoleMiningSessions', 'roleMiningSessionDtoBeta', roleMiningSessionDtoBeta)
            const localVarPath = `/role-mining-sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleMiningSessionDtoBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint downloads a completed export of information for a potential role in a role mining session.
         * @summary Export (download) details for a potential role in a role mining session
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {string} exportId The id of a previously run export job for this potential role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        downloadRoleMiningPotentialRoleZip: async (sessionId: string, potentialRoleId: string, exportId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('downloadRoleMiningPotentialRoleZip', 'sessionId', sessionId)
            // verify required parameter 'potentialRoleId' is not null or undefined
            assertParamExists('downloadRoleMiningPotentialRoleZip', 'potentialRoleId', potentialRoleId)
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists('downloadRoleMiningPotentialRoleZip', 'exportId', exportId)
            const localVarPath = `/role-mining-sessions/{sessionId}/potential-roles/{potentialRoleId}/export-async/{exportId}/download`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"potentialRoleId"}}`, encodeURIComponent(String(potentialRoleId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint downloads all the information for a potential role in a role mining session. Includes identities and entitlements in the potential role.
         * @summary Export (download) details for a potential role in a role mining session
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportRoleMiningPotentialRole: async (sessionId: string, potentialRoleId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('exportRoleMiningPotentialRole', 'sessionId', sessionId)
            // verify required parameter 'potentialRoleId' is not null or undefined
            assertParamExists('exportRoleMiningPotentialRole', 'potentialRoleId', potentialRoleId)
            const localVarPath = `/role-mining-sessions/{sessionId}/potential-roles/{potentialRoleId}/export`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"potentialRoleId"}}`, encodeURIComponent(String(potentialRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint uploads all the information for a potential role in a role mining session to S3 as a downloadable zip archive.  Includes identities and entitlements in the potential role.
         * @summary Asynchronously export details for a potential role in a role mining session and upload to S3
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {RoleMiningPotentialRoleExportRequestBeta} [roleMiningPotentialRoleExportRequestBeta] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportRoleMiningPotentialRoleAsync: async (sessionId: string, potentialRoleId: string, roleMiningPotentialRoleExportRequestBeta?: RoleMiningPotentialRoleExportRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('exportRoleMiningPotentialRoleAsync', 'sessionId', sessionId)
            // verify required parameter 'potentialRoleId' is not null or undefined
            assertParamExists('exportRoleMiningPotentialRoleAsync', 'potentialRoleId', potentialRoleId)
            const localVarPath = `/role-mining-sessions/{sessionId}/potential-roles/{potentialRoleId}/export-async`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"potentialRoleId"}}`, encodeURIComponent(String(potentialRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleMiningPotentialRoleExportRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves information about the current status of a potential role export.
         * @summary Retrieve status of a potential role export job
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {string} exportId The id of a previously run export job for this potential role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportRoleMiningPotentialRoleStatus: async (sessionId: string, potentialRoleId: string, exportId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('exportRoleMiningPotentialRoleStatus', 'sessionId', sessionId)
            // verify required parameter 'potentialRoleId' is not null or undefined
            assertParamExists('exportRoleMiningPotentialRoleStatus', 'potentialRoleId', potentialRoleId)
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists('exportRoleMiningPotentialRoleStatus', 'exportId', exportId)
            const localVarPath = `/role-mining-sessions/{sessionId}/potential-roles/{potentialRoleId}/export-async/{exportId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"potentialRoleId"}}`, encodeURIComponent(String(potentialRoleId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This method returns entitlement popularity distribution for a potential role in a role mining session.
         * @summary Retrieves entitlement popularity distribution for a potential role in a role mining session
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {boolean} [includeCommonAccess] Boolean determining whether common access entitlements will be included or not
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getEntitlementDistributionPotentialRole: async (sessionId: string, potentialRoleId: string, includeCommonAccess?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getEntitlementDistributionPotentialRole', 'sessionId', sessionId)
            // verify required parameter 'potentialRoleId' is not null or undefined
            assertParamExists('getEntitlementDistributionPotentialRole', 'potentialRoleId', potentialRoleId)
            const localVarPath = `/role-mining-sessions/{sessionId}/potential-roles/{potentialRoleId}/entitlement-popularity-distribution`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"potentialRoleId"}}`, encodeURIComponent(String(potentialRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (includeCommonAccess !== undefined) {
                localVarQueryParameter['includeCommonAccess'] = includeCommonAccess;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This method returns entitlements for a potential role in a role mining session.
         * @summary Retrieves entitlements for a potential role in a role mining session
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {boolean} [includeCommonAccess] Boolean determining whether common access entitlements will be included or not
         * @param {string} [sorters] sort by popularity, default order descending
         * @param {string} [filters] Filter parameter by \&quot;starts with\&quot; for the applicationName and entitlementRef.name.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getEntitlementsPotentialRole: async (sessionId: string, potentialRoleId: string, includeCommonAccess?: boolean, sorters?: string, filters?: string, offset?: number, limit?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getEntitlementsPotentialRole', 'sessionId', sessionId)
            // verify required parameter 'potentialRoleId' is not null or undefined
            assertParamExists('getEntitlementsPotentialRole', 'potentialRoleId', potentialRoleId)
            const localVarPath = `/role-mining-sessions/{sessionId}/potential-roles/{potentialRoleId}/entitlement-popularities`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"potentialRoleId"}}`, encodeURIComponent(String(potentialRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (includeCommonAccess !== undefined) {
                localVarQueryParameter['includeCommonAccess'] = includeCommonAccess;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This method returns excluded entitlements for a potential role in a role mining session.
         * @summary Retrieves excluded entitlements for a potential role in a role mining session
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {string} [sorters] sort by popularity, default order descending
         * @param {string} [filters] Filter parameter by \&quot;starts with\&quot; for the applicationName and entitlementRef.name.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getExcludedEntitlementsPotentialRole: async (sessionId: string, potentialRoleId: string, sorters?: string, filters?: string, offset?: number, limit?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getExcludedEntitlementsPotentialRole', 'sessionId', sessionId)
            // verify required parameter 'potentialRoleId' is not null or undefined
            assertParamExists('getExcludedEntitlementsPotentialRole', 'potentialRoleId', potentialRoleId)
            const localVarPath = `/role-mining-sessions/{sessionId}/potential-roles/{potentialRoleId}/excluded-entitlements`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"potentialRoleId"}}`, encodeURIComponent(String(potentialRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This method returns identities for a potential role in a role mining session.
         * @summary Retrieves identities for a potential role in a role mining session
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {string} [sorters] sort by name, default order ascending
         * @param {string} [filters] Filter parameter by \&quot;starts with\&quot; for the name.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentitiesPotentialRole: async (sessionId: string, potentialRoleId: string, sorters?: string, filters?: string, offset?: number, limit?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getIdentitiesPotentialRole', 'sessionId', sessionId)
            // verify required parameter 'potentialRoleId' is not null or undefined
            assertParamExists('getIdentitiesPotentialRole', 'potentialRoleId', potentialRoleId)
            const localVarPath = `/role-mining-sessions/{sessionId}/potential-roles/{potentialRoleId}/identities`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"potentialRoleId"}}`, encodeURIComponent(String(potentialRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This method returns a specific potential role for a role mining session.
         * @summary Retrieves a specific potential role
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPotentialRole: async (sessionId: string, potentialRoleId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getPotentialRole', 'sessionId', sessionId)
            // verify required parameter 'potentialRoleId' is not null or undefined
            assertParamExists('getPotentialRole', 'potentialRoleId', potentialRoleId)
            const localVarPath = `/role-mining-sessions/{sessionId}/potential-role-summaries/{potentialRoleId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"potentialRoleId"}}`, encodeURIComponent(String(potentialRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This method returns the applications of a potential role for a role mining session.
         * @summary Retrieves the applications of a potential role for a role mining session
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPotentialRoleApplications: async (sessionId: string, potentialRoleId: string, offset?: number, limit?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getPotentialRoleApplications', 'sessionId', sessionId)
            // verify required parameter 'potentialRoleId' is not null or undefined
            assertParamExists('getPotentialRoleApplications', 'potentialRoleId', potentialRoleId)
            const localVarPath = `/role-mining-sessions/{sessionId}/potential-role-summaries/{potentialRoleId}/applications`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"potentialRoleId"}}`, encodeURIComponent(String(potentialRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This method returns the potential role summaries for a role mining session.
         * @summary Retrieves all potential role summaries
         * @param {string} sessionId The role mining session id
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters/) Sorting is supported for the following fields: **createdDate**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters/) Filtering is supported for the following fields and operators: **createdById**: *eq, sw, co* **createdByName**: *eq, sw, co* **description**: *sw, co* **endDate**: *le, lt* **freshness**: *eq, ge, gt, le, lt* **name**: *eq, sw, co* **quality**: *eq, ge, gt, le, lt* **startDate**: *ge, gt* **saved**: *eq* **type**: *eq*
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPotentialRoleSummaries: async (sessionId: string, sorters?: string, filters?: string, offset?: number, limit?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getPotentialRoleSummaries', 'sessionId', sessionId)
            const localVarPath = `/role-mining-sessions/{sessionId}/potential-role-summaries`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * The method retrieves a role mining session.
         * @summary Get a role mining session
         * @param {string} sessionId The role mining session id to be retrieved.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRoleMiningSession: async (sessionId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getRoleMiningSession', 'sessionId', sessionId)
            const localVarPath = `/role-mining-sessions/{sessionId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This method returns a role mining session status for a customer.
         * @summary Get role mining session status state
         * @param {string} sessionId The role mining session id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRoleMiningSessionStatus: async (sessionId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getRoleMiningSessionStatus', 'sessionId', sessionId)
            const localVarPath = `/role-mining-sessions/{sessionId}/status`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Returns all role mining sessions that match the query parameters
         * @summary Retrieves all role mining sessions
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **saved**: *eq* \&quot;true\&quot; or \&quot;false\&quot; **name**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **createdBy, createdDate**
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRoleMiningSessions: async (filters?: string, sorters?: string, offset?: number, limit?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/role-mining-sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * The method updates an existing potential role using.  The following fields can be modified:  * `description`  * `name`  * `saved`   >**NOTE: All other fields cannot be modified.** 
         * @summary Update a potential role
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId The potential role summary id
         * @param {Array<PatchPotentialRoleRequestInnerBeta>} patchPotentialRoleRequestInnerBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchPotentialRole: async (sessionId: string, potentialRoleId: string, patchPotentialRoleRequestInnerBeta: Array<PatchPotentialRoleRequestInnerBeta>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('patchPotentialRole', 'sessionId', sessionId)
            // verify required parameter 'potentialRoleId' is not null or undefined
            assertParamExists('patchPotentialRole', 'potentialRoleId', potentialRoleId)
            // verify required parameter 'patchPotentialRoleRequestInnerBeta' is not null or undefined
            assertParamExists('patchPotentialRole', 'patchPotentialRoleRequestInnerBeta', patchPotentialRoleRequestInnerBeta)
            const localVarPath = `/role-mining-sessions/{sessionId}/potential-role-summaries/{potentialRoleId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"potentialRoleId"}}`, encodeURIComponent(String(potentialRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchPotentialRoleRequestInnerBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * The  method updates an existing role mining session using PATCH. Supports op in {\"replace\"} and changes to pruneThreshold and/or minNumIdentitiesInPotentialRole. The potential roles in this role mining session is then re-calculated.
         * @summary Patch a role mining session
         * @param {string} sessionId The role mining session id to be patched
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta Replace pruneThreshold and/or minNumIdentitiesInPotentialRole in role mining session. Update saved status or saved name for a role mining session.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchRoleMiningSession: async (sessionId: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('patchRoleMiningSession', 'sessionId', sessionId)
            // verify required parameter 'jsonPatchOperationBeta' is not null or undefined
            assertParamExists('patchRoleMiningSession', 'jsonPatchOperationBeta', jsonPatchOperationBeta)
            const localVarPath = `/role-mining-sessions/{sessionId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperationBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint adds or removes entitlements from an exclusion list for a potential role.
         * @summary Edit entitlements for a potential role to exclude some entitlements
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {RoleMiningPotentialRoleEditEntitlementsBeta} roleMiningPotentialRoleEditEntitlementsBeta Role mining session parameters
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateEntitlementsPotentialRole: async (sessionId: string, potentialRoleId: string, roleMiningPotentialRoleEditEntitlementsBeta: RoleMiningPotentialRoleEditEntitlementsBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('updateEntitlementsPotentialRole', 'sessionId', sessionId)
            // verify required parameter 'potentialRoleId' is not null or undefined
            assertParamExists('updateEntitlementsPotentialRole', 'potentialRoleId', potentialRoleId)
            // verify required parameter 'roleMiningPotentialRoleEditEntitlementsBeta' is not null or undefined
            assertParamExists('updateEntitlementsPotentialRole', 'roleMiningPotentialRoleEditEntitlementsBeta', roleMiningPotentialRoleEditEntitlementsBeta)
            const localVarPath = `/role-mining-sessions/{sessionId}/potential-roles/{potentialRoleId}/edit-entitlements`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"potentialRoleId"}}`, encodeURIComponent(String(potentialRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleMiningPotentialRoleEditEntitlementsBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * IAIRoleMiningBetaApi - functional programming interface
 * @export
 */
export const IAIRoleMiningBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IAIRoleMiningBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This method starts a job to provision a potential role
         * @summary Create request to provision a potential role into an actual role.
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {number} [minEntitlementPopularity] Minimum popularity required for an entitlement to be included in the provisioned role.
         * @param {boolean} [includeCommonAccess] Boolean determining whether common access entitlements will be included in the provisioned role.
         * @param {RoleMiningPotentialRoleProvisionRequestBeta} [roleMiningPotentialRoleProvisionRequestBeta] Required information to create a new role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createPotentialRoleProvisionRequest(sessionId: string, potentialRoleId: string, minEntitlementPopularity?: number, includeCommonAccess?: boolean, roleMiningPotentialRoleProvisionRequestBeta?: RoleMiningPotentialRoleProvisionRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleMiningPotentialRoleSummaryBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPotentialRoleProvisionRequest(sessionId, potentialRoleId, minEntitlementPopularity, includeCommonAccess, roleMiningPotentialRoleProvisionRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This submits a create role mining session request to the role mining application.
         * @summary Create a role mining session
         * @param {RoleMiningSessionDtoBeta} roleMiningSessionDtoBeta Role mining session parameters
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createRoleMiningSessions(roleMiningSessionDtoBeta: RoleMiningSessionDtoBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleMiningSessionResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRoleMiningSessions(roleMiningSessionDtoBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint downloads a completed export of information for a potential role in a role mining session.
         * @summary Export (download) details for a potential role in a role mining session
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {string} exportId The id of a previously run export job for this potential role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async downloadRoleMiningPotentialRoleZip(sessionId: string, potentialRoleId: string, exportId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadRoleMiningPotentialRoleZip(sessionId, potentialRoleId, exportId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint downloads all the information for a potential role in a role mining session. Includes identities and entitlements in the potential role.
         * @summary Export (download) details for a potential role in a role mining session
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async exportRoleMiningPotentialRole(sessionId: string, potentialRoleId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportRoleMiningPotentialRole(sessionId, potentialRoleId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint uploads all the information for a potential role in a role mining session to S3 as a downloadable zip archive.  Includes identities and entitlements in the potential role.
         * @summary Asynchronously export details for a potential role in a role mining session and upload to S3
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {RoleMiningPotentialRoleExportRequestBeta} [roleMiningPotentialRoleExportRequestBeta] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async exportRoleMiningPotentialRoleAsync(sessionId: string, potentialRoleId: string, roleMiningPotentialRoleExportRequestBeta?: RoleMiningPotentialRoleExportRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleMiningPotentialRoleExportResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportRoleMiningPotentialRoleAsync(sessionId, potentialRoleId, roleMiningPotentialRoleExportRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint retrieves information about the current status of a potential role export.
         * @summary Retrieve status of a potential role export job
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {string} exportId The id of a previously run export job for this potential role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async exportRoleMiningPotentialRoleStatus(sessionId: string, potentialRoleId: string, exportId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleMiningPotentialRoleExportResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportRoleMiningPotentialRoleStatus(sessionId, potentialRoleId, exportId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method returns entitlement popularity distribution for a potential role in a role mining session.
         * @summary Retrieves entitlement popularity distribution for a potential role in a role mining session
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {boolean} [includeCommonAccess] Boolean determining whether common access entitlements will be included or not
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getEntitlementDistributionPotentialRole(sessionId: string, potentialRoleId: string, includeCommonAccess?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: number; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntitlementDistributionPotentialRole(sessionId, potentialRoleId, includeCommonAccess, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method returns entitlements for a potential role in a role mining session.
         * @summary Retrieves entitlements for a potential role in a role mining session
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {boolean} [includeCommonAccess] Boolean determining whether common access entitlements will be included or not
         * @param {string} [sorters] sort by popularity, default order descending
         * @param {string} [filters] Filter parameter by \&quot;starts with\&quot; for the applicationName and entitlementRef.name.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getEntitlementsPotentialRole(sessionId: string, potentialRoleId: string, includeCommonAccess?: boolean, sorters?: string, filters?: string, offset?: number, limit?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleMiningEntitlementBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntitlementsPotentialRole(sessionId, potentialRoleId, includeCommonAccess, sorters, filters, offset, limit, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method returns excluded entitlements for a potential role in a role mining session.
         * @summary Retrieves excluded entitlements for a potential role in a role mining session
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {string} [sorters] sort by popularity, default order descending
         * @param {string} [filters] Filter parameter by \&quot;starts with\&quot; for the applicationName and entitlementRef.name.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getExcludedEntitlementsPotentialRole(sessionId: string, potentialRoleId: string, sorters?: string, filters?: string, offset?: number, limit?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleMiningEntitlementBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExcludedEntitlementsPotentialRole(sessionId, potentialRoleId, sorters, filters, offset, limit, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method returns identities for a potential role in a role mining session.
         * @summary Retrieves identities for a potential role in a role mining session
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {string} [sorters] sort by name, default order ascending
         * @param {string} [filters] Filter parameter by \&quot;starts with\&quot; for the name.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentitiesPotentialRole(sessionId: string, potentialRoleId: string, sorters?: string, filters?: string, offset?: number, limit?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleMiningIdentityBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentitiesPotentialRole(sessionId, potentialRoleId, sorters, filters, offset, limit, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method returns a specific potential role for a role mining session.
         * @summary Retrieves a specific potential role
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPotentialRole(sessionId: string, potentialRoleId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleMiningPotentialRoleBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPotentialRole(sessionId, potentialRoleId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method returns the applications of a potential role for a role mining session.
         * @summary Retrieves the applications of a potential role for a role mining session
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPotentialRoleApplications(sessionId: string, potentialRoleId: string, offset?: number, limit?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleMiningPotentialRoleApplicationBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPotentialRoleApplications(sessionId, potentialRoleId, offset, limit, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method returns the potential role summaries for a role mining session.
         * @summary Retrieves all potential role summaries
         * @param {string} sessionId The role mining session id
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters/) Sorting is supported for the following fields: **createdDate**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters/) Filtering is supported for the following fields and operators: **createdById**: *eq, sw, co* **createdByName**: *eq, sw, co* **description**: *sw, co* **endDate**: *le, lt* **freshness**: *eq, ge, gt, le, lt* **name**: *eq, sw, co* **quality**: *eq, ge, gt, le, lt* **startDate**: *ge, gt* **saved**: *eq* **type**: *eq*
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPotentialRoleSummaries(sessionId: string, sorters?: string, filters?: string, offset?: number, limit?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleMiningPotentialRoleSummaryBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPotentialRoleSummaries(sessionId, sorters, filters, offset, limit, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The method retrieves a role mining session.
         * @summary Get a role mining session
         * @param {string} sessionId The role mining session id to be retrieved.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleMiningSession(sessionId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleMiningSessionResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleMiningSession(sessionId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method returns a role mining session status for a customer.
         * @summary Get role mining session status state
         * @param {string} sessionId The role mining session id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleMiningSessionStatus(sessionId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleMiningSessionStatusBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleMiningSessionStatus(sessionId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all role mining sessions that match the query parameters
         * @summary Retrieves all role mining sessions
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **saved**: *eq* \&quot;true\&quot; or \&quot;false\&quot; **name**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **createdBy, createdDate**
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleMiningSessions(filters?: string, sorters?: string, offset?: number, limit?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleMiningSessionDtoBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleMiningSessions(filters, sorters, offset, limit, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The method updates an existing potential role using.  The following fields can be modified:  * `description`  * `name`  * `saved`   >**NOTE: All other fields cannot be modified.** 
         * @summary Update a potential role
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId The potential role summary id
         * @param {Array<PatchPotentialRoleRequestInnerBeta>} patchPotentialRoleRequestInnerBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchPotentialRole(sessionId: string, potentialRoleId: string, patchPotentialRoleRequestInnerBeta: Array<PatchPotentialRoleRequestInnerBeta>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchPotentialRole(sessionId, potentialRoleId, patchPotentialRoleRequestInnerBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The  method updates an existing role mining session using PATCH. Supports op in {\"replace\"} and changes to pruneThreshold and/or minNumIdentitiesInPotentialRole. The potential roles in this role mining session is then re-calculated.
         * @summary Patch a role mining session
         * @param {string} sessionId The role mining session id to be patched
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta Replace pruneThreshold and/or minNumIdentitiesInPotentialRole in role mining session. Update saved status or saved name for a role mining session.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchRoleMiningSession(sessionId: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchRoleMiningSession(sessionId, jsonPatchOperationBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint adds or removes entitlements from an exclusion list for a potential role.
         * @summary Edit entitlements for a potential role to exclude some entitlements
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {RoleMiningPotentialRoleEditEntitlementsBeta} roleMiningPotentialRoleEditEntitlementsBeta Role mining session parameters
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntitlementsPotentialRole(sessionId: string, potentialRoleId: string, roleMiningPotentialRoleEditEntitlementsBeta: RoleMiningPotentialRoleEditEntitlementsBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleMiningPotentialRoleBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntitlementsPotentialRole(sessionId, potentialRoleId, roleMiningPotentialRoleEditEntitlementsBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IAIRoleMiningBetaApi - factory interface
 * @export
 */
export const IAIRoleMiningBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IAIRoleMiningBetaApiFp(configuration)
    return {
        /**
         * This method starts a job to provision a potential role
         * @summary Create request to provision a potential role into an actual role.
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {number} [minEntitlementPopularity] Minimum popularity required for an entitlement to be included in the provisioned role.
         * @param {boolean} [includeCommonAccess] Boolean determining whether common access entitlements will be included in the provisioned role.
         * @param {RoleMiningPotentialRoleProvisionRequestBeta} [roleMiningPotentialRoleProvisionRequestBeta] Required information to create a new role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPotentialRoleProvisionRequest(sessionId: string, potentialRoleId: string, minEntitlementPopularity?: number, includeCommonAccess?: boolean, roleMiningPotentialRoleProvisionRequestBeta?: RoleMiningPotentialRoleProvisionRequestBeta, axiosOptions?: any): AxiosPromise<RoleMiningPotentialRoleSummaryBeta> {
            return localVarFp.createPotentialRoleProvisionRequest(sessionId, potentialRoleId, minEntitlementPopularity, includeCommonAccess, roleMiningPotentialRoleProvisionRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This submits a create role mining session request to the role mining application.
         * @summary Create a role mining session
         * @param {RoleMiningSessionDtoBeta} roleMiningSessionDtoBeta Role mining session parameters
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createRoleMiningSessions(roleMiningSessionDtoBeta: RoleMiningSessionDtoBeta, axiosOptions?: any): AxiosPromise<RoleMiningSessionResponseBeta> {
            return localVarFp.createRoleMiningSessions(roleMiningSessionDtoBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint downloads a completed export of information for a potential role in a role mining session.
         * @summary Export (download) details for a potential role in a role mining session
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {string} exportId The id of a previously run export job for this potential role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        downloadRoleMiningPotentialRoleZip(sessionId: string, potentialRoleId: string, exportId: string, axiosOptions?: any): AxiosPromise<any> {
            return localVarFp.downloadRoleMiningPotentialRoleZip(sessionId, potentialRoleId, exportId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint downloads all the information for a potential role in a role mining session. Includes identities and entitlements in the potential role.
         * @summary Export (download) details for a potential role in a role mining session
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportRoleMiningPotentialRole(sessionId: string, potentialRoleId: string, axiosOptions?: any): AxiosPromise<any> {
            return localVarFp.exportRoleMiningPotentialRole(sessionId, potentialRoleId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint uploads all the information for a potential role in a role mining session to S3 as a downloadable zip archive.  Includes identities and entitlements in the potential role.
         * @summary Asynchronously export details for a potential role in a role mining session and upload to S3
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {RoleMiningPotentialRoleExportRequestBeta} [roleMiningPotentialRoleExportRequestBeta] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportRoleMiningPotentialRoleAsync(sessionId: string, potentialRoleId: string, roleMiningPotentialRoleExportRequestBeta?: RoleMiningPotentialRoleExportRequestBeta, axiosOptions?: any): AxiosPromise<RoleMiningPotentialRoleExportResponseBeta> {
            return localVarFp.exportRoleMiningPotentialRoleAsync(sessionId, potentialRoleId, roleMiningPotentialRoleExportRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves information about the current status of a potential role export.
         * @summary Retrieve status of a potential role export job
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {string} exportId The id of a previously run export job for this potential role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportRoleMiningPotentialRoleStatus(sessionId: string, potentialRoleId: string, exportId: string, axiosOptions?: any): AxiosPromise<RoleMiningPotentialRoleExportResponseBeta> {
            return localVarFp.exportRoleMiningPotentialRoleStatus(sessionId, potentialRoleId, exportId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This method returns entitlement popularity distribution for a potential role in a role mining session.
         * @summary Retrieves entitlement popularity distribution for a potential role in a role mining session
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {boolean} [includeCommonAccess] Boolean determining whether common access entitlements will be included or not
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getEntitlementDistributionPotentialRole(sessionId: string, potentialRoleId: string, includeCommonAccess?: boolean, axiosOptions?: any): AxiosPromise<{ [key: string]: number; }> {
            return localVarFp.getEntitlementDistributionPotentialRole(sessionId, potentialRoleId, includeCommonAccess, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This method returns entitlements for a potential role in a role mining session.
         * @summary Retrieves entitlements for a potential role in a role mining session
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {boolean} [includeCommonAccess] Boolean determining whether common access entitlements will be included or not
         * @param {string} [sorters] sort by popularity, default order descending
         * @param {string} [filters] Filter parameter by \&quot;starts with\&quot; for the applicationName and entitlementRef.name.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getEntitlementsPotentialRole(sessionId: string, potentialRoleId: string, includeCommonAccess?: boolean, sorters?: string, filters?: string, offset?: number, limit?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<RoleMiningEntitlementBeta>> {
            return localVarFp.getEntitlementsPotentialRole(sessionId, potentialRoleId, includeCommonAccess, sorters, filters, offset, limit, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This method returns excluded entitlements for a potential role in a role mining session.
         * @summary Retrieves excluded entitlements for a potential role in a role mining session
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {string} [sorters] sort by popularity, default order descending
         * @param {string} [filters] Filter parameter by \&quot;starts with\&quot; for the applicationName and entitlementRef.name.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getExcludedEntitlementsPotentialRole(sessionId: string, potentialRoleId: string, sorters?: string, filters?: string, offset?: number, limit?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<RoleMiningEntitlementBeta>> {
            return localVarFp.getExcludedEntitlementsPotentialRole(sessionId, potentialRoleId, sorters, filters, offset, limit, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This method returns identities for a potential role in a role mining session.
         * @summary Retrieves identities for a potential role in a role mining session
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {string} [sorters] sort by name, default order ascending
         * @param {string} [filters] Filter parameter by \&quot;starts with\&quot; for the name.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentitiesPotentialRole(sessionId: string, potentialRoleId: string, sorters?: string, filters?: string, offset?: number, limit?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<RoleMiningIdentityBeta>> {
            return localVarFp.getIdentitiesPotentialRole(sessionId, potentialRoleId, sorters, filters, offset, limit, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This method returns a specific potential role for a role mining session.
         * @summary Retrieves a specific potential role
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPotentialRole(sessionId: string, potentialRoleId: string, axiosOptions?: any): AxiosPromise<RoleMiningPotentialRoleBeta> {
            return localVarFp.getPotentialRole(sessionId, potentialRoleId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This method returns the applications of a potential role for a role mining session.
         * @summary Retrieves the applications of a potential role for a role mining session
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPotentialRoleApplications(sessionId: string, potentialRoleId: string, offset?: number, limit?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<RoleMiningPotentialRoleApplicationBeta>> {
            return localVarFp.getPotentialRoleApplications(sessionId, potentialRoleId, offset, limit, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This method returns the potential role summaries for a role mining session.
         * @summary Retrieves all potential role summaries
         * @param {string} sessionId The role mining session id
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters/) Sorting is supported for the following fields: **createdDate**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters/) Filtering is supported for the following fields and operators: **createdById**: *eq, sw, co* **createdByName**: *eq, sw, co* **description**: *sw, co* **endDate**: *le, lt* **freshness**: *eq, ge, gt, le, lt* **name**: *eq, sw, co* **quality**: *eq, ge, gt, le, lt* **startDate**: *ge, gt* **saved**: *eq* **type**: *eq*
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPotentialRoleSummaries(sessionId: string, sorters?: string, filters?: string, offset?: number, limit?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<RoleMiningPotentialRoleSummaryBeta>> {
            return localVarFp.getPotentialRoleSummaries(sessionId, sorters, filters, offset, limit, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * The method retrieves a role mining session.
         * @summary Get a role mining session
         * @param {string} sessionId The role mining session id to be retrieved.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRoleMiningSession(sessionId: string, axiosOptions?: any): AxiosPromise<RoleMiningSessionResponseBeta> {
            return localVarFp.getRoleMiningSession(sessionId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This method returns a role mining session status for a customer.
         * @summary Get role mining session status state
         * @param {string} sessionId The role mining session id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRoleMiningSessionStatus(sessionId: string, axiosOptions?: any): AxiosPromise<RoleMiningSessionStatusBeta> {
            return localVarFp.getRoleMiningSessionStatus(sessionId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Returns all role mining sessions that match the query parameters
         * @summary Retrieves all role mining sessions
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **saved**: *eq* \&quot;true\&quot; or \&quot;false\&quot; **name**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **createdBy, createdDate**
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRoleMiningSessions(filters?: string, sorters?: string, offset?: number, limit?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<RoleMiningSessionDtoBeta>> {
            return localVarFp.getRoleMiningSessions(filters, sorters, offset, limit, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * The method updates an existing potential role using.  The following fields can be modified:  * `description`  * `name`  * `saved`   >**NOTE: All other fields cannot be modified.** 
         * @summary Update a potential role
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId The potential role summary id
         * @param {Array<PatchPotentialRoleRequestInnerBeta>} patchPotentialRoleRequestInnerBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchPotentialRole(sessionId: string, potentialRoleId: string, patchPotentialRoleRequestInnerBeta: Array<PatchPotentialRoleRequestInnerBeta>, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.patchPotentialRole(sessionId, potentialRoleId, patchPotentialRoleRequestInnerBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * The  method updates an existing role mining session using PATCH. Supports op in {\"replace\"} and changes to pruneThreshold and/or minNumIdentitiesInPotentialRole. The potential roles in this role mining session is then re-calculated.
         * @summary Patch a role mining session
         * @param {string} sessionId The role mining session id to be patched
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta Replace pruneThreshold and/or minNumIdentitiesInPotentialRole in role mining session. Update saved status or saved name for a role mining session.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchRoleMiningSession(sessionId: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.patchRoleMiningSession(sessionId, jsonPatchOperationBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint adds or removes entitlements from an exclusion list for a potential role.
         * @summary Edit entitlements for a potential role to exclude some entitlements
         * @param {string} sessionId The role mining session id
         * @param {string} potentialRoleId A potential role id in a role mining session
         * @param {RoleMiningPotentialRoleEditEntitlementsBeta} roleMiningPotentialRoleEditEntitlementsBeta Role mining session parameters
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateEntitlementsPotentialRole(sessionId: string, potentialRoleId: string, roleMiningPotentialRoleEditEntitlementsBeta: RoleMiningPotentialRoleEditEntitlementsBeta, axiosOptions?: any): AxiosPromise<RoleMiningPotentialRoleBeta> {
            return localVarFp.updateEntitlementsPotentialRole(sessionId, potentialRoleId, roleMiningPotentialRoleEditEntitlementsBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPotentialRoleProvisionRequest operation in IAIRoleMiningBetaApi.
 * @export
 * @interface IAIRoleMiningBetaApiCreatePotentialRoleProvisionRequestRequest
 */
export interface IAIRoleMiningBetaApiCreatePotentialRoleProvisionRequestRequest {
    /**
     * The role mining session id
     * @type {string}
     * @memberof IAIRoleMiningBetaApiCreatePotentialRoleProvisionRequest
     */
    readonly sessionId: string

    /**
     * A potential role id in a role mining session
     * @type {string}
     * @memberof IAIRoleMiningBetaApiCreatePotentialRoleProvisionRequest
     */
    readonly potentialRoleId: string

    /**
     * Minimum popularity required for an entitlement to be included in the provisioned role.
     * @type {number}
     * @memberof IAIRoleMiningBetaApiCreatePotentialRoleProvisionRequest
     */
    readonly minEntitlementPopularity?: number

    /**
     * Boolean determining whether common access entitlements will be included in the provisioned role.
     * @type {boolean}
     * @memberof IAIRoleMiningBetaApiCreatePotentialRoleProvisionRequest
     */
    readonly includeCommonAccess?: boolean

    /**
     * Required information to create a new role
     * @type {RoleMiningPotentialRoleProvisionRequestBeta}
     * @memberof IAIRoleMiningBetaApiCreatePotentialRoleProvisionRequest
     */
    readonly roleMiningPotentialRoleProvisionRequestBeta?: RoleMiningPotentialRoleProvisionRequestBeta
}

/**
 * Request parameters for createRoleMiningSessions operation in IAIRoleMiningBetaApi.
 * @export
 * @interface IAIRoleMiningBetaApiCreateRoleMiningSessionsRequest
 */
export interface IAIRoleMiningBetaApiCreateRoleMiningSessionsRequest {
    /**
     * Role mining session parameters
     * @type {RoleMiningSessionDtoBeta}
     * @memberof IAIRoleMiningBetaApiCreateRoleMiningSessions
     */
    readonly roleMiningSessionDtoBeta: RoleMiningSessionDtoBeta
}

/**
 * Request parameters for downloadRoleMiningPotentialRoleZip operation in IAIRoleMiningBetaApi.
 * @export
 * @interface IAIRoleMiningBetaApiDownloadRoleMiningPotentialRoleZipRequest
 */
export interface IAIRoleMiningBetaApiDownloadRoleMiningPotentialRoleZipRequest {
    /**
     * The role mining session id
     * @type {string}
     * @memberof IAIRoleMiningBetaApiDownloadRoleMiningPotentialRoleZip
     */
    readonly sessionId: string

    /**
     * A potential role id in a role mining session
     * @type {string}
     * @memberof IAIRoleMiningBetaApiDownloadRoleMiningPotentialRoleZip
     */
    readonly potentialRoleId: string

    /**
     * The id of a previously run export job for this potential role
     * @type {string}
     * @memberof IAIRoleMiningBetaApiDownloadRoleMiningPotentialRoleZip
     */
    readonly exportId: string
}

/**
 * Request parameters for exportRoleMiningPotentialRole operation in IAIRoleMiningBetaApi.
 * @export
 * @interface IAIRoleMiningBetaApiExportRoleMiningPotentialRoleRequest
 */
export interface IAIRoleMiningBetaApiExportRoleMiningPotentialRoleRequest {
    /**
     * The role mining session id
     * @type {string}
     * @memberof IAIRoleMiningBetaApiExportRoleMiningPotentialRole
     */
    readonly sessionId: string

    /**
     * A potential role id in a role mining session
     * @type {string}
     * @memberof IAIRoleMiningBetaApiExportRoleMiningPotentialRole
     */
    readonly potentialRoleId: string
}

/**
 * Request parameters for exportRoleMiningPotentialRoleAsync operation in IAIRoleMiningBetaApi.
 * @export
 * @interface IAIRoleMiningBetaApiExportRoleMiningPotentialRoleAsyncRequest
 */
export interface IAIRoleMiningBetaApiExportRoleMiningPotentialRoleAsyncRequest {
    /**
     * The role mining session id
     * @type {string}
     * @memberof IAIRoleMiningBetaApiExportRoleMiningPotentialRoleAsync
     */
    readonly sessionId: string

    /**
     * A potential role id in a role mining session
     * @type {string}
     * @memberof IAIRoleMiningBetaApiExportRoleMiningPotentialRoleAsync
     */
    readonly potentialRoleId: string

    /**
     * 
     * @type {RoleMiningPotentialRoleExportRequestBeta}
     * @memberof IAIRoleMiningBetaApiExportRoleMiningPotentialRoleAsync
     */
    readonly roleMiningPotentialRoleExportRequestBeta?: RoleMiningPotentialRoleExportRequestBeta
}

/**
 * Request parameters for exportRoleMiningPotentialRoleStatus operation in IAIRoleMiningBetaApi.
 * @export
 * @interface IAIRoleMiningBetaApiExportRoleMiningPotentialRoleStatusRequest
 */
export interface IAIRoleMiningBetaApiExportRoleMiningPotentialRoleStatusRequest {
    /**
     * The role mining session id
     * @type {string}
     * @memberof IAIRoleMiningBetaApiExportRoleMiningPotentialRoleStatus
     */
    readonly sessionId: string

    /**
     * A potential role id in a role mining session
     * @type {string}
     * @memberof IAIRoleMiningBetaApiExportRoleMiningPotentialRoleStatus
     */
    readonly potentialRoleId: string

    /**
     * The id of a previously run export job for this potential role
     * @type {string}
     * @memberof IAIRoleMiningBetaApiExportRoleMiningPotentialRoleStatus
     */
    readonly exportId: string
}

/**
 * Request parameters for getEntitlementDistributionPotentialRole operation in IAIRoleMiningBetaApi.
 * @export
 * @interface IAIRoleMiningBetaApiGetEntitlementDistributionPotentialRoleRequest
 */
export interface IAIRoleMiningBetaApiGetEntitlementDistributionPotentialRoleRequest {
    /**
     * The role mining session id
     * @type {string}
     * @memberof IAIRoleMiningBetaApiGetEntitlementDistributionPotentialRole
     */
    readonly sessionId: string

    /**
     * A potential role id in a role mining session
     * @type {string}
     * @memberof IAIRoleMiningBetaApiGetEntitlementDistributionPotentialRole
     */
    readonly potentialRoleId: string

    /**
     * Boolean determining whether common access entitlements will be included or not
     * @type {boolean}
     * @memberof IAIRoleMiningBetaApiGetEntitlementDistributionPotentialRole
     */
    readonly includeCommonAccess?: boolean
}

/**
 * Request parameters for getEntitlementsPotentialRole operation in IAIRoleMiningBetaApi.
 * @export
 * @interface IAIRoleMiningBetaApiGetEntitlementsPotentialRoleRequest
 */
export interface IAIRoleMiningBetaApiGetEntitlementsPotentialRoleRequest {
    /**
     * The role mining session id
     * @type {string}
     * @memberof IAIRoleMiningBetaApiGetEntitlementsPotentialRole
     */
    readonly sessionId: string

    /**
     * A potential role id in a role mining session
     * @type {string}
     * @memberof IAIRoleMiningBetaApiGetEntitlementsPotentialRole
     */
    readonly potentialRoleId: string

    /**
     * Boolean determining whether common access entitlements will be included or not
     * @type {boolean}
     * @memberof IAIRoleMiningBetaApiGetEntitlementsPotentialRole
     */
    readonly includeCommonAccess?: boolean

    /**
     * sort by popularity, default order descending
     * @type {string}
     * @memberof IAIRoleMiningBetaApiGetEntitlementsPotentialRole
     */
    readonly sorters?: string

    /**
     * Filter parameter by \&quot;starts with\&quot; for the applicationName and entitlementRef.name.
     * @type {string}
     * @memberof IAIRoleMiningBetaApiGetEntitlementsPotentialRole
     */
    readonly filters?: string

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IAIRoleMiningBetaApiGetEntitlementsPotentialRole
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IAIRoleMiningBetaApiGetEntitlementsPotentialRole
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IAIRoleMiningBetaApiGetEntitlementsPotentialRole
     */
    readonly count?: boolean
}

/**
 * Request parameters for getExcludedEntitlementsPotentialRole operation in IAIRoleMiningBetaApi.
 * @export
 * @interface IAIRoleMiningBetaApiGetExcludedEntitlementsPotentialRoleRequest
 */
export interface IAIRoleMiningBetaApiGetExcludedEntitlementsPotentialRoleRequest {
    /**
     * The role mining session id
     * @type {string}
     * @memberof IAIRoleMiningBetaApiGetExcludedEntitlementsPotentialRole
     */
    readonly sessionId: string

    /**
     * A potential role id in a role mining session
     * @type {string}
     * @memberof IAIRoleMiningBetaApiGetExcludedEntitlementsPotentialRole
     */
    readonly potentialRoleId: string

    /**
     * sort by popularity, default order descending
     * @type {string}
     * @memberof IAIRoleMiningBetaApiGetExcludedEntitlementsPotentialRole
     */
    readonly sorters?: string

    /**
     * Filter parameter by \&quot;starts with\&quot; for the applicationName and entitlementRef.name.
     * @type {string}
     * @memberof IAIRoleMiningBetaApiGetExcludedEntitlementsPotentialRole
     */
    readonly filters?: string

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IAIRoleMiningBetaApiGetExcludedEntitlementsPotentialRole
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IAIRoleMiningBetaApiGetExcludedEntitlementsPotentialRole
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IAIRoleMiningBetaApiGetExcludedEntitlementsPotentialRole
     */
    readonly count?: boolean
}

/**
 * Request parameters for getIdentitiesPotentialRole operation in IAIRoleMiningBetaApi.
 * @export
 * @interface IAIRoleMiningBetaApiGetIdentitiesPotentialRoleRequest
 */
export interface IAIRoleMiningBetaApiGetIdentitiesPotentialRoleRequest {
    /**
     * The role mining session id
     * @type {string}
     * @memberof IAIRoleMiningBetaApiGetIdentitiesPotentialRole
     */
    readonly sessionId: string

    /**
     * A potential role id in a role mining session
     * @type {string}
     * @memberof IAIRoleMiningBetaApiGetIdentitiesPotentialRole
     */
    readonly potentialRoleId: string

    /**
     * sort by name, default order ascending
     * @type {string}
     * @memberof IAIRoleMiningBetaApiGetIdentitiesPotentialRole
     */
    readonly sorters?: string

    /**
     * Filter parameter by \&quot;starts with\&quot; for the name.
     * @type {string}
     * @memberof IAIRoleMiningBetaApiGetIdentitiesPotentialRole
     */
    readonly filters?: string

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IAIRoleMiningBetaApiGetIdentitiesPotentialRole
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IAIRoleMiningBetaApiGetIdentitiesPotentialRole
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IAIRoleMiningBetaApiGetIdentitiesPotentialRole
     */
    readonly count?: boolean
}

/**
 * Request parameters for getPotentialRole operation in IAIRoleMiningBetaApi.
 * @export
 * @interface IAIRoleMiningBetaApiGetPotentialRoleRequest
 */
export interface IAIRoleMiningBetaApiGetPotentialRoleRequest {
    /**
     * The role mining session id
     * @type {string}
     * @memberof IAIRoleMiningBetaApiGetPotentialRole
     */
    readonly sessionId: string

    /**
     * A potential role id in a role mining session
     * @type {string}
     * @memberof IAIRoleMiningBetaApiGetPotentialRole
     */
    readonly potentialRoleId: string
}

/**
 * Request parameters for getPotentialRoleApplications operation in IAIRoleMiningBetaApi.
 * @export
 * @interface IAIRoleMiningBetaApiGetPotentialRoleApplicationsRequest
 */
export interface IAIRoleMiningBetaApiGetPotentialRoleApplicationsRequest {
    /**
     * The role mining session id
     * @type {string}
     * @memberof IAIRoleMiningBetaApiGetPotentialRoleApplications
     */
    readonly sessionId: string

    /**
     * A potential role id in a role mining session
     * @type {string}
     * @memberof IAIRoleMiningBetaApiGetPotentialRoleApplications
     */
    readonly potentialRoleId: string

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IAIRoleMiningBetaApiGetPotentialRoleApplications
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IAIRoleMiningBetaApiGetPotentialRoleApplications
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IAIRoleMiningBetaApiGetPotentialRoleApplications
     */
    readonly count?: boolean
}

/**
 * Request parameters for getPotentialRoleSummaries operation in IAIRoleMiningBetaApi.
 * @export
 * @interface IAIRoleMiningBetaApiGetPotentialRoleSummariesRequest
 */
export interface IAIRoleMiningBetaApiGetPotentialRoleSummariesRequest {
    /**
     * The role mining session id
     * @type {string}
     * @memberof IAIRoleMiningBetaApiGetPotentialRoleSummaries
     */
    readonly sessionId: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters/) Sorting is supported for the following fields: **createdDate**
     * @type {string}
     * @memberof IAIRoleMiningBetaApiGetPotentialRoleSummaries
     */
    readonly sorters?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters/) Filtering is supported for the following fields and operators: **createdById**: *eq, sw, co* **createdByName**: *eq, sw, co* **description**: *sw, co* **endDate**: *le, lt* **freshness**: *eq, ge, gt, le, lt* **name**: *eq, sw, co* **quality**: *eq, ge, gt, le, lt* **startDate**: *ge, gt* **saved**: *eq* **type**: *eq*
     * @type {string}
     * @memberof IAIRoleMiningBetaApiGetPotentialRoleSummaries
     */
    readonly filters?: string

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IAIRoleMiningBetaApiGetPotentialRoleSummaries
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IAIRoleMiningBetaApiGetPotentialRoleSummaries
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IAIRoleMiningBetaApiGetPotentialRoleSummaries
     */
    readonly count?: boolean
}

/**
 * Request parameters for getRoleMiningSession operation in IAIRoleMiningBetaApi.
 * @export
 * @interface IAIRoleMiningBetaApiGetRoleMiningSessionRequest
 */
export interface IAIRoleMiningBetaApiGetRoleMiningSessionRequest {
    /**
     * The role mining session id to be retrieved.
     * @type {string}
     * @memberof IAIRoleMiningBetaApiGetRoleMiningSession
     */
    readonly sessionId: string
}

/**
 * Request parameters for getRoleMiningSessionStatus operation in IAIRoleMiningBetaApi.
 * @export
 * @interface IAIRoleMiningBetaApiGetRoleMiningSessionStatusRequest
 */
export interface IAIRoleMiningBetaApiGetRoleMiningSessionStatusRequest {
    /**
     * The role mining session id
     * @type {string}
     * @memberof IAIRoleMiningBetaApiGetRoleMiningSessionStatus
     */
    readonly sessionId: string
}

/**
 * Request parameters for getRoleMiningSessions operation in IAIRoleMiningBetaApi.
 * @export
 * @interface IAIRoleMiningBetaApiGetRoleMiningSessionsRequest
 */
export interface IAIRoleMiningBetaApiGetRoleMiningSessionsRequest {
    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **saved**: *eq* \&quot;true\&quot; or \&quot;false\&quot; **name**: *eq, sw*
     * @type {string}
     * @memberof IAIRoleMiningBetaApiGetRoleMiningSessions
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **createdBy, createdDate**
     * @type {string}
     * @memberof IAIRoleMiningBetaApiGetRoleMiningSessions
     */
    readonly sorters?: string

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IAIRoleMiningBetaApiGetRoleMiningSessions
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IAIRoleMiningBetaApiGetRoleMiningSessions
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IAIRoleMiningBetaApiGetRoleMiningSessions
     */
    readonly count?: boolean
}

/**
 * Request parameters for patchPotentialRole operation in IAIRoleMiningBetaApi.
 * @export
 * @interface IAIRoleMiningBetaApiPatchPotentialRoleRequest
 */
export interface IAIRoleMiningBetaApiPatchPotentialRoleRequest {
    /**
     * The role mining session id
     * @type {string}
     * @memberof IAIRoleMiningBetaApiPatchPotentialRole
     */
    readonly sessionId: string

    /**
     * The potential role summary id
     * @type {string}
     * @memberof IAIRoleMiningBetaApiPatchPotentialRole
     */
    readonly potentialRoleId: string

    /**
     * 
     * @type {Array<PatchPotentialRoleRequestInnerBeta>}
     * @memberof IAIRoleMiningBetaApiPatchPotentialRole
     */
    readonly patchPotentialRoleRequestInnerBeta: Array<PatchPotentialRoleRequestInnerBeta>
}

/**
 * Request parameters for patchRoleMiningSession operation in IAIRoleMiningBetaApi.
 * @export
 * @interface IAIRoleMiningBetaApiPatchRoleMiningSessionRequest
 */
export interface IAIRoleMiningBetaApiPatchRoleMiningSessionRequest {
    /**
     * The role mining session id to be patched
     * @type {string}
     * @memberof IAIRoleMiningBetaApiPatchRoleMiningSession
     */
    readonly sessionId: string

    /**
     * Replace pruneThreshold and/or minNumIdentitiesInPotentialRole in role mining session. Update saved status or saved name for a role mining session.
     * @type {Array<JsonPatchOperationBeta>}
     * @memberof IAIRoleMiningBetaApiPatchRoleMiningSession
     */
    readonly jsonPatchOperationBeta: Array<JsonPatchOperationBeta>
}

/**
 * Request parameters for updateEntitlementsPotentialRole operation in IAIRoleMiningBetaApi.
 * @export
 * @interface IAIRoleMiningBetaApiUpdateEntitlementsPotentialRoleRequest
 */
export interface IAIRoleMiningBetaApiUpdateEntitlementsPotentialRoleRequest {
    /**
     * The role mining session id
     * @type {string}
     * @memberof IAIRoleMiningBetaApiUpdateEntitlementsPotentialRole
     */
    readonly sessionId: string

    /**
     * A potential role id in a role mining session
     * @type {string}
     * @memberof IAIRoleMiningBetaApiUpdateEntitlementsPotentialRole
     */
    readonly potentialRoleId: string

    /**
     * Role mining session parameters
     * @type {RoleMiningPotentialRoleEditEntitlementsBeta}
     * @memberof IAIRoleMiningBetaApiUpdateEntitlementsPotentialRole
     */
    readonly roleMiningPotentialRoleEditEntitlementsBeta: RoleMiningPotentialRoleEditEntitlementsBeta
}

/**
 * IAIRoleMiningBetaApi - object-oriented interface
 * @export
 * @class IAIRoleMiningBetaApi
 * @extends {BaseAPI}
 */
export class IAIRoleMiningBetaApi extends BaseAPI {
    /**
     * This method starts a job to provision a potential role
     * @summary Create request to provision a potential role into an actual role.
     * @param {IAIRoleMiningBetaApiCreatePotentialRoleProvisionRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIRoleMiningBetaApi
     */
    public createPotentialRoleProvisionRequest(requestParameters: IAIRoleMiningBetaApiCreatePotentialRoleProvisionRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIRoleMiningBetaApiFp(this.configuration).createPotentialRoleProvisionRequest(requestParameters.sessionId, requestParameters.potentialRoleId, requestParameters.minEntitlementPopularity, requestParameters.includeCommonAccess, requestParameters.roleMiningPotentialRoleProvisionRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This submits a create role mining session request to the role mining application.
     * @summary Create a role mining session
     * @param {IAIRoleMiningBetaApiCreateRoleMiningSessionsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIRoleMiningBetaApi
     */
    public createRoleMiningSessions(requestParameters: IAIRoleMiningBetaApiCreateRoleMiningSessionsRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIRoleMiningBetaApiFp(this.configuration).createRoleMiningSessions(requestParameters.roleMiningSessionDtoBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint downloads a completed export of information for a potential role in a role mining session.
     * @summary Export (download) details for a potential role in a role mining session
     * @param {IAIRoleMiningBetaApiDownloadRoleMiningPotentialRoleZipRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIRoleMiningBetaApi
     */
    public downloadRoleMiningPotentialRoleZip(requestParameters: IAIRoleMiningBetaApiDownloadRoleMiningPotentialRoleZipRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIRoleMiningBetaApiFp(this.configuration).downloadRoleMiningPotentialRoleZip(requestParameters.sessionId, requestParameters.potentialRoleId, requestParameters.exportId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint downloads all the information for a potential role in a role mining session. Includes identities and entitlements in the potential role.
     * @summary Export (download) details for a potential role in a role mining session
     * @param {IAIRoleMiningBetaApiExportRoleMiningPotentialRoleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIRoleMiningBetaApi
     */
    public exportRoleMiningPotentialRole(requestParameters: IAIRoleMiningBetaApiExportRoleMiningPotentialRoleRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIRoleMiningBetaApiFp(this.configuration).exportRoleMiningPotentialRole(requestParameters.sessionId, requestParameters.potentialRoleId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint uploads all the information for a potential role in a role mining session to S3 as a downloadable zip archive.  Includes identities and entitlements in the potential role.
     * @summary Asynchronously export details for a potential role in a role mining session and upload to S3
     * @param {IAIRoleMiningBetaApiExportRoleMiningPotentialRoleAsyncRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIRoleMiningBetaApi
     */
    public exportRoleMiningPotentialRoleAsync(requestParameters: IAIRoleMiningBetaApiExportRoleMiningPotentialRoleAsyncRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIRoleMiningBetaApiFp(this.configuration).exportRoleMiningPotentialRoleAsync(requestParameters.sessionId, requestParameters.potentialRoleId, requestParameters.roleMiningPotentialRoleExportRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves information about the current status of a potential role export.
     * @summary Retrieve status of a potential role export job
     * @param {IAIRoleMiningBetaApiExportRoleMiningPotentialRoleStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIRoleMiningBetaApi
     */
    public exportRoleMiningPotentialRoleStatus(requestParameters: IAIRoleMiningBetaApiExportRoleMiningPotentialRoleStatusRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIRoleMiningBetaApiFp(this.configuration).exportRoleMiningPotentialRoleStatus(requestParameters.sessionId, requestParameters.potentialRoleId, requestParameters.exportId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method returns entitlement popularity distribution for a potential role in a role mining session.
     * @summary Retrieves entitlement popularity distribution for a potential role in a role mining session
     * @param {IAIRoleMiningBetaApiGetEntitlementDistributionPotentialRoleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIRoleMiningBetaApi
     */
    public getEntitlementDistributionPotentialRole(requestParameters: IAIRoleMiningBetaApiGetEntitlementDistributionPotentialRoleRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIRoleMiningBetaApiFp(this.configuration).getEntitlementDistributionPotentialRole(requestParameters.sessionId, requestParameters.potentialRoleId, requestParameters.includeCommonAccess, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method returns entitlements for a potential role in a role mining session.
     * @summary Retrieves entitlements for a potential role in a role mining session
     * @param {IAIRoleMiningBetaApiGetEntitlementsPotentialRoleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIRoleMiningBetaApi
     */
    public getEntitlementsPotentialRole(requestParameters: IAIRoleMiningBetaApiGetEntitlementsPotentialRoleRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIRoleMiningBetaApiFp(this.configuration).getEntitlementsPotentialRole(requestParameters.sessionId, requestParameters.potentialRoleId, requestParameters.includeCommonAccess, requestParameters.sorters, requestParameters.filters, requestParameters.offset, requestParameters.limit, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method returns excluded entitlements for a potential role in a role mining session.
     * @summary Retrieves excluded entitlements for a potential role in a role mining session
     * @param {IAIRoleMiningBetaApiGetExcludedEntitlementsPotentialRoleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIRoleMiningBetaApi
     */
    public getExcludedEntitlementsPotentialRole(requestParameters: IAIRoleMiningBetaApiGetExcludedEntitlementsPotentialRoleRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIRoleMiningBetaApiFp(this.configuration).getExcludedEntitlementsPotentialRole(requestParameters.sessionId, requestParameters.potentialRoleId, requestParameters.sorters, requestParameters.filters, requestParameters.offset, requestParameters.limit, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method returns identities for a potential role in a role mining session.
     * @summary Retrieves identities for a potential role in a role mining session
     * @param {IAIRoleMiningBetaApiGetIdentitiesPotentialRoleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIRoleMiningBetaApi
     */
    public getIdentitiesPotentialRole(requestParameters: IAIRoleMiningBetaApiGetIdentitiesPotentialRoleRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIRoleMiningBetaApiFp(this.configuration).getIdentitiesPotentialRole(requestParameters.sessionId, requestParameters.potentialRoleId, requestParameters.sorters, requestParameters.filters, requestParameters.offset, requestParameters.limit, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method returns a specific potential role for a role mining session.
     * @summary Retrieves a specific potential role
     * @param {IAIRoleMiningBetaApiGetPotentialRoleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIRoleMiningBetaApi
     */
    public getPotentialRole(requestParameters: IAIRoleMiningBetaApiGetPotentialRoleRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIRoleMiningBetaApiFp(this.configuration).getPotentialRole(requestParameters.sessionId, requestParameters.potentialRoleId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method returns the applications of a potential role for a role mining session.
     * @summary Retrieves the applications of a potential role for a role mining session
     * @param {IAIRoleMiningBetaApiGetPotentialRoleApplicationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIRoleMiningBetaApi
     */
    public getPotentialRoleApplications(requestParameters: IAIRoleMiningBetaApiGetPotentialRoleApplicationsRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIRoleMiningBetaApiFp(this.configuration).getPotentialRoleApplications(requestParameters.sessionId, requestParameters.potentialRoleId, requestParameters.offset, requestParameters.limit, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method returns the potential role summaries for a role mining session.
     * @summary Retrieves all potential role summaries
     * @param {IAIRoleMiningBetaApiGetPotentialRoleSummariesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIRoleMiningBetaApi
     */
    public getPotentialRoleSummaries(requestParameters: IAIRoleMiningBetaApiGetPotentialRoleSummariesRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIRoleMiningBetaApiFp(this.configuration).getPotentialRoleSummaries(requestParameters.sessionId, requestParameters.sorters, requestParameters.filters, requestParameters.offset, requestParameters.limit, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The method retrieves a role mining session.
     * @summary Get a role mining session
     * @param {IAIRoleMiningBetaApiGetRoleMiningSessionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIRoleMiningBetaApi
     */
    public getRoleMiningSession(requestParameters: IAIRoleMiningBetaApiGetRoleMiningSessionRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIRoleMiningBetaApiFp(this.configuration).getRoleMiningSession(requestParameters.sessionId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method returns a role mining session status for a customer.
     * @summary Get role mining session status state
     * @param {IAIRoleMiningBetaApiGetRoleMiningSessionStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIRoleMiningBetaApi
     */
    public getRoleMiningSessionStatus(requestParameters: IAIRoleMiningBetaApiGetRoleMiningSessionStatusRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIRoleMiningBetaApiFp(this.configuration).getRoleMiningSessionStatus(requestParameters.sessionId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all role mining sessions that match the query parameters
     * @summary Retrieves all role mining sessions
     * @param {IAIRoleMiningBetaApiGetRoleMiningSessionsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIRoleMiningBetaApi
     */
    public getRoleMiningSessions(requestParameters: IAIRoleMiningBetaApiGetRoleMiningSessionsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return IAIRoleMiningBetaApiFp(this.configuration).getRoleMiningSessions(requestParameters.filters, requestParameters.sorters, requestParameters.offset, requestParameters.limit, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The method updates an existing potential role using.  The following fields can be modified:  * `description`  * `name`  * `saved`   >**NOTE: All other fields cannot be modified.** 
     * @summary Update a potential role
     * @param {IAIRoleMiningBetaApiPatchPotentialRoleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIRoleMiningBetaApi
     */
    public patchPotentialRole(requestParameters: IAIRoleMiningBetaApiPatchPotentialRoleRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIRoleMiningBetaApiFp(this.configuration).patchPotentialRole(requestParameters.sessionId, requestParameters.potentialRoleId, requestParameters.patchPotentialRoleRequestInnerBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The  method updates an existing role mining session using PATCH. Supports op in {\"replace\"} and changes to pruneThreshold and/or minNumIdentitiesInPotentialRole. The potential roles in this role mining session is then re-calculated.
     * @summary Patch a role mining session
     * @param {IAIRoleMiningBetaApiPatchRoleMiningSessionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIRoleMiningBetaApi
     */
    public patchRoleMiningSession(requestParameters: IAIRoleMiningBetaApiPatchRoleMiningSessionRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIRoleMiningBetaApiFp(this.configuration).patchRoleMiningSession(requestParameters.sessionId, requestParameters.jsonPatchOperationBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint adds or removes entitlements from an exclusion list for a potential role.
     * @summary Edit entitlements for a potential role to exclude some entitlements
     * @param {IAIRoleMiningBetaApiUpdateEntitlementsPotentialRoleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IAIRoleMiningBetaApi
     */
    public updateEntitlementsPotentialRole(requestParameters: IAIRoleMiningBetaApiUpdateEntitlementsPotentialRoleRequest, axiosOptions?: AxiosRequestConfig) {
        return IAIRoleMiningBetaApiFp(this.configuration).updateEntitlementsPotentialRole(requestParameters.sessionId, requestParameters.potentialRoleId, requestParameters.roleMiningPotentialRoleEditEntitlementsBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdentitiesBetaApi - axios parameter creator
 * @export
 */
export const IdentitiesBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The API returns successful response if the requested identity was deleted.
         * @summary Deletes an identity.
         * @param {string} id Identity Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentity: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteIdentity', 'id', id)
            const localVarPath = `/identities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a single identity using the Identity ID.
         * @summary Identity Details
         * @param {string} id Identity Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentity: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentity', 'id', id)
            const localVarPath = `/identities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of identities.
         * @summary List Identities
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **alias**: *eq, sw*  **firstname**: *eq, sw*  **lastname**: *eq, sw*  **email**: *eq, sw*  **cloudStatus**: *eq*  **processingState**: *eq*  **correlated**: *eq*  **protected**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters/#sorting-results)  Sorting is supported for the following fields: **name, alias, cloudStatus**
         * @param {'CORRELATED_ONLY' | 'NONE'} [defaultFilter] Adds additional filter to filters query parameter.  CORRELATED_ONLY adds correlated&#x3D;true and returns only identities that are correlated.  NONE does not add any and returns all identities that satisfy filters query parameter.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentities: async (filters?: string, sorters?: string, defaultFilter?: 'CORRELATED_ONLY' | 'NONE', count?: boolean, limit?: number, offset?: number, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (defaultFilter !== undefined) {
                localVarQueryParameter['defaultFilter'] = defaultFilter;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * You could use this endpoint to: 1. Calculate identity attributes, including applying or running any rules or transforms (e.g. calculate Lifecycle State at a point-in-time it\'s expected to change). 2. Evaluate role assignments, leading to assignment of new roles and removal of existing roles. 3. Enforce provisioning for any assigned accesses that haven\'t been fulfilled (e.g. failure due to source health). 4. Recalculate manager relationships. 5. Potentially clean-up identity processing errors, assuming the error has been resolved.  To learn more, refer to the [identity processing documentation](https://documentation.sailpoint.com/saas/help/setup/identity_processing.html). 
         * @summary Process a list of identityIds
         * @param {ProcessIdentitiesRequestBeta} processIdentitiesRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startIdentityProcessing: async (processIdentitiesRequestBeta: ProcessIdentitiesRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'processIdentitiesRequestBeta' is not null or undefined
            assertParamExists('startIdentityProcessing', 'processIdentitiesRequestBeta', processIdentitiesRequestBeta)
            const localVarPath = `/identities/process`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processIdentitiesRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point performs attribute synchronization for a selected identity. The endpoint can be called once in 10 seconds per identity. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Attribute synchronization for single identity.
         * @param {string} identityId The Identity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        synchronizeAttributesForIdentity: async (identityId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('synchronizeAttributesForIdentity', 'identityId', identityId)
            const localVarPath = `/identities/{identityId}/synchronize-attributes`
                .replace(`{${"identityId"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdentitiesBetaApi - functional programming interface
 * @export
 */
export const IdentitiesBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdentitiesBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * The API returns successful response if the requested identity was deleted.
         * @summary Deletes an identity.
         * @param {string} id Identity Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIdentity(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIdentity(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a single identity using the Identity ID.
         * @summary Identity Details
         * @param {string} id Identity Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentity(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentity(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of identities.
         * @summary List Identities
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **alias**: *eq, sw*  **firstname**: *eq, sw*  **lastname**: *eq, sw*  **email**: *eq, sw*  **cloudStatus**: *eq*  **processingState**: *eq*  **correlated**: *eq*  **protected**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters/#sorting-results)  Sorting is supported for the following fields: **name, alias, cloudStatus**
         * @param {'CORRELATED_ONLY' | 'NONE'} [defaultFilter] Adds additional filter to filters query parameter.  CORRELATED_ONLY adds correlated&#x3D;true and returns only identities that are correlated.  NONE does not add any and returns all identities that satisfy filters query parameter.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listIdentities(filters?: string, sorters?: string, defaultFilter?: 'CORRELATED_ONLY' | 'NONE', count?: boolean, limit?: number, offset?: number, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentityBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdentities(filters, sorters, defaultFilter, count, limit, offset, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * You could use this endpoint to: 1. Calculate identity attributes, including applying or running any rules or transforms (e.g. calculate Lifecycle State at a point-in-time it\'s expected to change). 2. Evaluate role assignments, leading to assignment of new roles and removal of existing roles. 3. Enforce provisioning for any assigned accesses that haven\'t been fulfilled (e.g. failure due to source health). 4. Recalculate manager relationships. 5. Potentially clean-up identity processing errors, assuming the error has been resolved.  To learn more, refer to the [identity processing documentation](https://documentation.sailpoint.com/saas/help/setup/identity_processing.html). 
         * @summary Process a list of identityIds
         * @param {ProcessIdentitiesRequestBeta} processIdentitiesRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startIdentityProcessing(processIdentitiesRequestBeta: ProcessIdentitiesRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseReferenceDtoBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startIdentityProcessing(processIdentitiesRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point performs attribute synchronization for a selected identity. The endpoint can be called once in 10 seconds per identity. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Attribute synchronization for single identity.
         * @param {string} identityId The Identity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async synchronizeAttributesForIdentity(identityId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentitySyncJobBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.synchronizeAttributesForIdentity(identityId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdentitiesBetaApi - factory interface
 * @export
 */
export const IdentitiesBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdentitiesBetaApiFp(configuration)
    return {
        /**
         * The API returns successful response if the requested identity was deleted.
         * @summary Deletes an identity.
         * @param {string} id Identity Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentity(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteIdentity(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a single identity using the Identity ID.
         * @summary Identity Details
         * @param {string} id Identity Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentity(id: string, axiosOptions?: any): AxiosPromise<IdentityBeta> {
            return localVarFp.getIdentity(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of identities.
         * @summary List Identities
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **alias**: *eq, sw*  **firstname**: *eq, sw*  **lastname**: *eq, sw*  **email**: *eq, sw*  **cloudStatus**: *eq*  **processingState**: *eq*  **correlated**: *eq*  **protected**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters/#sorting-results)  Sorting is supported for the following fields: **name, alias, cloudStatus**
         * @param {'CORRELATED_ONLY' | 'NONE'} [defaultFilter] Adds additional filter to filters query parameter.  CORRELATED_ONLY adds correlated&#x3D;true and returns only identities that are correlated.  NONE does not add any and returns all identities that satisfy filters query parameter.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentities(filters?: string, sorters?: string, defaultFilter?: 'CORRELATED_ONLY' | 'NONE', count?: boolean, limit?: number, offset?: number, axiosOptions?: any): AxiosPromise<Array<IdentityBeta>> {
            return localVarFp.listIdentities(filters, sorters, defaultFilter, count, limit, offset, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * You could use this endpoint to: 1. Calculate identity attributes, including applying or running any rules or transforms (e.g. calculate Lifecycle State at a point-in-time it\'s expected to change). 2. Evaluate role assignments, leading to assignment of new roles and removal of existing roles. 3. Enforce provisioning for any assigned accesses that haven\'t been fulfilled (e.g. failure due to source health). 4. Recalculate manager relationships. 5. Potentially clean-up identity processing errors, assuming the error has been resolved.  To learn more, refer to the [identity processing documentation](https://documentation.sailpoint.com/saas/help/setup/identity_processing.html). 
         * @summary Process a list of identityIds
         * @param {ProcessIdentitiesRequestBeta} processIdentitiesRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startIdentityProcessing(processIdentitiesRequestBeta: ProcessIdentitiesRequestBeta, axiosOptions?: any): AxiosPromise<BaseReferenceDtoBeta> {
            return localVarFp.startIdentityProcessing(processIdentitiesRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point performs attribute synchronization for a selected identity. The endpoint can be called once in 10 seconds per identity. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Attribute synchronization for single identity.
         * @param {string} identityId The Identity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        synchronizeAttributesForIdentity(identityId: string, axiosOptions?: any): AxiosPromise<IdentitySyncJobBeta> {
            return localVarFp.synchronizeAttributesForIdentity(identityId, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteIdentity operation in IdentitiesBetaApi.
 * @export
 * @interface IdentitiesBetaApiDeleteIdentityRequest
 */
export interface IdentitiesBetaApiDeleteIdentityRequest {
    /**
     * Identity Id
     * @type {string}
     * @memberof IdentitiesBetaApiDeleteIdentity
     */
    readonly id: string
}

/**
 * Request parameters for getIdentity operation in IdentitiesBetaApi.
 * @export
 * @interface IdentitiesBetaApiGetIdentityRequest
 */
export interface IdentitiesBetaApiGetIdentityRequest {
    /**
     * Identity Id
     * @type {string}
     * @memberof IdentitiesBetaApiGetIdentity
     */
    readonly id: string
}

/**
 * Request parameters for listIdentities operation in IdentitiesBetaApi.
 * @export
 * @interface IdentitiesBetaApiListIdentitiesRequest
 */
export interface IdentitiesBetaApiListIdentitiesRequest {
    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **alias**: *eq, sw*  **firstname**: *eq, sw*  **lastname**: *eq, sw*  **email**: *eq, sw*  **cloudStatus**: *eq*  **processingState**: *eq*  **correlated**: *eq*  **protected**: *eq*
     * @type {string}
     * @memberof IdentitiesBetaApiListIdentities
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters/#sorting-results)  Sorting is supported for the following fields: **name, alias, cloudStatus**
     * @type {string}
     * @memberof IdentitiesBetaApiListIdentities
     */
    readonly sorters?: string

    /**
     * Adds additional filter to filters query parameter.  CORRELATED_ONLY adds correlated&#x3D;true and returns only identities that are correlated.  NONE does not add any and returns all identities that satisfy filters query parameter.
     * @type {'CORRELATED_ONLY' | 'NONE'}
     * @memberof IdentitiesBetaApiListIdentities
     */
    readonly defaultFilter?: 'CORRELATED_ONLY' | 'NONE'

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IdentitiesBetaApiListIdentities
     */
    readonly count?: boolean

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentitiesBetaApiListIdentities
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentitiesBetaApiListIdentities
     */
    readonly offset?: number
}

/**
 * Request parameters for startIdentityProcessing operation in IdentitiesBetaApi.
 * @export
 * @interface IdentitiesBetaApiStartIdentityProcessingRequest
 */
export interface IdentitiesBetaApiStartIdentityProcessingRequest {
    /**
     * 
     * @type {ProcessIdentitiesRequestBeta}
     * @memberof IdentitiesBetaApiStartIdentityProcessing
     */
    readonly processIdentitiesRequestBeta: ProcessIdentitiesRequestBeta
}

/**
 * Request parameters for synchronizeAttributesForIdentity operation in IdentitiesBetaApi.
 * @export
 * @interface IdentitiesBetaApiSynchronizeAttributesForIdentityRequest
 */
export interface IdentitiesBetaApiSynchronizeAttributesForIdentityRequest {
    /**
     * The Identity id
     * @type {string}
     * @memberof IdentitiesBetaApiSynchronizeAttributesForIdentity
     */
    readonly identityId: string
}

/**
 * IdentitiesBetaApi - object-oriented interface
 * @export
 * @class IdentitiesBetaApi
 * @extends {BaseAPI}
 */
export class IdentitiesBetaApi extends BaseAPI {
    /**
     * The API returns successful response if the requested identity was deleted.
     * @summary Deletes an identity.
     * @param {IdentitiesBetaApiDeleteIdentityRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentitiesBetaApi
     */
    public deleteIdentity(requestParameters: IdentitiesBetaApiDeleteIdentityRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentitiesBetaApiFp(this.configuration).deleteIdentity(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a single identity using the Identity ID.
     * @summary Identity Details
     * @param {IdentitiesBetaApiGetIdentityRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentitiesBetaApi
     */
    public getIdentity(requestParameters: IdentitiesBetaApiGetIdentityRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentitiesBetaApiFp(this.configuration).getIdentity(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of identities.
     * @summary List Identities
     * @param {IdentitiesBetaApiListIdentitiesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentitiesBetaApi
     */
    public listIdentities(requestParameters: IdentitiesBetaApiListIdentitiesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return IdentitiesBetaApiFp(this.configuration).listIdentities(requestParameters.filters, requestParameters.sorters, requestParameters.defaultFilter, requestParameters.count, requestParameters.limit, requestParameters.offset, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You could use this endpoint to: 1. Calculate identity attributes, including applying or running any rules or transforms (e.g. calculate Lifecycle State at a point-in-time it\'s expected to change). 2. Evaluate role assignments, leading to assignment of new roles and removal of existing roles. 3. Enforce provisioning for any assigned accesses that haven\'t been fulfilled (e.g. failure due to source health). 4. Recalculate manager relationships. 5. Potentially clean-up identity processing errors, assuming the error has been resolved.  To learn more, refer to the [identity processing documentation](https://documentation.sailpoint.com/saas/help/setup/identity_processing.html). 
     * @summary Process a list of identityIds
     * @param {IdentitiesBetaApiStartIdentityProcessingRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentitiesBetaApi
     */
    public startIdentityProcessing(requestParameters: IdentitiesBetaApiStartIdentityProcessingRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentitiesBetaApiFp(this.configuration).startIdentityProcessing(requestParameters.processIdentitiesRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point performs attribute synchronization for a selected identity. The endpoint can be called once in 10 seconds per identity. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Attribute synchronization for single identity.
     * @param {IdentitiesBetaApiSynchronizeAttributesForIdentityRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentitiesBetaApi
     */
    public synchronizeAttributesForIdentity(requestParameters: IdentitiesBetaApiSynchronizeAttributesForIdentityRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentitiesBetaApiFp(this.configuration).synchronizeAttributesForIdentity(requestParameters.identityId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdentityHistoryBetaApi - axios parameter creator
 * @export
 */
export const IdentityHistoryBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This method gets a difference of count for each access item types for the given identity between 2 snapshots Requires authorization scope of \'idn:identity-history:read\' 
         * @summary Gets a difference of count for each access item types for the given identity between 2 snapshots
         * @param {string} id The identity id
         * @param {string} [snapshot1] The snapshot 1 of identity
         * @param {string} [snapshot2] The snapshot 2 of identity
         * @param {Array<string>} [accessItemTypes] An optional list of access item types (app, account, entitlement, etc...) to return.   If null or empty, all access items types are returned 
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        compareIdentitySnapshots: async (id: string, snapshot1?: string, snapshot2?: string, accessItemTypes?: Array<string>, limit?: number, offset?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('compareIdentitySnapshots', 'id', id)
            const localVarPath = `/historical-identities/{id}/compare`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (snapshot1 !== undefined) {
                localVarQueryParameter['snapshot1'] = snapshot1;
            }

            if (snapshot2 !== undefined) {
                localVarQueryParameter['snapshot2'] = snapshot2;
            }

            if (accessItemTypes) {
                localVarQueryParameter['accessItemTypes'] = accessItemTypes.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This method gets a list of differences of specific accessType for the given identity between 2 snapshots Requires authorization scope of \'idn:identity-history:read\' 
         * @summary Gets a list of differences of specific accessType for the given identity between 2 snapshots
         * @param {string} id The identity id
         * @param {string} accessType The specific type which needs to be compared
         * @param {boolean} [accessAssociated] Indicates if added or removed access needs to be returned. true - added, false - removed, null - both added &amp; removed
         * @param {string} [snapshot1] The snapshot 1 of identity
         * @param {string} [snapshot2] The snapshot 2 of identity
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        compareIdentitySnapshotsAccessType: async (id: string, accessType: string, accessAssociated?: boolean, snapshot1?: string, snapshot2?: string, limit?: number, offset?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('compareIdentitySnapshotsAccessType', 'id', id)
            // verify required parameter 'accessType' is not null or undefined
            assertParamExists('compareIdentitySnapshotsAccessType', 'accessType', accessType)
            const localVarPath = `/historical-identities/{id}/compare/{access-type}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"accessType"}}`, encodeURIComponent(String(accessType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (accessAssociated !== undefined) {
                localVarQueryParameter['access-associated'] = accessAssociated;
            }

            if (snapshot1 !== undefined) {
                localVarQueryParameter['snapshot1'] = snapshot1;
            }

            if (snapshot2 !== undefined) {
                localVarQueryParameter['snapshot2'] = snapshot2;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This method retrieves a specified identity Requires authorization scope of \'idn:identity-history:read\'
         * @summary Get latest snapshot of identity
         * @param {string} id The identity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricalIdentity: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getHistoricalIdentity', 'id', id)
            const localVarPath = `/historical-identities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This method retrieves all access events for the identity Requires authorization scope of \'idn:identity-history:read\' 
         * @summary Lists all events for the given identity
         * @param {string} id The identity id
         * @param {string} [from] The optional instant from which to return the access events
         * @param {Array<string>} [eventTypes] An optional list of event types to return.  If null or empty, all events are returned
         * @param {Array<string>} [accessItemTypes] An optional list of access item types (app, account, entitlement, etc...) to return.   If null or empty, all access items types are returned
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricalIdentityEvents: async (id: string, from?: string, eventTypes?: Array<string>, accessItemTypes?: Array<string>, limit?: number, offset?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getHistoricalIdentityEvents', 'id', id)
            const localVarPath = `/historical-identities/{id}/events`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (eventTypes) {
                localVarQueryParameter['eventTypes'] = eventTypes.join(COLLECTION_FORMATS.csv);
            }

            if (accessItemTypes) {
                localVarQueryParameter['accessItemTypes'] = accessItemTypes.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This method retrieves a specified identity snapshot at a given date Requires authorization scope of \'idn:identity-history:read\' 
         * @summary Gets an identity snapshot at a given date
         * @param {string} id The identity id
         * @param {string} date The specified date
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentitySnapshot: async (id: string, date: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentitySnapshot', 'id', id)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('getIdentitySnapshot', 'date', date)
            const localVarPath = `/historical-identities/{id}/snapshots/{date}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This method gets the summary for the event count for a specific identity by month/day Requires authorization scope of \'idn:identity-history:read\' 
         * @summary Gets the summary for the event count for a specific identity
         * @param {string} id The identity id
         * @param {string} [before] The date before which snapshot summary is required
         * @param {'day' | 'month'} [interval] The interval indicating day or month. Defaults to month if not specified
         * @param {string} [timeZone] The time zone. Defaults to UTC if not provided
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentitySnapshotSummary: async (id: string, before?: string, interval?: 'day' | 'month', timeZone?: string, limit?: number, offset?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentitySnapshotSummary', 'id', id)
            const localVarPath = `/historical-identities/{id}/snapshot-summary`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (timeZone !== undefined) {
                localVarQueryParameter['time-zone'] = timeZone;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This method retrieves start date of the identity Requires authorization scope of \'idn:identity-history:read\' 
         * @summary Gets the start date of the identity
         * @param {string} id The identity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityStartDate: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentityStartDate', 'id', id)
            const localVarPath = `/historical-identities/{id}/start-date`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets the list of identities for the customer. This list end point does not support count=true request param. The total  count of identities would never be returned even if the count param is specified in the request Requires authorization scope of \'idn:identity-history:read\'
         * @summary Lists all the identities
         * @param {string} [startsWithQuery] This param is used for starts-with search for first, last and display name of the identity
         * @param {boolean} [isDeleted] Indicates if we want to only list down deleted identities or not.
         * @param {boolean} [isActive] Indicates if we want to only list active or inactive identities.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listHistoricalIdentities: async (startsWithQuery?: string, isDeleted?: boolean, isActive?: boolean, limit?: number, offset?: number, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/historical-identities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (startsWithQuery !== undefined) {
                localVarQueryParameter['starts-with-query'] = startsWithQuery;
            }

            if (isDeleted !== undefined) {
                localVarQueryParameter['is-deleted'] = isDeleted;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is-active'] = isActive;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This method retrieves a list of access item for the identity filtered by the access item type Requires authorization scope of \'idn:identity-history:read\' 
         * @summary Gets a list of access items for the identity filtered by item type
         * @param {string} id The identity id
         * @param {string} [type] The type of access item for the identity. If not provided, it defaults to account
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityAccessItems: async (id: string, type?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listIdentityAccessItems', 'id', id)
            const localVarPath = `/historical-identities/{id}/access-items`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This method retrieves the list of identity access items at a given date filterd by item type Requires authorization scope of \'idn:identity-history:read\' 
         * @summary Gets the list of identity access items at a given date filterd by item type
         * @param {string} id The identity id
         * @param {string} date The specified date
         * @param {string} [type] The access item type
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentitySnapshotAccessItems: async (id: string, date: string, type?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listIdentitySnapshotAccessItems', 'id', id)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('listIdentitySnapshotAccessItems', 'date', date)
            const localVarPath = `/historical-identities/{id}/snapshots/{date}/access-items`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This method retrieves all the snapshots for the identity Requires authorization scope of \'idn:identity-history:read\' 
         * @summary Lists all the snapshots for the identity
         * @param {string} id The identity id
         * @param {string} [start] The specified start date
         * @param {'day' | 'month'} [interval] The interval indicating the range in day or month for the specified interval-name
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentitySnapshots: async (id: string, start?: string, interval?: 'day' | 'month', limit?: number, offset?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listIdentitySnapshots', 'id', id)
            const localVarPath = `/historical-identities/{id}/snapshots`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdentityHistoryBetaApi - functional programming interface
 * @export
 */
export const IdentityHistoryBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdentityHistoryBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This method gets a difference of count for each access item types for the given identity between 2 snapshots Requires authorization scope of \'idn:identity-history:read\' 
         * @summary Gets a difference of count for each access item types for the given identity between 2 snapshots
         * @param {string} id The identity id
         * @param {string} [snapshot1] The snapshot 1 of identity
         * @param {string} [snapshot2] The snapshot 2 of identity
         * @param {Array<string>} [accessItemTypes] An optional list of access item types (app, account, entitlement, etc...) to return.   If null or empty, all access items types are returned 
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async compareIdentitySnapshots(id: string, snapshot1?: string, snapshot2?: string, accessItemTypes?: Array<string>, limit?: number, offset?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentityCompareResponseBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.compareIdentitySnapshots(id, snapshot1, snapshot2, accessItemTypes, limit, offset, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method gets a list of differences of specific accessType for the given identity between 2 snapshots Requires authorization scope of \'idn:identity-history:read\' 
         * @summary Gets a list of differences of specific accessType for the given identity between 2 snapshots
         * @param {string} id The identity id
         * @param {string} accessType The specific type which needs to be compared
         * @param {boolean} [accessAssociated] Indicates if added or removed access needs to be returned. true - added, false - removed, null - both added &amp; removed
         * @param {string} [snapshot1] The snapshot 1 of identity
         * @param {string} [snapshot2] The snapshot 2 of identity
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async compareIdentitySnapshotsAccessType(id: string, accessType: string, accessAssociated?: boolean, snapshot1?: string, snapshot2?: string, limit?: number, offset?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccessItemDiffBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.compareIdentitySnapshotsAccessType(id, accessType, accessAssociated, snapshot1, snapshot2, limit, offset, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method retrieves a specified identity Requires authorization scope of \'idn:identity-history:read\'
         * @summary Get latest snapshot of identity
         * @param {string} id The identity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getHistoricalIdentity(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityHistoryResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHistoricalIdentity(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method retrieves all access events for the identity Requires authorization scope of \'idn:identity-history:read\' 
         * @summary Lists all events for the given identity
         * @param {string} id The identity id
         * @param {string} [from] The optional instant from which to return the access events
         * @param {Array<string>} [eventTypes] An optional list of event types to return.  If null or empty, all events are returned
         * @param {Array<string>} [accessItemTypes] An optional list of access item types (app, account, entitlement, etc...) to return.   If null or empty, all access items types are returned
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getHistoricalIdentityEvents(id: string, from?: string, eventTypes?: Array<string>, accessItemTypes?: Array<string>, limit?: number, offset?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetHistoricalIdentityEvents200ResponseInnerBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHistoricalIdentityEvents(id, from, eventTypes, accessItemTypes, limit, offset, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method retrieves a specified identity snapshot at a given date Requires authorization scope of \'idn:identity-history:read\' 
         * @summary Gets an identity snapshot at a given date
         * @param {string} id The identity id
         * @param {string} date The specified date
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentitySnapshot(id: string, date: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityHistoryResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentitySnapshot(id, date, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method gets the summary for the event count for a specific identity by month/day Requires authorization scope of \'idn:identity-history:read\' 
         * @summary Gets the summary for the event count for a specific identity
         * @param {string} id The identity id
         * @param {string} [before] The date before which snapshot summary is required
         * @param {'day' | 'month'} [interval] The interval indicating day or month. Defaults to month if not specified
         * @param {string} [timeZone] The time zone. Defaults to UTC if not provided
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentitySnapshotSummary(id: string, before?: string, interval?: 'day' | 'month', timeZone?: string, limit?: number, offset?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MetricResponseBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentitySnapshotSummary(id, before, interval, timeZone, limit, offset, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method retrieves start date of the identity Requires authorization scope of \'idn:identity-history:read\' 
         * @summary Gets the start date of the identity
         * @param {string} id The identity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityStartDate(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityStartDate(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets the list of identities for the customer. This list end point does not support count=true request param. The total  count of identities would never be returned even if the count param is specified in the request Requires authorization scope of \'idn:identity-history:read\'
         * @summary Lists all the identities
         * @param {string} [startsWithQuery] This param is used for starts-with search for first, last and display name of the identity
         * @param {boolean} [isDeleted] Indicates if we want to only list down deleted identities or not.
         * @param {boolean} [isActive] Indicates if we want to only list active or inactive identities.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listHistoricalIdentities(startsWithQuery?: string, isDeleted?: boolean, isActive?: boolean, limit?: number, offset?: number, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentityListItemBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listHistoricalIdentities(startsWithQuery, isDeleted, isActive, limit, offset, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method retrieves a list of access item for the identity filtered by the access item type Requires authorization scope of \'idn:identity-history:read\' 
         * @summary Gets a list of access items for the identity filtered by item type
         * @param {string} id The identity id
         * @param {string} [type] The type of access item for the identity. If not provided, it defaults to account
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listIdentityAccessItems(id: string, type?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListIdentityAccessItems200ResponseInnerBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdentityAccessItems(id, type, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method retrieves the list of identity access items at a given date filterd by item type Requires authorization scope of \'idn:identity-history:read\' 
         * @summary Gets the list of identity access items at a given date filterd by item type
         * @param {string} id The identity id
         * @param {string} date The specified date
         * @param {string} [type] The access item type
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listIdentitySnapshotAccessItems(id: string, date: string, type?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListIdentityAccessItems200ResponseInnerBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdentitySnapshotAccessItems(id, date, type, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method retrieves all the snapshots for the identity Requires authorization scope of \'idn:identity-history:read\' 
         * @summary Lists all the snapshots for the identity
         * @param {string} id The identity id
         * @param {string} [start] The specified start date
         * @param {'day' | 'month'} [interval] The interval indicating the range in day or month for the specified interval-name
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listIdentitySnapshots(id: string, start?: string, interval?: 'day' | 'month', limit?: number, offset?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentitySnapshotSummaryResponseBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdentitySnapshots(id, start, interval, limit, offset, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdentityHistoryBetaApi - factory interface
 * @export
 */
export const IdentityHistoryBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdentityHistoryBetaApiFp(configuration)
    return {
        /**
         * This method gets a difference of count for each access item types for the given identity between 2 snapshots Requires authorization scope of \'idn:identity-history:read\' 
         * @summary Gets a difference of count for each access item types for the given identity between 2 snapshots
         * @param {string} id The identity id
         * @param {string} [snapshot1] The snapshot 1 of identity
         * @param {string} [snapshot2] The snapshot 2 of identity
         * @param {Array<string>} [accessItemTypes] An optional list of access item types (app, account, entitlement, etc...) to return.   If null or empty, all access items types are returned 
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        compareIdentitySnapshots(id: string, snapshot1?: string, snapshot2?: string, accessItemTypes?: Array<string>, limit?: number, offset?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<IdentityCompareResponseBeta>> {
            return localVarFp.compareIdentitySnapshots(id, snapshot1, snapshot2, accessItemTypes, limit, offset, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This method gets a list of differences of specific accessType for the given identity between 2 snapshots Requires authorization scope of \'idn:identity-history:read\' 
         * @summary Gets a list of differences of specific accessType for the given identity between 2 snapshots
         * @param {string} id The identity id
         * @param {string} accessType The specific type which needs to be compared
         * @param {boolean} [accessAssociated] Indicates if added or removed access needs to be returned. true - added, false - removed, null - both added &amp; removed
         * @param {string} [snapshot1] The snapshot 1 of identity
         * @param {string} [snapshot2] The snapshot 2 of identity
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        compareIdentitySnapshotsAccessType(id: string, accessType: string, accessAssociated?: boolean, snapshot1?: string, snapshot2?: string, limit?: number, offset?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<AccessItemDiffBeta>> {
            return localVarFp.compareIdentitySnapshotsAccessType(id, accessType, accessAssociated, snapshot1, snapshot2, limit, offset, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This method retrieves a specified identity Requires authorization scope of \'idn:identity-history:read\'
         * @summary Get latest snapshot of identity
         * @param {string} id The identity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricalIdentity(id: string, axiosOptions?: any): AxiosPromise<IdentityHistoryResponseBeta> {
            return localVarFp.getHistoricalIdentity(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This method retrieves all access events for the identity Requires authorization scope of \'idn:identity-history:read\' 
         * @summary Lists all events for the given identity
         * @param {string} id The identity id
         * @param {string} [from] The optional instant from which to return the access events
         * @param {Array<string>} [eventTypes] An optional list of event types to return.  If null or empty, all events are returned
         * @param {Array<string>} [accessItemTypes] An optional list of access item types (app, account, entitlement, etc...) to return.   If null or empty, all access items types are returned
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricalIdentityEvents(id: string, from?: string, eventTypes?: Array<string>, accessItemTypes?: Array<string>, limit?: number, offset?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<GetHistoricalIdentityEvents200ResponseInnerBeta>> {
            return localVarFp.getHistoricalIdentityEvents(id, from, eventTypes, accessItemTypes, limit, offset, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This method retrieves a specified identity snapshot at a given date Requires authorization scope of \'idn:identity-history:read\' 
         * @summary Gets an identity snapshot at a given date
         * @param {string} id The identity id
         * @param {string} date The specified date
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentitySnapshot(id: string, date: string, axiosOptions?: any): AxiosPromise<IdentityHistoryResponseBeta> {
            return localVarFp.getIdentitySnapshot(id, date, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This method gets the summary for the event count for a specific identity by month/day Requires authorization scope of \'idn:identity-history:read\' 
         * @summary Gets the summary for the event count for a specific identity
         * @param {string} id The identity id
         * @param {string} [before] The date before which snapshot summary is required
         * @param {'day' | 'month'} [interval] The interval indicating day or month. Defaults to month if not specified
         * @param {string} [timeZone] The time zone. Defaults to UTC if not provided
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentitySnapshotSummary(id: string, before?: string, interval?: 'day' | 'month', timeZone?: string, limit?: number, offset?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<MetricResponseBeta>> {
            return localVarFp.getIdentitySnapshotSummary(id, before, interval, timeZone, limit, offset, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This method retrieves start date of the identity Requires authorization scope of \'idn:identity-history:read\' 
         * @summary Gets the start date of the identity
         * @param {string} id The identity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityStartDate(id: string, axiosOptions?: any): AxiosPromise<string> {
            return localVarFp.getIdentityStartDate(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets the list of identities for the customer. This list end point does not support count=true request param. The total  count of identities would never be returned even if the count param is specified in the request Requires authorization scope of \'idn:identity-history:read\'
         * @summary Lists all the identities
         * @param {string} [startsWithQuery] This param is used for starts-with search for first, last and display name of the identity
         * @param {boolean} [isDeleted] Indicates if we want to only list down deleted identities or not.
         * @param {boolean} [isActive] Indicates if we want to only list active or inactive identities.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listHistoricalIdentities(startsWithQuery?: string, isDeleted?: boolean, isActive?: boolean, limit?: number, offset?: number, axiosOptions?: any): AxiosPromise<Array<IdentityListItemBeta>> {
            return localVarFp.listHistoricalIdentities(startsWithQuery, isDeleted, isActive, limit, offset, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This method retrieves a list of access item for the identity filtered by the access item type Requires authorization scope of \'idn:identity-history:read\' 
         * @summary Gets a list of access items for the identity filtered by item type
         * @param {string} id The identity id
         * @param {string} [type] The type of access item for the identity. If not provided, it defaults to account
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityAccessItems(id: string, type?: string, axiosOptions?: any): AxiosPromise<Array<ListIdentityAccessItems200ResponseInnerBeta>> {
            return localVarFp.listIdentityAccessItems(id, type, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This method retrieves the list of identity access items at a given date filterd by item type Requires authorization scope of \'idn:identity-history:read\' 
         * @summary Gets the list of identity access items at a given date filterd by item type
         * @param {string} id The identity id
         * @param {string} date The specified date
         * @param {string} [type] The access item type
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentitySnapshotAccessItems(id: string, date: string, type?: string, axiosOptions?: any): AxiosPromise<Array<ListIdentityAccessItems200ResponseInnerBeta>> {
            return localVarFp.listIdentitySnapshotAccessItems(id, date, type, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This method retrieves all the snapshots for the identity Requires authorization scope of \'idn:identity-history:read\' 
         * @summary Lists all the snapshots for the identity
         * @param {string} id The identity id
         * @param {string} [start] The specified start date
         * @param {'day' | 'month'} [interval] The interval indicating the range in day or month for the specified interval-name
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentitySnapshots(id: string, start?: string, interval?: 'day' | 'month', limit?: number, offset?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<IdentitySnapshotSummaryResponseBeta>> {
            return localVarFp.listIdentitySnapshots(id, start, interval, limit, offset, count, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for compareIdentitySnapshots operation in IdentityHistoryBetaApi.
 * @export
 * @interface IdentityHistoryBetaApiCompareIdentitySnapshotsRequest
 */
export interface IdentityHistoryBetaApiCompareIdentitySnapshotsRequest {
    /**
     * The identity id
     * @type {string}
     * @memberof IdentityHistoryBetaApiCompareIdentitySnapshots
     */
    readonly id: string

    /**
     * The snapshot 1 of identity
     * @type {string}
     * @memberof IdentityHistoryBetaApiCompareIdentitySnapshots
     */
    readonly snapshot1?: string

    /**
     * The snapshot 2 of identity
     * @type {string}
     * @memberof IdentityHistoryBetaApiCompareIdentitySnapshots
     */
    readonly snapshot2?: string

    /**
     * An optional list of access item types (app, account, entitlement, etc...) to return.   If null or empty, all access items types are returned 
     * @type {Array<string>}
     * @memberof IdentityHistoryBetaApiCompareIdentitySnapshots
     */
    readonly accessItemTypes?: Array<string>

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityHistoryBetaApiCompareIdentitySnapshots
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityHistoryBetaApiCompareIdentitySnapshots
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IdentityHistoryBetaApiCompareIdentitySnapshots
     */
    readonly count?: boolean
}

/**
 * Request parameters for compareIdentitySnapshotsAccessType operation in IdentityHistoryBetaApi.
 * @export
 * @interface IdentityHistoryBetaApiCompareIdentitySnapshotsAccessTypeRequest
 */
export interface IdentityHistoryBetaApiCompareIdentitySnapshotsAccessTypeRequest {
    /**
     * The identity id
     * @type {string}
     * @memberof IdentityHistoryBetaApiCompareIdentitySnapshotsAccessType
     */
    readonly id: string

    /**
     * The specific type which needs to be compared
     * @type {string}
     * @memberof IdentityHistoryBetaApiCompareIdentitySnapshotsAccessType
     */
    readonly accessType: string

    /**
     * Indicates if added or removed access needs to be returned. true - added, false - removed, null - both added &amp; removed
     * @type {boolean}
     * @memberof IdentityHistoryBetaApiCompareIdentitySnapshotsAccessType
     */
    readonly accessAssociated?: boolean

    /**
     * The snapshot 1 of identity
     * @type {string}
     * @memberof IdentityHistoryBetaApiCompareIdentitySnapshotsAccessType
     */
    readonly snapshot1?: string

    /**
     * The snapshot 2 of identity
     * @type {string}
     * @memberof IdentityHistoryBetaApiCompareIdentitySnapshotsAccessType
     */
    readonly snapshot2?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityHistoryBetaApiCompareIdentitySnapshotsAccessType
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityHistoryBetaApiCompareIdentitySnapshotsAccessType
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IdentityHistoryBetaApiCompareIdentitySnapshotsAccessType
     */
    readonly count?: boolean
}

/**
 * Request parameters for getHistoricalIdentity operation in IdentityHistoryBetaApi.
 * @export
 * @interface IdentityHistoryBetaApiGetHistoricalIdentityRequest
 */
export interface IdentityHistoryBetaApiGetHistoricalIdentityRequest {
    /**
     * The identity id
     * @type {string}
     * @memberof IdentityHistoryBetaApiGetHistoricalIdentity
     */
    readonly id: string
}

/**
 * Request parameters for getHistoricalIdentityEvents operation in IdentityHistoryBetaApi.
 * @export
 * @interface IdentityHistoryBetaApiGetHistoricalIdentityEventsRequest
 */
export interface IdentityHistoryBetaApiGetHistoricalIdentityEventsRequest {
    /**
     * The identity id
     * @type {string}
     * @memberof IdentityHistoryBetaApiGetHistoricalIdentityEvents
     */
    readonly id: string

    /**
     * The optional instant from which to return the access events
     * @type {string}
     * @memberof IdentityHistoryBetaApiGetHistoricalIdentityEvents
     */
    readonly from?: string

    /**
     * An optional list of event types to return.  If null or empty, all events are returned
     * @type {Array<string>}
     * @memberof IdentityHistoryBetaApiGetHistoricalIdentityEvents
     */
    readonly eventTypes?: Array<string>

    /**
     * An optional list of access item types (app, account, entitlement, etc...) to return.   If null or empty, all access items types are returned
     * @type {Array<string>}
     * @memberof IdentityHistoryBetaApiGetHistoricalIdentityEvents
     */
    readonly accessItemTypes?: Array<string>

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityHistoryBetaApiGetHistoricalIdentityEvents
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityHistoryBetaApiGetHistoricalIdentityEvents
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IdentityHistoryBetaApiGetHistoricalIdentityEvents
     */
    readonly count?: boolean
}

/**
 * Request parameters for getIdentitySnapshot operation in IdentityHistoryBetaApi.
 * @export
 * @interface IdentityHistoryBetaApiGetIdentitySnapshotRequest
 */
export interface IdentityHistoryBetaApiGetIdentitySnapshotRequest {
    /**
     * The identity id
     * @type {string}
     * @memberof IdentityHistoryBetaApiGetIdentitySnapshot
     */
    readonly id: string

    /**
     * The specified date
     * @type {string}
     * @memberof IdentityHistoryBetaApiGetIdentitySnapshot
     */
    readonly date: string
}

/**
 * Request parameters for getIdentitySnapshotSummary operation in IdentityHistoryBetaApi.
 * @export
 * @interface IdentityHistoryBetaApiGetIdentitySnapshotSummaryRequest
 */
export interface IdentityHistoryBetaApiGetIdentitySnapshotSummaryRequest {
    /**
     * The identity id
     * @type {string}
     * @memberof IdentityHistoryBetaApiGetIdentitySnapshotSummary
     */
    readonly id: string

    /**
     * The date before which snapshot summary is required
     * @type {string}
     * @memberof IdentityHistoryBetaApiGetIdentitySnapshotSummary
     */
    readonly before?: string

    /**
     * The interval indicating day or month. Defaults to month if not specified
     * @type {'day' | 'month'}
     * @memberof IdentityHistoryBetaApiGetIdentitySnapshotSummary
     */
    readonly interval?: 'day' | 'month'

    /**
     * The time zone. Defaults to UTC if not provided
     * @type {string}
     * @memberof IdentityHistoryBetaApiGetIdentitySnapshotSummary
     */
    readonly timeZone?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityHistoryBetaApiGetIdentitySnapshotSummary
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityHistoryBetaApiGetIdentitySnapshotSummary
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IdentityHistoryBetaApiGetIdentitySnapshotSummary
     */
    readonly count?: boolean
}

/**
 * Request parameters for getIdentityStartDate operation in IdentityHistoryBetaApi.
 * @export
 * @interface IdentityHistoryBetaApiGetIdentityStartDateRequest
 */
export interface IdentityHistoryBetaApiGetIdentityStartDateRequest {
    /**
     * The identity id
     * @type {string}
     * @memberof IdentityHistoryBetaApiGetIdentityStartDate
     */
    readonly id: string
}

/**
 * Request parameters for listHistoricalIdentities operation in IdentityHistoryBetaApi.
 * @export
 * @interface IdentityHistoryBetaApiListHistoricalIdentitiesRequest
 */
export interface IdentityHistoryBetaApiListHistoricalIdentitiesRequest {
    /**
     * This param is used for starts-with search for first, last and display name of the identity
     * @type {string}
     * @memberof IdentityHistoryBetaApiListHistoricalIdentities
     */
    readonly startsWithQuery?: string

    /**
     * Indicates if we want to only list down deleted identities or not.
     * @type {boolean}
     * @memberof IdentityHistoryBetaApiListHistoricalIdentities
     */
    readonly isDeleted?: boolean

    /**
     * Indicates if we want to only list active or inactive identities.
     * @type {boolean}
     * @memberof IdentityHistoryBetaApiListHistoricalIdentities
     */
    readonly isActive?: boolean

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityHistoryBetaApiListHistoricalIdentities
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityHistoryBetaApiListHistoricalIdentities
     */
    readonly offset?: number
}

/**
 * Request parameters for listIdentityAccessItems operation in IdentityHistoryBetaApi.
 * @export
 * @interface IdentityHistoryBetaApiListIdentityAccessItemsRequest
 */
export interface IdentityHistoryBetaApiListIdentityAccessItemsRequest {
    /**
     * The identity id
     * @type {string}
     * @memberof IdentityHistoryBetaApiListIdentityAccessItems
     */
    readonly id: string

    /**
     * The type of access item for the identity. If not provided, it defaults to account
     * @type {string}
     * @memberof IdentityHistoryBetaApiListIdentityAccessItems
     */
    readonly type?: string
}

/**
 * Request parameters for listIdentitySnapshotAccessItems operation in IdentityHistoryBetaApi.
 * @export
 * @interface IdentityHistoryBetaApiListIdentitySnapshotAccessItemsRequest
 */
export interface IdentityHistoryBetaApiListIdentitySnapshotAccessItemsRequest {
    /**
     * The identity id
     * @type {string}
     * @memberof IdentityHistoryBetaApiListIdentitySnapshotAccessItems
     */
    readonly id: string

    /**
     * The specified date
     * @type {string}
     * @memberof IdentityHistoryBetaApiListIdentitySnapshotAccessItems
     */
    readonly date: string

    /**
     * The access item type
     * @type {string}
     * @memberof IdentityHistoryBetaApiListIdentitySnapshotAccessItems
     */
    readonly type?: string
}

/**
 * Request parameters for listIdentitySnapshots operation in IdentityHistoryBetaApi.
 * @export
 * @interface IdentityHistoryBetaApiListIdentitySnapshotsRequest
 */
export interface IdentityHistoryBetaApiListIdentitySnapshotsRequest {
    /**
     * The identity id
     * @type {string}
     * @memberof IdentityHistoryBetaApiListIdentitySnapshots
     */
    readonly id: string

    /**
     * The specified start date
     * @type {string}
     * @memberof IdentityHistoryBetaApiListIdentitySnapshots
     */
    readonly start?: string

    /**
     * The interval indicating the range in day or month for the specified interval-name
     * @type {'day' | 'month'}
     * @memberof IdentityHistoryBetaApiListIdentitySnapshots
     */
    readonly interval?: 'day' | 'month'

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityHistoryBetaApiListIdentitySnapshots
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityHistoryBetaApiListIdentitySnapshots
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IdentityHistoryBetaApiListIdentitySnapshots
     */
    readonly count?: boolean
}

/**
 * IdentityHistoryBetaApi - object-oriented interface
 * @export
 * @class IdentityHistoryBetaApi
 * @extends {BaseAPI}
 */
export class IdentityHistoryBetaApi extends BaseAPI {
    /**
     * This method gets a difference of count for each access item types for the given identity between 2 snapshots Requires authorization scope of \'idn:identity-history:read\' 
     * @summary Gets a difference of count for each access item types for the given identity between 2 snapshots
     * @param {IdentityHistoryBetaApiCompareIdentitySnapshotsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityHistoryBetaApi
     */
    public compareIdentitySnapshots(requestParameters: IdentityHistoryBetaApiCompareIdentitySnapshotsRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityHistoryBetaApiFp(this.configuration).compareIdentitySnapshots(requestParameters.id, requestParameters.snapshot1, requestParameters.snapshot2, requestParameters.accessItemTypes, requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method gets a list of differences of specific accessType for the given identity between 2 snapshots Requires authorization scope of \'idn:identity-history:read\' 
     * @summary Gets a list of differences of specific accessType for the given identity between 2 snapshots
     * @param {IdentityHistoryBetaApiCompareIdentitySnapshotsAccessTypeRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityHistoryBetaApi
     */
    public compareIdentitySnapshotsAccessType(requestParameters: IdentityHistoryBetaApiCompareIdentitySnapshotsAccessTypeRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityHistoryBetaApiFp(this.configuration).compareIdentitySnapshotsAccessType(requestParameters.id, requestParameters.accessType, requestParameters.accessAssociated, requestParameters.snapshot1, requestParameters.snapshot2, requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method retrieves a specified identity Requires authorization scope of \'idn:identity-history:read\'
     * @summary Get latest snapshot of identity
     * @param {IdentityHistoryBetaApiGetHistoricalIdentityRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityHistoryBetaApi
     */
    public getHistoricalIdentity(requestParameters: IdentityHistoryBetaApiGetHistoricalIdentityRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityHistoryBetaApiFp(this.configuration).getHistoricalIdentity(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method retrieves all access events for the identity Requires authorization scope of \'idn:identity-history:read\' 
     * @summary Lists all events for the given identity
     * @param {IdentityHistoryBetaApiGetHistoricalIdentityEventsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityHistoryBetaApi
     */
    public getHistoricalIdentityEvents(requestParameters: IdentityHistoryBetaApiGetHistoricalIdentityEventsRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityHistoryBetaApiFp(this.configuration).getHistoricalIdentityEvents(requestParameters.id, requestParameters.from, requestParameters.eventTypes, requestParameters.accessItemTypes, requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method retrieves a specified identity snapshot at a given date Requires authorization scope of \'idn:identity-history:read\' 
     * @summary Gets an identity snapshot at a given date
     * @param {IdentityHistoryBetaApiGetIdentitySnapshotRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityHistoryBetaApi
     */
    public getIdentitySnapshot(requestParameters: IdentityHistoryBetaApiGetIdentitySnapshotRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityHistoryBetaApiFp(this.configuration).getIdentitySnapshot(requestParameters.id, requestParameters.date, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method gets the summary for the event count for a specific identity by month/day Requires authorization scope of \'idn:identity-history:read\' 
     * @summary Gets the summary for the event count for a specific identity
     * @param {IdentityHistoryBetaApiGetIdentitySnapshotSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityHistoryBetaApi
     */
    public getIdentitySnapshotSummary(requestParameters: IdentityHistoryBetaApiGetIdentitySnapshotSummaryRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityHistoryBetaApiFp(this.configuration).getIdentitySnapshotSummary(requestParameters.id, requestParameters.before, requestParameters.interval, requestParameters.timeZone, requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method retrieves start date of the identity Requires authorization scope of \'idn:identity-history:read\' 
     * @summary Gets the start date of the identity
     * @param {IdentityHistoryBetaApiGetIdentityStartDateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityHistoryBetaApi
     */
    public getIdentityStartDate(requestParameters: IdentityHistoryBetaApiGetIdentityStartDateRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityHistoryBetaApiFp(this.configuration).getIdentityStartDate(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets the list of identities for the customer. This list end point does not support count=true request param. The total  count of identities would never be returned even if the count param is specified in the request Requires authorization scope of \'idn:identity-history:read\'
     * @summary Lists all the identities
     * @param {IdentityHistoryBetaApiListHistoricalIdentitiesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityHistoryBetaApi
     */
    public listHistoricalIdentities(requestParameters: IdentityHistoryBetaApiListHistoricalIdentitiesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return IdentityHistoryBetaApiFp(this.configuration).listHistoricalIdentities(requestParameters.startsWithQuery, requestParameters.isDeleted, requestParameters.isActive, requestParameters.limit, requestParameters.offset, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method retrieves a list of access item for the identity filtered by the access item type Requires authorization scope of \'idn:identity-history:read\' 
     * @summary Gets a list of access items for the identity filtered by item type
     * @param {IdentityHistoryBetaApiListIdentityAccessItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityHistoryBetaApi
     */
    public listIdentityAccessItems(requestParameters: IdentityHistoryBetaApiListIdentityAccessItemsRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityHistoryBetaApiFp(this.configuration).listIdentityAccessItems(requestParameters.id, requestParameters.type, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method retrieves the list of identity access items at a given date filterd by item type Requires authorization scope of \'idn:identity-history:read\' 
     * @summary Gets the list of identity access items at a given date filterd by item type
     * @param {IdentityHistoryBetaApiListIdentitySnapshotAccessItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityHistoryBetaApi
     */
    public listIdentitySnapshotAccessItems(requestParameters: IdentityHistoryBetaApiListIdentitySnapshotAccessItemsRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityHistoryBetaApiFp(this.configuration).listIdentitySnapshotAccessItems(requestParameters.id, requestParameters.date, requestParameters.type, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method retrieves all the snapshots for the identity Requires authorization scope of \'idn:identity-history:read\' 
     * @summary Lists all the snapshots for the identity
     * @param {IdentityHistoryBetaApiListIdentitySnapshotsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityHistoryBetaApi
     */
    public listIdentitySnapshots(requestParameters: IdentityHistoryBetaApiListIdentitySnapshotsRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityHistoryBetaApiFp(this.configuration).listIdentitySnapshots(requestParameters.id, requestParameters.start, requestParameters.interval, requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdentityProfilesBetaApi - axios parameter creator
 * @export
 */
export const IdentityProfilesBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This creates an Identity Profile A token with ORG_ADMIN authority is required to call this API to create an Identity Profile.
         * @summary Create an Identity Profile
         * @param {IdentityProfileBeta} identityProfileBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createIdentityProfile: async (identityProfileBeta: IdentityProfileBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileBeta' is not null or undefined
            assertParamExists('createIdentityProfile', 'identityProfileBeta', identityProfileBeta)
            const localVarPath = `/identity-profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityProfileBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This deletes an Identity Profile based on ID. A token with ORG_ADMIN authority is required to call this API to delete an Identity Profile.
         * @summary Delete an Identity Profile
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityProfile: async (identityProfileId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('deleteIdentityProfile', 'identityProfileId', identityProfileId)
            const localVarPath = `/identity-profiles/{identity-profile-id}`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This deletes multiple Identity Profiles via a list of supplied IDs. On success, this endpoint will return a reference to the bulk delete task result. A token with ORG_ADMIN authority is required to call this API to delete a list of Identity Profiles.
         * @summary Delete Identity Profiles
         * @param {Array<string>} requestBody Identity Profile bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityProfiles: async (requestBody: Array<string>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('deleteIdentityProfiles', 'requestBody', requestBody)
            const localVarPath = `/identity-profiles/bulk-delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This exports existing identity profiles in the format specified by the sp-config service.
         * @summary Export Identity Profiles
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **priority**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportIdentityProfiles: async (limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identity-profiles/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This generates a non-persisted IdentityDetails object that will represent as the preview of the identities attribute when the given policy\'s attribute config is applied. A token with ORG_ADMIN authority is required to call this API to generate an identity preview.
         * @summary Generate Identity Profile Preview
         * @param {IdentityPreviewRequestBeta} identityPreviewRequestBeta Identity Preview request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        generateIdentityPreview: async (identityPreviewRequestBeta: IdentityPreviewRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityPreviewRequestBeta' is not null or undefined
            assertParamExists('generateIdentityPreview', 'identityPreviewRequestBeta', identityPreviewRequestBeta)
            const localVarPath = `/identity-profiles/identity-preview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityPreviewRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This returns the default identity attribute config A token with ORG_ADMIN authority is required to call this API to get the default identity attribute config.
         * @summary Default identity attribute config
         * @param {string} identityProfileId The Identity Profile ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultIdentityAttributeConfig: async (identityProfileId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('getDefaultIdentityAttributeConfig', 'identityProfileId', identityProfileId)
            const localVarPath = `/identity-profiles/{identity-profile-id}/default-identity-attribute-config`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This returns a single Identity Profile based on ID. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Gets a single Identity Profile
         * @param {string} identityProfileId The Identity Profile ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityProfile: async (identityProfileId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('getIdentityProfile', 'identityProfileId', identityProfileId)
            const localVarPath = `/identity-profiles/{identity-profile-id}`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This imports previously exported identity profiles.
         * @summary Import Identity Profiles
         * @param {Array<IdentityProfileExportedObjectBeta>} identityProfileExportedObjectBeta Previously exported Identity Profiles.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importIdentityProfiles: async (identityProfileExportedObjectBeta: Array<IdentityProfileExportedObjectBeta>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileExportedObjectBeta' is not null or undefined
            assertParamExists('importIdentityProfiles', 'identityProfileExportedObjectBeta', identityProfileExportedObjectBeta)
            const localVarPath = `/identity-profiles/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityProfileExportedObjectBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This returns a list of Identity Profiles based on the specified query parameters. A token with ORG_ADMIN or API authority is required to call this API to get a list of Identity Profiles.
         * @summary Identity Profiles list
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **priority**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityProfiles: async (limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identity-profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Process identities under the profile  A token with ORG_ADMIN authority is required to call this API.
         * @summary Process identities under profile
         * @param {string} identityProfileId The Identity Profile ID to be processed
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        syncIdentityProfile: async (identityProfileId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('syncIdentityProfile', 'identityProfileId', identityProfileId)
            const localVarPath = `/identity-profiles/{identity-profile-id}/process-identities`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This updates the specified Identity Profile. A token with ORG_ADMIN authority is required to call this API to update the Identity Profile. Some fields of the Schema cannot be updated. These fields are listed below. * id * name * created * modified
         * @summary Update the Identity Profile
         * @param {string} identityProfileId The Identity Profile ID
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta A list of Identity Profile update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateIdentityProfile: async (identityProfileId: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('updateIdentityProfile', 'identityProfileId', identityProfileId)
            // verify required parameter 'jsonPatchOperationBeta' is not null or undefined
            assertParamExists('updateIdentityProfile', 'jsonPatchOperationBeta', jsonPatchOperationBeta)
            const localVarPath = `/identity-profiles/{identity-profile-id}`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperationBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdentityProfilesBetaApi - functional programming interface
 * @export
 */
export const IdentityProfilesBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdentityProfilesBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This creates an Identity Profile A token with ORG_ADMIN authority is required to call this API to create an Identity Profile.
         * @summary Create an Identity Profile
         * @param {IdentityProfileBeta} identityProfileBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createIdentityProfile(identityProfileBeta: IdentityProfileBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityProfileBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createIdentityProfile(identityProfileBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This deletes an Identity Profile based on ID. A token with ORG_ADMIN authority is required to call this API to delete an Identity Profile.
         * @summary Delete an Identity Profile
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIdentityProfile(identityProfileId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseReferenceDtoBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIdentityProfile(identityProfileId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This deletes multiple Identity Profiles via a list of supplied IDs. On success, this endpoint will return a reference to the bulk delete task result. A token with ORG_ADMIN authority is required to call this API to delete a list of Identity Profiles.
         * @summary Delete Identity Profiles
         * @param {Array<string>} requestBody Identity Profile bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIdentityProfiles(requestBody: Array<string>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseReferenceDto1Beta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIdentityProfiles(requestBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This exports existing identity profiles in the format specified by the sp-config service.
         * @summary Export Identity Profiles
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **priority**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async exportIdentityProfiles(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentityProfileExportedObjectBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportIdentityProfiles(limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This generates a non-persisted IdentityDetails object that will represent as the preview of the identities attribute when the given policy\'s attribute config is applied. A token with ORG_ADMIN authority is required to call this API to generate an identity preview.
         * @summary Generate Identity Profile Preview
         * @param {IdentityPreviewRequestBeta} identityPreviewRequestBeta Identity Preview request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async generateIdentityPreview(identityPreviewRequestBeta: IdentityPreviewRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityPreviewResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateIdentityPreview(identityPreviewRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This returns the default identity attribute config A token with ORG_ADMIN authority is required to call this API to get the default identity attribute config.
         * @summary Default identity attribute config
         * @param {string} identityProfileId The Identity Profile ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultIdentityAttributeConfig(identityProfileId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityAttributeConfigBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultIdentityAttributeConfig(identityProfileId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This returns a single Identity Profile based on ID. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Gets a single Identity Profile
         * @param {string} identityProfileId The Identity Profile ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityProfile(identityProfileId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityProfileBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityProfile(identityProfileId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This imports previously exported identity profiles.
         * @summary Import Identity Profiles
         * @param {Array<IdentityProfileExportedObjectBeta>} identityProfileExportedObjectBeta Previously exported Identity Profiles.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async importIdentityProfiles(identityProfileExportedObjectBeta: Array<IdentityProfileExportedObjectBeta>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectImportResultBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importIdentityProfiles(identityProfileExportedObjectBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This returns a list of Identity Profiles based on the specified query parameters. A token with ORG_ADMIN or API authority is required to call this API to get a list of Identity Profiles.
         * @summary Identity Profiles list
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **priority**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listIdentityProfiles(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentityProfileBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdentityProfiles(limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Process identities under the profile  A token with ORG_ADMIN authority is required to call this API.
         * @summary Process identities under profile
         * @param {string} identityProfileId The Identity Profile ID to be processed
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async syncIdentityProfile(identityProfileId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncIdentityProfile(identityProfileId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This updates the specified Identity Profile. A token with ORG_ADMIN authority is required to call this API to update the Identity Profile. Some fields of the Schema cannot be updated. These fields are listed below. * id * name * created * modified
         * @summary Update the Identity Profile
         * @param {string} identityProfileId The Identity Profile ID
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta A list of Identity Profile update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateIdentityProfile(identityProfileId: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityProfileBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateIdentityProfile(identityProfileId, jsonPatchOperationBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdentityProfilesBetaApi - factory interface
 * @export
 */
export const IdentityProfilesBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdentityProfilesBetaApiFp(configuration)
    return {
        /**
         * This creates an Identity Profile A token with ORG_ADMIN authority is required to call this API to create an Identity Profile.
         * @summary Create an Identity Profile
         * @param {IdentityProfileBeta} identityProfileBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createIdentityProfile(identityProfileBeta: IdentityProfileBeta, axiosOptions?: any): AxiosPromise<IdentityProfileBeta> {
            return localVarFp.createIdentityProfile(identityProfileBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This deletes an Identity Profile based on ID. A token with ORG_ADMIN authority is required to call this API to delete an Identity Profile.
         * @summary Delete an Identity Profile
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityProfile(identityProfileId: string, axiosOptions?: any): AxiosPromise<BaseReferenceDtoBeta> {
            return localVarFp.deleteIdentityProfile(identityProfileId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This deletes multiple Identity Profiles via a list of supplied IDs. On success, this endpoint will return a reference to the bulk delete task result. A token with ORG_ADMIN authority is required to call this API to delete a list of Identity Profiles.
         * @summary Delete Identity Profiles
         * @param {Array<string>} requestBody Identity Profile bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityProfiles(requestBody: Array<string>, axiosOptions?: any): AxiosPromise<BaseReferenceDto1Beta> {
            return localVarFp.deleteIdentityProfiles(requestBody, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This exports existing identity profiles in the format specified by the sp-config service.
         * @summary Export Identity Profiles
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **priority**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportIdentityProfiles(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<IdentityProfileExportedObjectBeta>> {
            return localVarFp.exportIdentityProfiles(limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This generates a non-persisted IdentityDetails object that will represent as the preview of the identities attribute when the given policy\'s attribute config is applied. A token with ORG_ADMIN authority is required to call this API to generate an identity preview.
         * @summary Generate Identity Profile Preview
         * @param {IdentityPreviewRequestBeta} identityPreviewRequestBeta Identity Preview request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        generateIdentityPreview(identityPreviewRequestBeta: IdentityPreviewRequestBeta, axiosOptions?: any): AxiosPromise<IdentityPreviewResponseBeta> {
            return localVarFp.generateIdentityPreview(identityPreviewRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This returns the default identity attribute config A token with ORG_ADMIN authority is required to call this API to get the default identity attribute config.
         * @summary Default identity attribute config
         * @param {string} identityProfileId The Identity Profile ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultIdentityAttributeConfig(identityProfileId: string, axiosOptions?: any): AxiosPromise<IdentityAttributeConfigBeta> {
            return localVarFp.getDefaultIdentityAttributeConfig(identityProfileId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This returns a single Identity Profile based on ID. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Gets a single Identity Profile
         * @param {string} identityProfileId The Identity Profile ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityProfile(identityProfileId: string, axiosOptions?: any): AxiosPromise<IdentityProfileBeta> {
            return localVarFp.getIdentityProfile(identityProfileId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This imports previously exported identity profiles.
         * @summary Import Identity Profiles
         * @param {Array<IdentityProfileExportedObjectBeta>} identityProfileExportedObjectBeta Previously exported Identity Profiles.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importIdentityProfiles(identityProfileExportedObjectBeta: Array<IdentityProfileExportedObjectBeta>, axiosOptions?: any): AxiosPromise<ObjectImportResultBeta> {
            return localVarFp.importIdentityProfiles(identityProfileExportedObjectBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This returns a list of Identity Profiles based on the specified query parameters. A token with ORG_ADMIN or API authority is required to call this API to get a list of Identity Profiles.
         * @summary Identity Profiles list
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **priority**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityProfiles(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<IdentityProfileBeta>> {
            return localVarFp.listIdentityProfiles(limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Process identities under the profile  A token with ORG_ADMIN authority is required to call this API.
         * @summary Process identities under profile
         * @param {string} identityProfileId The Identity Profile ID to be processed
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        syncIdentityProfile(identityProfileId: string, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.syncIdentityProfile(identityProfileId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This updates the specified Identity Profile. A token with ORG_ADMIN authority is required to call this API to update the Identity Profile. Some fields of the Schema cannot be updated. These fields are listed below. * id * name * created * modified
         * @summary Update the Identity Profile
         * @param {string} identityProfileId The Identity Profile ID
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta A list of Identity Profile update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateIdentityProfile(identityProfileId: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: any): AxiosPromise<IdentityProfileBeta> {
            return localVarFp.updateIdentityProfile(identityProfileId, jsonPatchOperationBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createIdentityProfile operation in IdentityProfilesBetaApi.
 * @export
 * @interface IdentityProfilesBetaApiCreateIdentityProfileRequest
 */
export interface IdentityProfilesBetaApiCreateIdentityProfileRequest {
    /**
     * 
     * @type {IdentityProfileBeta}
     * @memberof IdentityProfilesBetaApiCreateIdentityProfile
     */
    readonly identityProfileBeta: IdentityProfileBeta
}

/**
 * Request parameters for deleteIdentityProfile operation in IdentityProfilesBetaApi.
 * @export
 * @interface IdentityProfilesBetaApiDeleteIdentityProfileRequest
 */
export interface IdentityProfilesBetaApiDeleteIdentityProfileRequest {
    /**
     * The Identity Profile ID.
     * @type {string}
     * @memberof IdentityProfilesBetaApiDeleteIdentityProfile
     */
    readonly identityProfileId: string
}

/**
 * Request parameters for deleteIdentityProfiles operation in IdentityProfilesBetaApi.
 * @export
 * @interface IdentityProfilesBetaApiDeleteIdentityProfilesRequest
 */
export interface IdentityProfilesBetaApiDeleteIdentityProfilesRequest {
    /**
     * Identity Profile bulk delete request body.
     * @type {Array<string>}
     * @memberof IdentityProfilesBetaApiDeleteIdentityProfiles
     */
    readonly requestBody: Array<string>
}

/**
 * Request parameters for exportIdentityProfiles operation in IdentityProfilesBetaApi.
 * @export
 * @interface IdentityProfilesBetaApiExportIdentityProfilesRequest
 */
export interface IdentityProfilesBetaApiExportIdentityProfilesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityProfilesBetaApiExportIdentityProfiles
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityProfilesBetaApiExportIdentityProfiles
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IdentityProfilesBetaApiExportIdentityProfiles
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
     * @type {string}
     * @memberof IdentityProfilesBetaApiExportIdentityProfiles
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **priority**
     * @type {string}
     * @memberof IdentityProfilesBetaApiExportIdentityProfiles
     */
    readonly sorters?: string
}

/**
 * Request parameters for generateIdentityPreview operation in IdentityProfilesBetaApi.
 * @export
 * @interface IdentityProfilesBetaApiGenerateIdentityPreviewRequest
 */
export interface IdentityProfilesBetaApiGenerateIdentityPreviewRequest {
    /**
     * Identity Preview request body.
     * @type {IdentityPreviewRequestBeta}
     * @memberof IdentityProfilesBetaApiGenerateIdentityPreview
     */
    readonly identityPreviewRequestBeta: IdentityPreviewRequestBeta
}

/**
 * Request parameters for getDefaultIdentityAttributeConfig operation in IdentityProfilesBetaApi.
 * @export
 * @interface IdentityProfilesBetaApiGetDefaultIdentityAttributeConfigRequest
 */
export interface IdentityProfilesBetaApiGetDefaultIdentityAttributeConfigRequest {
    /**
     * The Identity Profile ID
     * @type {string}
     * @memberof IdentityProfilesBetaApiGetDefaultIdentityAttributeConfig
     */
    readonly identityProfileId: string
}

/**
 * Request parameters for getIdentityProfile operation in IdentityProfilesBetaApi.
 * @export
 * @interface IdentityProfilesBetaApiGetIdentityProfileRequest
 */
export interface IdentityProfilesBetaApiGetIdentityProfileRequest {
    /**
     * The Identity Profile ID
     * @type {string}
     * @memberof IdentityProfilesBetaApiGetIdentityProfile
     */
    readonly identityProfileId: string
}

/**
 * Request parameters for importIdentityProfiles operation in IdentityProfilesBetaApi.
 * @export
 * @interface IdentityProfilesBetaApiImportIdentityProfilesRequest
 */
export interface IdentityProfilesBetaApiImportIdentityProfilesRequest {
    /**
     * Previously exported Identity Profiles.
     * @type {Array<IdentityProfileExportedObjectBeta>}
     * @memberof IdentityProfilesBetaApiImportIdentityProfiles
     */
    readonly identityProfileExportedObjectBeta: Array<IdentityProfileExportedObjectBeta>
}

/**
 * Request parameters for listIdentityProfiles operation in IdentityProfilesBetaApi.
 * @export
 * @interface IdentityProfilesBetaApiListIdentityProfilesRequest
 */
export interface IdentityProfilesBetaApiListIdentityProfilesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityProfilesBetaApiListIdentityProfiles
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityProfilesBetaApiListIdentityProfiles
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IdentityProfilesBetaApiListIdentityProfiles
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
     * @type {string}
     * @memberof IdentityProfilesBetaApiListIdentityProfiles
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **priority**
     * @type {string}
     * @memberof IdentityProfilesBetaApiListIdentityProfiles
     */
    readonly sorters?: string
}

/**
 * Request parameters for syncIdentityProfile operation in IdentityProfilesBetaApi.
 * @export
 * @interface IdentityProfilesBetaApiSyncIdentityProfileRequest
 */
export interface IdentityProfilesBetaApiSyncIdentityProfileRequest {
    /**
     * The Identity Profile ID to be processed
     * @type {string}
     * @memberof IdentityProfilesBetaApiSyncIdentityProfile
     */
    readonly identityProfileId: string
}

/**
 * Request parameters for updateIdentityProfile operation in IdentityProfilesBetaApi.
 * @export
 * @interface IdentityProfilesBetaApiUpdateIdentityProfileRequest
 */
export interface IdentityProfilesBetaApiUpdateIdentityProfileRequest {
    /**
     * The Identity Profile ID
     * @type {string}
     * @memberof IdentityProfilesBetaApiUpdateIdentityProfile
     */
    readonly identityProfileId: string

    /**
     * A list of Identity Profile update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
     * @type {Array<JsonPatchOperationBeta>}
     * @memberof IdentityProfilesBetaApiUpdateIdentityProfile
     */
    readonly jsonPatchOperationBeta: Array<JsonPatchOperationBeta>
}

/**
 * IdentityProfilesBetaApi - object-oriented interface
 * @export
 * @class IdentityProfilesBetaApi
 * @extends {BaseAPI}
 */
export class IdentityProfilesBetaApi extends BaseAPI {
    /**
     * This creates an Identity Profile A token with ORG_ADMIN authority is required to call this API to create an Identity Profile.
     * @summary Create an Identity Profile
     * @param {IdentityProfilesBetaApiCreateIdentityProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesBetaApi
     */
    public createIdentityProfile(requestParameters: IdentityProfilesBetaApiCreateIdentityProfileRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesBetaApiFp(this.configuration).createIdentityProfile(requestParameters.identityProfileBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes an Identity Profile based on ID. A token with ORG_ADMIN authority is required to call this API to delete an Identity Profile.
     * @summary Delete an Identity Profile
     * @param {IdentityProfilesBetaApiDeleteIdentityProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesBetaApi
     */
    public deleteIdentityProfile(requestParameters: IdentityProfilesBetaApiDeleteIdentityProfileRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesBetaApiFp(this.configuration).deleteIdentityProfile(requestParameters.identityProfileId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes multiple Identity Profiles via a list of supplied IDs. On success, this endpoint will return a reference to the bulk delete task result. A token with ORG_ADMIN authority is required to call this API to delete a list of Identity Profiles.
     * @summary Delete Identity Profiles
     * @param {IdentityProfilesBetaApiDeleteIdentityProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesBetaApi
     */
    public deleteIdentityProfiles(requestParameters: IdentityProfilesBetaApiDeleteIdentityProfilesRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesBetaApiFp(this.configuration).deleteIdentityProfiles(requestParameters.requestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This exports existing identity profiles in the format specified by the sp-config service.
     * @summary Export Identity Profiles
     * @param {IdentityProfilesBetaApiExportIdentityProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesBetaApi
     */
    public exportIdentityProfiles(requestParameters: IdentityProfilesBetaApiExportIdentityProfilesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesBetaApiFp(this.configuration).exportIdentityProfiles(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This generates a non-persisted IdentityDetails object that will represent as the preview of the identities attribute when the given policy\'s attribute config is applied. A token with ORG_ADMIN authority is required to call this API to generate an identity preview.
     * @summary Generate Identity Profile Preview
     * @param {IdentityProfilesBetaApiGenerateIdentityPreviewRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesBetaApi
     */
    public generateIdentityPreview(requestParameters: IdentityProfilesBetaApiGenerateIdentityPreviewRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesBetaApiFp(this.configuration).generateIdentityPreview(requestParameters.identityPreviewRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns the default identity attribute config A token with ORG_ADMIN authority is required to call this API to get the default identity attribute config.
     * @summary Default identity attribute config
     * @param {IdentityProfilesBetaApiGetDefaultIdentityAttributeConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesBetaApi
     */
    public getDefaultIdentityAttributeConfig(requestParameters: IdentityProfilesBetaApiGetDefaultIdentityAttributeConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesBetaApiFp(this.configuration).getDefaultIdentityAttributeConfig(requestParameters.identityProfileId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns a single Identity Profile based on ID. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Gets a single Identity Profile
     * @param {IdentityProfilesBetaApiGetIdentityProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesBetaApi
     */
    public getIdentityProfile(requestParameters: IdentityProfilesBetaApiGetIdentityProfileRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesBetaApiFp(this.configuration).getIdentityProfile(requestParameters.identityProfileId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This imports previously exported identity profiles.
     * @summary Import Identity Profiles
     * @param {IdentityProfilesBetaApiImportIdentityProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesBetaApi
     */
    public importIdentityProfiles(requestParameters: IdentityProfilesBetaApiImportIdentityProfilesRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesBetaApiFp(this.configuration).importIdentityProfiles(requestParameters.identityProfileExportedObjectBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns a list of Identity Profiles based on the specified query parameters. A token with ORG_ADMIN or API authority is required to call this API to get a list of Identity Profiles.
     * @summary Identity Profiles list
     * @param {IdentityProfilesBetaApiListIdentityProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesBetaApi
     */
    public listIdentityProfiles(requestParameters: IdentityProfilesBetaApiListIdentityProfilesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesBetaApiFp(this.configuration).listIdentityProfiles(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Process identities under the profile  A token with ORG_ADMIN authority is required to call this API.
     * @summary Process identities under profile
     * @param {IdentityProfilesBetaApiSyncIdentityProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesBetaApi
     */
    public syncIdentityProfile(requestParameters: IdentityProfilesBetaApiSyncIdentityProfileRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesBetaApiFp(this.configuration).syncIdentityProfile(requestParameters.identityProfileId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This updates the specified Identity Profile. A token with ORG_ADMIN authority is required to call this API to update the Identity Profile. Some fields of the Schema cannot be updated. These fields are listed below. * id * name * created * modified
     * @summary Update the Identity Profile
     * @param {IdentityProfilesBetaApiUpdateIdentityProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesBetaApi
     */
    public updateIdentityProfile(requestParameters: IdentityProfilesBetaApiUpdateIdentityProfileRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesBetaApiFp(this.configuration).updateIdentityProfile(requestParameters.identityProfileId, requestParameters.jsonPatchOperationBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LifecycleStatesBetaApi - axios parameter creator
 * @export
 */
export const LifecycleStatesBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns a lifecycle state.  A token with ORG_ADMIN or API authority is required to call this API. 
         * @summary Lifecycle State
         * @param {string} identityProfileId Identity Profile ID
         * @param {string} lifecycleStateId Lifecycle State ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listLifecycleStates: async (identityProfileId: string, lifecycleStateId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('listLifecycleStates', 'identityProfileId', identityProfileId)
            // verify required parameter 'lifecycleStateId' is not null or undefined
            assertParamExists('listLifecycleStates', 'lifecycleStateId', lifecycleStateId)
            const localVarPath = `/identity-profiles/{identity-profile-id}/lifecycle-states/{lifecycle-state-id}`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)))
                .replace(`{${"lifecycle-state-id"}}`, encodeURIComponent(String(lifecycleStateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates individual lifecycle state fields using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  A token with ORG_ADMIN or API authority is required to call this API. 
         * @summary Update Lifecycle State
         * @param {string} identityProfileId Identity Profile ID
         * @param {string} lifecycleStateId Lifecycle State ID
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta A list of lifecycle state update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields can be updated: * enabled * description * accountActions * accessProfileIds * emailNotificationOption 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateLifecycleStates: async (identityProfileId: string, lifecycleStateId: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('updateLifecycleStates', 'identityProfileId', identityProfileId)
            // verify required parameter 'lifecycleStateId' is not null or undefined
            assertParamExists('updateLifecycleStates', 'lifecycleStateId', lifecycleStateId)
            // verify required parameter 'jsonPatchOperationBeta' is not null or undefined
            assertParamExists('updateLifecycleStates', 'jsonPatchOperationBeta', jsonPatchOperationBeta)
            const localVarPath = `/identity-profiles/{identity-profile-id}/lifecycle-states/{lifecycle-state-id}`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)))
                .replace(`{${"lifecycle-state-id"}}`, encodeURIComponent(String(lifecycleStateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperationBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * LifecycleStatesBetaApi - functional programming interface
 * @export
 */
export const LifecycleStatesBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LifecycleStatesBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint returns a lifecycle state.  A token with ORG_ADMIN or API authority is required to call this API. 
         * @summary Lifecycle State
         * @param {string} identityProfileId Identity Profile ID
         * @param {string} lifecycleStateId Lifecycle State ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listLifecycleStates(identityProfileId: string, lifecycleStateId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifecycleStateBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLifecycleStates(identityProfileId, lifecycleStateId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API updates individual lifecycle state fields using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  A token with ORG_ADMIN or API authority is required to call this API. 
         * @summary Update Lifecycle State
         * @param {string} identityProfileId Identity Profile ID
         * @param {string} lifecycleStateId Lifecycle State ID
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta A list of lifecycle state update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields can be updated: * enabled * description * accountActions * accessProfileIds * emailNotificationOption 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateLifecycleStates(identityProfileId: string, lifecycleStateId: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifecycleStateBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLifecycleStates(identityProfileId, lifecycleStateId, jsonPatchOperationBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LifecycleStatesBetaApi - factory interface
 * @export
 */
export const LifecycleStatesBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LifecycleStatesBetaApiFp(configuration)
    return {
        /**
         * This endpoint returns a lifecycle state.  A token with ORG_ADMIN or API authority is required to call this API. 
         * @summary Lifecycle State
         * @param {string} identityProfileId Identity Profile ID
         * @param {string} lifecycleStateId Lifecycle State ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listLifecycleStates(identityProfileId: string, lifecycleStateId: string, axiosOptions?: any): AxiosPromise<LifecycleStateBeta> {
            return localVarFp.listLifecycleStates(identityProfileId, lifecycleStateId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates individual lifecycle state fields using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  A token with ORG_ADMIN or API authority is required to call this API. 
         * @summary Update Lifecycle State
         * @param {string} identityProfileId Identity Profile ID
         * @param {string} lifecycleStateId Lifecycle State ID
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta A list of lifecycle state update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields can be updated: * enabled * description * accountActions * accessProfileIds * emailNotificationOption 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateLifecycleStates(identityProfileId: string, lifecycleStateId: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: any): AxiosPromise<LifecycleStateBeta> {
            return localVarFp.updateLifecycleStates(identityProfileId, lifecycleStateId, jsonPatchOperationBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listLifecycleStates operation in LifecycleStatesBetaApi.
 * @export
 * @interface LifecycleStatesBetaApiListLifecycleStatesRequest
 */
export interface LifecycleStatesBetaApiListLifecycleStatesRequest {
    /**
     * Identity Profile ID
     * @type {string}
     * @memberof LifecycleStatesBetaApiListLifecycleStates
     */
    readonly identityProfileId: string

    /**
     * Lifecycle State ID
     * @type {string}
     * @memberof LifecycleStatesBetaApiListLifecycleStates
     */
    readonly lifecycleStateId: string
}

/**
 * Request parameters for updateLifecycleStates operation in LifecycleStatesBetaApi.
 * @export
 * @interface LifecycleStatesBetaApiUpdateLifecycleStatesRequest
 */
export interface LifecycleStatesBetaApiUpdateLifecycleStatesRequest {
    /**
     * Identity Profile ID
     * @type {string}
     * @memberof LifecycleStatesBetaApiUpdateLifecycleStates
     */
    readonly identityProfileId: string

    /**
     * Lifecycle State ID
     * @type {string}
     * @memberof LifecycleStatesBetaApiUpdateLifecycleStates
     */
    readonly lifecycleStateId: string

    /**
     * A list of lifecycle state update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields can be updated: * enabled * description * accountActions * accessProfileIds * emailNotificationOption 
     * @type {Array<JsonPatchOperationBeta>}
     * @memberof LifecycleStatesBetaApiUpdateLifecycleStates
     */
    readonly jsonPatchOperationBeta: Array<JsonPatchOperationBeta>
}

/**
 * LifecycleStatesBetaApi - object-oriented interface
 * @export
 * @class LifecycleStatesBetaApi
 * @extends {BaseAPI}
 */
export class LifecycleStatesBetaApi extends BaseAPI {
    /**
     * This endpoint returns a lifecycle state.  A token with ORG_ADMIN or API authority is required to call this API. 
     * @summary Lifecycle State
     * @param {LifecycleStatesBetaApiListLifecycleStatesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesBetaApi
     */
    public listLifecycleStates(requestParameters: LifecycleStatesBetaApiListLifecycleStatesRequest, axiosOptions?: AxiosRequestConfig) {
        return LifecycleStatesBetaApiFp(this.configuration).listLifecycleStates(requestParameters.identityProfileId, requestParameters.lifecycleStateId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates individual lifecycle state fields using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  A token with ORG_ADMIN or API authority is required to call this API. 
     * @summary Update Lifecycle State
     * @param {LifecycleStatesBetaApiUpdateLifecycleStatesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesBetaApi
     */
    public updateLifecycleStates(requestParameters: LifecycleStatesBetaApiUpdateLifecycleStatesRequest, axiosOptions?: AxiosRequestConfig) {
        return LifecycleStatesBetaApiFp(this.configuration).updateLifecycleStates(requestParameters.identityProfileId, requestParameters.lifecycleStateId, requestParameters.jsonPatchOperationBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MFAConfigurationBetaApi - axios parameter creator
 * @export
 */
export const MFAConfigurationBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API returns the configuration of a given MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Configuration of a MFA method
         * @param {string} method The name of the MFA method. The currently supported method name is okta-verify.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getMFAConfig: async (method: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'method' is not null or undefined
            assertParamExists('getMFAConfig', 'method', method)
            const localVarPath = `/mfa/{method}/config`
                .replace(`{${"method"}}`, encodeURIComponent(String(method)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API sets the configuration of a given MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Set MFA method configuration
         * @param {string} method The name of the MFA method. The currently supported method name is okta-verify.
         * @param {MfaConfigBeta} mfaConfigBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setMFAConfig: async (method: string, mfaConfigBeta: MfaConfigBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'method' is not null or undefined
            assertParamExists('setMFAConfig', 'method', method)
            // verify required parameter 'mfaConfigBeta' is not null or undefined
            assertParamExists('setMFAConfig', 'mfaConfigBeta', mfaConfigBeta)
            const localVarPath = `/mfa/{method}/config`
                .replace(`{${"method"}}`, encodeURIComponent(String(method)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaConfigBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API validates that the configuration is valid and will properly authenticate with the MFA provider identified by the method path parameter. A token with ORG_ADMIN authority is required to call this API.
         * @summary MFA method\'s test configuration
         * @param {string} method The name of the MFA method. The currently supported method name is okta-verify.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testMFAConfig: async (method: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'method' is not null or undefined
            assertParamExists('testMFAConfig', 'method', method)
            const localVarPath = `/mfa/{method}/test`
                .replace(`{${"method"}}`, encodeURIComponent(String(method)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * MFAConfigurationBetaApi - functional programming interface
 * @export
 */
export const MFAConfigurationBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MFAConfigurationBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This API returns the configuration of a given MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Configuration of a MFA method
         * @param {string} method The name of the MFA method. The currently supported method name is okta-verify.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getMFAConfig(method: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MfaConfigBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMFAConfig(method, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API sets the configuration of a given MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Set MFA method configuration
         * @param {string} method The name of the MFA method. The currently supported method name is okta-verify.
         * @param {MfaConfigBeta} mfaConfigBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setMFAConfig(method: string, mfaConfigBeta: MfaConfigBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MfaConfigBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setMFAConfig(method, mfaConfigBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API validates that the configuration is valid and will properly authenticate with the MFA provider identified by the method path parameter. A token with ORG_ADMIN authority is required to call this API.
         * @summary MFA method\'s test configuration
         * @param {string} method The name of the MFA method. The currently supported method name is okta-verify.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async testMFAConfig(method: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MfaConfigTestResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testMFAConfig(method, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MFAConfigurationBetaApi - factory interface
 * @export
 */
export const MFAConfigurationBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MFAConfigurationBetaApiFp(configuration)
    return {
        /**
         * This API returns the configuration of a given MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Configuration of a MFA method
         * @param {string} method The name of the MFA method. The currently supported method name is okta-verify.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getMFAConfig(method: string, axiosOptions?: any): AxiosPromise<MfaConfigBeta> {
            return localVarFp.getMFAConfig(method, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API sets the configuration of a given MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Set MFA method configuration
         * @param {string} method The name of the MFA method. The currently supported method name is okta-verify.
         * @param {MfaConfigBeta} mfaConfigBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setMFAConfig(method: string, mfaConfigBeta: MfaConfigBeta, axiosOptions?: any): AxiosPromise<MfaConfigBeta> {
            return localVarFp.setMFAConfig(method, mfaConfigBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API validates that the configuration is valid and will properly authenticate with the MFA provider identified by the method path parameter. A token with ORG_ADMIN authority is required to call this API.
         * @summary MFA method\'s test configuration
         * @param {string} method The name of the MFA method. The currently supported method name is okta-verify.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testMFAConfig(method: string, axiosOptions?: any): AxiosPromise<MfaConfigTestResponseBeta> {
            return localVarFp.testMFAConfig(method, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getMFAConfig operation in MFAConfigurationBetaApi.
 * @export
 * @interface MFAConfigurationBetaApiGetMFAConfigRequest
 */
export interface MFAConfigurationBetaApiGetMFAConfigRequest {
    /**
     * The name of the MFA method. The currently supported method name is okta-verify.
     * @type {string}
     * @memberof MFAConfigurationBetaApiGetMFAConfig
     */
    readonly method: string
}

/**
 * Request parameters for setMFAConfig operation in MFAConfigurationBetaApi.
 * @export
 * @interface MFAConfigurationBetaApiSetMFAConfigRequest
 */
export interface MFAConfigurationBetaApiSetMFAConfigRequest {
    /**
     * The name of the MFA method. The currently supported method name is okta-verify.
     * @type {string}
     * @memberof MFAConfigurationBetaApiSetMFAConfig
     */
    readonly method: string

    /**
     * 
     * @type {MfaConfigBeta}
     * @memberof MFAConfigurationBetaApiSetMFAConfig
     */
    readonly mfaConfigBeta: MfaConfigBeta
}

/**
 * Request parameters for testMFAConfig operation in MFAConfigurationBetaApi.
 * @export
 * @interface MFAConfigurationBetaApiTestMFAConfigRequest
 */
export interface MFAConfigurationBetaApiTestMFAConfigRequest {
    /**
     * The name of the MFA method. The currently supported method name is okta-verify.
     * @type {string}
     * @memberof MFAConfigurationBetaApiTestMFAConfig
     */
    readonly method: string
}

/**
 * MFAConfigurationBetaApi - object-oriented interface
 * @export
 * @class MFAConfigurationBetaApi
 * @extends {BaseAPI}
 */
export class MFAConfigurationBetaApi extends BaseAPI {
    /**
     * This API returns the configuration of a given MFA method. A token with ORG_ADMIN authority is required to call this API.
     * @summary Configuration of a MFA method
     * @param {MFAConfigurationBetaApiGetMFAConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAConfigurationBetaApi
     */
    public getMFAConfig(requestParameters: MFAConfigurationBetaApiGetMFAConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return MFAConfigurationBetaApiFp(this.configuration).getMFAConfig(requestParameters.method, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API sets the configuration of a given MFA method. A token with ORG_ADMIN authority is required to call this API.
     * @summary Set MFA method configuration
     * @param {MFAConfigurationBetaApiSetMFAConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAConfigurationBetaApi
     */
    public setMFAConfig(requestParameters: MFAConfigurationBetaApiSetMFAConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return MFAConfigurationBetaApiFp(this.configuration).setMFAConfig(requestParameters.method, requestParameters.mfaConfigBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API validates that the configuration is valid and will properly authenticate with the MFA provider identified by the method path parameter. A token with ORG_ADMIN authority is required to call this API.
     * @summary MFA method\'s test configuration
     * @param {MFAConfigurationBetaApiTestMFAConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAConfigurationBetaApi
     */
    public testMFAConfig(requestParameters: MFAConfigurationBetaApiTestMFAConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return MFAConfigurationBetaApiFp(this.configuration).testMFAConfig(requestParameters.method, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ManagedClientsBetaApi - axios parameter creator
 * @export
 */
export const ManagedClientsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve Managed Client Status by ID.
         * @summary Specified Managed Client Status.
         * @param {string} id ID of the Managed Client Status to get
         * @param {ManagedClientTypeBeta} type Type of the Managed Client Status to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClientStatus: async (id: string, type: ManagedClientTypeBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getManagedClientStatus', 'id', id)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getManagedClientStatus', 'type', type)
            const localVarPath = `/managed-clients/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update a status detail passed in from the client
         * @summary Handle status request from client
         * @param {string} id ID of the Managed Client Status to update
         * @param {ManagedClientStatusBeta} managedClientStatusBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateManagedClientStatus: async (id: string, managedClientStatusBeta: ManagedClientStatusBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateManagedClientStatus', 'id', id)
            // verify required parameter 'managedClientStatusBeta' is not null or undefined
            assertParamExists('updateManagedClientStatus', 'managedClientStatusBeta', managedClientStatusBeta)
            const localVarPath = `/managed-clients/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(managedClientStatusBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManagedClientsBetaApi - functional programming interface
 * @export
 */
export const ManagedClientsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManagedClientsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve Managed Client Status by ID.
         * @summary Specified Managed Client Status.
         * @param {string} id ID of the Managed Client Status to get
         * @param {ManagedClientTypeBeta} type Type of the Managed Client Status to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getManagedClientStatus(id: string, type: ManagedClientTypeBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagedClientStatusBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getManagedClientStatus(id, type, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a status detail passed in from the client
         * @summary Handle status request from client
         * @param {string} id ID of the Managed Client Status to update
         * @param {ManagedClientStatusBeta} managedClientStatusBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateManagedClientStatus(id: string, managedClientStatusBeta: ManagedClientStatusBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagedClientStatusAggResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateManagedClientStatus(id, managedClientStatusBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ManagedClientsBetaApi - factory interface
 * @export
 */
export const ManagedClientsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManagedClientsBetaApiFp(configuration)
    return {
        /**
         * Retrieve Managed Client Status by ID.
         * @summary Specified Managed Client Status.
         * @param {string} id ID of the Managed Client Status to get
         * @param {ManagedClientTypeBeta} type Type of the Managed Client Status to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClientStatus(id: string, type: ManagedClientTypeBeta, axiosOptions?: any): AxiosPromise<ManagedClientStatusBeta> {
            return localVarFp.getManagedClientStatus(id, type, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Update a status detail passed in from the client
         * @summary Handle status request from client
         * @param {string} id ID of the Managed Client Status to update
         * @param {ManagedClientStatusBeta} managedClientStatusBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateManagedClientStatus(id: string, managedClientStatusBeta: ManagedClientStatusBeta, axiosOptions?: any): AxiosPromise<ManagedClientStatusAggResponseBeta> {
            return localVarFp.updateManagedClientStatus(id, managedClientStatusBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getManagedClientStatus operation in ManagedClientsBetaApi.
 * @export
 * @interface ManagedClientsBetaApiGetManagedClientStatusRequest
 */
export interface ManagedClientsBetaApiGetManagedClientStatusRequest {
    /**
     * ID of the Managed Client Status to get
     * @type {string}
     * @memberof ManagedClientsBetaApiGetManagedClientStatus
     */
    readonly id: string

    /**
     * Type of the Managed Client Status to get
     * @type {ManagedClientTypeBeta}
     * @memberof ManagedClientsBetaApiGetManagedClientStatus
     */
    readonly type: ManagedClientTypeBeta
}

/**
 * Request parameters for updateManagedClientStatus operation in ManagedClientsBetaApi.
 * @export
 * @interface ManagedClientsBetaApiUpdateManagedClientStatusRequest
 */
export interface ManagedClientsBetaApiUpdateManagedClientStatusRequest {
    /**
     * ID of the Managed Client Status to update
     * @type {string}
     * @memberof ManagedClientsBetaApiUpdateManagedClientStatus
     */
    readonly id: string

    /**
     * 
     * @type {ManagedClientStatusBeta}
     * @memberof ManagedClientsBetaApiUpdateManagedClientStatus
     */
    readonly managedClientStatusBeta: ManagedClientStatusBeta
}

/**
 * ManagedClientsBetaApi - object-oriented interface
 * @export
 * @class ManagedClientsBetaApi
 * @extends {BaseAPI}
 */
export class ManagedClientsBetaApi extends BaseAPI {
    /**
     * Retrieve Managed Client Status by ID.
     * @summary Specified Managed Client Status.
     * @param {ManagedClientsBetaApiGetManagedClientStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClientsBetaApi
     */
    public getManagedClientStatus(requestParameters: ManagedClientsBetaApiGetManagedClientStatusRequest, axiosOptions?: AxiosRequestConfig) {
        return ManagedClientsBetaApiFp(this.configuration).getManagedClientStatus(requestParameters.id, requestParameters.type, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a status detail passed in from the client
     * @summary Handle status request from client
     * @param {ManagedClientsBetaApiUpdateManagedClientStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClientsBetaApi
     */
    public updateManagedClientStatus(requestParameters: ManagedClientsBetaApiUpdateManagedClientStatusRequest, axiosOptions?: AxiosRequestConfig) {
        return ManagedClientsBetaApiFp(this.configuration).updateManagedClientStatus(requestParameters.id, requestParameters.managedClientStatusBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ManagedClustersBetaApi - axios parameter creator
 * @export
 */
export const ManagedClustersBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get managed cluster\'s log configuration.
         * @summary Get managed cluster\'s log configuration
         * @param {string} id ID of ManagedCluster to get log configuration for
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getClientLogConfiguration: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getClientLogConfiguration', 'id', id)
            const localVarPath = `/managed-clusters/{id}/log-config`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a ManagedCluster by ID.
         * @summary Get a specified ManagedCluster.
         * @param {string} id ID of the ManagedCluster to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedCluster: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getManagedCluster', 'id', id)
            const localVarPath = `/managed-clusters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all Managed Clusters for the current Org, based on request context.
         * @summary Retrieve all Managed Clusters.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filtering is supported for the following fields and operators:  **operational**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClusters: async (offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/managed-clusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update managed cluster\'s log configuration
         * @summary Update managed cluster\'s log configuration
         * @param {string} id ID of ManagedCluster to update log configuration for
         * @param {ClientLogConfigurationBeta} clientLogConfigurationBeta ClientLogConfiguration for given ManagedCluster
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putClientLogConfiguration: async (id: string, clientLogConfigurationBeta: ClientLogConfigurationBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putClientLogConfiguration', 'id', id)
            // verify required parameter 'clientLogConfigurationBeta' is not null or undefined
            assertParamExists('putClientLogConfiguration', 'clientLogConfigurationBeta', clientLogConfigurationBeta)
            const localVarPath = `/managed-clusters/{id}/log-config`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientLogConfigurationBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManagedClustersBetaApi - functional programming interface
 * @export
 */
export const ManagedClustersBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManagedClustersBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Get managed cluster\'s log configuration.
         * @summary Get managed cluster\'s log configuration
         * @param {string} id ID of ManagedCluster to get log configuration for
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getClientLogConfiguration(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientLogConfigurationBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClientLogConfiguration(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a ManagedCluster by ID.
         * @summary Get a specified ManagedCluster.
         * @param {string} id ID of the ManagedCluster to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getManagedCluster(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagedClusterBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getManagedCluster(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all Managed Clusters for the current Org, based on request context.
         * @summary Retrieve all Managed Clusters.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filtering is supported for the following fields and operators:  **operational**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getManagedClusters(offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ManagedClusterBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getManagedClusters(offset, limit, count, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update managed cluster\'s log configuration
         * @summary Update managed cluster\'s log configuration
         * @param {string} id ID of ManagedCluster to update log configuration for
         * @param {ClientLogConfigurationBeta} clientLogConfigurationBeta ClientLogConfiguration for given ManagedCluster
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putClientLogConfiguration(id: string, clientLogConfigurationBeta: ClientLogConfigurationBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientLogConfigurationBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putClientLogConfiguration(id, clientLogConfigurationBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ManagedClustersBetaApi - factory interface
 * @export
 */
export const ManagedClustersBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManagedClustersBetaApiFp(configuration)
    return {
        /**
         * Get managed cluster\'s log configuration.
         * @summary Get managed cluster\'s log configuration
         * @param {string} id ID of ManagedCluster to get log configuration for
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getClientLogConfiguration(id: string, axiosOptions?: any): AxiosPromise<ClientLogConfigurationBeta> {
            return localVarFp.getClientLogConfiguration(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a ManagedCluster by ID.
         * @summary Get a specified ManagedCluster.
         * @param {string} id ID of the ManagedCluster to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedCluster(id: string, axiosOptions?: any): AxiosPromise<ManagedClusterBeta> {
            return localVarFp.getManagedCluster(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all Managed Clusters for the current Org, based on request context.
         * @summary Retrieve all Managed Clusters.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filtering is supported for the following fields and operators:  **operational**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClusters(offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions?: any): AxiosPromise<Array<ManagedClusterBeta>> {
            return localVarFp.getManagedClusters(offset, limit, count, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Update managed cluster\'s log configuration
         * @summary Update managed cluster\'s log configuration
         * @param {string} id ID of ManagedCluster to update log configuration for
         * @param {ClientLogConfigurationBeta} clientLogConfigurationBeta ClientLogConfiguration for given ManagedCluster
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putClientLogConfiguration(id: string, clientLogConfigurationBeta: ClientLogConfigurationBeta, axiosOptions?: any): AxiosPromise<ClientLogConfigurationBeta> {
            return localVarFp.putClientLogConfiguration(id, clientLogConfigurationBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getClientLogConfiguration operation in ManagedClustersBetaApi.
 * @export
 * @interface ManagedClustersBetaApiGetClientLogConfigurationRequest
 */
export interface ManagedClustersBetaApiGetClientLogConfigurationRequest {
    /**
     * ID of ManagedCluster to get log configuration for
     * @type {string}
     * @memberof ManagedClustersBetaApiGetClientLogConfiguration
     */
    readonly id: string
}

/**
 * Request parameters for getManagedCluster operation in ManagedClustersBetaApi.
 * @export
 * @interface ManagedClustersBetaApiGetManagedClusterRequest
 */
export interface ManagedClustersBetaApiGetManagedClusterRequest {
    /**
     * ID of the ManagedCluster to get
     * @type {string}
     * @memberof ManagedClustersBetaApiGetManagedCluster
     */
    readonly id: string
}

/**
 * Request parameters for getManagedClusters operation in ManagedClustersBetaApi.
 * @export
 * @interface ManagedClustersBetaApiGetManagedClustersRequest
 */
export interface ManagedClustersBetaApiGetManagedClustersRequest {
    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ManagedClustersBetaApiGetManagedClusters
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ManagedClustersBetaApiGetManagedClusters
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof ManagedClustersBetaApiGetManagedClusters
     */
    readonly count?: boolean

    /**
     * Filtering is supported for the following fields and operators:  **operational**: *eq*
     * @type {string}
     * @memberof ManagedClustersBetaApiGetManagedClusters
     */
    readonly filters?: string
}

/**
 * Request parameters for putClientLogConfiguration operation in ManagedClustersBetaApi.
 * @export
 * @interface ManagedClustersBetaApiPutClientLogConfigurationRequest
 */
export interface ManagedClustersBetaApiPutClientLogConfigurationRequest {
    /**
     * ID of ManagedCluster to update log configuration for
     * @type {string}
     * @memberof ManagedClustersBetaApiPutClientLogConfiguration
     */
    readonly id: string

    /**
     * ClientLogConfiguration for given ManagedCluster
     * @type {ClientLogConfigurationBeta}
     * @memberof ManagedClustersBetaApiPutClientLogConfiguration
     */
    readonly clientLogConfigurationBeta: ClientLogConfigurationBeta
}

/**
 * ManagedClustersBetaApi - object-oriented interface
 * @export
 * @class ManagedClustersBetaApi
 * @extends {BaseAPI}
 */
export class ManagedClustersBetaApi extends BaseAPI {
    /**
     * Get managed cluster\'s log configuration.
     * @summary Get managed cluster\'s log configuration
     * @param {ManagedClustersBetaApiGetClientLogConfigurationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClustersBetaApi
     */
    public getClientLogConfiguration(requestParameters: ManagedClustersBetaApiGetClientLogConfigurationRequest, axiosOptions?: AxiosRequestConfig) {
        return ManagedClustersBetaApiFp(this.configuration).getClientLogConfiguration(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a ManagedCluster by ID.
     * @summary Get a specified ManagedCluster.
     * @param {ManagedClustersBetaApiGetManagedClusterRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClustersBetaApi
     */
    public getManagedCluster(requestParameters: ManagedClustersBetaApiGetManagedClusterRequest, axiosOptions?: AxiosRequestConfig) {
        return ManagedClustersBetaApiFp(this.configuration).getManagedCluster(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all Managed Clusters for the current Org, based on request context.
     * @summary Retrieve all Managed Clusters.
     * @param {ManagedClustersBetaApiGetManagedClustersRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClustersBetaApi
     */
    public getManagedClusters(requestParameters: ManagedClustersBetaApiGetManagedClustersRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return ManagedClustersBetaApiFp(this.configuration).getManagedClusters(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update managed cluster\'s log configuration
     * @summary Update managed cluster\'s log configuration
     * @param {ManagedClustersBetaApiPutClientLogConfigurationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClustersBetaApi
     */
    public putClientLogConfiguration(requestParameters: ManagedClustersBetaApiPutClientLogConfigurationRequest, axiosOptions?: AxiosRequestConfig) {
        return ManagedClustersBetaApiFp(this.configuration).putClientLogConfiguration(requestParameters.id, requestParameters.clientLogConfigurationBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NonEmployeeLifecycleManagementBetaApi - axios parameter creator
 * @export
 */
export const NonEmployeeLifecycleManagementBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Approves a non-employee approval request and notifies the next approver.
         * @summary Approve a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeApprovalDecisionBeta} nonEmployeeApprovalDecisionBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveNonEmployeeRequest: async (id: string, nonEmployeeApprovalDecisionBeta: NonEmployeeApprovalDecisionBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('approveNonEmployeeRequest', 'id', id)
            // verify required parameter 'nonEmployeeApprovalDecisionBeta' is not null or undefined
            assertParamExists('approveNonEmployeeRequest', 'nonEmployeeApprovalDecisionBeta', nonEmployeeApprovalDecisionBeta)
            const localVarPath = `/non-employee-approvals/{id}/approve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeApprovalDecisionBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will create a non-employee record. Request will require the following security scope: \'idn:nesr:create\'
         * @summary Create Non-Employee Record
         * @param {NonEmployeeRequestBodyBeta} nonEmployeeRequestBodyBeta Non-Employee record creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeRecord: async (nonEmployeeRequestBodyBeta: NonEmployeeRequestBodyBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nonEmployeeRequestBodyBeta' is not null or undefined
            assertParamExists('createNonEmployeeRecord', 'nonEmployeeRequestBodyBeta', nonEmployeeRequestBodyBeta)
            const localVarPath = `/non-employee-records`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeRequestBodyBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will create a non-employee request and notify the approver
         * @summary Create Non-Employee Request
         * @param {NonEmployeeRequestBodyBeta} nonEmployeeRequestBodyBeta Non-Employee creation request body
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeRequest: async (nonEmployeeRequestBodyBeta: NonEmployeeRequestBodyBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nonEmployeeRequestBodyBeta' is not null or undefined
            assertParamExists('createNonEmployeeRequest', 'nonEmployeeRequestBodyBeta', nonEmployeeRequestBodyBeta)
            const localVarPath = `/non-employee-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeRequestBodyBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will create a non-employee source. Request will require the following security scope: \'idn:nesr:create\'
         * @summary Create Non-Employee Source
         * @param {NonEmployeeSourceRequestBodyBeta} nonEmployeeSourceRequestBodyBeta Non-Employee source creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeSource: async (nonEmployeeSourceRequestBodyBeta: NonEmployeeSourceRequestBodyBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nonEmployeeSourceRequestBodyBeta' is not null or undefined
            assertParamExists('createNonEmployeeSource', 'nonEmployeeSourceRequestBodyBeta', nonEmployeeSourceRequestBodyBeta)
            const localVarPath = `/non-employee-sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeSourceRequestBodyBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API creates a new schema attribute for Non-Employee Source. The schema technical name must be unique in the source. Attempts to create a schema attribute with an existing name will result in a \"400.1.409 Reference conflict\" response. At most, 10 custom attributes can be created per schema. Attempts to create more than 10 will result in a \"400.1.4 Limit violation\" response.
         * @summary Create Non-Employee Source Schema Attribute
         * @param {string} sourceId The Source id
         * @param {NonEmployeeSchemaAttributeBodyBeta} nonEmployeeSchemaAttributeBodyBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeSourceSchemaAttributes: async (sourceId: string, nonEmployeeSchemaAttributeBodyBeta: NonEmployeeSchemaAttributeBodyBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('createNonEmployeeSourceSchemaAttributes', 'sourceId', sourceId)
            // verify required parameter 'nonEmployeeSchemaAttributeBodyBeta' is not null or undefined
            assertParamExists('createNonEmployeeSourceSchemaAttributes', 'nonEmployeeSchemaAttributeBodyBeta', nonEmployeeSchemaAttributeBodyBeta)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeSchemaAttributeBodyBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will delete a non-employee record.
         * @summary Delete Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRecord: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteNonEmployeeRecord', 'id', id)
            const localVarPath = `/non-employee-records/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will delete multiple non-employee records based on the non-employee ids provided. Request will require the following scope: \'idn:nesr:delete\'
         * @summary Delete Multiple Non-Employee Records
         * @param {DeleteNonEmployeeRecordInBulkRequestBeta} deleteNonEmployeeRecordInBulkRequestBeta Non-Employee bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRecordInBulk: async (deleteNonEmployeeRecordInBulkRequestBeta: DeleteNonEmployeeRecordInBulkRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteNonEmployeeRecordInBulkRequestBeta' is not null or undefined
            assertParamExists('deleteNonEmployeeRecordInBulk', 'deleteNonEmployeeRecordInBulkRequestBeta', deleteNonEmployeeRecordInBulkRequestBeta)
            const localVarPath = `/non-employee-records/bulk-delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteNonEmployeeRecordInBulkRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will delete a non-employee request.
         * @summary Delete Non-Employee Request
         * @param {string} id Non-Employee request id in the UUID format
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRequest: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteNonEmployeeRequest', 'id', id)
            const localVarPath = `/non-employee-requests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point deletes a specific schema attribute for a non-employee source. 
         * @summary Delete Non-Employee Source\'s Schema Attribute
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSchemaAttribute: async (attributeId: string, sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('deleteNonEmployeeSchemaAttribute', 'attributeId', attributeId)
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteNonEmployeeSchemaAttribute', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes/{attributeId}`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will delete a non-employee source.
         * @summary Delete Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSource: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteNonEmployeeSource', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point deletes all custom schema attributes for a non-employee source.
         * @summary Delete all custom schema attributes
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSourceSchemaAttributes: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteNonEmployeeSourceSchemaAttributes', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This requests a CSV download for all non-employees from a provided source.
         * @summary Exports Non-Employee Records to CSV
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportNonEmployeeRecords: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('exportNonEmployeeRecords', 'id', id)
            const localVarPath = `/non-employee-sources/{id}/non-employees/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This requests a download for the Source Schema Template for a provided source. Request will require the following security scope: idn:nesr:read\'
         * @summary Exports Source Schema Template
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportNonEmployeeSourceSchemaTemplate: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('exportNonEmployeeSourceSchemaTemplate', 'id', id)
            const localVarPath = `/non-employee-sources/{id}/schema-attributes-template/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Approves a non-employee approval request and notifies the next approver.
         * @summary Get a non-employee approval item detail
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {string} [includeDetail] The object nonEmployeeRequest will not be included detail when set to false. *Default value is true*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeApproval: async (id: string, includeDetail?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNonEmployeeApproval', 'id', id)
            const localVarPath = `/non-employee-approvals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (includeDetail !== undefined) {
                localVarQueryParameter['include-detail'] = includeDetail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will retrieve a summary of non-employee approval requests. There are two contextual uses for the `requested-for` path parameter: 1. The current user is the Org Admin, in which case he or she may request a summary of all non-employee approval requests assigned to a particular approver by passing in that approver\'s id. 2. The current user is an approver, in which case \"me\" should be provided as the `requested-for` value. This will provide the approver with a summary of the approval items assigned to him or her.
         * @summary Get Summary of Non-Employee Approval Requests
         * @param {string} requestedFor The identity (UUID) of the approver for whom for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeApprovalSummary: async (requestedFor: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestedFor' is not null or undefined
            assertParamExists('getNonEmployeeApprovalSummary', 'requestedFor', requestedFor)
            const localVarPath = `/non-employee-approvals/summary/{requested-for}`
                .replace(`{${"requested-for"}}`, encodeURIComponent(String(requestedFor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * The nonEmployeeBulkUploadStatus API returns the status of the newest bulk upload job for the specified source. 
         * @summary Bulk upload status on source
         * @param {string} id Source ID (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeBulkUploadStatus: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNonEmployeeBulkUploadStatus', 'id', id)
            const localVarPath = `/non-employee-sources/{id}/non-employee-bulk-upload/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a non-employee record.
         * @summary Get a Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRecord: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNonEmployeeRecord', 'id', id)
            const localVarPath = `/non-employee-records/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a non-employee request.
         * @summary Get a Non-Employee Request
         * @param {string} id Non-Employee request id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRequest: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNonEmployeeRequest', 'id', id)
            const localVarPath = `/non-employee-requests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will retrieve a summary of non-employee requests. There are two contextual uses for the `requested-for` path parameter: 1. The current user is the Org Admin, in which case he or she may request a summary of all non-employee approval requests assigned to a particular account manager by passing in that manager\'s id. 2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a summary of the non-employee requests in the source(s) he or she manages.
         * @summary Get Summary of Non-Employee Requests
         * @param {string} requestedFor The identity (UUID) of the non-employee account manager for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRequestSummary: async (requestedFor: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestedFor' is not null or undefined
            assertParamExists('getNonEmployeeRequestSummary', 'requestedFor', requestedFor)
            const localVarPath = `/non-employee-requests/summary/{requested-for}`
                .replace(`{${"requested-for"}}`, encodeURIComponent(String(requestedFor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API gets a schema attribute by Id for the specified Non-Employee SourceId.
         * @summary Get Schema Attribute Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSchemaAttribute: async (attributeId: string, sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('getNonEmployeeSchemaAttribute', 'attributeId', attributeId)
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getNonEmployeeSchemaAttribute', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes/{attributeId}`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a non-employee source.
         * @summary Get a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSource: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getNonEmployeeSource', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API gets the list of schema attributes for the specified Non-Employee SourceId. There are 8 mandatory attributes added to each new Non-Employee Source automatically. Additionaly, user can add up to 10 custom attributes. This interface returns all the mandatory attributes followed by any custom attributes. At most, a total of 18 attributes will be returned.
         * @summary List Schema Attributes Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSourceSchemaAttributes: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getNonEmployeeSourceSchemaAttributes', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This post will import, or update, Non-Employee records found in the CSV. Request will need the following security scope: \'idn:nesr:create\'
         * @summary Imports, or Updates, Non-Employee Records
         * @param {string} id Source Id (UUID)
         * @param {any} data 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importNonEmployeeRecordsInBulk: async (id: string, data: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('importNonEmployeeRecordsInBulk', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('importNonEmployeeRecordsInBulk', 'data', data)
            const localVarPath = `/non-employee-sources/{id}/non-employee-bulk-upload`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


            if (data !== undefined) { 
                localVarFormParams.append('data', data as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a list of non-employee approval requests.
         * @summary Get List of Non-Employee Approval Requests
         * @param {string} [requestedFor] The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **approvalStatus**: *eq*  *Example:* approvalStatus eq \&quot;PENDING\&quot;
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeApproval: async (requestedFor?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/non-employee-approvals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (requestedFor !== undefined) {
                localVarQueryParameter['requested-for'] = requestedFor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a list of non-employee records.
         * @summary List Non-Employee Records
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **id, accountName, sourceId, manager, firstName, lastName, email, phone, startDate, endDate, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **sourceId**: *eq*  *Example:* sourceId eq \&quot;2c91808568c529c60168cca6f90c1313\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeRecords: async (limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/non-employee-records`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a list of non-employee requests.
         * @summary List Non-Employee Requests
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **created, approvalStatus, firstName, lastName, email, phone, accountName, startDate, endDate**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **sourceId**: *eq*  *Example:* sourceId eq \&quot;2c91808568c529c60168cca6f90c1313\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeRequests: async (requestedFor: string, limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestedFor' is not null or undefined
            assertParamExists('listNonEmployeeRequests', 'requestedFor', requestedFor)
            const localVarPath = `/non-employee-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (requestedFor !== undefined) {
                localVarQueryParameter['requested-for'] = requestedFor;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a list of non-employee sources.
         * @summary List Non-Employee Sources
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {boolean} nonEmployeeCount The flag to determine whether return a non-employee count associate with source.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **name, created**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeSources: async (requestedFor: string, nonEmployeeCount: boolean, limit?: number, offset?: number, count?: boolean, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestedFor' is not null or undefined
            assertParamExists('listNonEmployeeSources', 'requestedFor', requestedFor)
            // verify required parameter 'nonEmployeeCount' is not null or undefined
            assertParamExists('listNonEmployeeSources', 'nonEmployeeCount', nonEmployeeCount)
            const localVarPath = `/non-employee-sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (requestedFor !== undefined) {
                localVarQueryParameter['requested-for'] = requestedFor;
            }

            if (nonEmployeeCount !== undefined) {
                localVarQueryParameter['non-employee-count'] = nonEmployeeCount;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will patch a non-employee record.
         * @summary Patch Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta A list of non-employee update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeRecord: async (id: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchNonEmployeeRecord', 'id', id)
            // verify required parameter 'jsonPatchOperationBeta' is not null or undefined
            assertParamExists('patchNonEmployeeRecord', 'jsonPatchOperationBeta', jsonPatchOperationBeta)
            const localVarPath = `/non-employee-records/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperationBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point patches a specific schema attribute for a non-employee SourceId. 
         * @summary Patch Non-Employee Source\'s Schema Attribute
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta A list of schema attribute update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The following properties are allowed for update \&#39;:\&#39; \&#39;label\&#39;, \&#39;helpText\&#39;, \&#39;placeholder\&#39;, \&#39;required\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeSchemaAttribute: async (attributeId: string, sourceId: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('patchNonEmployeeSchemaAttribute', 'attributeId', attributeId)
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('patchNonEmployeeSchemaAttribute', 'sourceId', sourceId)
            // verify required parameter 'jsonPatchOperationBeta' is not null or undefined
            assertParamExists('patchNonEmployeeSchemaAttribute', 'jsonPatchOperationBeta', jsonPatchOperationBeta)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes/{attributeId}`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperationBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * patch a non-employee source. (Partial Update)  Patchable field: **name, description, approvers, accountManagers**
         * @summary Patch a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta A list of non-employee source update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeSource: async (sourceId: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('patchNonEmployeeSource', 'sourceId', sourceId)
            // verify required parameter 'jsonPatchOperationBeta' is not null or undefined
            assertParamExists('patchNonEmployeeSource', 'jsonPatchOperationBeta', jsonPatchOperationBeta)
            const localVarPath = `/non-employee-sources/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperationBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will reject an approval item request and notify user.
         * @summary Reject a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeRejectApprovalDecisionBeta} nonEmployeeRejectApprovalDecisionBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectNonEmployeeRequest: async (id: string, nonEmployeeRejectApprovalDecisionBeta: NonEmployeeRejectApprovalDecisionBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rejectNonEmployeeRequest', 'id', id)
            // verify required parameter 'nonEmployeeRejectApprovalDecisionBeta' is not null or undefined
            assertParamExists('rejectNonEmployeeRequest', 'nonEmployeeRejectApprovalDecisionBeta', nonEmployeeRejectApprovalDecisionBeta)
            const localVarPath = `/non-employee-approvals/{id}/reject`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeRejectApprovalDecisionBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will update a non-employee record.
         * @summary Update Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {NonEmployeeRequestBodyBeta} nonEmployeeRequestBodyBeta Non-employee record creation request body. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateNonEmployeeRecord: async (id: string, nonEmployeeRequestBodyBeta: NonEmployeeRequestBodyBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateNonEmployeeRecord', 'id', id)
            // verify required parameter 'nonEmployeeRequestBodyBeta' is not null or undefined
            assertParamExists('updateNonEmployeeRecord', 'nonEmployeeRequestBodyBeta', nonEmployeeRequestBodyBeta)
            const localVarPath = `/non-employee-records/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeRequestBodyBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * NonEmployeeLifecycleManagementBetaApi - functional programming interface
 * @export
 */
export const NonEmployeeLifecycleManagementBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NonEmployeeLifecycleManagementBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Approves a non-employee approval request and notifies the next approver.
         * @summary Approve a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeApprovalDecisionBeta} nonEmployeeApprovalDecisionBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async approveNonEmployeeRequest(id: string, nonEmployeeApprovalDecisionBeta: NonEmployeeApprovalDecisionBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeApprovalItemBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveNonEmployeeRequest(id, nonEmployeeApprovalDecisionBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will create a non-employee record. Request will require the following security scope: \'idn:nesr:create\'
         * @summary Create Non-Employee Record
         * @param {NonEmployeeRequestBodyBeta} nonEmployeeRequestBodyBeta Non-Employee record creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createNonEmployeeRecord(nonEmployeeRequestBodyBeta: NonEmployeeRequestBodyBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRecordBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNonEmployeeRecord(nonEmployeeRequestBodyBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will create a non-employee request and notify the approver
         * @summary Create Non-Employee Request
         * @param {NonEmployeeRequestBodyBeta} nonEmployeeRequestBodyBeta Non-Employee creation request body
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createNonEmployeeRequest(nonEmployeeRequestBodyBeta: NonEmployeeRequestBodyBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRequestBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNonEmployeeRequest(nonEmployeeRequestBodyBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will create a non-employee source. Request will require the following security scope: \'idn:nesr:create\'
         * @summary Create Non-Employee Source
         * @param {NonEmployeeSourceRequestBodyBeta} nonEmployeeSourceRequestBodyBeta Non-Employee source creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createNonEmployeeSource(nonEmployeeSourceRequestBodyBeta: NonEmployeeSourceRequestBodyBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSourceWithCloudExternalIdBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNonEmployeeSource(nonEmployeeSourceRequestBodyBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API creates a new schema attribute for Non-Employee Source. The schema technical name must be unique in the source. Attempts to create a schema attribute with an existing name will result in a \"400.1.409 Reference conflict\" response. At most, 10 custom attributes can be created per schema. Attempts to create more than 10 will result in a \"400.1.4 Limit violation\" response.
         * @summary Create Non-Employee Source Schema Attribute
         * @param {string} sourceId The Source id
         * @param {NonEmployeeSchemaAttributeBodyBeta} nonEmployeeSchemaAttributeBodyBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createNonEmployeeSourceSchemaAttributes(sourceId: string, nonEmployeeSchemaAttributeBodyBeta: NonEmployeeSchemaAttributeBodyBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSchemaAttributeBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNonEmployeeSourceSchemaAttributes(sourceId, nonEmployeeSchemaAttributeBodyBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will delete a non-employee record.
         * @summary Delete Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNonEmployeeRecord(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNonEmployeeRecord(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will delete multiple non-employee records based on the non-employee ids provided. Request will require the following scope: \'idn:nesr:delete\'
         * @summary Delete Multiple Non-Employee Records
         * @param {DeleteNonEmployeeRecordInBulkRequestBeta} deleteNonEmployeeRecordInBulkRequestBeta Non-Employee bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNonEmployeeRecordInBulk(deleteNonEmployeeRecordInBulkRequestBeta: DeleteNonEmployeeRecordInBulkRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNonEmployeeRecordInBulk(deleteNonEmployeeRecordInBulkRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will delete a non-employee request.
         * @summary Delete Non-Employee Request
         * @param {string} id Non-Employee request id in the UUID format
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNonEmployeeRequest(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNonEmployeeRequest(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point deletes a specific schema attribute for a non-employee source. 
         * @summary Delete Non-Employee Source\'s Schema Attribute
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNonEmployeeSchemaAttribute(attributeId: string, sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNonEmployeeSchemaAttribute(attributeId, sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will delete a non-employee source.
         * @summary Delete Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNonEmployeeSource(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNonEmployeeSource(sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point deletes all custom schema attributes for a non-employee source.
         * @summary Delete all custom schema attributes
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNonEmployeeSourceSchemaAttributes(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNonEmployeeSourceSchemaAttributes(sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This requests a CSV download for all non-employees from a provided source.
         * @summary Exports Non-Employee Records to CSV
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async exportNonEmployeeRecords(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportNonEmployeeRecords(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This requests a download for the Source Schema Template for a provided source. Request will require the following security scope: idn:nesr:read\'
         * @summary Exports Source Schema Template
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async exportNonEmployeeSourceSchemaTemplate(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportNonEmployeeSourceSchemaTemplate(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Approves a non-employee approval request and notifies the next approver.
         * @summary Get a non-employee approval item detail
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {string} [includeDetail] The object nonEmployeeRequest will not be included detail when set to false. *Default value is true*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeApproval(id: string, includeDetail?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeApprovalItemDetailBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeApproval(id, includeDetail, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will retrieve a summary of non-employee approval requests. There are two contextual uses for the `requested-for` path parameter: 1. The current user is the Org Admin, in which case he or she may request a summary of all non-employee approval requests assigned to a particular approver by passing in that approver\'s id. 2. The current user is an approver, in which case \"me\" should be provided as the `requested-for` value. This will provide the approver with a summary of the approval items assigned to him or her.
         * @summary Get Summary of Non-Employee Approval Requests
         * @param {string} requestedFor The identity (UUID) of the approver for whom for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeApprovalSummary(requestedFor: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeApprovalSummaryBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeApprovalSummary(requestedFor, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The nonEmployeeBulkUploadStatus API returns the status of the newest bulk upload job for the specified source. 
         * @summary Bulk upload status on source
         * @param {string} id Source ID (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeBulkUploadStatus(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeBulkUploadStatusBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeBulkUploadStatus(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a non-employee record.
         * @summary Get a Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeRecord(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRecordBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeRecord(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a non-employee request.
         * @summary Get a Non-Employee Request
         * @param {string} id Non-Employee request id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeRequest(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRequestBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeRequest(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will retrieve a summary of non-employee requests. There are two contextual uses for the `requested-for` path parameter: 1. The current user is the Org Admin, in which case he or she may request a summary of all non-employee approval requests assigned to a particular account manager by passing in that manager\'s id. 2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a summary of the non-employee requests in the source(s) he or she manages.
         * @summary Get Summary of Non-Employee Requests
         * @param {string} requestedFor The identity (UUID) of the non-employee account manager for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeRequestSummary(requestedFor: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRequestSummaryBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeRequestSummary(requestedFor, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API gets a schema attribute by Id for the specified Non-Employee SourceId.
         * @summary Get Schema Attribute Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeSchemaAttribute(attributeId: string, sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSchemaAttributeBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeSchemaAttribute(attributeId, sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a non-employee source.
         * @summary Get a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeSource(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSourceBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeSource(sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API gets the list of schema attributes for the specified Non-Employee SourceId. There are 8 mandatory attributes added to each new Non-Employee Source automatically. Additionaly, user can add up to 10 custom attributes. This interface returns all the mandatory attributes followed by any custom attributes. At most, a total of 18 attributes will be returned.
         * @summary List Schema Attributes Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeSourceSchemaAttributes(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NonEmployeeSchemaAttributeBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeSourceSchemaAttributes(sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This post will import, or update, Non-Employee records found in the CSV. Request will need the following security scope: \'idn:nesr:create\'
         * @summary Imports, or Updates, Non-Employee Records
         * @param {string} id Source Id (UUID)
         * @param {any} data 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async importNonEmployeeRecordsInBulk(id: string, data: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeBulkUploadJobBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importNonEmployeeRecordsInBulk(id, data, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a list of non-employee approval requests.
         * @summary Get List of Non-Employee Approval Requests
         * @param {string} [requestedFor] The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **approvalStatus**: *eq*  *Example:* approvalStatus eq \&quot;PENDING\&quot;
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listNonEmployeeApproval(requestedFor?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NonEmployeeApprovalItemBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNonEmployeeApproval(requestedFor, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a list of non-employee records.
         * @summary List Non-Employee Records
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **id, accountName, sourceId, manager, firstName, lastName, email, phone, startDate, endDate, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **sourceId**: *eq*  *Example:* sourceId eq \&quot;2c91808568c529c60168cca6f90c1313\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listNonEmployeeRecords(limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NonEmployeeRecordBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNonEmployeeRecords(limit, offset, count, sorters, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a list of non-employee requests.
         * @summary List Non-Employee Requests
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **created, approvalStatus, firstName, lastName, email, phone, accountName, startDate, endDate**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **sourceId**: *eq*  *Example:* sourceId eq \&quot;2c91808568c529c60168cca6f90c1313\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listNonEmployeeRequests(requestedFor: string, limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NonEmployeeRequestBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNonEmployeeRequests(requestedFor, limit, offset, count, sorters, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a list of non-employee sources.
         * @summary List Non-Employee Sources
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {boolean} nonEmployeeCount The flag to determine whether return a non-employee count associate with source.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **name, created**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listNonEmployeeSources(requestedFor: string, nonEmployeeCount: boolean, limit?: number, offset?: number, count?: boolean, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NonEmployeeSourceWithNECountBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNonEmployeeSources(requestedFor, nonEmployeeCount, limit, offset, count, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will patch a non-employee record.
         * @summary Patch Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta A list of non-employee update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchNonEmployeeRecord(id: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRecordBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchNonEmployeeRecord(id, jsonPatchOperationBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point patches a specific schema attribute for a non-employee SourceId. 
         * @summary Patch Non-Employee Source\'s Schema Attribute
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta A list of schema attribute update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The following properties are allowed for update \&#39;:\&#39; \&#39;label\&#39;, \&#39;helpText\&#39;, \&#39;placeholder\&#39;, \&#39;required\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchNonEmployeeSchemaAttribute(attributeId: string, sourceId: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSchemaAttributeBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchNonEmployeeSchemaAttribute(attributeId, sourceId, jsonPatchOperationBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * patch a non-employee source. (Partial Update)  Patchable field: **name, description, approvers, accountManagers**
         * @summary Patch a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta A list of non-employee source update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchNonEmployeeSource(sourceId: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSourceBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchNonEmployeeSource(sourceId, jsonPatchOperationBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will reject an approval item request and notify user.
         * @summary Reject a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeRejectApprovalDecisionBeta} nonEmployeeRejectApprovalDecisionBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async rejectNonEmployeeRequest(id: string, nonEmployeeRejectApprovalDecisionBeta: NonEmployeeRejectApprovalDecisionBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeApprovalItemBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectNonEmployeeRequest(id, nonEmployeeRejectApprovalDecisionBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will update a non-employee record.
         * @summary Update Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {NonEmployeeRequestBodyBeta} nonEmployeeRequestBodyBeta Non-employee record creation request body. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateNonEmployeeRecord(id: string, nonEmployeeRequestBodyBeta: NonEmployeeRequestBodyBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRecordBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNonEmployeeRecord(id, nonEmployeeRequestBodyBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NonEmployeeLifecycleManagementBetaApi - factory interface
 * @export
 */
export const NonEmployeeLifecycleManagementBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NonEmployeeLifecycleManagementBetaApiFp(configuration)
    return {
        /**
         * Approves a non-employee approval request and notifies the next approver.
         * @summary Approve a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeApprovalDecisionBeta} nonEmployeeApprovalDecisionBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveNonEmployeeRequest(id: string, nonEmployeeApprovalDecisionBeta: NonEmployeeApprovalDecisionBeta, axiosOptions?: any): AxiosPromise<NonEmployeeApprovalItemBeta> {
            return localVarFp.approveNonEmployeeRequest(id, nonEmployeeApprovalDecisionBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will create a non-employee record. Request will require the following security scope: \'idn:nesr:create\'
         * @summary Create Non-Employee Record
         * @param {NonEmployeeRequestBodyBeta} nonEmployeeRequestBodyBeta Non-Employee record creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeRecord(nonEmployeeRequestBodyBeta: NonEmployeeRequestBodyBeta, axiosOptions?: any): AxiosPromise<NonEmployeeRecordBeta> {
            return localVarFp.createNonEmployeeRecord(nonEmployeeRequestBodyBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will create a non-employee request and notify the approver
         * @summary Create Non-Employee Request
         * @param {NonEmployeeRequestBodyBeta} nonEmployeeRequestBodyBeta Non-Employee creation request body
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeRequest(nonEmployeeRequestBodyBeta: NonEmployeeRequestBodyBeta, axiosOptions?: any): AxiosPromise<NonEmployeeRequestBeta> {
            return localVarFp.createNonEmployeeRequest(nonEmployeeRequestBodyBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will create a non-employee source. Request will require the following security scope: \'idn:nesr:create\'
         * @summary Create Non-Employee Source
         * @param {NonEmployeeSourceRequestBodyBeta} nonEmployeeSourceRequestBodyBeta Non-Employee source creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeSource(nonEmployeeSourceRequestBodyBeta: NonEmployeeSourceRequestBodyBeta, axiosOptions?: any): AxiosPromise<NonEmployeeSourceWithCloudExternalIdBeta> {
            return localVarFp.createNonEmployeeSource(nonEmployeeSourceRequestBodyBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API creates a new schema attribute for Non-Employee Source. The schema technical name must be unique in the source. Attempts to create a schema attribute with an existing name will result in a \"400.1.409 Reference conflict\" response. At most, 10 custom attributes can be created per schema. Attempts to create more than 10 will result in a \"400.1.4 Limit violation\" response.
         * @summary Create Non-Employee Source Schema Attribute
         * @param {string} sourceId The Source id
         * @param {NonEmployeeSchemaAttributeBodyBeta} nonEmployeeSchemaAttributeBodyBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeSourceSchemaAttributes(sourceId: string, nonEmployeeSchemaAttributeBodyBeta: NonEmployeeSchemaAttributeBodyBeta, axiosOptions?: any): AxiosPromise<NonEmployeeSchemaAttributeBeta> {
            return localVarFp.createNonEmployeeSourceSchemaAttributes(sourceId, nonEmployeeSchemaAttributeBodyBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will delete a non-employee record.
         * @summary Delete Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRecord(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteNonEmployeeRecord(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will delete multiple non-employee records based on the non-employee ids provided. Request will require the following scope: \'idn:nesr:delete\'
         * @summary Delete Multiple Non-Employee Records
         * @param {DeleteNonEmployeeRecordInBulkRequestBeta} deleteNonEmployeeRecordInBulkRequestBeta Non-Employee bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRecordInBulk(deleteNonEmployeeRecordInBulkRequestBeta: DeleteNonEmployeeRecordInBulkRequestBeta, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteNonEmployeeRecordInBulk(deleteNonEmployeeRecordInBulkRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will delete a non-employee request.
         * @summary Delete Non-Employee Request
         * @param {string} id Non-Employee request id in the UUID format
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRequest(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteNonEmployeeRequest(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point deletes a specific schema attribute for a non-employee source. 
         * @summary Delete Non-Employee Source\'s Schema Attribute
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSchemaAttribute(attributeId: string, sourceId: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteNonEmployeeSchemaAttribute(attributeId, sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will delete a non-employee source.
         * @summary Delete Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSource(sourceId: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteNonEmployeeSource(sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point deletes all custom schema attributes for a non-employee source.
         * @summary Delete all custom schema attributes
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSourceSchemaAttributes(sourceId: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteNonEmployeeSourceSchemaAttributes(sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This requests a CSV download for all non-employees from a provided source.
         * @summary Exports Non-Employee Records to CSV
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportNonEmployeeRecords(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.exportNonEmployeeRecords(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This requests a download for the Source Schema Template for a provided source. Request will require the following security scope: idn:nesr:read\'
         * @summary Exports Source Schema Template
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportNonEmployeeSourceSchemaTemplate(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.exportNonEmployeeSourceSchemaTemplate(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Approves a non-employee approval request and notifies the next approver.
         * @summary Get a non-employee approval item detail
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {string} [includeDetail] The object nonEmployeeRequest will not be included detail when set to false. *Default value is true*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeApproval(id: string, includeDetail?: string, axiosOptions?: any): AxiosPromise<NonEmployeeApprovalItemDetailBeta> {
            return localVarFp.getNonEmployeeApproval(id, includeDetail, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will retrieve a summary of non-employee approval requests. There are two contextual uses for the `requested-for` path parameter: 1. The current user is the Org Admin, in which case he or she may request a summary of all non-employee approval requests assigned to a particular approver by passing in that approver\'s id. 2. The current user is an approver, in which case \"me\" should be provided as the `requested-for` value. This will provide the approver with a summary of the approval items assigned to him or her.
         * @summary Get Summary of Non-Employee Approval Requests
         * @param {string} requestedFor The identity (UUID) of the approver for whom for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeApprovalSummary(requestedFor: string, axiosOptions?: any): AxiosPromise<NonEmployeeApprovalSummaryBeta> {
            return localVarFp.getNonEmployeeApprovalSummary(requestedFor, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * The nonEmployeeBulkUploadStatus API returns the status of the newest bulk upload job for the specified source. 
         * @summary Bulk upload status on source
         * @param {string} id Source ID (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeBulkUploadStatus(id: string, axiosOptions?: any): AxiosPromise<NonEmployeeBulkUploadStatusBeta> {
            return localVarFp.getNonEmployeeBulkUploadStatus(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a non-employee record.
         * @summary Get a Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRecord(id: string, axiosOptions?: any): AxiosPromise<NonEmployeeRecordBeta> {
            return localVarFp.getNonEmployeeRecord(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a non-employee request.
         * @summary Get a Non-Employee Request
         * @param {string} id Non-Employee request id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRequest(id: string, axiosOptions?: any): AxiosPromise<NonEmployeeRequestBeta> {
            return localVarFp.getNonEmployeeRequest(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will retrieve a summary of non-employee requests. There are two contextual uses for the `requested-for` path parameter: 1. The current user is the Org Admin, in which case he or she may request a summary of all non-employee approval requests assigned to a particular account manager by passing in that manager\'s id. 2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a summary of the non-employee requests in the source(s) he or she manages.
         * @summary Get Summary of Non-Employee Requests
         * @param {string} requestedFor The identity (UUID) of the non-employee account manager for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRequestSummary(requestedFor: string, axiosOptions?: any): AxiosPromise<NonEmployeeRequestSummaryBeta> {
            return localVarFp.getNonEmployeeRequestSummary(requestedFor, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API gets a schema attribute by Id for the specified Non-Employee SourceId.
         * @summary Get Schema Attribute Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSchemaAttribute(attributeId: string, sourceId: string, axiosOptions?: any): AxiosPromise<NonEmployeeSchemaAttributeBeta> {
            return localVarFp.getNonEmployeeSchemaAttribute(attributeId, sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a non-employee source.
         * @summary Get a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSource(sourceId: string, axiosOptions?: any): AxiosPromise<NonEmployeeSourceBeta> {
            return localVarFp.getNonEmployeeSource(sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API gets the list of schema attributes for the specified Non-Employee SourceId. There are 8 mandatory attributes added to each new Non-Employee Source automatically. Additionaly, user can add up to 10 custom attributes. This interface returns all the mandatory attributes followed by any custom attributes. At most, a total of 18 attributes will be returned.
         * @summary List Schema Attributes Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSourceSchemaAttributes(sourceId: string, axiosOptions?: any): AxiosPromise<Array<NonEmployeeSchemaAttributeBeta>> {
            return localVarFp.getNonEmployeeSourceSchemaAttributes(sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This post will import, or update, Non-Employee records found in the CSV. Request will need the following security scope: \'idn:nesr:create\'
         * @summary Imports, or Updates, Non-Employee Records
         * @param {string} id Source Id (UUID)
         * @param {any} data 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importNonEmployeeRecordsInBulk(id: string, data: any, axiosOptions?: any): AxiosPromise<NonEmployeeBulkUploadJobBeta> {
            return localVarFp.importNonEmployeeRecordsInBulk(id, data, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a list of non-employee approval requests.
         * @summary Get List of Non-Employee Approval Requests
         * @param {string} [requestedFor] The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **approvalStatus**: *eq*  *Example:* approvalStatus eq \&quot;PENDING\&quot;
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeApproval(requestedFor?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<NonEmployeeApprovalItemBeta>> {
            return localVarFp.listNonEmployeeApproval(requestedFor, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a list of non-employee records.
         * @summary List Non-Employee Records
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **id, accountName, sourceId, manager, firstName, lastName, email, phone, startDate, endDate, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **sourceId**: *eq*  *Example:* sourceId eq \&quot;2c91808568c529c60168cca6f90c1313\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeRecords(limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: any): AxiosPromise<Array<NonEmployeeRecordBeta>> {
            return localVarFp.listNonEmployeeRecords(limit, offset, count, sorters, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a list of non-employee requests.
         * @summary List Non-Employee Requests
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **created, approvalStatus, firstName, lastName, email, phone, accountName, startDate, endDate**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **sourceId**: *eq*  *Example:* sourceId eq \&quot;2c91808568c529c60168cca6f90c1313\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeRequests(requestedFor: string, limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: any): AxiosPromise<Array<NonEmployeeRequestBeta>> {
            return localVarFp.listNonEmployeeRequests(requestedFor, limit, offset, count, sorters, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a list of non-employee sources.
         * @summary List Non-Employee Sources
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {boolean} nonEmployeeCount The flag to determine whether return a non-employee count associate with source.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **name, created**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeSources(requestedFor: string, nonEmployeeCount: boolean, limit?: number, offset?: number, count?: boolean, sorters?: string, axiosOptions?: any): AxiosPromise<Array<NonEmployeeSourceWithNECountBeta>> {
            return localVarFp.listNonEmployeeSources(requestedFor, nonEmployeeCount, limit, offset, count, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will patch a non-employee record.
         * @summary Patch Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta A list of non-employee update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeRecord(id: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: any): AxiosPromise<NonEmployeeRecordBeta> {
            return localVarFp.patchNonEmployeeRecord(id, jsonPatchOperationBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point patches a specific schema attribute for a non-employee SourceId. 
         * @summary Patch Non-Employee Source\'s Schema Attribute
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta A list of schema attribute update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The following properties are allowed for update \&#39;:\&#39; \&#39;label\&#39;, \&#39;helpText\&#39;, \&#39;placeholder\&#39;, \&#39;required\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeSchemaAttribute(attributeId: string, sourceId: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: any): AxiosPromise<NonEmployeeSchemaAttributeBeta> {
            return localVarFp.patchNonEmployeeSchemaAttribute(attributeId, sourceId, jsonPatchOperationBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * patch a non-employee source. (Partial Update)  Patchable field: **name, description, approvers, accountManagers**
         * @summary Patch a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta A list of non-employee source update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeSource(sourceId: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: any): AxiosPromise<NonEmployeeSourceBeta> {
            return localVarFp.patchNonEmployeeSource(sourceId, jsonPatchOperationBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will reject an approval item request and notify user.
         * @summary Reject a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeRejectApprovalDecisionBeta} nonEmployeeRejectApprovalDecisionBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectNonEmployeeRequest(id: string, nonEmployeeRejectApprovalDecisionBeta: NonEmployeeRejectApprovalDecisionBeta, axiosOptions?: any): AxiosPromise<NonEmployeeApprovalItemBeta> {
            return localVarFp.rejectNonEmployeeRequest(id, nonEmployeeRejectApprovalDecisionBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will update a non-employee record.
         * @summary Update Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {NonEmployeeRequestBodyBeta} nonEmployeeRequestBodyBeta Non-employee record creation request body. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateNonEmployeeRecord(id: string, nonEmployeeRequestBodyBeta: NonEmployeeRequestBodyBeta, axiosOptions?: any): AxiosPromise<NonEmployeeRecordBeta> {
            return localVarFp.updateNonEmployeeRecord(id, nonEmployeeRequestBodyBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for approveNonEmployeeRequest operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiApproveNonEmployeeRequestRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiApproveNonEmployeeRequestRequest {
    /**
     * Non-Employee approval item id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiApproveNonEmployeeRequest
     */
    readonly id: string

    /**
     * 
     * @type {NonEmployeeApprovalDecisionBeta}
     * @memberof NonEmployeeLifecycleManagementBetaApiApproveNonEmployeeRequest
     */
    readonly nonEmployeeApprovalDecisionBeta: NonEmployeeApprovalDecisionBeta
}

/**
 * Request parameters for createNonEmployeeRecord operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiCreateNonEmployeeRecordRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiCreateNonEmployeeRecordRequest {
    /**
     * Non-Employee record creation request body.
     * @type {NonEmployeeRequestBodyBeta}
     * @memberof NonEmployeeLifecycleManagementBetaApiCreateNonEmployeeRecord
     */
    readonly nonEmployeeRequestBodyBeta: NonEmployeeRequestBodyBeta
}

/**
 * Request parameters for createNonEmployeeRequest operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiCreateNonEmployeeRequestRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiCreateNonEmployeeRequestRequest {
    /**
     * Non-Employee creation request body
     * @type {NonEmployeeRequestBodyBeta}
     * @memberof NonEmployeeLifecycleManagementBetaApiCreateNonEmployeeRequest
     */
    readonly nonEmployeeRequestBodyBeta: NonEmployeeRequestBodyBeta
}

/**
 * Request parameters for createNonEmployeeSource operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiCreateNonEmployeeSourceRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiCreateNonEmployeeSourceRequest {
    /**
     * Non-Employee source creation request body.
     * @type {NonEmployeeSourceRequestBodyBeta}
     * @memberof NonEmployeeLifecycleManagementBetaApiCreateNonEmployeeSource
     */
    readonly nonEmployeeSourceRequestBodyBeta: NonEmployeeSourceRequestBodyBeta
}

/**
 * Request parameters for createNonEmployeeSourceSchemaAttributes operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiCreateNonEmployeeSourceSchemaAttributesRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiCreateNonEmployeeSourceSchemaAttributesRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiCreateNonEmployeeSourceSchemaAttributes
     */
    readonly sourceId: string

    /**
     * 
     * @type {NonEmployeeSchemaAttributeBodyBeta}
     * @memberof NonEmployeeLifecycleManagementBetaApiCreateNonEmployeeSourceSchemaAttributes
     */
    readonly nonEmployeeSchemaAttributeBodyBeta: NonEmployeeSchemaAttributeBodyBeta
}

/**
 * Request parameters for deleteNonEmployeeRecord operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiDeleteNonEmployeeRecordRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiDeleteNonEmployeeRecordRequest {
    /**
     * Non-Employee record id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiDeleteNonEmployeeRecord
     */
    readonly id: string
}

/**
 * Request parameters for deleteNonEmployeeRecordInBulk operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiDeleteNonEmployeeRecordInBulkRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiDeleteNonEmployeeRecordInBulkRequest {
    /**
     * Non-Employee bulk delete request body.
     * @type {DeleteNonEmployeeRecordInBulkRequestBeta}
     * @memberof NonEmployeeLifecycleManagementBetaApiDeleteNonEmployeeRecordInBulk
     */
    readonly deleteNonEmployeeRecordInBulkRequestBeta: DeleteNonEmployeeRecordInBulkRequestBeta
}

/**
 * Request parameters for deleteNonEmployeeRequest operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiDeleteNonEmployeeRequestRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiDeleteNonEmployeeRequestRequest {
    /**
     * Non-Employee request id in the UUID format
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiDeleteNonEmployeeRequest
     */
    readonly id: string
}

/**
 * Request parameters for deleteNonEmployeeSchemaAttribute operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiDeleteNonEmployeeSchemaAttributeRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiDeleteNonEmployeeSchemaAttributeRequest {
    /**
     * The Schema Attribute Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiDeleteNonEmployeeSchemaAttribute
     */
    readonly attributeId: string

    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiDeleteNonEmployeeSchemaAttribute
     */
    readonly sourceId: string
}

/**
 * Request parameters for deleteNonEmployeeSource operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiDeleteNonEmployeeSourceRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiDeleteNonEmployeeSourceRequest {
    /**
     * Source Id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiDeleteNonEmployeeSource
     */
    readonly sourceId: string
}

/**
 * Request parameters for deleteNonEmployeeSourceSchemaAttributes operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiDeleteNonEmployeeSourceSchemaAttributesRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiDeleteNonEmployeeSourceSchemaAttributesRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiDeleteNonEmployeeSourceSchemaAttributes
     */
    readonly sourceId: string
}

/**
 * Request parameters for exportNonEmployeeRecords operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiExportNonEmployeeRecordsRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiExportNonEmployeeRecordsRequest {
    /**
     * Source Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiExportNonEmployeeRecords
     */
    readonly id: string
}

/**
 * Request parameters for exportNonEmployeeSourceSchemaTemplate operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiExportNonEmployeeSourceSchemaTemplateRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiExportNonEmployeeSourceSchemaTemplateRequest {
    /**
     * Source Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiExportNonEmployeeSourceSchemaTemplate
     */
    readonly id: string
}

/**
 * Request parameters for getNonEmployeeApproval operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiGetNonEmployeeApprovalRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiGetNonEmployeeApprovalRequest {
    /**
     * Non-Employee approval item id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiGetNonEmployeeApproval
     */
    readonly id: string

    /**
     * The object nonEmployeeRequest will not be included detail when set to false. *Default value is true*
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiGetNonEmployeeApproval
     */
    readonly includeDetail?: string
}

/**
 * Request parameters for getNonEmployeeApprovalSummary operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiGetNonEmployeeApprovalSummaryRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiGetNonEmployeeApprovalSummaryRequest {
    /**
     * The identity (UUID) of the approver for whom for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiGetNonEmployeeApprovalSummary
     */
    readonly requestedFor: string
}

/**
 * Request parameters for getNonEmployeeBulkUploadStatus operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiGetNonEmployeeBulkUploadStatusRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiGetNonEmployeeBulkUploadStatusRequest {
    /**
     * Source ID (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiGetNonEmployeeBulkUploadStatus
     */
    readonly id: string
}

/**
 * Request parameters for getNonEmployeeRecord operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiGetNonEmployeeRecordRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiGetNonEmployeeRecordRequest {
    /**
     * Non-Employee record id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiGetNonEmployeeRecord
     */
    readonly id: string
}

/**
 * Request parameters for getNonEmployeeRequest operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiGetNonEmployeeRequestRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiGetNonEmployeeRequestRequest {
    /**
     * Non-Employee request id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiGetNonEmployeeRequest
     */
    readonly id: string
}

/**
 * Request parameters for getNonEmployeeRequestSummary operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiGetNonEmployeeRequestSummaryRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiGetNonEmployeeRequestSummaryRequest {
    /**
     * The identity (UUID) of the non-employee account manager for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiGetNonEmployeeRequestSummary
     */
    readonly requestedFor: string
}

/**
 * Request parameters for getNonEmployeeSchemaAttribute operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiGetNonEmployeeSchemaAttributeRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiGetNonEmployeeSchemaAttributeRequest {
    /**
     * The Schema Attribute Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiGetNonEmployeeSchemaAttribute
     */
    readonly attributeId: string

    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiGetNonEmployeeSchemaAttribute
     */
    readonly sourceId: string
}

/**
 * Request parameters for getNonEmployeeSource operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiGetNonEmployeeSourceRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiGetNonEmployeeSourceRequest {
    /**
     * Source Id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiGetNonEmployeeSource
     */
    readonly sourceId: string
}

/**
 * Request parameters for getNonEmployeeSourceSchemaAttributes operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiGetNonEmployeeSourceSchemaAttributesRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiGetNonEmployeeSourceSchemaAttributesRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiGetNonEmployeeSourceSchemaAttributes
     */
    readonly sourceId: string
}

/**
 * Request parameters for importNonEmployeeRecordsInBulk operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiImportNonEmployeeRecordsInBulkRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiImportNonEmployeeRecordsInBulkRequest {
    /**
     * Source Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiImportNonEmployeeRecordsInBulk
     */
    readonly id: string

    /**
     * 
     * @type {any}
     * @memberof NonEmployeeLifecycleManagementBetaApiImportNonEmployeeRecordsInBulk
     */
    readonly data: any
}

/**
 * Request parameters for listNonEmployeeApproval operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiListNonEmployeeApprovalRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiListNonEmployeeApprovalRequest {
    /**
     * The identity for whom the request was made. *me* indicates the current user.
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiListNonEmployeeApproval
     */
    readonly requestedFor?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementBetaApiListNonEmployeeApproval
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementBetaApiListNonEmployeeApproval
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementBetaApiListNonEmployeeApproval
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **approvalStatus**: *eq*  *Example:* approvalStatus eq \&quot;PENDING\&quot;
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiListNonEmployeeApproval
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **created, modified**
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiListNonEmployeeApproval
     */
    readonly sorters?: string
}

/**
 * Request parameters for listNonEmployeeRecords operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiListNonEmployeeRecordsRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiListNonEmployeeRecordsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementBetaApiListNonEmployeeRecords
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementBetaApiListNonEmployeeRecords
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementBetaApiListNonEmployeeRecords
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **id, accountName, sourceId, manager, firstName, lastName, email, phone, startDate, endDate, created, modified**
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiListNonEmployeeRecords
     */
    readonly sorters?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **sourceId**: *eq*  *Example:* sourceId eq \&quot;2c91808568c529c60168cca6f90c1313\&quot;
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiListNonEmployeeRecords
     */
    readonly filters?: string
}

/**
 * Request parameters for listNonEmployeeRequests operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiListNonEmployeeRequestsRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiListNonEmployeeRequestsRequest {
    /**
     * The identity for whom the request was made. *me* indicates the current user.
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiListNonEmployeeRequests
     */
    readonly requestedFor: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementBetaApiListNonEmployeeRequests
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementBetaApiListNonEmployeeRequests
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementBetaApiListNonEmployeeRequests
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **created, approvalStatus, firstName, lastName, email, phone, accountName, startDate, endDate**
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiListNonEmployeeRequests
     */
    readonly sorters?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **sourceId**: *eq*  *Example:* sourceId eq \&quot;2c91808568c529c60168cca6f90c1313\&quot;
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiListNonEmployeeRequests
     */
    readonly filters?: string
}

/**
 * Request parameters for listNonEmployeeSources operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiListNonEmployeeSourcesRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiListNonEmployeeSourcesRequest {
    /**
     * The identity for whom the request was made. *me* indicates the current user.
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiListNonEmployeeSources
     */
    readonly requestedFor: string

    /**
     * The flag to determine whether return a non-employee count associate with source.
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementBetaApiListNonEmployeeSources
     */
    readonly nonEmployeeCount: boolean

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementBetaApiListNonEmployeeSources
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementBetaApiListNonEmployeeSources
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementBetaApiListNonEmployeeSources
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **name, created**
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiListNonEmployeeSources
     */
    readonly sorters?: string
}

/**
 * Request parameters for patchNonEmployeeRecord operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiPatchNonEmployeeRecordRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiPatchNonEmployeeRecordRequest {
    /**
     * Non-employee record id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiPatchNonEmployeeRecord
     */
    readonly id: string

    /**
     * A list of non-employee update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
     * @type {Array<JsonPatchOperationBeta>}
     * @memberof NonEmployeeLifecycleManagementBetaApiPatchNonEmployeeRecord
     */
    readonly jsonPatchOperationBeta: Array<JsonPatchOperationBeta>
}

/**
 * Request parameters for patchNonEmployeeSchemaAttribute operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiPatchNonEmployeeSchemaAttributeRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiPatchNonEmployeeSchemaAttributeRequest {
    /**
     * The Schema Attribute Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiPatchNonEmployeeSchemaAttribute
     */
    readonly attributeId: string

    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiPatchNonEmployeeSchemaAttribute
     */
    readonly sourceId: string

    /**
     * A list of schema attribute update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The following properties are allowed for update \&#39;:\&#39; \&#39;label\&#39;, \&#39;helpText\&#39;, \&#39;placeholder\&#39;, \&#39;required\&#39;.
     * @type {Array<JsonPatchOperationBeta>}
     * @memberof NonEmployeeLifecycleManagementBetaApiPatchNonEmployeeSchemaAttribute
     */
    readonly jsonPatchOperationBeta: Array<JsonPatchOperationBeta>
}

/**
 * Request parameters for patchNonEmployeeSource operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiPatchNonEmployeeSourceRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiPatchNonEmployeeSourceRequest {
    /**
     * Source Id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiPatchNonEmployeeSource
     */
    readonly sourceId: string

    /**
     * A list of non-employee source update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
     * @type {Array<JsonPatchOperationBeta>}
     * @memberof NonEmployeeLifecycleManagementBetaApiPatchNonEmployeeSource
     */
    readonly jsonPatchOperationBeta: Array<JsonPatchOperationBeta>
}

/**
 * Request parameters for rejectNonEmployeeRequest operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiRejectNonEmployeeRequestRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiRejectNonEmployeeRequestRequest {
    /**
     * Non-Employee approval item id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiRejectNonEmployeeRequest
     */
    readonly id: string

    /**
     * 
     * @type {NonEmployeeRejectApprovalDecisionBeta}
     * @memberof NonEmployeeLifecycleManagementBetaApiRejectNonEmployeeRequest
     */
    readonly nonEmployeeRejectApprovalDecisionBeta: NonEmployeeRejectApprovalDecisionBeta
}

/**
 * Request parameters for updateNonEmployeeRecord operation in NonEmployeeLifecycleManagementBetaApi.
 * @export
 * @interface NonEmployeeLifecycleManagementBetaApiUpdateNonEmployeeRecordRequest
 */
export interface NonEmployeeLifecycleManagementBetaApiUpdateNonEmployeeRecordRequest {
    /**
     * Non-employee record id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementBetaApiUpdateNonEmployeeRecord
     */
    readonly id: string

    /**
     * Non-employee record creation request body. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
     * @type {NonEmployeeRequestBodyBeta}
     * @memberof NonEmployeeLifecycleManagementBetaApiUpdateNonEmployeeRecord
     */
    readonly nonEmployeeRequestBodyBeta: NonEmployeeRequestBodyBeta
}

/**
 * NonEmployeeLifecycleManagementBetaApi - object-oriented interface
 * @export
 * @class NonEmployeeLifecycleManagementBetaApi
 * @extends {BaseAPI}
 */
export class NonEmployeeLifecycleManagementBetaApi extends BaseAPI {
    /**
     * Approves a non-employee approval request and notifies the next approver.
     * @summary Approve a Non-Employee Request
     * @param {NonEmployeeLifecycleManagementBetaApiApproveNonEmployeeRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public approveNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementBetaApiApproveNonEmployeeRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).approveNonEmployeeRequest(requestParameters.id, requestParameters.nonEmployeeApprovalDecisionBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will create a non-employee record. Request will require the following security scope: \'idn:nesr:create\'
     * @summary Create Non-Employee Record
     * @param {NonEmployeeLifecycleManagementBetaApiCreateNonEmployeeRecordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public createNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementBetaApiCreateNonEmployeeRecordRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).createNonEmployeeRecord(requestParameters.nonEmployeeRequestBodyBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will create a non-employee request and notify the approver
     * @summary Create Non-Employee Request
     * @param {NonEmployeeLifecycleManagementBetaApiCreateNonEmployeeRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public createNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementBetaApiCreateNonEmployeeRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).createNonEmployeeRequest(requestParameters.nonEmployeeRequestBodyBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will create a non-employee source. Request will require the following security scope: \'idn:nesr:create\'
     * @summary Create Non-Employee Source
     * @param {NonEmployeeLifecycleManagementBetaApiCreateNonEmployeeSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public createNonEmployeeSource(requestParameters: NonEmployeeLifecycleManagementBetaApiCreateNonEmployeeSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).createNonEmployeeSource(requestParameters.nonEmployeeSourceRequestBodyBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API creates a new schema attribute for Non-Employee Source. The schema technical name must be unique in the source. Attempts to create a schema attribute with an existing name will result in a \"400.1.409 Reference conflict\" response. At most, 10 custom attributes can be created per schema. Attempts to create more than 10 will result in a \"400.1.4 Limit violation\" response.
     * @summary Create Non-Employee Source Schema Attribute
     * @param {NonEmployeeLifecycleManagementBetaApiCreateNonEmployeeSourceSchemaAttributesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public createNonEmployeeSourceSchemaAttributes(requestParameters: NonEmployeeLifecycleManagementBetaApiCreateNonEmployeeSourceSchemaAttributesRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).createNonEmployeeSourceSchemaAttributes(requestParameters.sourceId, requestParameters.nonEmployeeSchemaAttributeBodyBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will delete a non-employee record.
     * @summary Delete Non-Employee Record
     * @param {NonEmployeeLifecycleManagementBetaApiDeleteNonEmployeeRecordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public deleteNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementBetaApiDeleteNonEmployeeRecordRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).deleteNonEmployeeRecord(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will delete multiple non-employee records based on the non-employee ids provided. Request will require the following scope: \'idn:nesr:delete\'
     * @summary Delete Multiple Non-Employee Records
     * @param {NonEmployeeLifecycleManagementBetaApiDeleteNonEmployeeRecordInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public deleteNonEmployeeRecordInBulk(requestParameters: NonEmployeeLifecycleManagementBetaApiDeleteNonEmployeeRecordInBulkRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).deleteNonEmployeeRecordInBulk(requestParameters.deleteNonEmployeeRecordInBulkRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will delete a non-employee request.
     * @summary Delete Non-Employee Request
     * @param {NonEmployeeLifecycleManagementBetaApiDeleteNonEmployeeRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public deleteNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementBetaApiDeleteNonEmployeeRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).deleteNonEmployeeRequest(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point deletes a specific schema attribute for a non-employee source. 
     * @summary Delete Non-Employee Source\'s Schema Attribute
     * @param {NonEmployeeLifecycleManagementBetaApiDeleteNonEmployeeSchemaAttributeRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public deleteNonEmployeeSchemaAttribute(requestParameters: NonEmployeeLifecycleManagementBetaApiDeleteNonEmployeeSchemaAttributeRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).deleteNonEmployeeSchemaAttribute(requestParameters.attributeId, requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will delete a non-employee source.
     * @summary Delete Non-Employee Source
     * @param {NonEmployeeLifecycleManagementBetaApiDeleteNonEmployeeSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public deleteNonEmployeeSource(requestParameters: NonEmployeeLifecycleManagementBetaApiDeleteNonEmployeeSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).deleteNonEmployeeSource(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point deletes all custom schema attributes for a non-employee source.
     * @summary Delete all custom schema attributes
     * @param {NonEmployeeLifecycleManagementBetaApiDeleteNonEmployeeSourceSchemaAttributesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public deleteNonEmployeeSourceSchemaAttributes(requestParameters: NonEmployeeLifecycleManagementBetaApiDeleteNonEmployeeSourceSchemaAttributesRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).deleteNonEmployeeSourceSchemaAttributes(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This requests a CSV download for all non-employees from a provided source.
     * @summary Exports Non-Employee Records to CSV
     * @param {NonEmployeeLifecycleManagementBetaApiExportNonEmployeeRecordsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public exportNonEmployeeRecords(requestParameters: NonEmployeeLifecycleManagementBetaApiExportNonEmployeeRecordsRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).exportNonEmployeeRecords(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This requests a download for the Source Schema Template for a provided source. Request will require the following security scope: idn:nesr:read\'
     * @summary Exports Source Schema Template
     * @param {NonEmployeeLifecycleManagementBetaApiExportNonEmployeeSourceSchemaTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public exportNonEmployeeSourceSchemaTemplate(requestParameters: NonEmployeeLifecycleManagementBetaApiExportNonEmployeeSourceSchemaTemplateRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).exportNonEmployeeSourceSchemaTemplate(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Approves a non-employee approval request and notifies the next approver.
     * @summary Get a non-employee approval item detail
     * @param {NonEmployeeLifecycleManagementBetaApiGetNonEmployeeApprovalRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public getNonEmployeeApproval(requestParameters: NonEmployeeLifecycleManagementBetaApiGetNonEmployeeApprovalRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).getNonEmployeeApproval(requestParameters.id, requestParameters.includeDetail, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will retrieve a summary of non-employee approval requests. There are two contextual uses for the `requested-for` path parameter: 1. The current user is the Org Admin, in which case he or she may request a summary of all non-employee approval requests assigned to a particular approver by passing in that approver\'s id. 2. The current user is an approver, in which case \"me\" should be provided as the `requested-for` value. This will provide the approver with a summary of the approval items assigned to him or her.
     * @summary Get Summary of Non-Employee Approval Requests
     * @param {NonEmployeeLifecycleManagementBetaApiGetNonEmployeeApprovalSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public getNonEmployeeApprovalSummary(requestParameters: NonEmployeeLifecycleManagementBetaApiGetNonEmployeeApprovalSummaryRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).getNonEmployeeApprovalSummary(requestParameters.requestedFor, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The nonEmployeeBulkUploadStatus API returns the status of the newest bulk upload job for the specified source. 
     * @summary Bulk upload status on source
     * @param {NonEmployeeLifecycleManagementBetaApiGetNonEmployeeBulkUploadStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public getNonEmployeeBulkUploadStatus(requestParameters: NonEmployeeLifecycleManagementBetaApiGetNonEmployeeBulkUploadStatusRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).getNonEmployeeBulkUploadStatus(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a non-employee record.
     * @summary Get a Non-Employee Record
     * @param {NonEmployeeLifecycleManagementBetaApiGetNonEmployeeRecordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public getNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementBetaApiGetNonEmployeeRecordRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).getNonEmployeeRecord(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a non-employee request.
     * @summary Get a Non-Employee Request
     * @param {NonEmployeeLifecycleManagementBetaApiGetNonEmployeeRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public getNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementBetaApiGetNonEmployeeRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).getNonEmployeeRequest(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will retrieve a summary of non-employee requests. There are two contextual uses for the `requested-for` path parameter: 1. The current user is the Org Admin, in which case he or she may request a summary of all non-employee approval requests assigned to a particular account manager by passing in that manager\'s id. 2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a summary of the non-employee requests in the source(s) he or she manages.
     * @summary Get Summary of Non-Employee Requests
     * @param {NonEmployeeLifecycleManagementBetaApiGetNonEmployeeRequestSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public getNonEmployeeRequestSummary(requestParameters: NonEmployeeLifecycleManagementBetaApiGetNonEmployeeRequestSummaryRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).getNonEmployeeRequestSummary(requestParameters.requestedFor, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API gets a schema attribute by Id for the specified Non-Employee SourceId.
     * @summary Get Schema Attribute Non-Employee Source
     * @param {NonEmployeeLifecycleManagementBetaApiGetNonEmployeeSchemaAttributeRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public getNonEmployeeSchemaAttribute(requestParameters: NonEmployeeLifecycleManagementBetaApiGetNonEmployeeSchemaAttributeRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).getNonEmployeeSchemaAttribute(requestParameters.attributeId, requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a non-employee source.
     * @summary Get a Non-Employee Source
     * @param {NonEmployeeLifecycleManagementBetaApiGetNonEmployeeSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public getNonEmployeeSource(requestParameters: NonEmployeeLifecycleManagementBetaApiGetNonEmployeeSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).getNonEmployeeSource(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API gets the list of schema attributes for the specified Non-Employee SourceId. There are 8 mandatory attributes added to each new Non-Employee Source automatically. Additionaly, user can add up to 10 custom attributes. This interface returns all the mandatory attributes followed by any custom attributes. At most, a total of 18 attributes will be returned.
     * @summary List Schema Attributes Non-Employee Source
     * @param {NonEmployeeLifecycleManagementBetaApiGetNonEmployeeSourceSchemaAttributesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public getNonEmployeeSourceSchemaAttributes(requestParameters: NonEmployeeLifecycleManagementBetaApiGetNonEmployeeSourceSchemaAttributesRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).getNonEmployeeSourceSchemaAttributes(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This post will import, or update, Non-Employee records found in the CSV. Request will need the following security scope: \'idn:nesr:create\'
     * @summary Imports, or Updates, Non-Employee Records
     * @param {NonEmployeeLifecycleManagementBetaApiImportNonEmployeeRecordsInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public importNonEmployeeRecordsInBulk(requestParameters: NonEmployeeLifecycleManagementBetaApiImportNonEmployeeRecordsInBulkRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).importNonEmployeeRecordsInBulk(requestParameters.id, requestParameters.data, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a list of non-employee approval requests.
     * @summary Get List of Non-Employee Approval Requests
     * @param {NonEmployeeLifecycleManagementBetaApiListNonEmployeeApprovalRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public listNonEmployeeApproval(requestParameters: NonEmployeeLifecycleManagementBetaApiListNonEmployeeApprovalRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).listNonEmployeeApproval(requestParameters.requestedFor, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a list of non-employee records.
     * @summary List Non-Employee Records
     * @param {NonEmployeeLifecycleManagementBetaApiListNonEmployeeRecordsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public listNonEmployeeRecords(requestParameters: NonEmployeeLifecycleManagementBetaApiListNonEmployeeRecordsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).listNonEmployeeRecords(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a list of non-employee requests.
     * @summary List Non-Employee Requests
     * @param {NonEmployeeLifecycleManagementBetaApiListNonEmployeeRequestsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public listNonEmployeeRequests(requestParameters: NonEmployeeLifecycleManagementBetaApiListNonEmployeeRequestsRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).listNonEmployeeRequests(requestParameters.requestedFor, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a list of non-employee sources.
     * @summary List Non-Employee Sources
     * @param {NonEmployeeLifecycleManagementBetaApiListNonEmployeeSourcesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public listNonEmployeeSources(requestParameters: NonEmployeeLifecycleManagementBetaApiListNonEmployeeSourcesRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).listNonEmployeeSources(requestParameters.requestedFor, requestParameters.nonEmployeeCount, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will patch a non-employee record.
     * @summary Patch Non-Employee Record
     * @param {NonEmployeeLifecycleManagementBetaApiPatchNonEmployeeRecordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public patchNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementBetaApiPatchNonEmployeeRecordRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).patchNonEmployeeRecord(requestParameters.id, requestParameters.jsonPatchOperationBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point patches a specific schema attribute for a non-employee SourceId. 
     * @summary Patch Non-Employee Source\'s Schema Attribute
     * @param {NonEmployeeLifecycleManagementBetaApiPatchNonEmployeeSchemaAttributeRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public patchNonEmployeeSchemaAttribute(requestParameters: NonEmployeeLifecycleManagementBetaApiPatchNonEmployeeSchemaAttributeRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).patchNonEmployeeSchemaAttribute(requestParameters.attributeId, requestParameters.sourceId, requestParameters.jsonPatchOperationBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch a non-employee source. (Partial Update)  Patchable field: **name, description, approvers, accountManagers**
     * @summary Patch a Non-Employee Source
     * @param {NonEmployeeLifecycleManagementBetaApiPatchNonEmployeeSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public patchNonEmployeeSource(requestParameters: NonEmployeeLifecycleManagementBetaApiPatchNonEmployeeSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).patchNonEmployeeSource(requestParameters.sourceId, requestParameters.jsonPatchOperationBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will reject an approval item request and notify user.
     * @summary Reject a Non-Employee Request
     * @param {NonEmployeeLifecycleManagementBetaApiRejectNonEmployeeRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public rejectNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementBetaApiRejectNonEmployeeRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).rejectNonEmployeeRequest(requestParameters.id, requestParameters.nonEmployeeRejectApprovalDecisionBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will update a non-employee record.
     * @summary Update Non-Employee Record
     * @param {NonEmployeeLifecycleManagementBetaApiUpdateNonEmployeeRecordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementBetaApi
     */
    public updateNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementBetaApiUpdateNonEmployeeRecordRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementBetaApiFp(this.configuration).updateNonEmployeeRecord(requestParameters.id, requestParameters.nonEmployeeRequestBodyBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotificationsBetaApi - axios parameter creator
 * @export
 */
export const NotificationsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a domain to be verified via DKIM (DomainKeys Identified Mail)
         * @summary Verify domain address via DKIM
         * @param {DomainAddressBeta} domainAddressBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createDomainDkim: async (domainAddressBeta: DomainAddressBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainAddressBeta' is not null or undefined
            assertParamExists('createDomainDkim', 'domainAddressBeta', domainAddressBeta)
            const localVarPath = `/verified-domains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainAddressBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This creates a template for your site.   You can also use this endpoint to update a template.  First, copy the response body from the [get notification template endpoint](https://developer.sailpoint.com/idn/api/beta/get-notification-template) for a template you wish to update and paste it into the request body for this endpoint.   Modify the fields you want to change and submit the POST request when ready.
         * @summary Create Notification Template
         * @param {TemplateDtoBeta} templateDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNotificationTemplate: async (templateDtoBeta: TemplateDtoBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateDtoBeta' is not null or undefined
            assertParamExists('createNotificationTemplate', 'templateDtoBeta', templateDtoBeta)
            const localVarPath = `/notification-templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(templateDtoBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Create a new sender email address and initiate verification process.
         * @summary Create Verified From Address
         * @param {EmailStatusDtoBeta} emailStatusDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createVerifiedFromAddress: async (emailStatusDtoBeta: EmailStatusDtoBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'emailStatusDtoBeta' is not null or undefined
            assertParamExists('createVerifiedFromAddress', 'emailStatusDtoBeta', emailStatusDtoBeta)
            const localVarPath = `/verified-from-addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailStatusDtoBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This lets you bulk delete templates that you previously created for your site. Since this is a beta feature, you can only delete a subset of your notifications, i.e. ones that show up in the list call.
         * @summary Bulk Delete Notification Templates
         * @param {Array<TemplateBulkDeleteDtoBeta>} templateBulkDeleteDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotificationTemplatesInBulk: async (templateBulkDeleteDtoBeta: Array<TemplateBulkDeleteDtoBeta>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateBulkDeleteDtoBeta' is not null or undefined
            assertParamExists('deleteNotificationTemplatesInBulk', 'templateBulkDeleteDtoBeta', templateBulkDeleteDtoBeta)
            const localVarPath = `/notification-templates/bulk-delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(templateBulkDeleteDtoBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Delete a verified sender email address
         * @summary Delete Verified From Address
         * @param {string} id 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteVerifiedFromAddress: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteVerifiedFromAddress', 'id', id)
            const localVarPath = `/verified-from-addresses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Retrieve DKIM (DomainKeys Identified Mail) attributes for all your tenants\' AWS SES identities. Limits retrieval to 100 identities per call.
         * @summary Get DKIM Attributes
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDkimAttributes: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/verified-domains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Retrieve MAIL FROM attributes for a given AWS SES identity.
         * @summary Get MAIL FROM Attributes
         * @param {string} id Returns the MX and TXT record to be put in your DNS, as well as the MAIL FROM domain status
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getMailFromAttributes: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMailFromAttributes', 'id', id)
            const localVarPath = `/mail-from-attributes/{identity}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Returns the notification preferences for tenant.  Note that if the key doesn\'t exist, then a 404 will be returned. Request will require the following legacy roles:  ORG_ADMIN and API
         * @summary Get Notification Preferences for tenant.
         * @param {string} key The notification key.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationPreference: async (key: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getNotificationPreference', 'key', key)
            const localVarPath = `/notification-preferences/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a template that you have modified for your site by Id.
         * @summary Get Notification Template By Id
         * @param {string} id Id of the Notification Template
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationTemplate: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNotificationTemplate', 'id', id)
            const localVarPath = `/notification-templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * The notification service (Hermes) maintains metadata to construct the notification templates or supply any information during the event propagation.  The data-store where this information is retrieved is  called \"Global Context\" (a.k.a. notification template context). It defines a set of attributes  that will be available per tenant (organization).  Regarding authorization, the access token contains the tenant and will grant access to the one requested. Requires the following security scope:  idn:notification-templates:read
         * @summary Get Notification Template Context
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationsTemplateContext: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notification-template-context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of sender email addresses and their verification statuses
         * @summary List From Addresses
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **email**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields:  **email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listFromAddresses: async (limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/verified-from-addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This lists the default templates used for notifications, such as emails from IdentityNow. Since this is a beta feature, it doesn\'t include all the templates.
         * @summary List Notification Template Defaults
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **key**: *eq, in*  **medium**: *eq*  **locale**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNotificationTemplateDefaults: async (limit?: number, offset?: number, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notification-template-defaults`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This lists the templates that you have modified for your site. Since this is a beta feature, it doesn\'t include all your modified templates.
         * @summary List Notification Templates
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **key**: *eq, in*  **medium**: *eq*  **locale**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNotificationTemplates: async (limit?: number, offset?: number, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notification-templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Change the MAIL FROM domain of an AWS SES email identity and provide the MX and TXT records to be placed in the caller\'s DNS
         * @summary Change MAIL FROM domain
         * @param {MailFromAttributesDtoBeta} mailFromAttributesDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putMailFromAttributes: async (mailFromAttributesDtoBeta: MailFromAttributesDtoBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mailFromAttributesDtoBeta' is not null or undefined
            assertParamExists('putMailFromAttributes', 'mailFromAttributesDtoBeta', mailFromAttributesDtoBeta)
            const localVarPath = `/mail-from-attributes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mailFromAttributesDtoBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * In the notification world, a notification flows through these salient stages -   1. Interest matching,   2. Preferences   3. Template Rendering.   The default notification preferences make up a part of the second stage, along with user preferences (which is a future goal). The expectation is for  admins to be able to set default preferences for their org, like opting in to or out of certain notifications, and configuring future preferences as  we tack on more features. The key in the Dto is not necessary but if it is provided and doesn\'t match the key in the URI, then a 400 will be thrown.  Request will require the following legacy roles:  ORG_ADMIN and API
         * @summary Overwrite the preferences for the given notification key.
         * @param {string} key The notification key.
         * @param {PreferencesDtoBeta} preferencesDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putNotificationPreference: async (key: string, preferencesDtoBeta: PreferencesDtoBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('putNotificationPreference', 'key', key)
            // verify required parameter 'preferencesDtoBeta' is not null or undefined
            assertParamExists('putNotificationPreference', 'preferencesDtoBeta', preferencesDtoBeta)
            const localVarPath = `/notification-preferences/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(preferencesDtoBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Send a Test Notification
         * @summary Send Test Notification
         * @param {SendTestNotificationRequestDtoBeta} sendTestNotificationRequestDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendTestNotification: async (sendTestNotificationRequestDtoBeta: SendTestNotificationRequestDtoBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendTestNotificationRequestDtoBeta' is not null or undefined
            assertParamExists('sendTestNotification', 'sendTestNotificationRequestDtoBeta', sendTestNotificationRequestDtoBeta)
            const localVarPath = `/send-test-notification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendTestNotificationRequestDtoBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsBetaApi - functional programming interface
 * @export
 */
export const NotificationsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a domain to be verified via DKIM (DomainKeys Identified Mail)
         * @summary Verify domain address via DKIM
         * @param {DomainAddressBeta} domainAddressBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createDomainDkim(domainAddressBeta: DomainAddressBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainStatusDtoBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDomainDkim(domainAddressBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This creates a template for your site.   You can also use this endpoint to update a template.  First, copy the response body from the [get notification template endpoint](https://developer.sailpoint.com/idn/api/beta/get-notification-template) for a template you wish to update and paste it into the request body for this endpoint.   Modify the fields you want to change and submit the POST request when ready.
         * @summary Create Notification Template
         * @param {TemplateDtoBeta} templateDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createNotificationTemplate(templateDtoBeta: TemplateDtoBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplateDtoBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNotificationTemplate(templateDtoBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new sender email address and initiate verification process.
         * @summary Create Verified From Address
         * @param {EmailStatusDtoBeta} emailStatusDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createVerifiedFromAddress(emailStatusDtoBeta: EmailStatusDtoBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailStatusDtoBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVerifiedFromAddress(emailStatusDtoBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This lets you bulk delete templates that you previously created for your site. Since this is a beta feature, you can only delete a subset of your notifications, i.e. ones that show up in the list call.
         * @summary Bulk Delete Notification Templates
         * @param {Array<TemplateBulkDeleteDtoBeta>} templateBulkDeleteDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNotificationTemplatesInBulk(templateBulkDeleteDtoBeta: Array<TemplateBulkDeleteDtoBeta>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNotificationTemplatesInBulk(templateBulkDeleteDtoBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a verified sender email address
         * @summary Delete Verified From Address
         * @param {string} id 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVerifiedFromAddress(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVerifiedFromAddress(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve DKIM (DomainKeys Identified Mail) attributes for all your tenants\' AWS SES identities. Limits retrieval to 100 identities per call.
         * @summary Get DKIM Attributes
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getDkimAttributes(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DkimAttributesBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDkimAttributes(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve MAIL FROM attributes for a given AWS SES identity.
         * @summary Get MAIL FROM Attributes
         * @param {string} id Returns the MX and TXT record to be put in your DNS, as well as the MAIL FROM domain status
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getMailFromAttributes(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MailFromAttributesBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMailFromAttributes(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the notification preferences for tenant.  Note that if the key doesn\'t exist, then a 404 will be returned. Request will require the following legacy roles:  ORG_ADMIN and API
         * @summary Get Notification Preferences for tenant.
         * @param {string} key The notification key.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationPreference(key: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PreferencesDtoBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotificationPreference(key, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a template that you have modified for your site by Id.
         * @summary Get Notification Template By Id
         * @param {string} id Id of the Notification Template
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationTemplate(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TemplateDtoBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotificationTemplate(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The notification service (Hermes) maintains metadata to construct the notification templates or supply any information during the event propagation.  The data-store where this information is retrieved is  called \"Global Context\" (a.k.a. notification template context). It defines a set of attributes  that will be available per tenant (organization).  Regarding authorization, the access token contains the tenant and will grant access to the one requested. Requires the following security scope:  idn:notification-templates:read
         * @summary Get Notification Template Context
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationsTemplateContext(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotificationTemplateContextBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotificationsTemplateContext(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a list of sender email addresses and their verification statuses
         * @summary List From Addresses
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **email**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields:  **email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listFromAddresses(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EmailStatusDtoBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFromAddresses(limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This lists the default templates used for notifications, such as emails from IdentityNow. Since this is a beta feature, it doesn\'t include all the templates.
         * @summary List Notification Template Defaults
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **key**: *eq, in*  **medium**: *eq*  **locale**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listNotificationTemplateDefaults(limit?: number, offset?: number, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TemplateDtoDefaultBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNotificationTemplateDefaults(limit, offset, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This lists the templates that you have modified for your site. Since this is a beta feature, it doesn\'t include all your modified templates.
         * @summary List Notification Templates
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **key**: *eq, in*  **medium**: *eq*  **locale**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listNotificationTemplates(limit?: number, offset?: number, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TemplateDtoBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNotificationTemplates(limit, offset, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change the MAIL FROM domain of an AWS SES email identity and provide the MX and TXT records to be placed in the caller\'s DNS
         * @summary Change MAIL FROM domain
         * @param {MailFromAttributesDtoBeta} mailFromAttributesDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putMailFromAttributes(mailFromAttributesDtoBeta: MailFromAttributesDtoBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MailFromAttributesBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putMailFromAttributes(mailFromAttributesDtoBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * In the notification world, a notification flows through these salient stages -   1. Interest matching,   2. Preferences   3. Template Rendering.   The default notification preferences make up a part of the second stage, along with user preferences (which is a future goal). The expectation is for  admins to be able to set default preferences for their org, like opting in to or out of certain notifications, and configuring future preferences as  we tack on more features. The key in the Dto is not necessary but if it is provided and doesn\'t match the key in the URI, then a 400 will be thrown.  Request will require the following legacy roles:  ORG_ADMIN and API
         * @summary Overwrite the preferences for the given notification key.
         * @param {string} key The notification key.
         * @param {PreferencesDtoBeta} preferencesDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putNotificationPreference(key: string, preferencesDtoBeta: PreferencesDtoBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PreferencesDtoBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putNotificationPreference(key, preferencesDtoBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send a Test Notification
         * @summary Send Test Notification
         * @param {SendTestNotificationRequestDtoBeta} sendTestNotificationRequestDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async sendTestNotification(sendTestNotificationRequestDtoBeta: SendTestNotificationRequestDtoBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendTestNotification(sendTestNotificationRequestDtoBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotificationsBetaApi - factory interface
 * @export
 */
export const NotificationsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationsBetaApiFp(configuration)
    return {
        /**
         * Create a domain to be verified via DKIM (DomainKeys Identified Mail)
         * @summary Verify domain address via DKIM
         * @param {DomainAddressBeta} domainAddressBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createDomainDkim(domainAddressBeta: DomainAddressBeta, axiosOptions?: any): AxiosPromise<DomainStatusDtoBeta> {
            return localVarFp.createDomainDkim(domainAddressBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This creates a template for your site.   You can also use this endpoint to update a template.  First, copy the response body from the [get notification template endpoint](https://developer.sailpoint.com/idn/api/beta/get-notification-template) for a template you wish to update and paste it into the request body for this endpoint.   Modify the fields you want to change and submit the POST request when ready.
         * @summary Create Notification Template
         * @param {TemplateDtoBeta} templateDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNotificationTemplate(templateDtoBeta: TemplateDtoBeta, axiosOptions?: any): AxiosPromise<TemplateDtoBeta> {
            return localVarFp.createNotificationTemplate(templateDtoBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Create a new sender email address and initiate verification process.
         * @summary Create Verified From Address
         * @param {EmailStatusDtoBeta} emailStatusDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createVerifiedFromAddress(emailStatusDtoBeta: EmailStatusDtoBeta, axiosOptions?: any): AxiosPromise<EmailStatusDtoBeta> {
            return localVarFp.createVerifiedFromAddress(emailStatusDtoBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This lets you bulk delete templates that you previously created for your site. Since this is a beta feature, you can only delete a subset of your notifications, i.e. ones that show up in the list call.
         * @summary Bulk Delete Notification Templates
         * @param {Array<TemplateBulkDeleteDtoBeta>} templateBulkDeleteDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotificationTemplatesInBulk(templateBulkDeleteDtoBeta: Array<TemplateBulkDeleteDtoBeta>, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteNotificationTemplatesInBulk(templateBulkDeleteDtoBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Delete a verified sender email address
         * @summary Delete Verified From Address
         * @param {string} id 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteVerifiedFromAddress(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteVerifiedFromAddress(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve DKIM (DomainKeys Identified Mail) attributes for all your tenants\' AWS SES identities. Limits retrieval to 100 identities per call.
         * @summary Get DKIM Attributes
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDkimAttributes(axiosOptions?: any): AxiosPromise<Array<DkimAttributesBeta>> {
            return localVarFp.getDkimAttributes(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve MAIL FROM attributes for a given AWS SES identity.
         * @summary Get MAIL FROM Attributes
         * @param {string} id Returns the MX and TXT record to be put in your DNS, as well as the MAIL FROM domain status
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getMailFromAttributes(id: string, axiosOptions?: any): AxiosPromise<MailFromAttributesBeta> {
            return localVarFp.getMailFromAttributes(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Returns the notification preferences for tenant.  Note that if the key doesn\'t exist, then a 404 will be returned. Request will require the following legacy roles:  ORG_ADMIN and API
         * @summary Get Notification Preferences for tenant.
         * @param {string} key The notification key.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationPreference(key: string, axiosOptions?: any): AxiosPromise<PreferencesDtoBeta> {
            return localVarFp.getNotificationPreference(key, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a template that you have modified for your site by Id.
         * @summary Get Notification Template By Id
         * @param {string} id Id of the Notification Template
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationTemplate(id: string, axiosOptions?: any): AxiosPromise<Array<TemplateDtoBeta>> {
            return localVarFp.getNotificationTemplate(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * The notification service (Hermes) maintains metadata to construct the notification templates or supply any information during the event propagation.  The data-store where this information is retrieved is  called \"Global Context\" (a.k.a. notification template context). It defines a set of attributes  that will be available per tenant (organization).  Regarding authorization, the access token contains the tenant and will grant access to the one requested. Requires the following security scope:  idn:notification-templates:read
         * @summary Get Notification Template Context
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationsTemplateContext(axiosOptions?: any): AxiosPromise<Array<NotificationTemplateContextBeta>> {
            return localVarFp.getNotificationsTemplateContext(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of sender email addresses and their verification statuses
         * @summary List From Addresses
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **email**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields:  **email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listFromAddresses(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<EmailStatusDtoBeta>> {
            return localVarFp.listFromAddresses(limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This lists the default templates used for notifications, such as emails from IdentityNow. Since this is a beta feature, it doesn\'t include all the templates.
         * @summary List Notification Template Defaults
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **key**: *eq, in*  **medium**: *eq*  **locale**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNotificationTemplateDefaults(limit?: number, offset?: number, filters?: string, axiosOptions?: any): AxiosPromise<Array<TemplateDtoDefaultBeta>> {
            return localVarFp.listNotificationTemplateDefaults(limit, offset, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This lists the templates that you have modified for your site. Since this is a beta feature, it doesn\'t include all your modified templates.
         * @summary List Notification Templates
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **key**: *eq, in*  **medium**: *eq*  **locale**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNotificationTemplates(limit?: number, offset?: number, filters?: string, axiosOptions?: any): AxiosPromise<Array<TemplateDtoBeta>> {
            return localVarFp.listNotificationTemplates(limit, offset, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Change the MAIL FROM domain of an AWS SES email identity and provide the MX and TXT records to be placed in the caller\'s DNS
         * @summary Change MAIL FROM domain
         * @param {MailFromAttributesDtoBeta} mailFromAttributesDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putMailFromAttributes(mailFromAttributesDtoBeta: MailFromAttributesDtoBeta, axiosOptions?: any): AxiosPromise<MailFromAttributesBeta> {
            return localVarFp.putMailFromAttributes(mailFromAttributesDtoBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * In the notification world, a notification flows through these salient stages -   1. Interest matching,   2. Preferences   3. Template Rendering.   The default notification preferences make up a part of the second stage, along with user preferences (which is a future goal). The expectation is for  admins to be able to set default preferences for their org, like opting in to or out of certain notifications, and configuring future preferences as  we tack on more features. The key in the Dto is not necessary but if it is provided and doesn\'t match the key in the URI, then a 400 will be thrown.  Request will require the following legacy roles:  ORG_ADMIN and API
         * @summary Overwrite the preferences for the given notification key.
         * @param {string} key The notification key.
         * @param {PreferencesDtoBeta} preferencesDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putNotificationPreference(key: string, preferencesDtoBeta: PreferencesDtoBeta, axiosOptions?: any): AxiosPromise<PreferencesDtoBeta> {
            return localVarFp.putNotificationPreference(key, preferencesDtoBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Send a Test Notification
         * @summary Send Test Notification
         * @param {SendTestNotificationRequestDtoBeta} sendTestNotificationRequestDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendTestNotification(sendTestNotificationRequestDtoBeta: SendTestNotificationRequestDtoBeta, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.sendTestNotification(sendTestNotificationRequestDtoBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createDomainDkim operation in NotificationsBetaApi.
 * @export
 * @interface NotificationsBetaApiCreateDomainDkimRequest
 */
export interface NotificationsBetaApiCreateDomainDkimRequest {
    /**
     * 
     * @type {DomainAddressBeta}
     * @memberof NotificationsBetaApiCreateDomainDkim
     */
    readonly domainAddressBeta: DomainAddressBeta
}

/**
 * Request parameters for createNotificationTemplate operation in NotificationsBetaApi.
 * @export
 * @interface NotificationsBetaApiCreateNotificationTemplateRequest
 */
export interface NotificationsBetaApiCreateNotificationTemplateRequest {
    /**
     * 
     * @type {TemplateDtoBeta}
     * @memberof NotificationsBetaApiCreateNotificationTemplate
     */
    readonly templateDtoBeta: TemplateDtoBeta
}

/**
 * Request parameters for createVerifiedFromAddress operation in NotificationsBetaApi.
 * @export
 * @interface NotificationsBetaApiCreateVerifiedFromAddressRequest
 */
export interface NotificationsBetaApiCreateVerifiedFromAddressRequest {
    /**
     * 
     * @type {EmailStatusDtoBeta}
     * @memberof NotificationsBetaApiCreateVerifiedFromAddress
     */
    readonly emailStatusDtoBeta: EmailStatusDtoBeta
}

/**
 * Request parameters for deleteNotificationTemplatesInBulk operation in NotificationsBetaApi.
 * @export
 * @interface NotificationsBetaApiDeleteNotificationTemplatesInBulkRequest
 */
export interface NotificationsBetaApiDeleteNotificationTemplatesInBulkRequest {
    /**
     * 
     * @type {Array<TemplateBulkDeleteDtoBeta>}
     * @memberof NotificationsBetaApiDeleteNotificationTemplatesInBulk
     */
    readonly templateBulkDeleteDtoBeta: Array<TemplateBulkDeleteDtoBeta>
}

/**
 * Request parameters for deleteVerifiedFromAddress operation in NotificationsBetaApi.
 * @export
 * @interface NotificationsBetaApiDeleteVerifiedFromAddressRequest
 */
export interface NotificationsBetaApiDeleteVerifiedFromAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof NotificationsBetaApiDeleteVerifiedFromAddress
     */
    readonly id: string
}

/**
 * Request parameters for getMailFromAttributes operation in NotificationsBetaApi.
 * @export
 * @interface NotificationsBetaApiGetMailFromAttributesRequest
 */
export interface NotificationsBetaApiGetMailFromAttributesRequest {
    /**
     * Returns the MX and TXT record to be put in your DNS, as well as the MAIL FROM domain status
     * @type {string}
     * @memberof NotificationsBetaApiGetMailFromAttributes
     */
    readonly id: string
}

/**
 * Request parameters for getNotificationPreference operation in NotificationsBetaApi.
 * @export
 * @interface NotificationsBetaApiGetNotificationPreferenceRequest
 */
export interface NotificationsBetaApiGetNotificationPreferenceRequest {
    /**
     * The notification key.
     * @type {string}
     * @memberof NotificationsBetaApiGetNotificationPreference
     */
    readonly key: string
}

/**
 * Request parameters for getNotificationTemplate operation in NotificationsBetaApi.
 * @export
 * @interface NotificationsBetaApiGetNotificationTemplateRequest
 */
export interface NotificationsBetaApiGetNotificationTemplateRequest {
    /**
     * Id of the Notification Template
     * @type {string}
     * @memberof NotificationsBetaApiGetNotificationTemplate
     */
    readonly id: string
}

/**
 * Request parameters for listFromAddresses operation in NotificationsBetaApi.
 * @export
 * @interface NotificationsBetaApiListFromAddressesRequest
 */
export interface NotificationsBetaApiListFromAddressesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NotificationsBetaApiListFromAddresses
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NotificationsBetaApiListFromAddresses
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof NotificationsBetaApiListFromAddresses
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **email**: *eq*
     * @type {string}
     * @memberof NotificationsBetaApiListFromAddresses
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields:  **email**
     * @type {string}
     * @memberof NotificationsBetaApiListFromAddresses
     */
    readonly sorters?: string
}

/**
 * Request parameters for listNotificationTemplateDefaults operation in NotificationsBetaApi.
 * @export
 * @interface NotificationsBetaApiListNotificationTemplateDefaultsRequest
 */
export interface NotificationsBetaApiListNotificationTemplateDefaultsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NotificationsBetaApiListNotificationTemplateDefaults
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NotificationsBetaApiListNotificationTemplateDefaults
     */
    readonly offset?: number

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **key**: *eq, in*  **medium**: *eq*  **locale**: *eq*
     * @type {string}
     * @memberof NotificationsBetaApiListNotificationTemplateDefaults
     */
    readonly filters?: string
}

/**
 * Request parameters for listNotificationTemplates operation in NotificationsBetaApi.
 * @export
 * @interface NotificationsBetaApiListNotificationTemplatesRequest
 */
export interface NotificationsBetaApiListNotificationTemplatesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NotificationsBetaApiListNotificationTemplates
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NotificationsBetaApiListNotificationTemplates
     */
    readonly offset?: number

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **key**: *eq, in*  **medium**: *eq*  **locale**: *eq*
     * @type {string}
     * @memberof NotificationsBetaApiListNotificationTemplates
     */
    readonly filters?: string
}

/**
 * Request parameters for putMailFromAttributes operation in NotificationsBetaApi.
 * @export
 * @interface NotificationsBetaApiPutMailFromAttributesRequest
 */
export interface NotificationsBetaApiPutMailFromAttributesRequest {
    /**
     * 
     * @type {MailFromAttributesDtoBeta}
     * @memberof NotificationsBetaApiPutMailFromAttributes
     */
    readonly mailFromAttributesDtoBeta: MailFromAttributesDtoBeta
}

/**
 * Request parameters for putNotificationPreference operation in NotificationsBetaApi.
 * @export
 * @interface NotificationsBetaApiPutNotificationPreferenceRequest
 */
export interface NotificationsBetaApiPutNotificationPreferenceRequest {
    /**
     * The notification key.
     * @type {string}
     * @memberof NotificationsBetaApiPutNotificationPreference
     */
    readonly key: string

    /**
     * 
     * @type {PreferencesDtoBeta}
     * @memberof NotificationsBetaApiPutNotificationPreference
     */
    readonly preferencesDtoBeta: PreferencesDtoBeta
}

/**
 * Request parameters for sendTestNotification operation in NotificationsBetaApi.
 * @export
 * @interface NotificationsBetaApiSendTestNotificationRequest
 */
export interface NotificationsBetaApiSendTestNotificationRequest {
    /**
     * 
     * @type {SendTestNotificationRequestDtoBeta}
     * @memberof NotificationsBetaApiSendTestNotification
     */
    readonly sendTestNotificationRequestDtoBeta: SendTestNotificationRequestDtoBeta
}

/**
 * NotificationsBetaApi - object-oriented interface
 * @export
 * @class NotificationsBetaApi
 * @extends {BaseAPI}
 */
export class NotificationsBetaApi extends BaseAPI {
    /**
     * Create a domain to be verified via DKIM (DomainKeys Identified Mail)
     * @summary Verify domain address via DKIM
     * @param {NotificationsBetaApiCreateDomainDkimRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsBetaApi
     */
    public createDomainDkim(requestParameters: NotificationsBetaApiCreateDomainDkimRequest, axiosOptions?: AxiosRequestConfig) {
        return NotificationsBetaApiFp(this.configuration).createDomainDkim(requestParameters.domainAddressBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This creates a template for your site.   You can also use this endpoint to update a template.  First, copy the response body from the [get notification template endpoint](https://developer.sailpoint.com/idn/api/beta/get-notification-template) for a template you wish to update and paste it into the request body for this endpoint.   Modify the fields you want to change and submit the POST request when ready.
     * @summary Create Notification Template
     * @param {NotificationsBetaApiCreateNotificationTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsBetaApi
     */
    public createNotificationTemplate(requestParameters: NotificationsBetaApiCreateNotificationTemplateRequest, axiosOptions?: AxiosRequestConfig) {
        return NotificationsBetaApiFp(this.configuration).createNotificationTemplate(requestParameters.templateDtoBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new sender email address and initiate verification process.
     * @summary Create Verified From Address
     * @param {NotificationsBetaApiCreateVerifiedFromAddressRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsBetaApi
     */
    public createVerifiedFromAddress(requestParameters: NotificationsBetaApiCreateVerifiedFromAddressRequest, axiosOptions?: AxiosRequestConfig) {
        return NotificationsBetaApiFp(this.configuration).createVerifiedFromAddress(requestParameters.emailStatusDtoBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This lets you bulk delete templates that you previously created for your site. Since this is a beta feature, you can only delete a subset of your notifications, i.e. ones that show up in the list call.
     * @summary Bulk Delete Notification Templates
     * @param {NotificationsBetaApiDeleteNotificationTemplatesInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsBetaApi
     */
    public deleteNotificationTemplatesInBulk(requestParameters: NotificationsBetaApiDeleteNotificationTemplatesInBulkRequest, axiosOptions?: AxiosRequestConfig) {
        return NotificationsBetaApiFp(this.configuration).deleteNotificationTemplatesInBulk(requestParameters.templateBulkDeleteDtoBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a verified sender email address
     * @summary Delete Verified From Address
     * @param {NotificationsBetaApiDeleteVerifiedFromAddressRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsBetaApi
     */
    public deleteVerifiedFromAddress(requestParameters: NotificationsBetaApiDeleteVerifiedFromAddressRequest, axiosOptions?: AxiosRequestConfig) {
        return NotificationsBetaApiFp(this.configuration).deleteVerifiedFromAddress(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve DKIM (DomainKeys Identified Mail) attributes for all your tenants\' AWS SES identities. Limits retrieval to 100 identities per call.
     * @summary Get DKIM Attributes
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsBetaApi
     */
    public getDkimAttributes(axiosOptions?: AxiosRequestConfig) {
        return NotificationsBetaApiFp(this.configuration).getDkimAttributes(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve MAIL FROM attributes for a given AWS SES identity.
     * @summary Get MAIL FROM Attributes
     * @param {NotificationsBetaApiGetMailFromAttributesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsBetaApi
     */
    public getMailFromAttributes(requestParameters: NotificationsBetaApiGetMailFromAttributesRequest, axiosOptions?: AxiosRequestConfig) {
        return NotificationsBetaApiFp(this.configuration).getMailFromAttributes(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the notification preferences for tenant.  Note that if the key doesn\'t exist, then a 404 will be returned. Request will require the following legacy roles:  ORG_ADMIN and API
     * @summary Get Notification Preferences for tenant.
     * @param {NotificationsBetaApiGetNotificationPreferenceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsBetaApi
     */
    public getNotificationPreference(requestParameters: NotificationsBetaApiGetNotificationPreferenceRequest, axiosOptions?: AxiosRequestConfig) {
        return NotificationsBetaApiFp(this.configuration).getNotificationPreference(requestParameters.key, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a template that you have modified for your site by Id.
     * @summary Get Notification Template By Id
     * @param {NotificationsBetaApiGetNotificationTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsBetaApi
     */
    public getNotificationTemplate(requestParameters: NotificationsBetaApiGetNotificationTemplateRequest, axiosOptions?: AxiosRequestConfig) {
        return NotificationsBetaApiFp(this.configuration).getNotificationTemplate(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The notification service (Hermes) maintains metadata to construct the notification templates or supply any information during the event propagation.  The data-store where this information is retrieved is  called \"Global Context\" (a.k.a. notification template context). It defines a set of attributes  that will be available per tenant (organization).  Regarding authorization, the access token contains the tenant and will grant access to the one requested. Requires the following security scope:  idn:notification-templates:read
     * @summary Get Notification Template Context
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsBetaApi
     */
    public getNotificationsTemplateContext(axiosOptions?: AxiosRequestConfig) {
        return NotificationsBetaApiFp(this.configuration).getNotificationsTemplateContext(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of sender email addresses and their verification statuses
     * @summary List From Addresses
     * @param {NotificationsBetaApiListFromAddressesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsBetaApi
     */
    public listFromAddresses(requestParameters: NotificationsBetaApiListFromAddressesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return NotificationsBetaApiFp(this.configuration).listFromAddresses(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This lists the default templates used for notifications, such as emails from IdentityNow. Since this is a beta feature, it doesn\'t include all the templates.
     * @summary List Notification Template Defaults
     * @param {NotificationsBetaApiListNotificationTemplateDefaultsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsBetaApi
     */
    public listNotificationTemplateDefaults(requestParameters: NotificationsBetaApiListNotificationTemplateDefaultsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return NotificationsBetaApiFp(this.configuration).listNotificationTemplateDefaults(requestParameters.limit, requestParameters.offset, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This lists the templates that you have modified for your site. Since this is a beta feature, it doesn\'t include all your modified templates.
     * @summary List Notification Templates
     * @param {NotificationsBetaApiListNotificationTemplatesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsBetaApi
     */
    public listNotificationTemplates(requestParameters: NotificationsBetaApiListNotificationTemplatesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return NotificationsBetaApiFp(this.configuration).listNotificationTemplates(requestParameters.limit, requestParameters.offset, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change the MAIL FROM domain of an AWS SES email identity and provide the MX and TXT records to be placed in the caller\'s DNS
     * @summary Change MAIL FROM domain
     * @param {NotificationsBetaApiPutMailFromAttributesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsBetaApi
     */
    public putMailFromAttributes(requestParameters: NotificationsBetaApiPutMailFromAttributesRequest, axiosOptions?: AxiosRequestConfig) {
        return NotificationsBetaApiFp(this.configuration).putMailFromAttributes(requestParameters.mailFromAttributesDtoBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * In the notification world, a notification flows through these salient stages -   1. Interest matching,   2. Preferences   3. Template Rendering.   The default notification preferences make up a part of the second stage, along with user preferences (which is a future goal). The expectation is for  admins to be able to set default preferences for their org, like opting in to or out of certain notifications, and configuring future preferences as  we tack on more features. The key in the Dto is not necessary but if it is provided and doesn\'t match the key in the URI, then a 400 will be thrown.  Request will require the following legacy roles:  ORG_ADMIN and API
     * @summary Overwrite the preferences for the given notification key.
     * @param {NotificationsBetaApiPutNotificationPreferenceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsBetaApi
     */
    public putNotificationPreference(requestParameters: NotificationsBetaApiPutNotificationPreferenceRequest, axiosOptions?: AxiosRequestConfig) {
        return NotificationsBetaApiFp(this.configuration).putNotificationPreference(requestParameters.key, requestParameters.preferencesDtoBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a Test Notification
     * @summary Send Test Notification
     * @param {NotificationsBetaApiSendTestNotificationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsBetaApi
     */
    public sendTestNotification(requestParameters: NotificationsBetaApiSendTestNotificationRequest, axiosOptions?: AxiosRequestConfig) {
        return NotificationsBetaApiFp(this.configuration).sendTestNotification(requestParameters.sendTestNotificationRequestDtoBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OAuthClientsBetaApi - axios parameter creator
 * @export
 */
export const OAuthClientsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This creates an OAuth client.
         * @summary Create OAuth Client
         * @param {CreateOAuthClientRequestBeta} createOAuthClientRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createOauthClient: async (createOAuthClientRequestBeta: CreateOAuthClientRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOAuthClientRequestBeta' is not null or undefined
            assertParamExists('createOauthClient', 'createOAuthClientRequestBeta', createOAuthClientRequestBeta)
            const localVarPath = `/oauth-clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOAuthClientRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This deletes an OAuth client.
         * @summary Delete OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteOauthClient: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOauthClient', 'id', id)
            const localVarPath = `/oauth-clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets details of an OAuth client.
         * @summary Get OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getOauthClient: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOauthClient', 'id', id)
            const localVarPath = `/oauth-clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a list of OAuth clients.
         * @summary List OAuth Clients
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listOauthClients: async (filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth-clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This performs a targeted update to the field(s) of an OAuth client. Request will require a security scope of  - sp:oauth-client:manage
         * @summary Patch OAuth Client
         * @param {string} id The OAuth client id
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * tenant * businessName * homepageUrl * name * description * accessTokenValiditySeconds * refreshTokenValiditySeconds * redirectUris * grantTypes * accessType * enabled * strongAuthSupported * claimsSupported 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchOauthClient: async (id: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchOauthClient', 'id', id)
            // verify required parameter 'jsonPatchOperationBeta' is not null or undefined
            assertParamExists('patchOauthClient', 'jsonPatchOperationBeta', jsonPatchOperationBeta)
            const localVarPath = `/oauth-clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperationBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * OAuthClientsBetaApi - functional programming interface
 * @export
 */
export const OAuthClientsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OAuthClientsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This creates an OAuth client.
         * @summary Create OAuth Client
         * @param {CreateOAuthClientRequestBeta} createOAuthClientRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createOauthClient(createOAuthClientRequestBeta: CreateOAuthClientRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOAuthClientResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOauthClient(createOAuthClientRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This deletes an OAuth client.
         * @summary Delete OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOauthClient(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOauthClient(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets details of an OAuth client.
         * @summary Get OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getOauthClient(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOAuthClientResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOauthClient(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a list of OAuth clients.
         * @summary List OAuth Clients
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listOauthClients(filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOAuthClientResponseBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOauthClients(filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This performs a targeted update to the field(s) of an OAuth client. Request will require a security scope of  - sp:oauth-client:manage
         * @summary Patch OAuth Client
         * @param {string} id The OAuth client id
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * tenant * businessName * homepageUrl * name * description * accessTokenValiditySeconds * refreshTokenValiditySeconds * redirectUris * grantTypes * accessType * enabled * strongAuthSupported * claimsSupported 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchOauthClient(id: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOAuthClientResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchOauthClient(id, jsonPatchOperationBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OAuthClientsBetaApi - factory interface
 * @export
 */
export const OAuthClientsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OAuthClientsBetaApiFp(configuration)
    return {
        /**
         * This creates an OAuth client.
         * @summary Create OAuth Client
         * @param {CreateOAuthClientRequestBeta} createOAuthClientRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createOauthClient(createOAuthClientRequestBeta: CreateOAuthClientRequestBeta, axiosOptions?: any): AxiosPromise<CreateOAuthClientResponseBeta> {
            return localVarFp.createOauthClient(createOAuthClientRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This deletes an OAuth client.
         * @summary Delete OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteOauthClient(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteOauthClient(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets details of an OAuth client.
         * @summary Get OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getOauthClient(id: string, axiosOptions?: any): AxiosPromise<GetOAuthClientResponseBeta> {
            return localVarFp.getOauthClient(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a list of OAuth clients.
         * @summary List OAuth Clients
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listOauthClients(filters?: string, axiosOptions?: any): AxiosPromise<Array<GetOAuthClientResponseBeta>> {
            return localVarFp.listOauthClients(filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This performs a targeted update to the field(s) of an OAuth client. Request will require a security scope of  - sp:oauth-client:manage
         * @summary Patch OAuth Client
         * @param {string} id The OAuth client id
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * tenant * businessName * homepageUrl * name * description * accessTokenValiditySeconds * refreshTokenValiditySeconds * redirectUris * grantTypes * accessType * enabled * strongAuthSupported * claimsSupported 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchOauthClient(id: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: any): AxiosPromise<GetOAuthClientResponseBeta> {
            return localVarFp.patchOauthClient(id, jsonPatchOperationBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createOauthClient operation in OAuthClientsBetaApi.
 * @export
 * @interface OAuthClientsBetaApiCreateOauthClientRequest
 */
export interface OAuthClientsBetaApiCreateOauthClientRequest {
    /**
     * 
     * @type {CreateOAuthClientRequestBeta}
     * @memberof OAuthClientsBetaApiCreateOauthClient
     */
    readonly createOAuthClientRequestBeta: CreateOAuthClientRequestBeta
}

/**
 * Request parameters for deleteOauthClient operation in OAuthClientsBetaApi.
 * @export
 * @interface OAuthClientsBetaApiDeleteOauthClientRequest
 */
export interface OAuthClientsBetaApiDeleteOauthClientRequest {
    /**
     * The OAuth client id
     * @type {string}
     * @memberof OAuthClientsBetaApiDeleteOauthClient
     */
    readonly id: string
}

/**
 * Request parameters for getOauthClient operation in OAuthClientsBetaApi.
 * @export
 * @interface OAuthClientsBetaApiGetOauthClientRequest
 */
export interface OAuthClientsBetaApiGetOauthClientRequest {
    /**
     * The OAuth client id
     * @type {string}
     * @memberof OAuthClientsBetaApiGetOauthClient
     */
    readonly id: string
}

/**
 * Request parameters for listOauthClients operation in OAuthClientsBetaApi.
 * @export
 * @interface OAuthClientsBetaApiListOauthClientsRequest
 */
export interface OAuthClientsBetaApiListOauthClientsRequest {
    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
     * @type {string}
     * @memberof OAuthClientsBetaApiListOauthClients
     */
    readonly filters?: string
}

/**
 * Request parameters for patchOauthClient operation in OAuthClientsBetaApi.
 * @export
 * @interface OAuthClientsBetaApiPatchOauthClientRequest
 */
export interface OAuthClientsBetaApiPatchOauthClientRequest {
    /**
     * The OAuth client id
     * @type {string}
     * @memberof OAuthClientsBetaApiPatchOauthClient
     */
    readonly id: string

    /**
     * A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * tenant * businessName * homepageUrl * name * description * accessTokenValiditySeconds * refreshTokenValiditySeconds * redirectUris * grantTypes * accessType * enabled * strongAuthSupported * claimsSupported 
     * @type {Array<JsonPatchOperationBeta>}
     * @memberof OAuthClientsBetaApiPatchOauthClient
     */
    readonly jsonPatchOperationBeta: Array<JsonPatchOperationBeta>
}

/**
 * OAuthClientsBetaApi - object-oriented interface
 * @export
 * @class OAuthClientsBetaApi
 * @extends {BaseAPI}
 */
export class OAuthClientsBetaApi extends BaseAPI {
    /**
     * This creates an OAuth client.
     * @summary Create OAuth Client
     * @param {OAuthClientsBetaApiCreateOauthClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsBetaApi
     */
    public createOauthClient(requestParameters: OAuthClientsBetaApiCreateOauthClientRequest, axiosOptions?: AxiosRequestConfig) {
        return OAuthClientsBetaApiFp(this.configuration).createOauthClient(requestParameters.createOAuthClientRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes an OAuth client.
     * @summary Delete OAuth Client
     * @param {OAuthClientsBetaApiDeleteOauthClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsBetaApi
     */
    public deleteOauthClient(requestParameters: OAuthClientsBetaApiDeleteOauthClientRequest, axiosOptions?: AxiosRequestConfig) {
        return OAuthClientsBetaApiFp(this.configuration).deleteOauthClient(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets details of an OAuth client.
     * @summary Get OAuth Client
     * @param {OAuthClientsBetaApiGetOauthClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsBetaApi
     */
    public getOauthClient(requestParameters: OAuthClientsBetaApiGetOauthClientRequest, axiosOptions?: AxiosRequestConfig) {
        return OAuthClientsBetaApiFp(this.configuration).getOauthClient(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a list of OAuth clients.
     * @summary List OAuth Clients
     * @param {OAuthClientsBetaApiListOauthClientsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsBetaApi
     */
    public listOauthClients(requestParameters: OAuthClientsBetaApiListOauthClientsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return OAuthClientsBetaApiFp(this.configuration).listOauthClients(requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This performs a targeted update to the field(s) of an OAuth client. Request will require a security scope of  - sp:oauth-client:manage
     * @summary Patch OAuth Client
     * @param {OAuthClientsBetaApiPatchOauthClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsBetaApi
     */
    public patchOauthClient(requestParameters: OAuthClientsBetaApiPatchOauthClientRequest, axiosOptions?: AxiosRequestConfig) {
        return OAuthClientsBetaApiFp(this.configuration).patchOauthClient(requestParameters.id, requestParameters.jsonPatchOperationBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrgConfigBetaApi - axios parameter creator
 * @export
 */
export const OrgConfigBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get org configuration with only external (org admin) accessible properties for the current org.
         * @summary Get Org configuration settings
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getOrgConfig: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/org-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get a list of valid time zones that can be set in org configurations.
         * @summary Get list of time zones
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getValidTimeZones: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/org-config/valid-time-zones`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Patch configuration of the current org using http://jsonpatch.com/ syntax.  Commonly used for changing the time zone of an org.
         * @summary Patch an Org configuration property
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta A list of schema attribute update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchOrgConfig: async (jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jsonPatchOperationBeta' is not null or undefined
            assertParamExists('patchOrgConfig', 'jsonPatchOperationBeta', jsonPatchOperationBeta)
            const localVarPath = `/org-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperationBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrgConfigBetaApi - functional programming interface
 * @export
 */
export const OrgConfigBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrgConfigBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Get org configuration with only external (org admin) accessible properties for the current org.
         * @summary Get Org configuration settings
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getOrgConfig(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrgConfigBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrgConfig(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of valid time zones that can be set in org configurations.
         * @summary Get list of time zones
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getValidTimeZones(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getValidTimeZones(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Patch configuration of the current org using http://jsonpatch.com/ syntax.  Commonly used for changing the time zone of an org.
         * @summary Patch an Org configuration property
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta A list of schema attribute update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchOrgConfig(jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrgConfigBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchOrgConfig(jsonPatchOperationBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrgConfigBetaApi - factory interface
 * @export
 */
export const OrgConfigBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrgConfigBetaApiFp(configuration)
    return {
        /**
         * Get org configuration with only external (org admin) accessible properties for the current org.
         * @summary Get Org configuration settings
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getOrgConfig(axiosOptions?: any): AxiosPromise<OrgConfigBeta> {
            return localVarFp.getOrgConfig(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of valid time zones that can be set in org configurations.
         * @summary Get list of time zones
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getValidTimeZones(axiosOptions?: any): AxiosPromise<Array<string>> {
            return localVarFp.getValidTimeZones(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Patch configuration of the current org using http://jsonpatch.com/ syntax.  Commonly used for changing the time zone of an org.
         * @summary Patch an Org configuration property
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta A list of schema attribute update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchOrgConfig(jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: any): AxiosPromise<OrgConfigBeta> {
            return localVarFp.patchOrgConfig(jsonPatchOperationBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for patchOrgConfig operation in OrgConfigBetaApi.
 * @export
 * @interface OrgConfigBetaApiPatchOrgConfigRequest
 */
export interface OrgConfigBetaApiPatchOrgConfigRequest {
    /**
     * A list of schema attribute update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
     * @type {Array<JsonPatchOperationBeta>}
     * @memberof OrgConfigBetaApiPatchOrgConfig
     */
    readonly jsonPatchOperationBeta: Array<JsonPatchOperationBeta>
}

/**
 * OrgConfigBetaApi - object-oriented interface
 * @export
 * @class OrgConfigBetaApi
 * @extends {BaseAPI}
 */
export class OrgConfigBetaApi extends BaseAPI {
    /**
     * Get org configuration with only external (org admin) accessible properties for the current org.
     * @summary Get Org configuration settings
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgConfigBetaApi
     */
    public getOrgConfig(axiosOptions?: AxiosRequestConfig) {
        return OrgConfigBetaApiFp(this.configuration).getOrgConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of valid time zones that can be set in org configurations.
     * @summary Get list of time zones
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgConfigBetaApi
     */
    public getValidTimeZones(axiosOptions?: AxiosRequestConfig) {
        return OrgConfigBetaApiFp(this.configuration).getValidTimeZones(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Patch configuration of the current org using http://jsonpatch.com/ syntax.  Commonly used for changing the time zone of an org.
     * @summary Patch an Org configuration property
     * @param {OrgConfigBetaApiPatchOrgConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgConfigBetaApi
     */
    public patchOrgConfig(requestParameters: OrgConfigBetaApiPatchOrgConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return OrgConfigBetaApiFp(this.configuration).patchOrgConfig(requestParameters.jsonPatchOperationBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PasswordConfigurationBetaApi - axios parameter creator
 * @export
 */
export const PasswordConfigurationBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates the password org config. Unspecified fields will use default value. To be able to use the custom password instructions, you must set the `customInstructionsEnabled` field to \"true\". Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Create Password Org Config
         * @param {PasswordOrgConfigBeta} passwordOrgConfigBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPasswordOrgConfig: async (passwordOrgConfigBeta: PasswordOrgConfigBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordOrgConfigBeta' is not null or undefined
            assertParamExists('createPasswordOrgConfig', 'passwordOrgConfigBeta', passwordOrgConfigBeta)
            const localVarPath = `/password-org-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordOrgConfigBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the password org config . Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:read\'
         * @summary Get Password Org Config
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordOrgConfig: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/password-org-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates the password org config for specified fields. Other fields will keep original value. You must set the `customInstructionsEnabled` field to \"true\" to be able to use custom password instructions.  Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Update Password Org Config
         * @param {PasswordOrgConfigBeta} passwordOrgConfigBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putPasswordOrgConfig: async (passwordOrgConfigBeta: PasswordOrgConfigBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordOrgConfigBeta' is not null or undefined
            assertParamExists('putPasswordOrgConfig', 'passwordOrgConfigBeta', passwordOrgConfigBeta)
            const localVarPath = `/password-org-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordOrgConfigBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasswordConfigurationBetaApi - functional programming interface
 * @export
 */
export const PasswordConfigurationBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasswordConfigurationBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates the password org config. Unspecified fields will use default value. To be able to use the custom password instructions, you must set the `customInstructionsEnabled` field to \"true\". Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Create Password Org Config
         * @param {PasswordOrgConfigBeta} passwordOrgConfigBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createPasswordOrgConfig(passwordOrgConfigBeta: PasswordOrgConfigBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordOrgConfigBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPasswordOrgConfig(passwordOrgConfigBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the password org config . Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:read\'
         * @summary Get Password Org Config
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPasswordOrgConfig(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordOrgConfigBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordOrgConfig(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API updates the password org config for specified fields. Other fields will keep original value. You must set the `customInstructionsEnabled` field to \"true\" to be able to use custom password instructions.  Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Update Password Org Config
         * @param {PasswordOrgConfigBeta} passwordOrgConfigBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putPasswordOrgConfig(passwordOrgConfigBeta: PasswordOrgConfigBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordOrgConfigBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putPasswordOrgConfig(passwordOrgConfigBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PasswordConfigurationBetaApi - factory interface
 * @export
 */
export const PasswordConfigurationBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasswordConfigurationBetaApiFp(configuration)
    return {
        /**
         * This API creates the password org config. Unspecified fields will use default value. To be able to use the custom password instructions, you must set the `customInstructionsEnabled` field to \"true\". Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Create Password Org Config
         * @param {PasswordOrgConfigBeta} passwordOrgConfigBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPasswordOrgConfig(passwordOrgConfigBeta: PasswordOrgConfigBeta, axiosOptions?: any): AxiosPromise<PasswordOrgConfigBeta> {
            return localVarFp.createPasswordOrgConfig(passwordOrgConfigBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the password org config . Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:read\'
         * @summary Get Password Org Config
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordOrgConfig(axiosOptions?: any): AxiosPromise<PasswordOrgConfigBeta> {
            return localVarFp.getPasswordOrgConfig(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates the password org config for specified fields. Other fields will keep original value. You must set the `customInstructionsEnabled` field to \"true\" to be able to use custom password instructions.  Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Update Password Org Config
         * @param {PasswordOrgConfigBeta} passwordOrgConfigBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putPasswordOrgConfig(passwordOrgConfigBeta: PasswordOrgConfigBeta, axiosOptions?: any): AxiosPromise<PasswordOrgConfigBeta> {
            return localVarFp.putPasswordOrgConfig(passwordOrgConfigBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPasswordOrgConfig operation in PasswordConfigurationBetaApi.
 * @export
 * @interface PasswordConfigurationBetaApiCreatePasswordOrgConfigRequest
 */
export interface PasswordConfigurationBetaApiCreatePasswordOrgConfigRequest {
    /**
     * 
     * @type {PasswordOrgConfigBeta}
     * @memberof PasswordConfigurationBetaApiCreatePasswordOrgConfig
     */
    readonly passwordOrgConfigBeta: PasswordOrgConfigBeta
}

/**
 * Request parameters for putPasswordOrgConfig operation in PasswordConfigurationBetaApi.
 * @export
 * @interface PasswordConfigurationBetaApiPutPasswordOrgConfigRequest
 */
export interface PasswordConfigurationBetaApiPutPasswordOrgConfigRequest {
    /**
     * 
     * @type {PasswordOrgConfigBeta}
     * @memberof PasswordConfigurationBetaApiPutPasswordOrgConfig
     */
    readonly passwordOrgConfigBeta: PasswordOrgConfigBeta
}

/**
 * PasswordConfigurationBetaApi - object-oriented interface
 * @export
 * @class PasswordConfigurationBetaApi
 * @extends {BaseAPI}
 */
export class PasswordConfigurationBetaApi extends BaseAPI {
    /**
     * This API creates the password org config. Unspecified fields will use default value. To be able to use the custom password instructions, you must set the `customInstructionsEnabled` field to \"true\". Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
     * @summary Create Password Org Config
     * @param {PasswordConfigurationBetaApiCreatePasswordOrgConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordConfigurationBetaApi
     */
    public createPasswordOrgConfig(requestParameters: PasswordConfigurationBetaApiCreatePasswordOrgConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordConfigurationBetaApiFp(this.configuration).createPasswordOrgConfig(requestParameters.passwordOrgConfigBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the password org config . Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:read\'
     * @summary Get Password Org Config
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordConfigurationBetaApi
     */
    public getPasswordOrgConfig(axiosOptions?: AxiosRequestConfig) {
        return PasswordConfigurationBetaApiFp(this.configuration).getPasswordOrgConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates the password org config for specified fields. Other fields will keep original value. You must set the `customInstructionsEnabled` field to \"true\" to be able to use custom password instructions.  Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
     * @summary Update Password Org Config
     * @param {PasswordConfigurationBetaApiPutPasswordOrgConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordConfigurationBetaApi
     */
    public putPasswordOrgConfig(requestParameters: PasswordConfigurationBetaApiPutPasswordOrgConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordConfigurationBetaApiFp(this.configuration).putPasswordOrgConfig(requestParameters.passwordOrgConfigBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PasswordDictionaryBetaApi - axios parameter creator
 * @export
 */
export const PasswordDictionaryBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This gets password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Dictionary
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordDictionary: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/password-dictionary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This updates password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Password Dictionary
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePasswordDictionary: async (file?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/password-dictionary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasswordDictionaryBetaApi - functional programming interface
 * @export
 */
export const PasswordDictionaryBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasswordDictionaryBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This gets password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Dictionary
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPasswordDictionary(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordDictionary(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This updates password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Password Dictionary
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updatePasswordDictionary(file?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePasswordDictionary(file, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PasswordDictionaryBetaApi - factory interface
 * @export
 */
export const PasswordDictionaryBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasswordDictionaryBetaApiFp(configuration)
    return {
        /**
         * This gets password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Dictionary
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordDictionary(axiosOptions?: any): AxiosPromise<string> {
            return localVarFp.getPasswordDictionary(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This updates password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Password Dictionary
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePasswordDictionary(file?: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.updatePasswordDictionary(file, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for updatePasswordDictionary operation in PasswordDictionaryBetaApi.
 * @export
 * @interface PasswordDictionaryBetaApiUpdatePasswordDictionaryRequest
 */
export interface PasswordDictionaryBetaApiUpdatePasswordDictionaryRequest {
    /**
     * 
     * @type {any}
     * @memberof PasswordDictionaryBetaApiUpdatePasswordDictionary
     */
    readonly file?: any
}

/**
 * PasswordDictionaryBetaApi - object-oriented interface
 * @export
 * @class PasswordDictionaryBetaApi
 * @extends {BaseAPI}
 */
export class PasswordDictionaryBetaApi extends BaseAPI {
    /**
     * This gets password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API.
     * @summary Get Password Dictionary
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordDictionaryBetaApi
     */
    public getPasswordDictionary(axiosOptions?: AxiosRequestConfig) {
        return PasswordDictionaryBetaApiFp(this.configuration).getPasswordDictionary(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This updates password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API.
     * @summary Update Password Dictionary
     * @param {PasswordDictionaryBetaApiUpdatePasswordDictionaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordDictionaryBetaApi
     */
    public updatePasswordDictionary(requestParameters: PasswordDictionaryBetaApiUpdatePasswordDictionaryRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return PasswordDictionaryBetaApiFp(this.configuration).updatePasswordDictionary(requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PasswordManagementBetaApi - axios parameter creator
 * @export
 */
export const PasswordManagementBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API is used to generate a digit token for password management. Requires authorization scope of \"idn:password-digit-token:create\".
         * @summary Generate a digit token
         * @param {PasswordDigitTokenResetBeta} passwordDigitTokenResetBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        generateDigitToken: async (passwordDigitTokenResetBeta: PasswordDigitTokenResetBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordDigitTokenResetBeta' is not null or undefined
            assertParamExists('generateDigitToken', 'passwordDigitTokenResetBeta', passwordDigitTokenResetBeta)
            const localVarPath = `/generate-password-reset-token/digit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordDigitTokenResetBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the status of a password change request. A token with identity owner or trusted API client application authority is required to call this API.
         * @summary Get Password Change Request Status
         * @param {string} id 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityPasswordChangeStatus: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentityPasswordChangeStatus', 'id', id)
            const localVarPath = `/password-change-status/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API is used to query password related information.   A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow)  is required to call this API.  \"API authority\" refers to a token that only has the \"client_credentials\"  grant type, and therefore no user context. A [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens)  or a token generated with the [authorization_code](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow)  grant type will **NOT** work on this endpoint, and a `403 Forbidden` response  will be returned. 
         * @summary Query Password Info
         * @param {PasswordInfoQueryDTOBeta} passwordInfoQueryDTOBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        queryPasswordInfo: async (passwordInfoQueryDTOBeta: PasswordInfoQueryDTOBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordInfoQueryDTOBeta' is not null or undefined
            assertParamExists('queryPasswordInfo', 'passwordInfoQueryDTOBeta', passwordInfoQueryDTOBeta)
            const localVarPath = `/query-password-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordInfoQueryDTOBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API is used to set a password for an identity.   An identity can change their own password (as well as any of their accounts\' passwords) if they use a token generated by their IDN user, such as a [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens) or [\"authorization_code\" derived OAuth token](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow).  A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow) can be used to change **any** identity\'s password or the password of any of the identity\'s accounts.  \"API authority\" refers to a token that only has the \"client_credentials\" grant type.  You can use this endpoint to generate an `encryptedPassword` (RSA encrypted using publicKey).  To do so, follow these steps:  1. Use [Query Password Info](https://developer.sailpoint.com/idn/api/v3/query-password-info) to get the following information: `identityId`, `sourceId`, `publicKeyId`, `publicKey`, `accounts`, and `policies`.   2. Choose an account from the previous response that you will provide as an `accountId` in your request to set an encrypted password.   3. Use [Set Identity\'s Password](https://developer.sailpoint.com/idn/api/v3/set-password) and provide the information you got from your earlier query. Then add this code to your request to get the encrypted password:  ```java import javax.crypto.Cipher; import java.security.KeyFactory; import java.security.PublicKey; import java.security.spec.X509EncodedKeySpec; import java util.Base64;  String encrypt(String publicKey, String toEncrypt) throws Exception {   byte[] publicKeyBytes = Base64.getDecoder().decode(publicKey);   byte[] encryptedBytes = encryptRsa(publicKeyBytes, toEncrypt.getBytes(\"UTF-8\"));   return Base64.getEncoder().encodeToString(encryptedBytes); }  private byte[] encryptRsa(byte[] publicKeyBytes, byte[] toEncryptBytes) throws Exception {   PublicKey key = KeyFactory.getInstance(\"RSA\").generatePublic(new X509EncodedKeySpec(publicKeyBytes));   String transformation = \"RSA/ECB/PKCS1Padding\";   Cipher cipher = Cipher.getInstance(transformation);   cipher.init(1, key);   return cipher.doFinal(toEncryptBytes); } ```      In this example, `toEncrypt` refers to the plain text password you are setting and then encrypting, and the `publicKey` refers to the publicKey you got from the first request you sent.   You can then use [Get Password Change Request Status](https://developer.sailpoint.com/idn/api/v3/get-password-change-status) to check the password change request status. To do so, you must provide the `requestId` from your earlier request to set the password.  
         * @summary Set Identity\'s Password
         * @param {PasswordChangeRequestBeta} passwordChangeRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setIdentityPassword: async (passwordChangeRequestBeta: PasswordChangeRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordChangeRequestBeta' is not null or undefined
            assertParamExists('setIdentityPassword', 'passwordChangeRequestBeta', passwordChangeRequestBeta)
            const localVarPath = `/set-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordChangeRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasswordManagementBetaApi - functional programming interface
 * @export
 */
export const PasswordManagementBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasswordManagementBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This API is used to generate a digit token for password management. Requires authorization scope of \"idn:password-digit-token:create\".
         * @summary Generate a digit token
         * @param {PasswordDigitTokenResetBeta} passwordDigitTokenResetBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async generateDigitToken(passwordDigitTokenResetBeta: PasswordDigitTokenResetBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordDigitTokenBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateDigitToken(passwordDigitTokenResetBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the status of a password change request. A token with identity owner or trusted API client application authority is required to call this API.
         * @summary Get Password Change Request Status
         * @param {string} id 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityPasswordChangeStatus(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordStatusBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityPasswordChangeStatus(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API is used to query password related information.   A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow)  is required to call this API.  \"API authority\" refers to a token that only has the \"client_credentials\"  grant type, and therefore no user context. A [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens)  or a token generated with the [authorization_code](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow)  grant type will **NOT** work on this endpoint, and a `403 Forbidden` response  will be returned. 
         * @summary Query Password Info
         * @param {PasswordInfoQueryDTOBeta} passwordInfoQueryDTOBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async queryPasswordInfo(passwordInfoQueryDTOBeta: PasswordInfoQueryDTOBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordInfoBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryPasswordInfo(passwordInfoQueryDTOBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API is used to set a password for an identity.   An identity can change their own password (as well as any of their accounts\' passwords) if they use a token generated by their IDN user, such as a [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens) or [\"authorization_code\" derived OAuth token](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow).  A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow) can be used to change **any** identity\'s password or the password of any of the identity\'s accounts.  \"API authority\" refers to a token that only has the \"client_credentials\" grant type.  You can use this endpoint to generate an `encryptedPassword` (RSA encrypted using publicKey).  To do so, follow these steps:  1. Use [Query Password Info](https://developer.sailpoint.com/idn/api/v3/query-password-info) to get the following information: `identityId`, `sourceId`, `publicKeyId`, `publicKey`, `accounts`, and `policies`.   2. Choose an account from the previous response that you will provide as an `accountId` in your request to set an encrypted password.   3. Use [Set Identity\'s Password](https://developer.sailpoint.com/idn/api/v3/set-password) and provide the information you got from your earlier query. Then add this code to your request to get the encrypted password:  ```java import javax.crypto.Cipher; import java.security.KeyFactory; import java.security.PublicKey; import java.security.spec.X509EncodedKeySpec; import java util.Base64;  String encrypt(String publicKey, String toEncrypt) throws Exception {   byte[] publicKeyBytes = Base64.getDecoder().decode(publicKey);   byte[] encryptedBytes = encryptRsa(publicKeyBytes, toEncrypt.getBytes(\"UTF-8\"));   return Base64.getEncoder().encodeToString(encryptedBytes); }  private byte[] encryptRsa(byte[] publicKeyBytes, byte[] toEncryptBytes) throws Exception {   PublicKey key = KeyFactory.getInstance(\"RSA\").generatePublic(new X509EncodedKeySpec(publicKeyBytes));   String transformation = \"RSA/ECB/PKCS1Padding\";   Cipher cipher = Cipher.getInstance(transformation);   cipher.init(1, key);   return cipher.doFinal(toEncryptBytes); } ```      In this example, `toEncrypt` refers to the plain text password you are setting and then encrypting, and the `publicKey` refers to the publicKey you got from the first request you sent.   You can then use [Get Password Change Request Status](https://developer.sailpoint.com/idn/api/v3/get-password-change-status) to check the password change request status. To do so, you must provide the `requestId` from your earlier request to set the password.  
         * @summary Set Identity\'s Password
         * @param {PasswordChangeRequestBeta} passwordChangeRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setIdentityPassword(passwordChangeRequestBeta: PasswordChangeRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordChangeResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setIdentityPassword(passwordChangeRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PasswordManagementBetaApi - factory interface
 * @export
 */
export const PasswordManagementBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasswordManagementBetaApiFp(configuration)
    return {
        /**
         * This API is used to generate a digit token for password management. Requires authorization scope of \"idn:password-digit-token:create\".
         * @summary Generate a digit token
         * @param {PasswordDigitTokenResetBeta} passwordDigitTokenResetBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        generateDigitToken(passwordDigitTokenResetBeta: PasswordDigitTokenResetBeta, axiosOptions?: any): AxiosPromise<PasswordDigitTokenBeta> {
            return localVarFp.generateDigitToken(passwordDigitTokenResetBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the status of a password change request. A token with identity owner or trusted API client application authority is required to call this API.
         * @summary Get Password Change Request Status
         * @param {string} id 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityPasswordChangeStatus(id: string, axiosOptions?: any): AxiosPromise<PasswordStatusBeta> {
            return localVarFp.getIdentityPasswordChangeStatus(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API is used to query password related information.   A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow)  is required to call this API.  \"API authority\" refers to a token that only has the \"client_credentials\"  grant type, and therefore no user context. A [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens)  or a token generated with the [authorization_code](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow)  grant type will **NOT** work on this endpoint, and a `403 Forbidden` response  will be returned. 
         * @summary Query Password Info
         * @param {PasswordInfoQueryDTOBeta} passwordInfoQueryDTOBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        queryPasswordInfo(passwordInfoQueryDTOBeta: PasswordInfoQueryDTOBeta, axiosOptions?: any): AxiosPromise<PasswordInfoBeta> {
            return localVarFp.queryPasswordInfo(passwordInfoQueryDTOBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API is used to set a password for an identity.   An identity can change their own password (as well as any of their accounts\' passwords) if they use a token generated by their IDN user, such as a [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens) or [\"authorization_code\" derived OAuth token](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow).  A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow) can be used to change **any** identity\'s password or the password of any of the identity\'s accounts.  \"API authority\" refers to a token that only has the \"client_credentials\" grant type.  You can use this endpoint to generate an `encryptedPassword` (RSA encrypted using publicKey).  To do so, follow these steps:  1. Use [Query Password Info](https://developer.sailpoint.com/idn/api/v3/query-password-info) to get the following information: `identityId`, `sourceId`, `publicKeyId`, `publicKey`, `accounts`, and `policies`.   2. Choose an account from the previous response that you will provide as an `accountId` in your request to set an encrypted password.   3. Use [Set Identity\'s Password](https://developer.sailpoint.com/idn/api/v3/set-password) and provide the information you got from your earlier query. Then add this code to your request to get the encrypted password:  ```java import javax.crypto.Cipher; import java.security.KeyFactory; import java.security.PublicKey; import java.security.spec.X509EncodedKeySpec; import java util.Base64;  String encrypt(String publicKey, String toEncrypt) throws Exception {   byte[] publicKeyBytes = Base64.getDecoder().decode(publicKey);   byte[] encryptedBytes = encryptRsa(publicKeyBytes, toEncrypt.getBytes(\"UTF-8\"));   return Base64.getEncoder().encodeToString(encryptedBytes); }  private byte[] encryptRsa(byte[] publicKeyBytes, byte[] toEncryptBytes) throws Exception {   PublicKey key = KeyFactory.getInstance(\"RSA\").generatePublic(new X509EncodedKeySpec(publicKeyBytes));   String transformation = \"RSA/ECB/PKCS1Padding\";   Cipher cipher = Cipher.getInstance(transformation);   cipher.init(1, key);   return cipher.doFinal(toEncryptBytes); } ```      In this example, `toEncrypt` refers to the plain text password you are setting and then encrypting, and the `publicKey` refers to the publicKey you got from the first request you sent.   You can then use [Get Password Change Request Status](https://developer.sailpoint.com/idn/api/v3/get-password-change-status) to check the password change request status. To do so, you must provide the `requestId` from your earlier request to set the password.  
         * @summary Set Identity\'s Password
         * @param {PasswordChangeRequestBeta} passwordChangeRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setIdentityPassword(passwordChangeRequestBeta: PasswordChangeRequestBeta, axiosOptions?: any): AxiosPromise<PasswordChangeResponseBeta> {
            return localVarFp.setIdentityPassword(passwordChangeRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for generateDigitToken operation in PasswordManagementBetaApi.
 * @export
 * @interface PasswordManagementBetaApiGenerateDigitTokenRequest
 */
export interface PasswordManagementBetaApiGenerateDigitTokenRequest {
    /**
     * 
     * @type {PasswordDigitTokenResetBeta}
     * @memberof PasswordManagementBetaApiGenerateDigitToken
     */
    readonly passwordDigitTokenResetBeta: PasswordDigitTokenResetBeta
}

/**
 * Request parameters for getIdentityPasswordChangeStatus operation in PasswordManagementBetaApi.
 * @export
 * @interface PasswordManagementBetaApiGetIdentityPasswordChangeStatusRequest
 */
export interface PasswordManagementBetaApiGetIdentityPasswordChangeStatusRequest {
    /**
     * 
     * @type {string}
     * @memberof PasswordManagementBetaApiGetIdentityPasswordChangeStatus
     */
    readonly id: string
}

/**
 * Request parameters for queryPasswordInfo operation in PasswordManagementBetaApi.
 * @export
 * @interface PasswordManagementBetaApiQueryPasswordInfoRequest
 */
export interface PasswordManagementBetaApiQueryPasswordInfoRequest {
    /**
     * 
     * @type {PasswordInfoQueryDTOBeta}
     * @memberof PasswordManagementBetaApiQueryPasswordInfo
     */
    readonly passwordInfoQueryDTOBeta: PasswordInfoQueryDTOBeta
}

/**
 * Request parameters for setIdentityPassword operation in PasswordManagementBetaApi.
 * @export
 * @interface PasswordManagementBetaApiSetIdentityPasswordRequest
 */
export interface PasswordManagementBetaApiSetIdentityPasswordRequest {
    /**
     * 
     * @type {PasswordChangeRequestBeta}
     * @memberof PasswordManagementBetaApiSetIdentityPassword
     */
    readonly passwordChangeRequestBeta: PasswordChangeRequestBeta
}

/**
 * PasswordManagementBetaApi - object-oriented interface
 * @export
 * @class PasswordManagementBetaApi
 * @extends {BaseAPI}
 */
export class PasswordManagementBetaApi extends BaseAPI {
    /**
     * This API is used to generate a digit token for password management. Requires authorization scope of \"idn:password-digit-token:create\".
     * @summary Generate a digit token
     * @param {PasswordManagementBetaApiGenerateDigitTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordManagementBetaApi
     */
    public generateDigitToken(requestParameters: PasswordManagementBetaApiGenerateDigitTokenRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordManagementBetaApiFp(this.configuration).generateDigitToken(requestParameters.passwordDigitTokenResetBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the status of a password change request. A token with identity owner or trusted API client application authority is required to call this API.
     * @summary Get Password Change Request Status
     * @param {PasswordManagementBetaApiGetIdentityPasswordChangeStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordManagementBetaApi
     */
    public getIdentityPasswordChangeStatus(requestParameters: PasswordManagementBetaApiGetIdentityPasswordChangeStatusRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordManagementBetaApiFp(this.configuration).getIdentityPasswordChangeStatus(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API is used to query password related information.   A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow)  is required to call this API.  \"API authority\" refers to a token that only has the \"client_credentials\"  grant type, and therefore no user context. A [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens)  or a token generated with the [authorization_code](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow)  grant type will **NOT** work on this endpoint, and a `403 Forbidden` response  will be returned. 
     * @summary Query Password Info
     * @param {PasswordManagementBetaApiQueryPasswordInfoRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordManagementBetaApi
     */
    public queryPasswordInfo(requestParameters: PasswordManagementBetaApiQueryPasswordInfoRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordManagementBetaApiFp(this.configuration).queryPasswordInfo(requestParameters.passwordInfoQueryDTOBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API is used to set a password for an identity.   An identity can change their own password (as well as any of their accounts\' passwords) if they use a token generated by their IDN user, such as a [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens) or [\"authorization_code\" derived OAuth token](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow).  A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow) can be used to change **any** identity\'s password or the password of any of the identity\'s accounts.  \"API authority\" refers to a token that only has the \"client_credentials\" grant type.  You can use this endpoint to generate an `encryptedPassword` (RSA encrypted using publicKey).  To do so, follow these steps:  1. Use [Query Password Info](https://developer.sailpoint.com/idn/api/v3/query-password-info) to get the following information: `identityId`, `sourceId`, `publicKeyId`, `publicKey`, `accounts`, and `policies`.   2. Choose an account from the previous response that you will provide as an `accountId` in your request to set an encrypted password.   3. Use [Set Identity\'s Password](https://developer.sailpoint.com/idn/api/v3/set-password) and provide the information you got from your earlier query. Then add this code to your request to get the encrypted password:  ```java import javax.crypto.Cipher; import java.security.KeyFactory; import java.security.PublicKey; import java.security.spec.X509EncodedKeySpec; import java util.Base64;  String encrypt(String publicKey, String toEncrypt) throws Exception {   byte[] publicKeyBytes = Base64.getDecoder().decode(publicKey);   byte[] encryptedBytes = encryptRsa(publicKeyBytes, toEncrypt.getBytes(\"UTF-8\"));   return Base64.getEncoder().encodeToString(encryptedBytes); }  private byte[] encryptRsa(byte[] publicKeyBytes, byte[] toEncryptBytes) throws Exception {   PublicKey key = KeyFactory.getInstance(\"RSA\").generatePublic(new X509EncodedKeySpec(publicKeyBytes));   String transformation = \"RSA/ECB/PKCS1Padding\";   Cipher cipher = Cipher.getInstance(transformation);   cipher.init(1, key);   return cipher.doFinal(toEncryptBytes); } ```      In this example, `toEncrypt` refers to the plain text password you are setting and then encrypting, and the `publicKey` refers to the publicKey you got from the first request you sent.   You can then use [Get Password Change Request Status](https://developer.sailpoint.com/idn/api/v3/get-password-change-status) to check the password change request status. To do so, you must provide the `requestId` from your earlier request to set the password.  
     * @summary Set Identity\'s Password
     * @param {PasswordManagementBetaApiSetIdentityPasswordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordManagementBetaApi
     */
    public setIdentityPassword(requestParameters: PasswordManagementBetaApiSetIdentityPasswordRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordManagementBetaApiFp(this.configuration).setIdentityPassword(requestParameters.passwordChangeRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PasswordSyncGroupsBetaApi - axios parameter creator
 * @export
 */
export const PasswordSyncGroupsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates a password sync group based on the specifications provided. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Password Sync Group
         * @param {PasswordSyncGroupBeta} passwordSyncGroupBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPasswordSyncGroup: async (passwordSyncGroupBeta: PasswordSyncGroupBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordSyncGroupBeta' is not null or undefined
            assertParamExists('createPasswordSyncGroup', 'passwordSyncGroupBeta', passwordSyncGroupBeta)
            const localVarPath = `/password-sync-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordSyncGroupBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API deletes the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Password Sync Group by ID
         * @param {string} id The ID of password sync group to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePasswordSyncGroup: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePasswordSyncGroup', 'id', id)
            const localVarPath = `/password-sync-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the sync group for the specified ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Sync Group by ID
         * @param {string} id The ID of password sync group to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordSyncGroup: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPasswordSyncGroup', 'id', id)
            const localVarPath = `/password-sync-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of password sync groups. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Sync Group List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordSyncGroups: async (limit?: number, offset?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/password-sync-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Password Sync Group by ID
         * @param {string} id The ID of password sync group to update.
         * @param {PasswordSyncGroupBeta} passwordSyncGroupBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePasswordSyncGroup: async (id: string, passwordSyncGroupBeta: PasswordSyncGroupBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePasswordSyncGroup', 'id', id)
            // verify required parameter 'passwordSyncGroupBeta' is not null or undefined
            assertParamExists('updatePasswordSyncGroup', 'passwordSyncGroupBeta', passwordSyncGroupBeta)
            const localVarPath = `/password-sync-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordSyncGroupBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasswordSyncGroupsBetaApi - functional programming interface
 * @export
 */
export const PasswordSyncGroupsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasswordSyncGroupsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates a password sync group based on the specifications provided. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Password Sync Group
         * @param {PasswordSyncGroupBeta} passwordSyncGroupBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createPasswordSyncGroup(passwordSyncGroupBeta: PasswordSyncGroupBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordSyncGroupBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPasswordSyncGroup(passwordSyncGroupBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API deletes the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Password Sync Group by ID
         * @param {string} id The ID of password sync group to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deletePasswordSyncGroup(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePasswordSyncGroup(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the sync group for the specified ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Sync Group by ID
         * @param {string} id The ID of password sync group to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPasswordSyncGroup(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordSyncGroupBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordSyncGroup(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of password sync groups. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Sync Group List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPasswordSyncGroups(limit?: number, offset?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PasswordSyncGroupBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordSyncGroups(limit, offset, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API updates the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Password Sync Group by ID
         * @param {string} id The ID of password sync group to update.
         * @param {PasswordSyncGroupBeta} passwordSyncGroupBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updatePasswordSyncGroup(id: string, passwordSyncGroupBeta: PasswordSyncGroupBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordSyncGroupBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePasswordSyncGroup(id, passwordSyncGroupBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PasswordSyncGroupsBetaApi - factory interface
 * @export
 */
export const PasswordSyncGroupsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasswordSyncGroupsBetaApiFp(configuration)
    return {
        /**
         * This API creates a password sync group based on the specifications provided. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Password Sync Group
         * @param {PasswordSyncGroupBeta} passwordSyncGroupBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPasswordSyncGroup(passwordSyncGroupBeta: PasswordSyncGroupBeta, axiosOptions?: any): AxiosPromise<PasswordSyncGroupBeta> {
            return localVarFp.createPasswordSyncGroup(passwordSyncGroupBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API deletes the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Password Sync Group by ID
         * @param {string} id The ID of password sync group to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePasswordSyncGroup(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deletePasswordSyncGroup(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the sync group for the specified ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Sync Group by ID
         * @param {string} id The ID of password sync group to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordSyncGroup(id: string, axiosOptions?: any): AxiosPromise<PasswordSyncGroupBeta> {
            return localVarFp.getPasswordSyncGroup(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of password sync groups. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Sync Group List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordSyncGroups(limit?: number, offset?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<PasswordSyncGroupBeta>> {
            return localVarFp.getPasswordSyncGroups(limit, offset, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Password Sync Group by ID
         * @param {string} id The ID of password sync group to update.
         * @param {PasswordSyncGroupBeta} passwordSyncGroupBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePasswordSyncGroup(id: string, passwordSyncGroupBeta: PasswordSyncGroupBeta, axiosOptions?: any): AxiosPromise<PasswordSyncGroupBeta> {
            return localVarFp.updatePasswordSyncGroup(id, passwordSyncGroupBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPasswordSyncGroup operation in PasswordSyncGroupsBetaApi.
 * @export
 * @interface PasswordSyncGroupsBetaApiCreatePasswordSyncGroupRequest
 */
export interface PasswordSyncGroupsBetaApiCreatePasswordSyncGroupRequest {
    /**
     * 
     * @type {PasswordSyncGroupBeta}
     * @memberof PasswordSyncGroupsBetaApiCreatePasswordSyncGroup
     */
    readonly passwordSyncGroupBeta: PasswordSyncGroupBeta
}

/**
 * Request parameters for deletePasswordSyncGroup operation in PasswordSyncGroupsBetaApi.
 * @export
 * @interface PasswordSyncGroupsBetaApiDeletePasswordSyncGroupRequest
 */
export interface PasswordSyncGroupsBetaApiDeletePasswordSyncGroupRequest {
    /**
     * The ID of password sync group to delete.
     * @type {string}
     * @memberof PasswordSyncGroupsBetaApiDeletePasswordSyncGroup
     */
    readonly id: string
}

/**
 * Request parameters for getPasswordSyncGroup operation in PasswordSyncGroupsBetaApi.
 * @export
 * @interface PasswordSyncGroupsBetaApiGetPasswordSyncGroupRequest
 */
export interface PasswordSyncGroupsBetaApiGetPasswordSyncGroupRequest {
    /**
     * The ID of password sync group to retrieve.
     * @type {string}
     * @memberof PasswordSyncGroupsBetaApiGetPasswordSyncGroup
     */
    readonly id: string
}

/**
 * Request parameters for getPasswordSyncGroups operation in PasswordSyncGroupsBetaApi.
 * @export
 * @interface PasswordSyncGroupsBetaApiGetPasswordSyncGroupsRequest
 */
export interface PasswordSyncGroupsBetaApiGetPasswordSyncGroupsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof PasswordSyncGroupsBetaApiGetPasswordSyncGroups
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof PasswordSyncGroupsBetaApiGetPasswordSyncGroups
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof PasswordSyncGroupsBetaApiGetPasswordSyncGroups
     */
    readonly count?: boolean
}

/**
 * Request parameters for updatePasswordSyncGroup operation in PasswordSyncGroupsBetaApi.
 * @export
 * @interface PasswordSyncGroupsBetaApiUpdatePasswordSyncGroupRequest
 */
export interface PasswordSyncGroupsBetaApiUpdatePasswordSyncGroupRequest {
    /**
     * The ID of password sync group to update.
     * @type {string}
     * @memberof PasswordSyncGroupsBetaApiUpdatePasswordSyncGroup
     */
    readonly id: string

    /**
     * 
     * @type {PasswordSyncGroupBeta}
     * @memberof PasswordSyncGroupsBetaApiUpdatePasswordSyncGroup
     */
    readonly passwordSyncGroupBeta: PasswordSyncGroupBeta
}

/**
 * PasswordSyncGroupsBetaApi - object-oriented interface
 * @export
 * @class PasswordSyncGroupsBetaApi
 * @extends {BaseAPI}
 */
export class PasswordSyncGroupsBetaApi extends BaseAPI {
    /**
     * This API creates a password sync group based on the specifications provided. A token with ORG_ADMIN authority is required to call this API.
     * @summary Create Password Sync Group
     * @param {PasswordSyncGroupsBetaApiCreatePasswordSyncGroupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordSyncGroupsBetaApi
     */
    public createPasswordSyncGroup(requestParameters: PasswordSyncGroupsBetaApiCreatePasswordSyncGroupRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordSyncGroupsBetaApiFp(this.configuration).createPasswordSyncGroup(requestParameters.passwordSyncGroupBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API deletes the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
     * @summary Delete Password Sync Group by ID
     * @param {PasswordSyncGroupsBetaApiDeletePasswordSyncGroupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordSyncGroupsBetaApi
     */
    public deletePasswordSyncGroup(requestParameters: PasswordSyncGroupsBetaApiDeletePasswordSyncGroupRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordSyncGroupsBetaApiFp(this.configuration).deletePasswordSyncGroup(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the sync group for the specified ID. A token with ORG_ADMIN authority is required to call this API.
     * @summary Get Password Sync Group by ID
     * @param {PasswordSyncGroupsBetaApiGetPasswordSyncGroupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordSyncGroupsBetaApi
     */
    public getPasswordSyncGroup(requestParameters: PasswordSyncGroupsBetaApiGetPasswordSyncGroupRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordSyncGroupsBetaApiFp(this.configuration).getPasswordSyncGroup(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of password sync groups. A token with ORG_ADMIN authority is required to call this API.
     * @summary Get Password Sync Group List
     * @param {PasswordSyncGroupsBetaApiGetPasswordSyncGroupsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordSyncGroupsBetaApi
     */
    public getPasswordSyncGroups(requestParameters: PasswordSyncGroupsBetaApiGetPasswordSyncGroupsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return PasswordSyncGroupsBetaApiFp(this.configuration).getPasswordSyncGroups(requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
     * @summary Update Password Sync Group by ID
     * @param {PasswordSyncGroupsBetaApiUpdatePasswordSyncGroupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordSyncGroupsBetaApi
     */
    public updatePasswordSyncGroup(requestParameters: PasswordSyncGroupsBetaApiUpdatePasswordSyncGroupRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordSyncGroupsBetaApiFp(this.configuration).updatePasswordSyncGroup(requestParameters.id, requestParameters.passwordSyncGroupBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PersonalAccessTokensBetaApi - axios parameter creator
 * @export
 */
export const PersonalAccessTokensBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This creates a personal access token.
         * @summary Create Personal Access Token
         * @param {CreatePersonalAccessTokenRequestBeta} createPersonalAccessTokenRequestBeta Name and scope of personal access token.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPersonalAccessToken: async (createPersonalAccessTokenRequestBeta: CreatePersonalAccessTokenRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPersonalAccessTokenRequestBeta' is not null or undefined
            assertParamExists('createPersonalAccessToken', 'createPersonalAccessTokenRequestBeta', createPersonalAccessTokenRequestBeta)
            const localVarPath = `/personal-access-tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPersonalAccessTokenRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This deletes a personal access token.
         * @summary Delete Personal Access Token
         * @param {string} id The personal access token id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonalAccessToken: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePersonalAccessToken', 'id', id)
            const localVarPath = `/personal-access-tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a collection of personal access tokens associated with the optional `owner-id`.  query parameter. If the `owner-id` query parameter is omitted, all personal access tokens  for a tenant will be retrieved, but the caller must have the \'idn:all-personal-access-tokens:read\' right.
         * @summary List Personal Access Tokens
         * @param {string} [ownerId] The identity ID of the owner whose personal access tokens should be listed.  If \&quot;me\&quot;, the caller should have the following right: \&#39;idn:my-personal-access-tokens:read\&#39; If an actual owner ID or if the &#x60;owner-id&#x60; parameter is omitted in the request,  the caller should have the following right: \&#39;idn:all-personal-access-tokens:read\&#39;.  If the caller has the following right, then managed personal access tokens associated with &#x60;owner-id&#x60; will be retrieved: \&#39;idn:managed-personal-access-tokens:read\&#39;
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPersonalAccessTokens: async (ownerId?: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/personal-access-tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['owner-id'] = ownerId;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This performs a targeted update to the field(s) of a Personal Access Token.
         * @summary Patch Personal Access Token
         * @param {string} id The Personal Access Token id
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * scope 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchPersonalAccessToken: async (id: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchPersonalAccessToken', 'id', id)
            // verify required parameter 'jsonPatchOperationBeta' is not null or undefined
            assertParamExists('patchPersonalAccessToken', 'jsonPatchOperationBeta', jsonPatchOperationBeta)
            const localVarPath = `/personal-access-tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperationBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonalAccessTokensBetaApi - functional programming interface
 * @export
 */
export const PersonalAccessTokensBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonalAccessTokensBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This creates a personal access token.
         * @summary Create Personal Access Token
         * @param {CreatePersonalAccessTokenRequestBeta} createPersonalAccessTokenRequestBeta Name and scope of personal access token.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createPersonalAccessToken(createPersonalAccessTokenRequestBeta: CreatePersonalAccessTokenRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePersonalAccessTokenResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPersonalAccessToken(createPersonalAccessTokenRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This deletes a personal access token.
         * @summary Delete Personal Access Token
         * @param {string} id The personal access token id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deletePersonalAccessToken(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePersonalAccessToken(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a collection of personal access tokens associated with the optional `owner-id`.  query parameter. If the `owner-id` query parameter is omitted, all personal access tokens  for a tenant will be retrieved, but the caller must have the \'idn:all-personal-access-tokens:read\' right.
         * @summary List Personal Access Tokens
         * @param {string} [ownerId] The identity ID of the owner whose personal access tokens should be listed.  If \&quot;me\&quot;, the caller should have the following right: \&#39;idn:my-personal-access-tokens:read\&#39; If an actual owner ID or if the &#x60;owner-id&#x60; parameter is omitted in the request,  the caller should have the following right: \&#39;idn:all-personal-access-tokens:read\&#39;.  If the caller has the following right, then managed personal access tokens associated with &#x60;owner-id&#x60; will be retrieved: \&#39;idn:managed-personal-access-tokens:read\&#39;
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listPersonalAccessTokens(ownerId?: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPersonalAccessTokenResponseBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPersonalAccessTokens(ownerId, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This performs a targeted update to the field(s) of a Personal Access Token.
         * @summary Patch Personal Access Token
         * @param {string} id The Personal Access Token id
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * scope 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchPersonalAccessToken(id: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPersonalAccessTokenResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchPersonalAccessToken(id, jsonPatchOperationBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PersonalAccessTokensBetaApi - factory interface
 * @export
 */
export const PersonalAccessTokensBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonalAccessTokensBetaApiFp(configuration)
    return {
        /**
         * This creates a personal access token.
         * @summary Create Personal Access Token
         * @param {CreatePersonalAccessTokenRequestBeta} createPersonalAccessTokenRequestBeta Name and scope of personal access token.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPersonalAccessToken(createPersonalAccessTokenRequestBeta: CreatePersonalAccessTokenRequestBeta, axiosOptions?: any): AxiosPromise<CreatePersonalAccessTokenResponseBeta> {
            return localVarFp.createPersonalAccessToken(createPersonalAccessTokenRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This deletes a personal access token.
         * @summary Delete Personal Access Token
         * @param {string} id The personal access token id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonalAccessToken(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deletePersonalAccessToken(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a collection of personal access tokens associated with the optional `owner-id`.  query parameter. If the `owner-id` query parameter is omitted, all personal access tokens  for a tenant will be retrieved, but the caller must have the \'idn:all-personal-access-tokens:read\' right.
         * @summary List Personal Access Tokens
         * @param {string} [ownerId] The identity ID of the owner whose personal access tokens should be listed.  If \&quot;me\&quot;, the caller should have the following right: \&#39;idn:my-personal-access-tokens:read\&#39; If an actual owner ID or if the &#x60;owner-id&#x60; parameter is omitted in the request,  the caller should have the following right: \&#39;idn:all-personal-access-tokens:read\&#39;.  If the caller has the following right, then managed personal access tokens associated with &#x60;owner-id&#x60; will be retrieved: \&#39;idn:managed-personal-access-tokens:read\&#39;
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPersonalAccessTokens(ownerId?: string, filters?: string, axiosOptions?: any): AxiosPromise<Array<GetPersonalAccessTokenResponseBeta>> {
            return localVarFp.listPersonalAccessTokens(ownerId, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This performs a targeted update to the field(s) of a Personal Access Token.
         * @summary Patch Personal Access Token
         * @param {string} id The Personal Access Token id
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * scope 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchPersonalAccessToken(id: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: any): AxiosPromise<GetPersonalAccessTokenResponseBeta> {
            return localVarFp.patchPersonalAccessToken(id, jsonPatchOperationBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPersonalAccessToken operation in PersonalAccessTokensBetaApi.
 * @export
 * @interface PersonalAccessTokensBetaApiCreatePersonalAccessTokenRequest
 */
export interface PersonalAccessTokensBetaApiCreatePersonalAccessTokenRequest {
    /**
     * Name and scope of personal access token.
     * @type {CreatePersonalAccessTokenRequestBeta}
     * @memberof PersonalAccessTokensBetaApiCreatePersonalAccessToken
     */
    readonly createPersonalAccessTokenRequestBeta: CreatePersonalAccessTokenRequestBeta
}

/**
 * Request parameters for deletePersonalAccessToken operation in PersonalAccessTokensBetaApi.
 * @export
 * @interface PersonalAccessTokensBetaApiDeletePersonalAccessTokenRequest
 */
export interface PersonalAccessTokensBetaApiDeletePersonalAccessTokenRequest {
    /**
     * The personal access token id
     * @type {string}
     * @memberof PersonalAccessTokensBetaApiDeletePersonalAccessToken
     */
    readonly id: string
}

/**
 * Request parameters for listPersonalAccessTokens operation in PersonalAccessTokensBetaApi.
 * @export
 * @interface PersonalAccessTokensBetaApiListPersonalAccessTokensRequest
 */
export interface PersonalAccessTokensBetaApiListPersonalAccessTokensRequest {
    /**
     * The identity ID of the owner whose personal access tokens should be listed.  If \&quot;me\&quot;, the caller should have the following right: \&#39;idn:my-personal-access-tokens:read\&#39; If an actual owner ID or if the &#x60;owner-id&#x60; parameter is omitted in the request,  the caller should have the following right: \&#39;idn:all-personal-access-tokens:read\&#39;.  If the caller has the following right, then managed personal access tokens associated with &#x60;owner-id&#x60; will be retrieved: \&#39;idn:managed-personal-access-tokens:read\&#39;
     * @type {string}
     * @memberof PersonalAccessTokensBetaApiListPersonalAccessTokens
     */
    readonly ownerId?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
     * @type {string}
     * @memberof PersonalAccessTokensBetaApiListPersonalAccessTokens
     */
    readonly filters?: string
}

/**
 * Request parameters for patchPersonalAccessToken operation in PersonalAccessTokensBetaApi.
 * @export
 * @interface PersonalAccessTokensBetaApiPatchPersonalAccessTokenRequest
 */
export interface PersonalAccessTokensBetaApiPatchPersonalAccessTokenRequest {
    /**
     * The Personal Access Token id
     * @type {string}
     * @memberof PersonalAccessTokensBetaApiPatchPersonalAccessToken
     */
    readonly id: string

    /**
     * A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * scope 
     * @type {Array<JsonPatchOperationBeta>}
     * @memberof PersonalAccessTokensBetaApiPatchPersonalAccessToken
     */
    readonly jsonPatchOperationBeta: Array<JsonPatchOperationBeta>
}

/**
 * PersonalAccessTokensBetaApi - object-oriented interface
 * @export
 * @class PersonalAccessTokensBetaApi
 * @extends {BaseAPI}
 */
export class PersonalAccessTokensBetaApi extends BaseAPI {
    /**
     * This creates a personal access token.
     * @summary Create Personal Access Token
     * @param {PersonalAccessTokensBetaApiCreatePersonalAccessTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensBetaApi
     */
    public createPersonalAccessToken(requestParameters: PersonalAccessTokensBetaApiCreatePersonalAccessTokenRequest, axiosOptions?: AxiosRequestConfig) {
        return PersonalAccessTokensBetaApiFp(this.configuration).createPersonalAccessToken(requestParameters.createPersonalAccessTokenRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes a personal access token.
     * @summary Delete Personal Access Token
     * @param {PersonalAccessTokensBetaApiDeletePersonalAccessTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensBetaApi
     */
    public deletePersonalAccessToken(requestParameters: PersonalAccessTokensBetaApiDeletePersonalAccessTokenRequest, axiosOptions?: AxiosRequestConfig) {
        return PersonalAccessTokensBetaApiFp(this.configuration).deletePersonalAccessToken(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a collection of personal access tokens associated with the optional `owner-id`.  query parameter. If the `owner-id` query parameter is omitted, all personal access tokens  for a tenant will be retrieved, but the caller must have the \'idn:all-personal-access-tokens:read\' right.
     * @summary List Personal Access Tokens
     * @param {PersonalAccessTokensBetaApiListPersonalAccessTokensRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensBetaApi
     */
    public listPersonalAccessTokens(requestParameters: PersonalAccessTokensBetaApiListPersonalAccessTokensRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return PersonalAccessTokensBetaApiFp(this.configuration).listPersonalAccessTokens(requestParameters.ownerId, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This performs a targeted update to the field(s) of a Personal Access Token.
     * @summary Patch Personal Access Token
     * @param {PersonalAccessTokensBetaApiPatchPersonalAccessTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensBetaApi
     */
    public patchPersonalAccessToken(requestParameters: PersonalAccessTokensBetaApiPatchPersonalAccessTokenRequest, axiosOptions?: AxiosRequestConfig) {
        return PersonalAccessTokensBetaApiFp(this.configuration).patchPersonalAccessToken(requestParameters.id, requestParameters.jsonPatchOperationBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PublicIdentitiesConfigBetaApi - axios parameter creator
 * @export
 */
export const PublicIdentitiesConfigBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This gets details of public identity config.
         * @summary Get Public Identity Config
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPublicIdentityConfig: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public-identities-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This updates the details of public identity config.
         * @summary Update Public Identity Config
         * @param {PublicIdentityConfigBeta} publicIdentityConfigBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicIdentityConfig: async (publicIdentityConfigBeta: PublicIdentityConfigBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publicIdentityConfigBeta' is not null or undefined
            assertParamExists('updatePublicIdentityConfig', 'publicIdentityConfigBeta', publicIdentityConfigBeta)
            const localVarPath = `/public-identities-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publicIdentityConfigBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicIdentitiesConfigBetaApi - functional programming interface
 * @export
 */
export const PublicIdentitiesConfigBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicIdentitiesConfigBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This gets details of public identity config.
         * @summary Get Public Identity Config
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicIdentityConfig(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicIdentityConfigBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicIdentityConfig(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This updates the details of public identity config.
         * @summary Update Public Identity Config
         * @param {PublicIdentityConfigBeta} publicIdentityConfigBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updatePublicIdentityConfig(publicIdentityConfigBeta: PublicIdentityConfigBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicIdentityConfigBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePublicIdentityConfig(publicIdentityConfigBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PublicIdentitiesConfigBetaApi - factory interface
 * @export
 */
export const PublicIdentitiesConfigBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicIdentitiesConfigBetaApiFp(configuration)
    return {
        /**
         * This gets details of public identity config.
         * @summary Get Public Identity Config
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPublicIdentityConfig(axiosOptions?: any): AxiosPromise<PublicIdentityConfigBeta> {
            return localVarFp.getPublicIdentityConfig(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This updates the details of public identity config.
         * @summary Update Public Identity Config
         * @param {PublicIdentityConfigBeta} publicIdentityConfigBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicIdentityConfig(publicIdentityConfigBeta: PublicIdentityConfigBeta, axiosOptions?: any): AxiosPromise<PublicIdentityConfigBeta> {
            return localVarFp.updatePublicIdentityConfig(publicIdentityConfigBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for updatePublicIdentityConfig operation in PublicIdentitiesConfigBetaApi.
 * @export
 * @interface PublicIdentitiesConfigBetaApiUpdatePublicIdentityConfigRequest
 */
export interface PublicIdentitiesConfigBetaApiUpdatePublicIdentityConfigRequest {
    /**
     * 
     * @type {PublicIdentityConfigBeta}
     * @memberof PublicIdentitiesConfigBetaApiUpdatePublicIdentityConfig
     */
    readonly publicIdentityConfigBeta: PublicIdentityConfigBeta
}

/**
 * PublicIdentitiesConfigBetaApi - object-oriented interface
 * @export
 * @class PublicIdentitiesConfigBetaApi
 * @extends {BaseAPI}
 */
export class PublicIdentitiesConfigBetaApi extends BaseAPI {
    /**
     * This gets details of public identity config.
     * @summary Get Public Identity Config
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicIdentitiesConfigBetaApi
     */
    public getPublicIdentityConfig(axiosOptions?: AxiosRequestConfig) {
        return PublicIdentitiesConfigBetaApiFp(this.configuration).getPublicIdentityConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This updates the details of public identity config.
     * @summary Update Public Identity Config
     * @param {PublicIdentitiesConfigBetaApiUpdatePublicIdentityConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicIdentitiesConfigBetaApi
     */
    public updatePublicIdentityConfig(requestParameters: PublicIdentitiesConfigBetaApiUpdatePublicIdentityConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return PublicIdentitiesConfigBetaApiFp(this.configuration).updatePublicIdentityConfig(requestParameters.publicIdentityConfigBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RequestableObjectsBetaApi - axios parameter creator
 * @export
 */
export const RequestableObjectsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns a list of acccess items that that can be requested through the Access Request endpoints. Access items are marked with AVAILABLE, PENDING or ASSIGNED with respect to the identity provided using *identity-id* query param. Any authenticated token can call this endpoint to see their requestable access items. A token with ORG_ADMIN authority is required to call this endpoint to return a list of all of the requestable access items for the org or for another identity.
         * @summary Requestable Objects List
         * @param {string} [identityId] If present, the value returns only requestable objects for the specified identity.  * Admin users can call this with any identity ID value.  * Non-admin users can only specify *me* or pass their own identity ID value.  * If absent, returns a list of all requestable objects for the tenant. Only admin users can make such a call. In this case, the available, pending, assigned accesses will not be annotated in the result.
         * @param {Array<RequestableObjectTypeBeta>} [types] Filters the results to the specified type/types, where each type is one of ROLE or ACCESS_PROFILE. If absent, all types are returned. Support for additional types may be added in the future without notice.
         * @param {string} [term] It allows searching requestable access items with a partial match on the name or description. If term is provided, then the *filter* query parameter will be ignored.
         * @param {Array<RequestableObjectRequestStatusBeta>} [statuses] Filters the result to the specified status/statuses, where each status is one of AVAILABLE, ASSIGNED, or PENDING. It is an error to specify this parameter without also specifying an *identity-id* parameter. Additional statuses may be added in the future without notice.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw* 
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name** 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listRequestableObjects: async (identityId?: string, types?: Array<RequestableObjectTypeBeta>, term?: string, statuses?: Array<RequestableObjectRequestStatusBeta>, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/requestable-objects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (identityId !== undefined) {
                localVarQueryParameter['identity-id'] = identityId;
            }

            if (types) {
                localVarQueryParameter['types'] = types.join(COLLECTION_FORMATS.csv);
            }

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * RequestableObjectsBetaApi - functional programming interface
 * @export
 */
export const RequestableObjectsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RequestableObjectsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint returns a list of acccess items that that can be requested through the Access Request endpoints. Access items are marked with AVAILABLE, PENDING or ASSIGNED with respect to the identity provided using *identity-id* query param. Any authenticated token can call this endpoint to see their requestable access items. A token with ORG_ADMIN authority is required to call this endpoint to return a list of all of the requestable access items for the org or for another identity.
         * @summary Requestable Objects List
         * @param {string} [identityId] If present, the value returns only requestable objects for the specified identity.  * Admin users can call this with any identity ID value.  * Non-admin users can only specify *me* or pass their own identity ID value.  * If absent, returns a list of all requestable objects for the tenant. Only admin users can make such a call. In this case, the available, pending, assigned accesses will not be annotated in the result.
         * @param {Array<RequestableObjectTypeBeta>} [types] Filters the results to the specified type/types, where each type is one of ROLE or ACCESS_PROFILE. If absent, all types are returned. Support for additional types may be added in the future without notice.
         * @param {string} [term] It allows searching requestable access items with a partial match on the name or description. If term is provided, then the *filter* query parameter will be ignored.
         * @param {Array<RequestableObjectRequestStatusBeta>} [statuses] Filters the result to the specified status/statuses, where each status is one of AVAILABLE, ASSIGNED, or PENDING. It is an error to specify this parameter without also specifying an *identity-id* parameter. Additional statuses may be added in the future without notice.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw* 
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name** 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listRequestableObjects(identityId?: string, types?: Array<RequestableObjectTypeBeta>, term?: string, statuses?: Array<RequestableObjectRequestStatusBeta>, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RequestableObjectBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRequestableObjects(identityId, types, term, statuses, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RequestableObjectsBetaApi - factory interface
 * @export
 */
export const RequestableObjectsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RequestableObjectsBetaApiFp(configuration)
    return {
        /**
         * This endpoint returns a list of acccess items that that can be requested through the Access Request endpoints. Access items are marked with AVAILABLE, PENDING or ASSIGNED with respect to the identity provided using *identity-id* query param. Any authenticated token can call this endpoint to see their requestable access items. A token with ORG_ADMIN authority is required to call this endpoint to return a list of all of the requestable access items for the org or for another identity.
         * @summary Requestable Objects List
         * @param {string} [identityId] If present, the value returns only requestable objects for the specified identity.  * Admin users can call this with any identity ID value.  * Non-admin users can only specify *me* or pass their own identity ID value.  * If absent, returns a list of all requestable objects for the tenant. Only admin users can make such a call. In this case, the available, pending, assigned accesses will not be annotated in the result.
         * @param {Array<RequestableObjectTypeBeta>} [types] Filters the results to the specified type/types, where each type is one of ROLE or ACCESS_PROFILE. If absent, all types are returned. Support for additional types may be added in the future without notice.
         * @param {string} [term] It allows searching requestable access items with a partial match on the name or description. If term is provided, then the *filter* query parameter will be ignored.
         * @param {Array<RequestableObjectRequestStatusBeta>} [statuses] Filters the result to the specified status/statuses, where each status is one of AVAILABLE, ASSIGNED, or PENDING. It is an error to specify this parameter without also specifying an *identity-id* parameter. Additional statuses may be added in the future without notice.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw* 
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name** 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listRequestableObjects(identityId?: string, types?: Array<RequestableObjectTypeBeta>, term?: string, statuses?: Array<RequestableObjectRequestStatusBeta>, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<RequestableObjectBeta>> {
            return localVarFp.listRequestableObjects(identityId, types, term, statuses, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listRequestableObjects operation in RequestableObjectsBetaApi.
 * @export
 * @interface RequestableObjectsBetaApiListRequestableObjectsRequest
 */
export interface RequestableObjectsBetaApiListRequestableObjectsRequest {
    /**
     * If present, the value returns only requestable objects for the specified identity.  * Admin users can call this with any identity ID value.  * Non-admin users can only specify *me* or pass their own identity ID value.  * If absent, returns a list of all requestable objects for the tenant. Only admin users can make such a call. In this case, the available, pending, assigned accesses will not be annotated in the result.
     * @type {string}
     * @memberof RequestableObjectsBetaApiListRequestableObjects
     */
    readonly identityId?: string

    /**
     * Filters the results to the specified type/types, where each type is one of ROLE or ACCESS_PROFILE. If absent, all types are returned. Support for additional types may be added in the future without notice.
     * @type {Array<RequestableObjectTypeBeta>}
     * @memberof RequestableObjectsBetaApiListRequestableObjects
     */
    readonly types?: Array<RequestableObjectTypeBeta>

    /**
     * It allows searching requestable access items with a partial match on the name or description. If term is provided, then the *filter* query parameter will be ignored.
     * @type {string}
     * @memberof RequestableObjectsBetaApiListRequestableObjects
     */
    readonly term?: string

    /**
     * Filters the result to the specified status/statuses, where each status is one of AVAILABLE, ASSIGNED, or PENDING. It is an error to specify this parameter without also specifying an *identity-id* parameter. Additional statuses may be added in the future without notice.
     * @type {Array<RequestableObjectRequestStatusBeta>}
     * @memberof RequestableObjectsBetaApiListRequestableObjects
     */
    readonly statuses?: Array<RequestableObjectRequestStatusBeta>

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RequestableObjectsBetaApiListRequestableObjects
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RequestableObjectsBetaApiListRequestableObjects
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof RequestableObjectsBetaApiListRequestableObjects
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw* 
     * @type {string}
     * @memberof RequestableObjectsBetaApiListRequestableObjects
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name** 
     * @type {string}
     * @memberof RequestableObjectsBetaApiListRequestableObjects
     */
    readonly sorters?: string
}

/**
 * RequestableObjectsBetaApi - object-oriented interface
 * @export
 * @class RequestableObjectsBetaApi
 * @extends {BaseAPI}
 */
export class RequestableObjectsBetaApi extends BaseAPI {
    /**
     * This endpoint returns a list of acccess items that that can be requested through the Access Request endpoints. Access items are marked with AVAILABLE, PENDING or ASSIGNED with respect to the identity provided using *identity-id* query param. Any authenticated token can call this endpoint to see their requestable access items. A token with ORG_ADMIN authority is required to call this endpoint to return a list of all of the requestable access items for the org or for another identity.
     * @summary Requestable Objects List
     * @param {RequestableObjectsBetaApiListRequestableObjectsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestableObjectsBetaApi
     */
    public listRequestableObjects(requestParameters: RequestableObjectsBetaApiListRequestableObjectsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return RequestableObjectsBetaApiFp(this.configuration).listRequestableObjects(requestParameters.identityId, requestParameters.types, requestParameters.term, requestParameters.statuses, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RoleInsightsBetaApi - axios parameter creator
 * @export
 */
export const RoleInsightsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This submits a create role insights request to the role insights application. At this time there are no parameters. All business roles will be processed for the customer.
         * @summary A request to generate insights for roles
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createRoleInsightRequests: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/role-insights/requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns the entitlement insights for a role.
         * @summary Download entitlement insights for a role
         * @param {string} insightId The role insight id
         * @param {string} [sorters] sort by identitiesWithAccess, default order descending
         * @param {string} [filters] Filter parameter(s) by \&quot;starts with\&quot; for the name and description.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        downloadRoleInsightsEntitlementsChanges: async (insightId: string, sorters?: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'insightId' is not null or undefined
            assertParamExists('downloadRoleInsightsEntitlementsChanges', 'insightId', insightId)
            const localVarPath = `/role-insights/{insightId}/entitlement-changes/download`
                .replace(`{${"insightId"}}`, encodeURIComponent(String(insightId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Role insights suggests entitlements to be added for a role. This endpoint returns a list of identities in the role, with or without the entitlements, for a suggested entitlement so that the user can see which identities would be affected if the suggested entitlement were to be added to the role.
         * @summary Get identities for a suggested entitlement (for a role)
         * @param {string} insightId The role insight id
         * @param {string} entitlementId The entitlement id
         * @param {boolean} [hasEntitlement] Identity has this entitlement or not
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] sort by name
         * @param {string} [filters] Filter parameter by \&quot;starts with\&quot; for the name.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getEntitlementChangesIdentities: async (insightId: string, entitlementId: string, hasEntitlement?: boolean, offset?: number, limit?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'insightId' is not null or undefined
            assertParamExists('getEntitlementChangesIdentities', 'insightId', insightId)
            // verify required parameter 'entitlementId' is not null or undefined
            assertParamExists('getEntitlementChangesIdentities', 'entitlementId', entitlementId)
            const localVarPath = `/role-insights/{insightId}/entitlement-changes/{entitlementId}/identities`
                .replace(`{${"insightId"}}`, encodeURIComponent(String(insightId)))
                .replace(`{${"entitlementId"}}`, encodeURIComponent(String(entitlementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (hasEntitlement !== undefined) {
                localVarQueryParameter['hasEntitlement'] = hasEntitlement;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gets role insights information for a role.
         * @summary Get a single role insight
         * @param {string} insightId The role insight id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRoleInsight: async (insightId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'insightId' is not null or undefined
            assertParamExists('getRoleInsight', 'insightId', insightId)
            const localVarPath = `/role-insights/{insightId}`
                .replace(`{${"insightId"}}`, encodeURIComponent(String(insightId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This method returns detailed role insights for each role.
         * @summary Get role insights
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] sort by numberOfUpdates, identitiesWithAccess, totalNumberOfIdentities (default- ascending)
         * @param {string} [filters] Filter parameter(s) by \&quot;starts with\&quot; for the name, ownerName and description.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRoleInsights: async (offset?: number, limit?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/role-insights`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gets the entitlements for a role. The term \"current\" is to distinguish from the entitlement(s) an insight might recommend adding.
         * @summary Get current entitlement for a role
         * @param {string} insightId The role insight id
         * @param {string} [filters] Filter parameter(s) by \&quot;starts with\&quot; for the name and description.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRoleInsightsCurrentEntitlements: async (insightId: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'insightId' is not null or undefined
            assertParamExists('getRoleInsightsCurrentEntitlements', 'insightId', insightId)
            const localVarPath = `/role-insights/{insightId}/current-entitlements`
                .replace(`{${"insightId"}}`, encodeURIComponent(String(insightId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns entitlement insights for a role.
         * @summary Get entitlement insights for a role
         * @param {string} insightId The role insight id
         * @param {string} [sorters] sort by identitiesWithAccess or name
         * @param {string} [filters] Filter parameter(s) by \&quot;starts with\&quot; for the name and description.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRoleInsightsEntitlementsChanges: async (insightId: string, sorters?: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'insightId' is not null or undefined
            assertParamExists('getRoleInsightsEntitlementsChanges', 'insightId', insightId)
            const localVarPath = `/role-insights/{insightId}/entitlement-changes`
                .replace(`{${"insightId"}}`, encodeURIComponent(String(insightId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns details of a prior request.
         * @summary Returns the metadata for a request in order to generate insights for roles.
         * @param {string} id The role insights request id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRoleInsightsRequests: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRoleInsightsRequests', 'id', id)
            const localVarPath = `/role-insights/requests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This method returns high level summary information for role insights for a customer.
         * @summary Get role insights summary information
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRoleInsightsSummary: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/role-insights/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoleInsightsBetaApi - functional programming interface
 * @export
 */
export const RoleInsightsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoleInsightsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This submits a create role insights request to the role insights application. At this time there are no parameters. All business roles will be processed for the customer.
         * @summary A request to generate insights for roles
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createRoleInsightRequests(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleInsightsResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRoleInsightRequests(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns the entitlement insights for a role.
         * @summary Download entitlement insights for a role
         * @param {string} insightId The role insight id
         * @param {string} [sorters] sort by identitiesWithAccess, default order descending
         * @param {string} [filters] Filter parameter(s) by \&quot;starts with\&quot; for the name and description.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async downloadRoleInsightsEntitlementsChanges(insightId: string, sorters?: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadRoleInsightsEntitlementsChanges(insightId, sorters, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Role insights suggests entitlements to be added for a role. This endpoint returns a list of identities in the role, with or without the entitlements, for a suggested entitlement so that the user can see which identities would be affected if the suggested entitlement were to be added to the role.
         * @summary Get identities for a suggested entitlement (for a role)
         * @param {string} insightId The role insight id
         * @param {string} entitlementId The entitlement id
         * @param {boolean} [hasEntitlement] Identity has this entitlement or not
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] sort by name
         * @param {string} [filters] Filter parameter by \&quot;starts with\&quot; for the name.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getEntitlementChangesIdentities(insightId: string, entitlementId: string, hasEntitlement?: boolean, offset?: number, limit?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleInsightsIdentitiesBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntitlementChangesIdentities(insightId, entitlementId, hasEntitlement, offset, limit, count, sorters, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gets role insights information for a role.
         * @summary Get a single role insight
         * @param {string} insightId The role insight id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleInsight(insightId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleInsightBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleInsight(insightId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method returns detailed role insights for each role.
         * @summary Get role insights
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] sort by numberOfUpdates, identitiesWithAccess, totalNumberOfIdentities (default- ascending)
         * @param {string} [filters] Filter parameter(s) by \&quot;starts with\&quot; for the name, ownerName and description.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleInsights(offset?: number, limit?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleInsightBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleInsights(offset, limit, count, sorters, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gets the entitlements for a role. The term \"current\" is to distinguish from the entitlement(s) an insight might recommend adding.
         * @summary Get current entitlement for a role
         * @param {string} insightId The role insight id
         * @param {string} [filters] Filter parameter(s) by \&quot;starts with\&quot; for the name and description.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleInsightsCurrentEntitlements(insightId: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleInsightsEntitlementBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleInsightsCurrentEntitlements(insightId, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns entitlement insights for a role.
         * @summary Get entitlement insights for a role
         * @param {string} insightId The role insight id
         * @param {string} [sorters] sort by identitiesWithAccess or name
         * @param {string} [filters] Filter parameter(s) by \&quot;starts with\&quot; for the name and description.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleInsightsEntitlementsChanges(insightId: string, sorters?: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleInsightsEntitlementChangesBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleInsightsEntitlementsChanges(insightId, sorters, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns details of a prior request.
         * @summary Returns the metadata for a request in order to generate insights for roles.
         * @param {string} id The role insights request id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleInsightsRequests(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleInsightsResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleInsightsRequests(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method returns high level summary information for role insights for a customer.
         * @summary Get role insights summary information
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleInsightsSummary(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleInsightsSummaryBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleInsightsSummary(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RoleInsightsBetaApi - factory interface
 * @export
 */
export const RoleInsightsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoleInsightsBetaApiFp(configuration)
    return {
        /**
         * This submits a create role insights request to the role insights application. At this time there are no parameters. All business roles will be processed for the customer.
         * @summary A request to generate insights for roles
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createRoleInsightRequests(axiosOptions?: any): AxiosPromise<RoleInsightsResponseBeta> {
            return localVarFp.createRoleInsightRequests(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns the entitlement insights for a role.
         * @summary Download entitlement insights for a role
         * @param {string} insightId The role insight id
         * @param {string} [sorters] sort by identitiesWithAccess, default order descending
         * @param {string} [filters] Filter parameter(s) by \&quot;starts with\&quot; for the name and description.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        downloadRoleInsightsEntitlementsChanges(insightId: string, sorters?: string, filters?: string, axiosOptions?: any): AxiosPromise<string> {
            return localVarFp.downloadRoleInsightsEntitlementsChanges(insightId, sorters, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Role insights suggests entitlements to be added for a role. This endpoint returns a list of identities in the role, with or without the entitlements, for a suggested entitlement so that the user can see which identities would be affected if the suggested entitlement were to be added to the role.
         * @summary Get identities for a suggested entitlement (for a role)
         * @param {string} insightId The role insight id
         * @param {string} entitlementId The entitlement id
         * @param {boolean} [hasEntitlement] Identity has this entitlement or not
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] sort by name
         * @param {string} [filters] Filter parameter by \&quot;starts with\&quot; for the name.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getEntitlementChangesIdentities(insightId: string, entitlementId: string, hasEntitlement?: boolean, offset?: number, limit?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: any): AxiosPromise<Array<RoleInsightsIdentitiesBeta>> {
            return localVarFp.getEntitlementChangesIdentities(insightId, entitlementId, hasEntitlement, offset, limit, count, sorters, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gets role insights information for a role.
         * @summary Get a single role insight
         * @param {string} insightId The role insight id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRoleInsight(insightId: string, axiosOptions?: any): AxiosPromise<RoleInsightBeta> {
            return localVarFp.getRoleInsight(insightId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This method returns detailed role insights for each role.
         * @summary Get role insights
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] sort by numberOfUpdates, identitiesWithAccess, totalNumberOfIdentities (default- ascending)
         * @param {string} [filters] Filter parameter(s) by \&quot;starts with\&quot; for the name, ownerName and description.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRoleInsights(offset?: number, limit?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: any): AxiosPromise<Array<RoleInsightBeta>> {
            return localVarFp.getRoleInsights(offset, limit, count, sorters, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gets the entitlements for a role. The term \"current\" is to distinguish from the entitlement(s) an insight might recommend adding.
         * @summary Get current entitlement for a role
         * @param {string} insightId The role insight id
         * @param {string} [filters] Filter parameter(s) by \&quot;starts with\&quot; for the name and description.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRoleInsightsCurrentEntitlements(insightId: string, filters?: string, axiosOptions?: any): AxiosPromise<Array<RoleInsightsEntitlementBeta>> {
            return localVarFp.getRoleInsightsCurrentEntitlements(insightId, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns entitlement insights for a role.
         * @summary Get entitlement insights for a role
         * @param {string} insightId The role insight id
         * @param {string} [sorters] sort by identitiesWithAccess or name
         * @param {string} [filters] Filter parameter(s) by \&quot;starts with\&quot; for the name and description.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRoleInsightsEntitlementsChanges(insightId: string, sorters?: string, filters?: string, axiosOptions?: any): AxiosPromise<Array<RoleInsightsEntitlementChangesBeta>> {
            return localVarFp.getRoleInsightsEntitlementsChanges(insightId, sorters, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns details of a prior request.
         * @summary Returns the metadata for a request in order to generate insights for roles.
         * @param {string} id The role insights request id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRoleInsightsRequests(id: string, axiosOptions?: any): AxiosPromise<RoleInsightsResponseBeta> {
            return localVarFp.getRoleInsightsRequests(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This method returns high level summary information for role insights for a customer.
         * @summary Get role insights summary information
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRoleInsightsSummary(axiosOptions?: any): AxiosPromise<RoleInsightsSummaryBeta> {
            return localVarFp.getRoleInsightsSummary(axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadRoleInsightsEntitlementsChanges operation in RoleInsightsBetaApi.
 * @export
 * @interface RoleInsightsBetaApiDownloadRoleInsightsEntitlementsChangesRequest
 */
export interface RoleInsightsBetaApiDownloadRoleInsightsEntitlementsChangesRequest {
    /**
     * The role insight id
     * @type {string}
     * @memberof RoleInsightsBetaApiDownloadRoleInsightsEntitlementsChanges
     */
    readonly insightId: string

    /**
     * sort by identitiesWithAccess, default order descending
     * @type {string}
     * @memberof RoleInsightsBetaApiDownloadRoleInsightsEntitlementsChanges
     */
    readonly sorters?: string

    /**
     * Filter parameter(s) by \&quot;starts with\&quot; for the name and description.
     * @type {string}
     * @memberof RoleInsightsBetaApiDownloadRoleInsightsEntitlementsChanges
     */
    readonly filters?: string
}

/**
 * Request parameters for getEntitlementChangesIdentities operation in RoleInsightsBetaApi.
 * @export
 * @interface RoleInsightsBetaApiGetEntitlementChangesIdentitiesRequest
 */
export interface RoleInsightsBetaApiGetEntitlementChangesIdentitiesRequest {
    /**
     * The role insight id
     * @type {string}
     * @memberof RoleInsightsBetaApiGetEntitlementChangesIdentities
     */
    readonly insightId: string

    /**
     * The entitlement id
     * @type {string}
     * @memberof RoleInsightsBetaApiGetEntitlementChangesIdentities
     */
    readonly entitlementId: string

    /**
     * Identity has this entitlement or not
     * @type {boolean}
     * @memberof RoleInsightsBetaApiGetEntitlementChangesIdentities
     */
    readonly hasEntitlement?: boolean

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RoleInsightsBetaApiGetEntitlementChangesIdentities
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RoleInsightsBetaApiGetEntitlementChangesIdentities
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof RoleInsightsBetaApiGetEntitlementChangesIdentities
     */
    readonly count?: boolean

    /**
     * sort by name
     * @type {string}
     * @memberof RoleInsightsBetaApiGetEntitlementChangesIdentities
     */
    readonly sorters?: string

    /**
     * Filter parameter by \&quot;starts with\&quot; for the name.
     * @type {string}
     * @memberof RoleInsightsBetaApiGetEntitlementChangesIdentities
     */
    readonly filters?: string
}

/**
 * Request parameters for getRoleInsight operation in RoleInsightsBetaApi.
 * @export
 * @interface RoleInsightsBetaApiGetRoleInsightRequest
 */
export interface RoleInsightsBetaApiGetRoleInsightRequest {
    /**
     * The role insight id
     * @type {string}
     * @memberof RoleInsightsBetaApiGetRoleInsight
     */
    readonly insightId: string
}

/**
 * Request parameters for getRoleInsights operation in RoleInsightsBetaApi.
 * @export
 * @interface RoleInsightsBetaApiGetRoleInsightsRequest
 */
export interface RoleInsightsBetaApiGetRoleInsightsRequest {
    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RoleInsightsBetaApiGetRoleInsights
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RoleInsightsBetaApiGetRoleInsights
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof RoleInsightsBetaApiGetRoleInsights
     */
    readonly count?: boolean

    /**
     * sort by numberOfUpdates, identitiesWithAccess, totalNumberOfIdentities (default- ascending)
     * @type {string}
     * @memberof RoleInsightsBetaApiGetRoleInsights
     */
    readonly sorters?: string

    /**
     * Filter parameter(s) by \&quot;starts with\&quot; for the name, ownerName and description.
     * @type {string}
     * @memberof RoleInsightsBetaApiGetRoleInsights
     */
    readonly filters?: string
}

/**
 * Request parameters for getRoleInsightsCurrentEntitlements operation in RoleInsightsBetaApi.
 * @export
 * @interface RoleInsightsBetaApiGetRoleInsightsCurrentEntitlementsRequest
 */
export interface RoleInsightsBetaApiGetRoleInsightsCurrentEntitlementsRequest {
    /**
     * The role insight id
     * @type {string}
     * @memberof RoleInsightsBetaApiGetRoleInsightsCurrentEntitlements
     */
    readonly insightId: string

    /**
     * Filter parameter(s) by \&quot;starts with\&quot; for the name and description.
     * @type {string}
     * @memberof RoleInsightsBetaApiGetRoleInsightsCurrentEntitlements
     */
    readonly filters?: string
}

/**
 * Request parameters for getRoleInsightsEntitlementsChanges operation in RoleInsightsBetaApi.
 * @export
 * @interface RoleInsightsBetaApiGetRoleInsightsEntitlementsChangesRequest
 */
export interface RoleInsightsBetaApiGetRoleInsightsEntitlementsChangesRequest {
    /**
     * The role insight id
     * @type {string}
     * @memberof RoleInsightsBetaApiGetRoleInsightsEntitlementsChanges
     */
    readonly insightId: string

    /**
     * sort by identitiesWithAccess or name
     * @type {string}
     * @memberof RoleInsightsBetaApiGetRoleInsightsEntitlementsChanges
     */
    readonly sorters?: string

    /**
     * Filter parameter(s) by \&quot;starts with\&quot; for the name and description.
     * @type {string}
     * @memberof RoleInsightsBetaApiGetRoleInsightsEntitlementsChanges
     */
    readonly filters?: string
}

/**
 * Request parameters for getRoleInsightsRequests operation in RoleInsightsBetaApi.
 * @export
 * @interface RoleInsightsBetaApiGetRoleInsightsRequestsRequest
 */
export interface RoleInsightsBetaApiGetRoleInsightsRequestsRequest {
    /**
     * The role insights request id
     * @type {string}
     * @memberof RoleInsightsBetaApiGetRoleInsightsRequests
     */
    readonly id: string
}

/**
 * RoleInsightsBetaApi - object-oriented interface
 * @export
 * @class RoleInsightsBetaApi
 * @extends {BaseAPI}
 */
export class RoleInsightsBetaApi extends BaseAPI {
    /**
     * This submits a create role insights request to the role insights application. At this time there are no parameters. All business roles will be processed for the customer.
     * @summary A request to generate insights for roles
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleInsightsBetaApi
     */
    public createRoleInsightRequests(axiosOptions?: AxiosRequestConfig) {
        return RoleInsightsBetaApiFp(this.configuration).createRoleInsightRequests(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns the entitlement insights for a role.
     * @summary Download entitlement insights for a role
     * @param {RoleInsightsBetaApiDownloadRoleInsightsEntitlementsChangesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleInsightsBetaApi
     */
    public downloadRoleInsightsEntitlementsChanges(requestParameters: RoleInsightsBetaApiDownloadRoleInsightsEntitlementsChangesRequest, axiosOptions?: AxiosRequestConfig) {
        return RoleInsightsBetaApiFp(this.configuration).downloadRoleInsightsEntitlementsChanges(requestParameters.insightId, requestParameters.sorters, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Role insights suggests entitlements to be added for a role. This endpoint returns a list of identities in the role, with or without the entitlements, for a suggested entitlement so that the user can see which identities would be affected if the suggested entitlement were to be added to the role.
     * @summary Get identities for a suggested entitlement (for a role)
     * @param {RoleInsightsBetaApiGetEntitlementChangesIdentitiesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleInsightsBetaApi
     */
    public getEntitlementChangesIdentities(requestParameters: RoleInsightsBetaApiGetEntitlementChangesIdentitiesRequest, axiosOptions?: AxiosRequestConfig) {
        return RoleInsightsBetaApiFp(this.configuration).getEntitlementChangesIdentities(requestParameters.insightId, requestParameters.entitlementId, requestParameters.hasEntitlement, requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.sorters, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gets role insights information for a role.
     * @summary Get a single role insight
     * @param {RoleInsightsBetaApiGetRoleInsightRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleInsightsBetaApi
     */
    public getRoleInsight(requestParameters: RoleInsightsBetaApiGetRoleInsightRequest, axiosOptions?: AxiosRequestConfig) {
        return RoleInsightsBetaApiFp(this.configuration).getRoleInsight(requestParameters.insightId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method returns detailed role insights for each role.
     * @summary Get role insights
     * @param {RoleInsightsBetaApiGetRoleInsightsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleInsightsBetaApi
     */
    public getRoleInsights(requestParameters: RoleInsightsBetaApiGetRoleInsightsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return RoleInsightsBetaApiFp(this.configuration).getRoleInsights(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.sorters, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gets the entitlements for a role. The term \"current\" is to distinguish from the entitlement(s) an insight might recommend adding.
     * @summary Get current entitlement for a role
     * @param {RoleInsightsBetaApiGetRoleInsightsCurrentEntitlementsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleInsightsBetaApi
     */
    public getRoleInsightsCurrentEntitlements(requestParameters: RoleInsightsBetaApiGetRoleInsightsCurrentEntitlementsRequest, axiosOptions?: AxiosRequestConfig) {
        return RoleInsightsBetaApiFp(this.configuration).getRoleInsightsCurrentEntitlements(requestParameters.insightId, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns entitlement insights for a role.
     * @summary Get entitlement insights for a role
     * @param {RoleInsightsBetaApiGetRoleInsightsEntitlementsChangesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleInsightsBetaApi
     */
    public getRoleInsightsEntitlementsChanges(requestParameters: RoleInsightsBetaApiGetRoleInsightsEntitlementsChangesRequest, axiosOptions?: AxiosRequestConfig) {
        return RoleInsightsBetaApiFp(this.configuration).getRoleInsightsEntitlementsChanges(requestParameters.insightId, requestParameters.sorters, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns details of a prior request.
     * @summary Returns the metadata for a request in order to generate insights for roles.
     * @param {RoleInsightsBetaApiGetRoleInsightsRequestsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleInsightsBetaApi
     */
    public getRoleInsightsRequests(requestParameters: RoleInsightsBetaApiGetRoleInsightsRequestsRequest, axiosOptions?: AxiosRequestConfig) {
        return RoleInsightsBetaApiFp(this.configuration).getRoleInsightsRequests(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method returns high level summary information for role insights for a customer.
     * @summary Get role insights summary information
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleInsightsBetaApi
     */
    public getRoleInsightsSummary(axiosOptions?: AxiosRequestConfig) {
        return RoleInsightsBetaApiFp(this.configuration).getRoleInsightsSummary(axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RolesBetaApi - axios parameter creator
 * @export
 */
export const RolesBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API initiates a bulk deletion of one or more Roles.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Roles included in the request are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Delete Role(s)
         * @param {RoleBulkDeleteRequestBeta} roleBulkDeleteRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteRoles: async (roleBulkDeleteRequestBeta: RoleBulkDeleteRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleBulkDeleteRequestBeta' is not null or undefined
            assertParamExists('bulkDeleteRoles', 'roleBulkDeleteRequestBeta', roleBulkDeleteRequestBeta)
            const localVarPath = `/roles/bulk-delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleBulkDeleteRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API creates a role. You must have a token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority to call this API.  In addition, a ROLE_SUBADMIN may not create a role including an access profile if that access profile is associated with a source the ROLE_SUBADMIN is not associated with themselves.  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles. However, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Create a Role
         * @param {RoleBeta} roleBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createRole: async (roleBeta: RoleBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleBeta' is not null or undefined
            assertParamExists('createRole', 'roleBeta', roleBeta)
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API deletes a Role by its ID. A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Delete a Role
         * @param {string} id ID of the Role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRole', 'id', id)
            const localVarPath = `/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a Role by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Get a Role
         * @param {string} id ID of the Role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRole: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRole', 'id', id)
            const localVarPath = `/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Identities assigned a Role
         * @param {string} id ID of the Role for which the assigned Identities are to be listed
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **aliasName**: *eq, sw*  **email**: *eq, sw*  **name**: *eq, sw, co*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **aliasName**, **email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRoleAssignedIdentities: async (id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRoleAssignedIdentities', 'id', id)
            const localVarPath = `/roles/{id}/assigned-identities`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of Roles.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary List Roles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID. A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **id**: *eq, in* **name**: *eq, sw* **created, modified**: *gt, lt, ge, le* **owner.id**: *eq, in* **requestable**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters Roles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Whether or not the response list should contain unsegmented Roles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listRoles: async (forSubadmin?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSegmentIds?: string, includeUnsegmented?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (forSubadmin !== undefined) {
                localVarQueryParameter['for-subadmin'] = forSubadmin;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (forSegmentIds !== undefined) {
                localVarQueryParameter['for-segment-ids'] = forSegmentIds;
            }

            if (includeUnsegmented !== undefined) {
                localVarQueryParameter['include-unsegmented'] = includeUnsegmented;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates an existing Role using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.  The following fields are patchable: **name**, **description**, **enabled**, **owner**, **accessProfiles**, **membership**, **requestable**, **accessRequestConfig**, **revokeRequestConfig**, **segments** A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles, however, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Patch a specified Role
         * @param {string} id ID of the Role to patch
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchRole: async (id: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchRole', 'id', id)
            // verify required parameter 'jsonPatchOperationBeta' is not null or undefined
            assertParamExists('patchRole', 'jsonPatchOperationBeta', jsonPatchOperationBeta)
            const localVarPath = `/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperationBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesBetaApi - functional programming interface
 * @export
 */
export const RolesBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RolesBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This API initiates a bulk deletion of one or more Roles.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Roles included in the request are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Delete Role(s)
         * @param {RoleBulkDeleteRequestBeta} roleBulkDeleteRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async bulkDeleteRoles(roleBulkDeleteRequestBeta: RoleBulkDeleteRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseReferenceDto1Beta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkDeleteRoles(roleBulkDeleteRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API creates a role. You must have a token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority to call this API.  In addition, a ROLE_SUBADMIN may not create a role including an access profile if that access profile is associated with a source the ROLE_SUBADMIN is not associated with themselves.  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles. However, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Create a Role
         * @param {RoleBeta} roleBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createRole(roleBeta: RoleBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRole(roleBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API deletes a Role by its ID. A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Delete a Role
         * @param {string} id ID of the Role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRole(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRole(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a Role by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Get a Role
         * @param {string} id ID of the Role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getRole(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRole(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Identities assigned a Role
         * @param {string} id ID of the Role for which the assigned Identities are to be listed
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **aliasName**: *eq, sw*  **email**: *eq, sw*  **name**: *eq, sw, co*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **aliasName**, **email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleAssignedIdentities(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleIdentityBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleAssignedIdentities(id, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of Roles.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary List Roles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID. A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **id**: *eq, in* **name**: *eq, sw* **created, modified**: *gt, lt, ge, le* **owner.id**: *eq, in* **requestable**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters Roles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Whether or not the response list should contain unsegmented Roles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listRoles(forSubadmin?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSegmentIds?: string, includeUnsegmented?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoles(forSubadmin, limit, offset, count, filters, sorters, forSegmentIds, includeUnsegmented, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API updates an existing Role using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.  The following fields are patchable: **name**, **description**, **enabled**, **owner**, **accessProfiles**, **membership**, **requestable**, **accessRequestConfig**, **revokeRequestConfig**, **segments** A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles, however, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Patch a specified Role
         * @param {string} id ID of the Role to patch
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchRole(id: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchRole(id, jsonPatchOperationBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RolesBetaApi - factory interface
 * @export
 */
export const RolesBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RolesBetaApiFp(configuration)
    return {
        /**
         * This API initiates a bulk deletion of one or more Roles.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Roles included in the request are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Delete Role(s)
         * @param {RoleBulkDeleteRequestBeta} roleBulkDeleteRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteRoles(roleBulkDeleteRequestBeta: RoleBulkDeleteRequestBeta, axiosOptions?: any): AxiosPromise<BaseReferenceDto1Beta> {
            return localVarFp.bulkDeleteRoles(roleBulkDeleteRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API creates a role. You must have a token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority to call this API.  In addition, a ROLE_SUBADMIN may not create a role including an access profile if that access profile is associated with a source the ROLE_SUBADMIN is not associated with themselves.  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles. However, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Create a Role
         * @param {RoleBeta} roleBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createRole(roleBeta: RoleBeta, axiosOptions?: any): AxiosPromise<RoleBeta> {
            return localVarFp.createRole(roleBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API deletes a Role by its ID. A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Delete a Role
         * @param {string} id ID of the Role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteRole(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a Role by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Get a Role
         * @param {string} id ID of the Role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRole(id: string, axiosOptions?: any): AxiosPromise<RoleBeta> {
            return localVarFp.getRole(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Identities assigned a Role
         * @param {string} id ID of the Role for which the assigned Identities are to be listed
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **aliasName**: *eq, sw*  **email**: *eq, sw*  **name**: *eq, sw, co*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **aliasName**, **email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRoleAssignedIdentities(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<RoleIdentityBeta>> {
            return localVarFp.getRoleAssignedIdentities(id, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of Roles.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary List Roles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID. A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **id**: *eq, in* **name**: *eq, sw* **created, modified**: *gt, lt, ge, le* **owner.id**: *eq, in* **requestable**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters Roles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Whether or not the response list should contain unsegmented Roles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(forSubadmin?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSegmentIds?: string, includeUnsegmented?: boolean, axiosOptions?: any): AxiosPromise<Array<RoleBeta>> {
            return localVarFp.listRoles(forSubadmin, limit, offset, count, filters, sorters, forSegmentIds, includeUnsegmented, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates an existing Role using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.  The following fields are patchable: **name**, **description**, **enabled**, **owner**, **accessProfiles**, **membership**, **requestable**, **accessRequestConfig**, **revokeRequestConfig**, **segments** A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles, however, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Patch a specified Role
         * @param {string} id ID of the Role to patch
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchRole(id: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: any): AxiosPromise<RoleBeta> {
            return localVarFp.patchRole(id, jsonPatchOperationBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for bulkDeleteRoles operation in RolesBetaApi.
 * @export
 * @interface RolesBetaApiBulkDeleteRolesRequest
 */
export interface RolesBetaApiBulkDeleteRolesRequest {
    /**
     * 
     * @type {RoleBulkDeleteRequestBeta}
     * @memberof RolesBetaApiBulkDeleteRoles
     */
    readonly roleBulkDeleteRequestBeta: RoleBulkDeleteRequestBeta
}

/**
 * Request parameters for createRole operation in RolesBetaApi.
 * @export
 * @interface RolesBetaApiCreateRoleRequest
 */
export interface RolesBetaApiCreateRoleRequest {
    /**
     * 
     * @type {RoleBeta}
     * @memberof RolesBetaApiCreateRole
     */
    readonly roleBeta: RoleBeta
}

/**
 * Request parameters for deleteRole operation in RolesBetaApi.
 * @export
 * @interface RolesBetaApiDeleteRoleRequest
 */
export interface RolesBetaApiDeleteRoleRequest {
    /**
     * ID of the Role
     * @type {string}
     * @memberof RolesBetaApiDeleteRole
     */
    readonly id: string
}

/**
 * Request parameters for getRole operation in RolesBetaApi.
 * @export
 * @interface RolesBetaApiGetRoleRequest
 */
export interface RolesBetaApiGetRoleRequest {
    /**
     * ID of the Role
     * @type {string}
     * @memberof RolesBetaApiGetRole
     */
    readonly id: string
}

/**
 * Request parameters for getRoleAssignedIdentities operation in RolesBetaApi.
 * @export
 * @interface RolesBetaApiGetRoleAssignedIdentitiesRequest
 */
export interface RolesBetaApiGetRoleAssignedIdentitiesRequest {
    /**
     * ID of the Role for which the assigned Identities are to be listed
     * @type {string}
     * @memberof RolesBetaApiGetRoleAssignedIdentities
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RolesBetaApiGetRoleAssignedIdentities
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RolesBetaApiGetRoleAssignedIdentities
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof RolesBetaApiGetRoleAssignedIdentities
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **aliasName**: *eq, sw*  **email**: *eq, sw*  **name**: *eq, sw, co*
     * @type {string}
     * @memberof RolesBetaApiGetRoleAssignedIdentities
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **aliasName**, **email**
     * @type {string}
     * @memberof RolesBetaApiGetRoleAssignedIdentities
     */
    readonly sorters?: string
}

/**
 * Request parameters for listRoles operation in RolesBetaApi.
 * @export
 * @interface RolesBetaApiListRolesRequest
 */
export interface RolesBetaApiListRolesRequest {
    /**
     * If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID. A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
     * @type {string}
     * @memberof RolesBetaApiListRoles
     */
    readonly forSubadmin?: string

    /**
     * Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RolesBetaApiListRoles
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RolesBetaApiListRoles
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof RolesBetaApiListRoles
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **id**: *eq, in* **name**: *eq, sw* **created, modified**: *gt, lt, ge, le* **owner.id**: *eq, in* **requestable**: *eq*
     * @type {string}
     * @memberof RolesBetaApiListRoles
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **name, created, modified**
     * @type {string}
     * @memberof RolesBetaApiListRoles
     */
    readonly sorters?: string

    /**
     * If present and not empty, additionally filters Roles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
     * @type {string}
     * @memberof RolesBetaApiListRoles
     */
    readonly forSegmentIds?: string

    /**
     * Whether or not the response list should contain unsegmented Roles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
     * @type {boolean}
     * @memberof RolesBetaApiListRoles
     */
    readonly includeUnsegmented?: boolean
}

/**
 * Request parameters for patchRole operation in RolesBetaApi.
 * @export
 * @interface RolesBetaApiPatchRoleRequest
 */
export interface RolesBetaApiPatchRoleRequest {
    /**
     * ID of the Role to patch
     * @type {string}
     * @memberof RolesBetaApiPatchRole
     */
    readonly id: string

    /**
     * 
     * @type {Array<JsonPatchOperationBeta>}
     * @memberof RolesBetaApiPatchRole
     */
    readonly jsonPatchOperationBeta: Array<JsonPatchOperationBeta>
}

/**
 * RolesBetaApi - object-oriented interface
 * @export
 * @class RolesBetaApi
 * @extends {BaseAPI}
 */
export class RolesBetaApi extends BaseAPI {
    /**
     * This API initiates a bulk deletion of one or more Roles.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Roles included in the request are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
     * @summary Delete Role(s)
     * @param {RolesBetaApiBulkDeleteRolesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesBetaApi
     */
    public bulkDeleteRoles(requestParameters: RolesBetaApiBulkDeleteRolesRequest, axiosOptions?: AxiosRequestConfig) {
        return RolesBetaApiFp(this.configuration).bulkDeleteRoles(requestParameters.roleBulkDeleteRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API creates a role. You must have a token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority to call this API.  In addition, a ROLE_SUBADMIN may not create a role including an access profile if that access profile is associated with a source the ROLE_SUBADMIN is not associated with themselves.  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles. However, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
     * @summary Create a Role
     * @param {RolesBetaApiCreateRoleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesBetaApi
     */
    public createRole(requestParameters: RolesBetaApiCreateRoleRequest, axiosOptions?: AxiosRequestConfig) {
        return RolesBetaApiFp(this.configuration).createRole(requestParameters.roleBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API deletes a Role by its ID. A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
     * @summary Delete a Role
     * @param {RolesBetaApiDeleteRoleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesBetaApi
     */
    public deleteRole(requestParameters: RolesBetaApiDeleteRoleRequest, axiosOptions?: AxiosRequestConfig) {
        return RolesBetaApiFp(this.configuration).deleteRole(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a Role by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
     * @summary Get a Role
     * @param {RolesBetaApiGetRoleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesBetaApi
     */
    public getRole(requestParameters: RolesBetaApiGetRoleRequest, axiosOptions?: AxiosRequestConfig) {
        return RolesBetaApiFp(this.configuration).getRole(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Identities assigned a Role
     * @param {RolesBetaApiGetRoleAssignedIdentitiesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesBetaApi
     */
    public getRoleAssignedIdentities(requestParameters: RolesBetaApiGetRoleAssignedIdentitiesRequest, axiosOptions?: AxiosRequestConfig) {
        return RolesBetaApiFp(this.configuration).getRoleAssignedIdentities(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of Roles.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API.
     * @summary List Roles
     * @param {RolesBetaApiListRolesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesBetaApi
     */
    public listRoles(requestParameters: RolesBetaApiListRolesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return RolesBetaApiFp(this.configuration).listRoles(requestParameters.forSubadmin, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.forSegmentIds, requestParameters.includeUnsegmented, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates an existing Role using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.  The following fields are patchable: **name**, **description**, **enabled**, **owner**, **accessProfiles**, **membership**, **requestable**, **accessRequestConfig**, **revokeRequestConfig**, **segments** A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles, however, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
     * @summary Patch a specified Role
     * @param {RolesBetaApiPatchRoleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesBetaApi
     */
    public patchRole(requestParameters: RolesBetaApiPatchRoleRequest, axiosOptions?: AxiosRequestConfig) {
        return RolesBetaApiFp(this.configuration).patchRole(requestParameters.id, requestParameters.jsonPatchOperationBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SODPolicyBetaApi - axios parameter creator
 * @export
 */
export const SODPolicyBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This creates both General and Conflicting Access Based policy, with a limit of 50 entitlements for each (left & right) criteria for Conflicting Access Based SOD policy. Requires role of ORG_ADMIN.
         * @summary Create SOD policy
         * @param {SodPolicyBeta} sodPolicyBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSodPolicy: async (sodPolicyBeta: SodPolicyBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sodPolicyBeta' is not null or undefined
            assertParamExists('createSodPolicy', 'sodPolicyBeta', sodPolicyBeta)
            const localVarPath = `/sod-policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sodPolicyBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This deletes a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Delete SOD policy by ID
         * @param {string} id The ID of the SOD Policy to delete.
         * @param {boolean} [logical] Indicates whether this is a soft delete (logical true) or a hard delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSodPolicy: async (id: string, logical?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSodPolicy', 'id', id)
            const localVarPath = `/sod-policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (logical !== undefined) {
                localVarQueryParameter['logical'] = logical;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This deletes schedule for a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Delete SOD policy schedule
         * @param {string} id The ID of the SOD policy the schedule must be deleted for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSodPolicySchedule: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSodPolicySchedule', 'id', id)
            const localVarPath = `/sod-policies/{id}/schedule`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This allows to download a specified named violation report for a given report reference. Requires role of ORG_ADMIN.
         * @summary Download custom violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {string} fileName Custom Name for the  file.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        downloadCustomViolationReport: async (reportResultId: string, fileName: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportResultId' is not null or undefined
            assertParamExists('downloadCustomViolationReport', 'reportResultId', reportResultId)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('downloadCustomViolationReport', 'fileName', fileName)
            const localVarPath = `/sod-violation-report/{reportResultId}/download/{fileName}`
                .replace(`{${"reportResultId"}}`, encodeURIComponent(String(reportResultId)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This allows to download a violation report for a given report reference. Requires role of ORG_ADMIN.
         * @summary Download violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        downloadDefaultViolationReport: async (reportResultId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportResultId' is not null or undefined
            assertParamExists('downloadDefaultViolationReport', 'reportResultId', reportResultId)
            const localVarPath = `/sod-violation-report/{reportResultId}/download`
                .replace(`{${"reportResultId"}}`, encodeURIComponent(String(reportResultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gets the status for a violation report for all policy run. Requires role of ORG_ADMIN.
         * @summary Get multi-report run task status
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodAllReportRunStatus: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sod-violation-report`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Get SOD policy by ID
         * @param {string} id The ID of the object reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodPolicy: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSodPolicy', 'id', id)
            const localVarPath = `/sod-policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gets a specified SOD policy\'s schedule. Requires the role of ORG_ADMIN.
         * @summary Get SOD policy schedule
         * @param {string} id The ID of the object reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodPolicySchedule: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSodPolicySchedule', 'id', id)
            const localVarPath = `/sod-policies/{id}/schedule`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets the status for a violation report run task that has already been invoked. Requires role of ORG_ADMIN.
         * @summary Get violation report run status
         * @param {string} reportResultId The ID of the report reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodViolationReportRunStatus: async (reportResultId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportResultId' is not null or undefined
            assertParamExists('getSodViolationReportRunStatus', 'reportResultId', reportResultId)
            const localVarPath = `/sod-policies/sod-violation-report-status/{reportResultId}`
                .replace(`{${"reportResultId"}}`, encodeURIComponent(String(reportResultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets the status for a violation report run task that has already been invoked. Requires role of ORG_ADMIN.
         * @summary Get SOD violation report status
         * @param {string} id The ID of the object reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodViolationReportStatus: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSodViolationReportStatus', 'id', id)
            const localVarPath = `/sod-policies/{id}/violation-report`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets list of all SOD policies. Requires role of ORG_ADMIN
         * @summary List SOD policies
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*  **name**: *eq*  **state**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSodPolicies: async (limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sod-policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Allows updating SOD Policy fields other than [\"id\",\"created\",\"creatorId\",\"policyQuery\",\"type\"] using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Requires role of ORG_ADMIN. This endpoint can only patch CONFLICTING_ACCESS_BASED type policies. Do not use this endpoint to patch general policies - doing so will build an API exception. 
         * @summary Patch a SOD policy
         * @param {string} id The ID of the SOD policy being modified.
         * @param {Array<object>} requestBody A list of SOD Policy update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * ownerRef * externalPolicyReference * compensatingControls * correctionAdvice * state * tags * violationOwnerAssignmentConfig * scheduled * conflictingAccessCriteria 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSodPolicy: async (id: string, requestBody: Array<object>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchSodPolicy', 'id', id)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('patchSodPolicy', 'requestBody', requestBody)
            const localVarPath = `/sod-policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Runs multi-policy report for the org. If a policy reports more than 5000 violations, the report mentions that the violation limit was exceeded for that policy. If the request is empty, the report runs for all policies. Otherwise, the report runs for only the filtered policy list provided. Requires role of ORG_ADMIN.
         * @summary Runs all policies for org
         * @param {MultiPolicyRequestBeta} [multiPolicyRequestBeta] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        runSodAllPoliciesForOrg: async (multiPolicyRequestBeta?: MultiPolicyRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sod-violation-report/run`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(multiPolicyRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This invokes processing of violation report for given SOD policy. If the policy reports more than 5000 violations, the report returns with violation limit exceeded message. Requires role of ORG_ADMIN.
         * @summary Runs SOD policy violation report
         * @param {string} id The SOD policy ID to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        runSodPolicy: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('runSodPolicy', 'id', id)
            const localVarPath = `/sod-policies/{id}/violation-report/run`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This updates schedule for a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Update SOD Policy schedule
         * @param {string} id The ID of the SOD policy to update its schedule.
         * @param {SodPolicyScheduleBeta} sodPolicyScheduleBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicySchedule: async (id: string, sodPolicyScheduleBeta: SodPolicyScheduleBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePolicySchedule', 'id', id)
            // verify required parameter 'sodPolicyScheduleBeta' is not null or undefined
            assertParamExists('updatePolicySchedule', 'sodPolicyScheduleBeta', sodPolicyScheduleBeta)
            const localVarPath = `/sod-policies/{id}/schedule`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sodPolicyScheduleBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This updates a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Update SOD policy by ID
         * @param {string} id The ID of the SOD policy to update.
         * @param {SodPolicyBeta} sodPolicyBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSodPolicy: async (id: string, sodPolicyBeta: SodPolicyBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSodPolicy', 'id', id)
            // verify required parameter 'sodPolicyBeta' is not null or undefined
            assertParamExists('updateSodPolicy', 'sodPolicyBeta', sodPolicyBeta)
            const localVarPath = `/sod-policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sodPolicyBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SODPolicyBetaApi - functional programming interface
 * @export
 */
export const SODPolicyBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SODPolicyBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This creates both General and Conflicting Access Based policy, with a limit of 50 entitlements for each (left & right) criteria for Conflicting Access Based SOD policy. Requires role of ORG_ADMIN.
         * @summary Create SOD policy
         * @param {SodPolicyBeta} sodPolicyBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSodPolicy(sodPolicyBeta: SodPolicyBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodPolicyBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSodPolicy(sodPolicyBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This deletes a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Delete SOD policy by ID
         * @param {string} id The ID of the SOD Policy to delete.
         * @param {boolean} [logical] Indicates whether this is a soft delete (logical true) or a hard delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSodPolicy(id: string, logical?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSodPolicy(id, logical, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This deletes schedule for a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Delete SOD policy schedule
         * @param {string} id The ID of the SOD policy the schedule must be deleted for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSodPolicySchedule(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSodPolicySchedule(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This allows to download a specified named violation report for a given report reference. Requires role of ORG_ADMIN.
         * @summary Download custom violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {string} fileName Custom Name for the  file.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async downloadCustomViolationReport(reportResultId: string, fileName: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadCustomViolationReport(reportResultId, fileName, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This allows to download a violation report for a given report reference. Requires role of ORG_ADMIN.
         * @summary Download violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async downloadDefaultViolationReport(reportResultId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadDefaultViolationReport(reportResultId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gets the status for a violation report for all policy run. Requires role of ORG_ADMIN.
         * @summary Get multi-report run task status
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSodAllReportRunStatus(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResultReferenceBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSodAllReportRunStatus(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Get SOD policy by ID
         * @param {string} id The ID of the object reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSodPolicy(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodPolicyBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSodPolicy(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gets a specified SOD policy\'s schedule. Requires the role of ORG_ADMIN.
         * @summary Get SOD policy schedule
         * @param {string} id The ID of the object reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSodPolicySchedule(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodPolicyScheduleBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSodPolicySchedule(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets the status for a violation report run task that has already been invoked. Requires role of ORG_ADMIN.
         * @summary Get violation report run status
         * @param {string} reportResultId The ID of the report reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSodViolationReportRunStatus(reportResultId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResultReferenceBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSodViolationReportRunStatus(reportResultId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets the status for a violation report run task that has already been invoked. Requires role of ORG_ADMIN.
         * @summary Get SOD violation report status
         * @param {string} id The ID of the object reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSodViolationReportStatus(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResultReferenceBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSodViolationReportStatus(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets list of all SOD policies. Requires role of ORG_ADMIN
         * @summary List SOD policies
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*  **name**: *eq*  **state**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listSodPolicies(limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SodPolicyBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSodPolicies(limit, offset, count, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allows updating SOD Policy fields other than [\"id\",\"created\",\"creatorId\",\"policyQuery\",\"type\"] using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Requires role of ORG_ADMIN. This endpoint can only patch CONFLICTING_ACCESS_BASED type policies. Do not use this endpoint to patch general policies - doing so will build an API exception. 
         * @summary Patch a SOD policy
         * @param {string} id The ID of the SOD policy being modified.
         * @param {Array<object>} requestBody A list of SOD Policy update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * ownerRef * externalPolicyReference * compensatingControls * correctionAdvice * state * tags * violationOwnerAssignmentConfig * scheduled * conflictingAccessCriteria 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchSodPolicy(id: string, requestBody: Array<object>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodPolicyBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchSodPolicy(id, requestBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Runs multi-policy report for the org. If a policy reports more than 5000 violations, the report mentions that the violation limit was exceeded for that policy. If the request is empty, the report runs for all policies. Otherwise, the report runs for only the filtered policy list provided. Requires role of ORG_ADMIN.
         * @summary Runs all policies for org
         * @param {MultiPolicyRequestBeta} [multiPolicyRequestBeta] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async runSodAllPoliciesForOrg(multiPolicyRequestBeta?: MultiPolicyRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResultReferenceBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runSodAllPoliciesForOrg(multiPolicyRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This invokes processing of violation report for given SOD policy. If the policy reports more than 5000 violations, the report returns with violation limit exceeded message. Requires role of ORG_ADMIN.
         * @summary Runs SOD policy violation report
         * @param {string} id The SOD policy ID to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async runSodPolicy(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResultReferenceBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runSodPolicy(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This updates schedule for a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Update SOD Policy schedule
         * @param {string} id The ID of the SOD policy to update its schedule.
         * @param {SodPolicyScheduleBeta} sodPolicyScheduleBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updatePolicySchedule(id: string, sodPolicyScheduleBeta: SodPolicyScheduleBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodPolicyScheduleBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePolicySchedule(id, sodPolicyScheduleBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This updates a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Update SOD policy by ID
         * @param {string} id The ID of the SOD policy to update.
         * @param {SodPolicyBeta} sodPolicyBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateSodPolicy(id: string, sodPolicyBeta: SodPolicyBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodPolicyBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSodPolicy(id, sodPolicyBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SODPolicyBetaApi - factory interface
 * @export
 */
export const SODPolicyBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SODPolicyBetaApiFp(configuration)
    return {
        /**
         * This creates both General and Conflicting Access Based policy, with a limit of 50 entitlements for each (left & right) criteria for Conflicting Access Based SOD policy. Requires role of ORG_ADMIN.
         * @summary Create SOD policy
         * @param {SodPolicyBeta} sodPolicyBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSodPolicy(sodPolicyBeta: SodPolicyBeta, axiosOptions?: any): AxiosPromise<SodPolicyBeta> {
            return localVarFp.createSodPolicy(sodPolicyBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This deletes a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Delete SOD policy by ID
         * @param {string} id The ID of the SOD Policy to delete.
         * @param {boolean} [logical] Indicates whether this is a soft delete (logical true) or a hard delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSodPolicy(id: string, logical?: boolean, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteSodPolicy(id, logical, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This deletes schedule for a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Delete SOD policy schedule
         * @param {string} id The ID of the SOD policy the schedule must be deleted for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSodPolicySchedule(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteSodPolicySchedule(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This allows to download a specified named violation report for a given report reference. Requires role of ORG_ADMIN.
         * @summary Download custom violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {string} fileName Custom Name for the  file.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        downloadCustomViolationReport(reportResultId: string, fileName: string, axiosOptions?: any): AxiosPromise<any> {
            return localVarFp.downloadCustomViolationReport(reportResultId, fileName, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This allows to download a violation report for a given report reference. Requires role of ORG_ADMIN.
         * @summary Download violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        downloadDefaultViolationReport(reportResultId: string, axiosOptions?: any): AxiosPromise<any> {
            return localVarFp.downloadDefaultViolationReport(reportResultId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gets the status for a violation report for all policy run. Requires role of ORG_ADMIN.
         * @summary Get multi-report run task status
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodAllReportRunStatus(axiosOptions?: any): AxiosPromise<ReportResultReferenceBeta> {
            return localVarFp.getSodAllReportRunStatus(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Get SOD policy by ID
         * @param {string} id The ID of the object reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodPolicy(id: string, axiosOptions?: any): AxiosPromise<SodPolicyBeta> {
            return localVarFp.getSodPolicy(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gets a specified SOD policy\'s schedule. Requires the role of ORG_ADMIN.
         * @summary Get SOD policy schedule
         * @param {string} id The ID of the object reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodPolicySchedule(id: string, axiosOptions?: any): AxiosPromise<SodPolicyScheduleBeta> {
            return localVarFp.getSodPolicySchedule(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets the status for a violation report run task that has already been invoked. Requires role of ORG_ADMIN.
         * @summary Get violation report run status
         * @param {string} reportResultId The ID of the report reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodViolationReportRunStatus(reportResultId: string, axiosOptions?: any): AxiosPromise<ReportResultReferenceBeta> {
            return localVarFp.getSodViolationReportRunStatus(reportResultId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets the status for a violation report run task that has already been invoked. Requires role of ORG_ADMIN.
         * @summary Get SOD violation report status
         * @param {string} id The ID of the object reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodViolationReportStatus(id: string, axiosOptions?: any): AxiosPromise<ReportResultReferenceBeta> {
            return localVarFp.getSodViolationReportStatus(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets list of all SOD policies. Requires role of ORG_ADMIN
         * @summary List SOD policies
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*  **name**: *eq*  **state**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSodPolicies(limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: any): AxiosPromise<Array<SodPolicyBeta>> {
            return localVarFp.listSodPolicies(limit, offset, count, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Allows updating SOD Policy fields other than [\"id\",\"created\",\"creatorId\",\"policyQuery\",\"type\"] using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Requires role of ORG_ADMIN. This endpoint can only patch CONFLICTING_ACCESS_BASED type policies. Do not use this endpoint to patch general policies - doing so will build an API exception. 
         * @summary Patch a SOD policy
         * @param {string} id The ID of the SOD policy being modified.
         * @param {Array<object>} requestBody A list of SOD Policy update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * ownerRef * externalPolicyReference * compensatingControls * correctionAdvice * state * tags * violationOwnerAssignmentConfig * scheduled * conflictingAccessCriteria 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSodPolicy(id: string, requestBody: Array<object>, axiosOptions?: any): AxiosPromise<SodPolicyBeta> {
            return localVarFp.patchSodPolicy(id, requestBody, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Runs multi-policy report for the org. If a policy reports more than 5000 violations, the report mentions that the violation limit was exceeded for that policy. If the request is empty, the report runs for all policies. Otherwise, the report runs for only the filtered policy list provided. Requires role of ORG_ADMIN.
         * @summary Runs all policies for org
         * @param {MultiPolicyRequestBeta} [multiPolicyRequestBeta] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        runSodAllPoliciesForOrg(multiPolicyRequestBeta?: MultiPolicyRequestBeta, axiosOptions?: any): AxiosPromise<ReportResultReferenceBeta> {
            return localVarFp.runSodAllPoliciesForOrg(multiPolicyRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This invokes processing of violation report for given SOD policy. If the policy reports more than 5000 violations, the report returns with violation limit exceeded message. Requires role of ORG_ADMIN.
         * @summary Runs SOD policy violation report
         * @param {string} id The SOD policy ID to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        runSodPolicy(id: string, axiosOptions?: any): AxiosPromise<ReportResultReferenceBeta> {
            return localVarFp.runSodPolicy(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This updates schedule for a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Update SOD Policy schedule
         * @param {string} id The ID of the SOD policy to update its schedule.
         * @param {SodPolicyScheduleBeta} sodPolicyScheduleBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicySchedule(id: string, sodPolicyScheduleBeta: SodPolicyScheduleBeta, axiosOptions?: any): AxiosPromise<SodPolicyScheduleBeta> {
            return localVarFp.updatePolicySchedule(id, sodPolicyScheduleBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This updates a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Update SOD policy by ID
         * @param {string} id The ID of the SOD policy to update.
         * @param {SodPolicyBeta} sodPolicyBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSodPolicy(id: string, sodPolicyBeta: SodPolicyBeta, axiosOptions?: any): AxiosPromise<SodPolicyBeta> {
            return localVarFp.updateSodPolicy(id, sodPolicyBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSodPolicy operation in SODPolicyBetaApi.
 * @export
 * @interface SODPolicyBetaApiCreateSodPolicyRequest
 */
export interface SODPolicyBetaApiCreateSodPolicyRequest {
    /**
     * 
     * @type {SodPolicyBeta}
     * @memberof SODPolicyBetaApiCreateSodPolicy
     */
    readonly sodPolicyBeta: SodPolicyBeta
}

/**
 * Request parameters for deleteSodPolicy operation in SODPolicyBetaApi.
 * @export
 * @interface SODPolicyBetaApiDeleteSodPolicyRequest
 */
export interface SODPolicyBetaApiDeleteSodPolicyRequest {
    /**
     * The ID of the SOD Policy to delete.
     * @type {string}
     * @memberof SODPolicyBetaApiDeleteSodPolicy
     */
    readonly id: string

    /**
     * Indicates whether this is a soft delete (logical true) or a hard delete.
     * @type {boolean}
     * @memberof SODPolicyBetaApiDeleteSodPolicy
     */
    readonly logical?: boolean
}

/**
 * Request parameters for deleteSodPolicySchedule operation in SODPolicyBetaApi.
 * @export
 * @interface SODPolicyBetaApiDeleteSodPolicyScheduleRequest
 */
export interface SODPolicyBetaApiDeleteSodPolicyScheduleRequest {
    /**
     * The ID of the SOD policy the schedule must be deleted for.
     * @type {string}
     * @memberof SODPolicyBetaApiDeleteSodPolicySchedule
     */
    readonly id: string
}

/**
 * Request parameters for downloadCustomViolationReport operation in SODPolicyBetaApi.
 * @export
 * @interface SODPolicyBetaApiDownloadCustomViolationReportRequest
 */
export interface SODPolicyBetaApiDownloadCustomViolationReportRequest {
    /**
     * The ID of the report reference to download.
     * @type {string}
     * @memberof SODPolicyBetaApiDownloadCustomViolationReport
     */
    readonly reportResultId: string

    /**
     * Custom Name for the  file.
     * @type {string}
     * @memberof SODPolicyBetaApiDownloadCustomViolationReport
     */
    readonly fileName: string
}

/**
 * Request parameters for downloadDefaultViolationReport operation in SODPolicyBetaApi.
 * @export
 * @interface SODPolicyBetaApiDownloadDefaultViolationReportRequest
 */
export interface SODPolicyBetaApiDownloadDefaultViolationReportRequest {
    /**
     * The ID of the report reference to download.
     * @type {string}
     * @memberof SODPolicyBetaApiDownloadDefaultViolationReport
     */
    readonly reportResultId: string
}

/**
 * Request parameters for getSodPolicy operation in SODPolicyBetaApi.
 * @export
 * @interface SODPolicyBetaApiGetSodPolicyRequest
 */
export interface SODPolicyBetaApiGetSodPolicyRequest {
    /**
     * The ID of the object reference to retrieve.
     * @type {string}
     * @memberof SODPolicyBetaApiGetSodPolicy
     */
    readonly id: string
}

/**
 * Request parameters for getSodPolicySchedule operation in SODPolicyBetaApi.
 * @export
 * @interface SODPolicyBetaApiGetSodPolicyScheduleRequest
 */
export interface SODPolicyBetaApiGetSodPolicyScheduleRequest {
    /**
     * The ID of the object reference to retrieve.
     * @type {string}
     * @memberof SODPolicyBetaApiGetSodPolicySchedule
     */
    readonly id: string
}

/**
 * Request parameters for getSodViolationReportRunStatus operation in SODPolicyBetaApi.
 * @export
 * @interface SODPolicyBetaApiGetSodViolationReportRunStatusRequest
 */
export interface SODPolicyBetaApiGetSodViolationReportRunStatusRequest {
    /**
     * The ID of the report reference to retrieve.
     * @type {string}
     * @memberof SODPolicyBetaApiGetSodViolationReportRunStatus
     */
    readonly reportResultId: string
}

/**
 * Request parameters for getSodViolationReportStatus operation in SODPolicyBetaApi.
 * @export
 * @interface SODPolicyBetaApiGetSodViolationReportStatusRequest
 */
export interface SODPolicyBetaApiGetSodViolationReportStatusRequest {
    /**
     * The ID of the object reference to retrieve.
     * @type {string}
     * @memberof SODPolicyBetaApiGetSodViolationReportStatus
     */
    readonly id: string
}

/**
 * Request parameters for listSodPolicies operation in SODPolicyBetaApi.
 * @export
 * @interface SODPolicyBetaApiListSodPoliciesRequest
 */
export interface SODPolicyBetaApiListSodPoliciesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SODPolicyBetaApiListSodPolicies
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SODPolicyBetaApiListSodPolicies
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SODPolicyBetaApiListSodPolicies
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*  **name**: *eq*  **state**: *eq*
     * @type {string}
     * @memberof SODPolicyBetaApiListSodPolicies
     */
    readonly filters?: string
}

/**
 * Request parameters for patchSodPolicy operation in SODPolicyBetaApi.
 * @export
 * @interface SODPolicyBetaApiPatchSodPolicyRequest
 */
export interface SODPolicyBetaApiPatchSodPolicyRequest {
    /**
     * The ID of the SOD policy being modified.
     * @type {string}
     * @memberof SODPolicyBetaApiPatchSodPolicy
     */
    readonly id: string

    /**
     * A list of SOD Policy update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * ownerRef * externalPolicyReference * compensatingControls * correctionAdvice * state * tags * violationOwnerAssignmentConfig * scheduled * conflictingAccessCriteria 
     * @type {Array<object>}
     * @memberof SODPolicyBetaApiPatchSodPolicy
     */
    readonly requestBody: Array<object>
}

/**
 * Request parameters for runSodAllPoliciesForOrg operation in SODPolicyBetaApi.
 * @export
 * @interface SODPolicyBetaApiRunSodAllPoliciesForOrgRequest
 */
export interface SODPolicyBetaApiRunSodAllPoliciesForOrgRequest {
    /**
     * 
     * @type {MultiPolicyRequestBeta}
     * @memberof SODPolicyBetaApiRunSodAllPoliciesForOrg
     */
    readonly multiPolicyRequestBeta?: MultiPolicyRequestBeta
}

/**
 * Request parameters for runSodPolicy operation in SODPolicyBetaApi.
 * @export
 * @interface SODPolicyBetaApiRunSodPolicyRequest
 */
export interface SODPolicyBetaApiRunSodPolicyRequest {
    /**
     * The SOD policy ID to run.
     * @type {string}
     * @memberof SODPolicyBetaApiRunSodPolicy
     */
    readonly id: string
}

/**
 * Request parameters for updatePolicySchedule operation in SODPolicyBetaApi.
 * @export
 * @interface SODPolicyBetaApiUpdatePolicyScheduleRequest
 */
export interface SODPolicyBetaApiUpdatePolicyScheduleRequest {
    /**
     * The ID of the SOD policy to update its schedule.
     * @type {string}
     * @memberof SODPolicyBetaApiUpdatePolicySchedule
     */
    readonly id: string

    /**
     * 
     * @type {SodPolicyScheduleBeta}
     * @memberof SODPolicyBetaApiUpdatePolicySchedule
     */
    readonly sodPolicyScheduleBeta: SodPolicyScheduleBeta
}

/**
 * Request parameters for updateSodPolicy operation in SODPolicyBetaApi.
 * @export
 * @interface SODPolicyBetaApiUpdateSodPolicyRequest
 */
export interface SODPolicyBetaApiUpdateSodPolicyRequest {
    /**
     * The ID of the SOD policy to update.
     * @type {string}
     * @memberof SODPolicyBetaApiUpdateSodPolicy
     */
    readonly id: string

    /**
     * 
     * @type {SodPolicyBeta}
     * @memberof SODPolicyBetaApiUpdateSodPolicy
     */
    readonly sodPolicyBeta: SodPolicyBeta
}

/**
 * SODPolicyBetaApi - object-oriented interface
 * @export
 * @class SODPolicyBetaApi
 * @extends {BaseAPI}
 */
export class SODPolicyBetaApi extends BaseAPI {
    /**
     * This creates both General and Conflicting Access Based policy, with a limit of 50 entitlements for each (left & right) criteria for Conflicting Access Based SOD policy. Requires role of ORG_ADMIN.
     * @summary Create SOD policy
     * @param {SODPolicyBetaApiCreateSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyBetaApi
     */
    public createSodPolicy(requestParameters: SODPolicyBetaApiCreateSodPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyBetaApiFp(this.configuration).createSodPolicy(requestParameters.sodPolicyBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes a specified SOD policy. Requires role of ORG_ADMIN.
     * @summary Delete SOD policy by ID
     * @param {SODPolicyBetaApiDeleteSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyBetaApi
     */
    public deleteSodPolicy(requestParameters: SODPolicyBetaApiDeleteSodPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyBetaApiFp(this.configuration).deleteSodPolicy(requestParameters.id, requestParameters.logical, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes schedule for a specified SOD policy. Requires role of ORG_ADMIN.
     * @summary Delete SOD policy schedule
     * @param {SODPolicyBetaApiDeleteSodPolicyScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyBetaApi
     */
    public deleteSodPolicySchedule(requestParameters: SODPolicyBetaApiDeleteSodPolicyScheduleRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyBetaApiFp(this.configuration).deleteSodPolicySchedule(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This allows to download a specified named violation report for a given report reference. Requires role of ORG_ADMIN.
     * @summary Download custom violation report
     * @param {SODPolicyBetaApiDownloadCustomViolationReportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyBetaApi
     */
    public downloadCustomViolationReport(requestParameters: SODPolicyBetaApiDownloadCustomViolationReportRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyBetaApiFp(this.configuration).downloadCustomViolationReport(requestParameters.reportResultId, requestParameters.fileName, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This allows to download a violation report for a given report reference. Requires role of ORG_ADMIN.
     * @summary Download violation report
     * @param {SODPolicyBetaApiDownloadDefaultViolationReportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyBetaApi
     */
    public downloadDefaultViolationReport(requestParameters: SODPolicyBetaApiDownloadDefaultViolationReportRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyBetaApiFp(this.configuration).downloadDefaultViolationReport(requestParameters.reportResultId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gets the status for a violation report for all policy run. Requires role of ORG_ADMIN.
     * @summary Get multi-report run task status
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyBetaApi
     */
    public getSodAllReportRunStatus(axiosOptions?: AxiosRequestConfig) {
        return SODPolicyBetaApiFp(this.configuration).getSodAllReportRunStatus(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets specified SOD policy. Requires role of ORG_ADMIN.
     * @summary Get SOD policy by ID
     * @param {SODPolicyBetaApiGetSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyBetaApi
     */
    public getSodPolicy(requestParameters: SODPolicyBetaApiGetSodPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyBetaApiFp(this.configuration).getSodPolicy(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gets a specified SOD policy\'s schedule. Requires the role of ORG_ADMIN.
     * @summary Get SOD policy schedule
     * @param {SODPolicyBetaApiGetSodPolicyScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyBetaApi
     */
    public getSodPolicySchedule(requestParameters: SODPolicyBetaApiGetSodPolicyScheduleRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyBetaApiFp(this.configuration).getSodPolicySchedule(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets the status for a violation report run task that has already been invoked. Requires role of ORG_ADMIN.
     * @summary Get violation report run status
     * @param {SODPolicyBetaApiGetSodViolationReportRunStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyBetaApi
     */
    public getSodViolationReportRunStatus(requestParameters: SODPolicyBetaApiGetSodViolationReportRunStatusRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyBetaApiFp(this.configuration).getSodViolationReportRunStatus(requestParameters.reportResultId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets the status for a violation report run task that has already been invoked. Requires role of ORG_ADMIN.
     * @summary Get SOD violation report status
     * @param {SODPolicyBetaApiGetSodViolationReportStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyBetaApi
     */
    public getSodViolationReportStatus(requestParameters: SODPolicyBetaApiGetSodViolationReportStatusRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyBetaApiFp(this.configuration).getSodViolationReportStatus(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets list of all SOD policies. Requires role of ORG_ADMIN
     * @summary List SOD policies
     * @param {SODPolicyBetaApiListSodPoliciesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyBetaApi
     */
    public listSodPolicies(requestParameters: SODPolicyBetaApiListSodPoliciesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyBetaApiFp(this.configuration).listSodPolicies(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows updating SOD Policy fields other than [\"id\",\"created\",\"creatorId\",\"policyQuery\",\"type\"] using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Requires role of ORG_ADMIN. This endpoint can only patch CONFLICTING_ACCESS_BASED type policies. Do not use this endpoint to patch general policies - doing so will build an API exception. 
     * @summary Patch a SOD policy
     * @param {SODPolicyBetaApiPatchSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyBetaApi
     */
    public patchSodPolicy(requestParameters: SODPolicyBetaApiPatchSodPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyBetaApiFp(this.configuration).patchSodPolicy(requestParameters.id, requestParameters.requestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Runs multi-policy report for the org. If a policy reports more than 5000 violations, the report mentions that the violation limit was exceeded for that policy. If the request is empty, the report runs for all policies. Otherwise, the report runs for only the filtered policy list provided. Requires role of ORG_ADMIN.
     * @summary Runs all policies for org
     * @param {SODPolicyBetaApiRunSodAllPoliciesForOrgRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyBetaApi
     */
    public runSodAllPoliciesForOrg(requestParameters: SODPolicyBetaApiRunSodAllPoliciesForOrgRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyBetaApiFp(this.configuration).runSodAllPoliciesForOrg(requestParameters.multiPolicyRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This invokes processing of violation report for given SOD policy. If the policy reports more than 5000 violations, the report returns with violation limit exceeded message. Requires role of ORG_ADMIN.
     * @summary Runs SOD policy violation report
     * @param {SODPolicyBetaApiRunSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyBetaApi
     */
    public runSodPolicy(requestParameters: SODPolicyBetaApiRunSodPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyBetaApiFp(this.configuration).runSodPolicy(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This updates schedule for a specified SOD policy. Requires role of ORG_ADMIN.
     * @summary Update SOD Policy schedule
     * @param {SODPolicyBetaApiUpdatePolicyScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyBetaApi
     */
    public updatePolicySchedule(requestParameters: SODPolicyBetaApiUpdatePolicyScheduleRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyBetaApiFp(this.configuration).updatePolicySchedule(requestParameters.id, requestParameters.sodPolicyScheduleBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This updates a specified SOD policy. Requires role of ORG_ADMIN.
     * @summary Update SOD policy by ID
     * @param {SODPolicyBetaApiUpdateSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyBetaApi
     */
    public updateSodPolicy(requestParameters: SODPolicyBetaApiUpdateSodPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyBetaApiFp(this.configuration).updateSodPolicy(requestParameters.id, requestParameters.sodPolicyBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SODViolationsBetaApi - axios parameter creator
 * @export
 */
export const SODViolationsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API is used to check if granting some additional accesses would cause the subject to be in violation of any SOD policies. Returns the violations that would be caused.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Predict SOD violations for the given identity if they were granted the given access.
         * @param {IdentityWithNewAccessBeta} identityWithNewAccessBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        predictSodViolations: async (identityWithNewAccessBeta: IdentityWithNewAccessBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityWithNewAccessBeta' is not null or undefined
            assertParamExists('predictSodViolations', 'identityWithNewAccessBeta', identityWithNewAccessBeta)
            const localVarPath = `/sod-violations/predict`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityWithNewAccessBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SODViolationsBetaApi - functional programming interface
 * @export
 */
export const SODViolationsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SODViolationsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This API is used to check if granting some additional accesses would cause the subject to be in violation of any SOD policies. Returns the violations that would be caused.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Predict SOD violations for the given identity if they were granted the given access.
         * @param {IdentityWithNewAccessBeta} identityWithNewAccessBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async predictSodViolations(identityWithNewAccessBeta: IdentityWithNewAccessBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViolationPredictionBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.predictSodViolations(identityWithNewAccessBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SODViolationsBetaApi - factory interface
 * @export
 */
export const SODViolationsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SODViolationsBetaApiFp(configuration)
    return {
        /**
         * This API is used to check if granting some additional accesses would cause the subject to be in violation of any SOD policies. Returns the violations that would be caused.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Predict SOD violations for the given identity if they were granted the given access.
         * @param {IdentityWithNewAccessBeta} identityWithNewAccessBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        predictSodViolations(identityWithNewAccessBeta: IdentityWithNewAccessBeta, axiosOptions?: any): AxiosPromise<ViolationPredictionBeta> {
            return localVarFp.predictSodViolations(identityWithNewAccessBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for predictSodViolations operation in SODViolationsBetaApi.
 * @export
 * @interface SODViolationsBetaApiPredictSodViolationsRequest
 */
export interface SODViolationsBetaApiPredictSodViolationsRequest {
    /**
     * 
     * @type {IdentityWithNewAccessBeta}
     * @memberof SODViolationsBetaApiPredictSodViolations
     */
    readonly identityWithNewAccessBeta: IdentityWithNewAccessBeta
}

/**
 * SODViolationsBetaApi - object-oriented interface
 * @export
 * @class SODViolationsBetaApi
 * @extends {BaseAPI}
 */
export class SODViolationsBetaApi extends BaseAPI {
    /**
     * This API is used to check if granting some additional accesses would cause the subject to be in violation of any SOD policies. Returns the violations that would be caused.  A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Predict SOD violations for the given identity if they were granted the given access.
     * @param {SODViolationsBetaApiPredictSodViolationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODViolationsBetaApi
     */
    public predictSodViolations(requestParameters: SODViolationsBetaApiPredictSodViolationsRequest, axiosOptions?: AxiosRequestConfig) {
        return SODViolationsBetaApiFp(this.configuration).predictSodViolations(requestParameters.identityWithNewAccessBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SPConfigBetaApi - axios parameter creator
 * @export
 */
export const SPConfigBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This post will export objects from the tenant to a JSON configuration file. For more information about the object types that currently support export functionality, refer to [SaaS Configuration](https://developer.sailpoint.com/idn/docs/saas-configuration/#supported-objects).
         * @summary Initiates configuration objects export job
         * @param {ExportPayloadBeta} exportPayloadBeta Export options control what will be included in the export.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportSpConfig: async (exportPayloadBeta: ExportPayloadBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exportPayloadBeta' is not null or undefined
            assertParamExists('exportSpConfig', 'exportPayloadBeta', exportPayloadBeta)
            const localVarPath = `/sp-config/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exportPayloadBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gets the export file resulting from the export job with the requested `id` and downloads it to a file. The request will need one of the following security scopes: - sp:config:read - sp:config:manage
         * @summary Download export job result.
         * @param {string} id The ID of the export job whose results will be downloaded.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSpConfigExport: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSpConfigExport', 'id', id)
            const localVarPath = `/sp-config/export/{id}/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets the status of the export job identified by the `id` parameter. The request will need one of the following security scopes: - sp:config:read - sp:config:manage
         * @summary Get export job status
         * @param {string} id The ID of the export job whose status will be returned.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSpConfigExportStatus: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSpConfigExportStatus', 'id', id)
            const localVarPath = `/sp-config/export/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets import file resulting from the import job with the requested id and downloads it to a file. The downloaded file will contain the results of the import operation, including any error, warning or informational messages associated with the import. The request will need the following security scope: - sp:config:manage
         * @summary Download import job result
         * @param {string} id The ID of the import job whose results will be downloaded.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSpConfigImport: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSpConfigImport', 'id', id)
            const localVarPath = `/sp-config/import/{id}/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets the status of the import job identified by the `id` parameter. For more information about the object types that currently support import functionality, refer to [SaaS Configuration](https://developer.sailpoint.com/idn/docs/saas-configuration/#supported-objects). The request will need the following security scope: - sp:config:manage
         * @summary Get import job status
         * @param {string} id The ID of the import job whose status will be returned.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSpConfigImportStatus: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSpConfigImportStatus', 'id', id)
            const localVarPath = `/sp-config/import/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This post will import objects from a JSON configuration file into a tenant. By default, every import will first export all existing objects supported by sp-config as a backup before the import is attempted. The backup is provided so that the state of the configuration prior to the import is available for inspection or restore if needed. The backup can be skipped by setting \"excludeBackup\" to true in the import options. If a backup is performed, the id of the backup will be provided in the ImportResult as the \"exportJobId\". This can be downloaded  using the /sp-config/export/{exportJobId}/download endpoint. You cannot currently import from the Non-Employee Lifecycle Management (NELM) source. You cannot use this endpoint to back up or store NELM data.  For more information about the object types that currently support import functionality, refer to [SaaS Configuration](https://developer.sailpoint.com/idn/docs/saas-configuration/#supported-objects). The request will need the following security scope: - sp:config:manage
         * @summary Initiates configuration objects import job
         * @param {any} data JSON file containing the objects to be imported.
         * @param {boolean} [preview] This option is intended to give the user information about how an import operation would proceed, without having any effect on the target tenant. If this parameter is \&quot;true\&quot;, no objects will be imported. Instead, the import process will pre-process the import file and attempt to resolve references within imported objects. The import result file will contain messages pertaining to how specific references were resolved, any errors associated with the preprocessing, and messages indicating which objects would be imported.
         * @param {ImportOptionsBeta} [options] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importSpConfig: async (data: any, preview?: boolean, options?: ImportOptionsBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('importSpConfig', 'data', data)
            const localVarPath = `/sp-config/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (preview !== undefined) {
                localVarQueryParameter['preview'] = preview;
            }


            if (data !== undefined) { 
                localVarFormParams.append('data', data as any);
            }
    
            if (options !== undefined) { 
                localVarFormParams.append('options', new Blob([JSON.stringify(options)], { type: "application/json", }));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets the list of object configurations which are known to the tenant export/import service. Object configurations that contain \"importUrl\" and \"exportUrl\" are available for export/import.
         * @summary Get config object details
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSpConfigObjects: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sp-config/config-objects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SPConfigBetaApi - functional programming interface
 * @export
 */
export const SPConfigBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SPConfigBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This post will export objects from the tenant to a JSON configuration file. For more information about the object types that currently support export functionality, refer to [SaaS Configuration](https://developer.sailpoint.com/idn/docs/saas-configuration/#supported-objects).
         * @summary Initiates configuration objects export job
         * @param {ExportPayloadBeta} exportPayloadBeta Export options control what will be included in the export.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async exportSpConfig(exportPayloadBeta: ExportPayloadBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpConfigJobBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportSpConfig(exportPayloadBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gets the export file resulting from the export job with the requested `id` and downloads it to a file. The request will need one of the following security scopes: - sp:config:read - sp:config:manage
         * @summary Download export job result.
         * @param {string} id The ID of the export job whose results will be downloaded.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSpConfigExport(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpConfigExportResultsBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSpConfigExport(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets the status of the export job identified by the `id` parameter. The request will need one of the following security scopes: - sp:config:read - sp:config:manage
         * @summary Get export job status
         * @param {string} id The ID of the export job whose status will be returned.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSpConfigExportStatus(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpConfigJobBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSpConfigExportStatus(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets import file resulting from the import job with the requested id and downloads it to a file. The downloaded file will contain the results of the import operation, including any error, warning or informational messages associated with the import. The request will need the following security scope: - sp:config:manage
         * @summary Download import job result
         * @param {string} id The ID of the import job whose results will be downloaded.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSpConfigImport(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpConfigImportResultsBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSpConfigImport(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets the status of the import job identified by the `id` parameter. For more information about the object types that currently support import functionality, refer to [SaaS Configuration](https://developer.sailpoint.com/idn/docs/saas-configuration/#supported-objects). The request will need the following security scope: - sp:config:manage
         * @summary Get import job status
         * @param {string} id The ID of the import job whose status will be returned.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSpConfigImportStatus(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpConfigJobBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSpConfigImportStatus(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This post will import objects from a JSON configuration file into a tenant. By default, every import will first export all existing objects supported by sp-config as a backup before the import is attempted. The backup is provided so that the state of the configuration prior to the import is available for inspection or restore if needed. The backup can be skipped by setting \"excludeBackup\" to true in the import options. If a backup is performed, the id of the backup will be provided in the ImportResult as the \"exportJobId\". This can be downloaded  using the /sp-config/export/{exportJobId}/download endpoint. You cannot currently import from the Non-Employee Lifecycle Management (NELM) source. You cannot use this endpoint to back up or store NELM data.  For more information about the object types that currently support import functionality, refer to [SaaS Configuration](https://developer.sailpoint.com/idn/docs/saas-configuration/#supported-objects). The request will need the following security scope: - sp:config:manage
         * @summary Initiates configuration objects import job
         * @param {any} data JSON file containing the objects to be imported.
         * @param {boolean} [preview] This option is intended to give the user information about how an import operation would proceed, without having any effect on the target tenant. If this parameter is \&quot;true\&quot;, no objects will be imported. Instead, the import process will pre-process the import file and attempt to resolve references within imported objects. The import result file will contain messages pertaining to how specific references were resolved, any errors associated with the preprocessing, and messages indicating which objects would be imported.
         * @param {ImportOptionsBeta} [options] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async importSpConfig(data: any, preview?: boolean, options?: ImportOptionsBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpConfigJobBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importSpConfig(data, preview, options, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets the list of object configurations which are known to the tenant export/import service. Object configurations that contain \"importUrl\" and \"exportUrl\" are available for export/import.
         * @summary Get config object details
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listSpConfigObjects(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SpConfigObjectBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSpConfigObjects(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SPConfigBetaApi - factory interface
 * @export
 */
export const SPConfigBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SPConfigBetaApiFp(configuration)
    return {
        /**
         * This post will export objects from the tenant to a JSON configuration file. For more information about the object types that currently support export functionality, refer to [SaaS Configuration](https://developer.sailpoint.com/idn/docs/saas-configuration/#supported-objects).
         * @summary Initiates configuration objects export job
         * @param {ExportPayloadBeta} exportPayloadBeta Export options control what will be included in the export.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportSpConfig(exportPayloadBeta: ExportPayloadBeta, axiosOptions?: any): AxiosPromise<SpConfigJobBeta> {
            return localVarFp.exportSpConfig(exportPayloadBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gets the export file resulting from the export job with the requested `id` and downloads it to a file. The request will need one of the following security scopes: - sp:config:read - sp:config:manage
         * @summary Download export job result.
         * @param {string} id The ID of the export job whose results will be downloaded.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSpConfigExport(id: string, axiosOptions?: any): AxiosPromise<SpConfigExportResultsBeta> {
            return localVarFp.getSpConfigExport(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets the status of the export job identified by the `id` parameter. The request will need one of the following security scopes: - sp:config:read - sp:config:manage
         * @summary Get export job status
         * @param {string} id The ID of the export job whose status will be returned.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSpConfigExportStatus(id: string, axiosOptions?: any): AxiosPromise<SpConfigJobBeta> {
            return localVarFp.getSpConfigExportStatus(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets import file resulting from the import job with the requested id and downloads it to a file. The downloaded file will contain the results of the import operation, including any error, warning or informational messages associated with the import. The request will need the following security scope: - sp:config:manage
         * @summary Download import job result
         * @param {string} id The ID of the import job whose results will be downloaded.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSpConfigImport(id: string, axiosOptions?: any): AxiosPromise<SpConfigImportResultsBeta> {
            return localVarFp.getSpConfigImport(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets the status of the import job identified by the `id` parameter. For more information about the object types that currently support import functionality, refer to [SaaS Configuration](https://developer.sailpoint.com/idn/docs/saas-configuration/#supported-objects). The request will need the following security scope: - sp:config:manage
         * @summary Get import job status
         * @param {string} id The ID of the import job whose status will be returned.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSpConfigImportStatus(id: string, axiosOptions?: any): AxiosPromise<SpConfigJobBeta> {
            return localVarFp.getSpConfigImportStatus(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This post will import objects from a JSON configuration file into a tenant. By default, every import will first export all existing objects supported by sp-config as a backup before the import is attempted. The backup is provided so that the state of the configuration prior to the import is available for inspection or restore if needed. The backup can be skipped by setting \"excludeBackup\" to true in the import options. If a backup is performed, the id of the backup will be provided in the ImportResult as the \"exportJobId\". This can be downloaded  using the /sp-config/export/{exportJobId}/download endpoint. You cannot currently import from the Non-Employee Lifecycle Management (NELM) source. You cannot use this endpoint to back up or store NELM data.  For more information about the object types that currently support import functionality, refer to [SaaS Configuration](https://developer.sailpoint.com/idn/docs/saas-configuration/#supported-objects). The request will need the following security scope: - sp:config:manage
         * @summary Initiates configuration objects import job
         * @param {any} data JSON file containing the objects to be imported.
         * @param {boolean} [preview] This option is intended to give the user information about how an import operation would proceed, without having any effect on the target tenant. If this parameter is \&quot;true\&quot;, no objects will be imported. Instead, the import process will pre-process the import file and attempt to resolve references within imported objects. The import result file will contain messages pertaining to how specific references were resolved, any errors associated with the preprocessing, and messages indicating which objects would be imported.
         * @param {ImportOptionsBeta} [options] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importSpConfig(data: any, preview?: boolean, options?: ImportOptionsBeta, axiosOptions?: any): AxiosPromise<SpConfigJobBeta> {
            return localVarFp.importSpConfig(data, preview, options, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets the list of object configurations which are known to the tenant export/import service. Object configurations that contain \"importUrl\" and \"exportUrl\" are available for export/import.
         * @summary Get config object details
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSpConfigObjects(axiosOptions?: any): AxiosPromise<Array<SpConfigObjectBeta>> {
            return localVarFp.listSpConfigObjects(axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for exportSpConfig operation in SPConfigBetaApi.
 * @export
 * @interface SPConfigBetaApiExportSpConfigRequest
 */
export interface SPConfigBetaApiExportSpConfigRequest {
    /**
     * Export options control what will be included in the export.
     * @type {ExportPayloadBeta}
     * @memberof SPConfigBetaApiExportSpConfig
     */
    readonly exportPayloadBeta: ExportPayloadBeta
}

/**
 * Request parameters for getSpConfigExport operation in SPConfigBetaApi.
 * @export
 * @interface SPConfigBetaApiGetSpConfigExportRequest
 */
export interface SPConfigBetaApiGetSpConfigExportRequest {
    /**
     * The ID of the export job whose results will be downloaded.
     * @type {string}
     * @memberof SPConfigBetaApiGetSpConfigExport
     */
    readonly id: string
}

/**
 * Request parameters for getSpConfigExportStatus operation in SPConfigBetaApi.
 * @export
 * @interface SPConfigBetaApiGetSpConfigExportStatusRequest
 */
export interface SPConfigBetaApiGetSpConfigExportStatusRequest {
    /**
     * The ID of the export job whose status will be returned.
     * @type {string}
     * @memberof SPConfigBetaApiGetSpConfigExportStatus
     */
    readonly id: string
}

/**
 * Request parameters for getSpConfigImport operation in SPConfigBetaApi.
 * @export
 * @interface SPConfigBetaApiGetSpConfigImportRequest
 */
export interface SPConfigBetaApiGetSpConfigImportRequest {
    /**
     * The ID of the import job whose results will be downloaded.
     * @type {string}
     * @memberof SPConfigBetaApiGetSpConfigImport
     */
    readonly id: string
}

/**
 * Request parameters for getSpConfigImportStatus operation in SPConfigBetaApi.
 * @export
 * @interface SPConfigBetaApiGetSpConfigImportStatusRequest
 */
export interface SPConfigBetaApiGetSpConfigImportStatusRequest {
    /**
     * The ID of the import job whose status will be returned.
     * @type {string}
     * @memberof SPConfigBetaApiGetSpConfigImportStatus
     */
    readonly id: string
}

/**
 * Request parameters for importSpConfig operation in SPConfigBetaApi.
 * @export
 * @interface SPConfigBetaApiImportSpConfigRequest
 */
export interface SPConfigBetaApiImportSpConfigRequest {
    /**
     * JSON file containing the objects to be imported.
     * @type {any}
     * @memberof SPConfigBetaApiImportSpConfig
     */
    readonly data: any

    /**
     * This option is intended to give the user information about how an import operation would proceed, without having any effect on the target tenant. If this parameter is \&quot;true\&quot;, no objects will be imported. Instead, the import process will pre-process the import file and attempt to resolve references within imported objects. The import result file will contain messages pertaining to how specific references were resolved, any errors associated with the preprocessing, and messages indicating which objects would be imported.
     * @type {boolean}
     * @memberof SPConfigBetaApiImportSpConfig
     */
    readonly preview?: boolean

    /**
     * 
     * @type {ImportOptionsBeta}
     * @memberof SPConfigBetaApiImportSpConfig
     */
    readonly options?: ImportOptionsBeta
}

/**
 * SPConfigBetaApi - object-oriented interface
 * @export
 * @class SPConfigBetaApi
 * @extends {BaseAPI}
 */
export class SPConfigBetaApi extends BaseAPI {
    /**
     * This post will export objects from the tenant to a JSON configuration file. For more information about the object types that currently support export functionality, refer to [SaaS Configuration](https://developer.sailpoint.com/idn/docs/saas-configuration/#supported-objects).
     * @summary Initiates configuration objects export job
     * @param {SPConfigBetaApiExportSpConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SPConfigBetaApi
     */
    public exportSpConfig(requestParameters: SPConfigBetaApiExportSpConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return SPConfigBetaApiFp(this.configuration).exportSpConfig(requestParameters.exportPayloadBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gets the export file resulting from the export job with the requested `id` and downloads it to a file. The request will need one of the following security scopes: - sp:config:read - sp:config:manage
     * @summary Download export job result.
     * @param {SPConfigBetaApiGetSpConfigExportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SPConfigBetaApi
     */
    public getSpConfigExport(requestParameters: SPConfigBetaApiGetSpConfigExportRequest, axiosOptions?: AxiosRequestConfig) {
        return SPConfigBetaApiFp(this.configuration).getSpConfigExport(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets the status of the export job identified by the `id` parameter. The request will need one of the following security scopes: - sp:config:read - sp:config:manage
     * @summary Get export job status
     * @param {SPConfigBetaApiGetSpConfigExportStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SPConfigBetaApi
     */
    public getSpConfigExportStatus(requestParameters: SPConfigBetaApiGetSpConfigExportStatusRequest, axiosOptions?: AxiosRequestConfig) {
        return SPConfigBetaApiFp(this.configuration).getSpConfigExportStatus(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets import file resulting from the import job with the requested id and downloads it to a file. The downloaded file will contain the results of the import operation, including any error, warning or informational messages associated with the import. The request will need the following security scope: - sp:config:manage
     * @summary Download import job result
     * @param {SPConfigBetaApiGetSpConfigImportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SPConfigBetaApi
     */
    public getSpConfigImport(requestParameters: SPConfigBetaApiGetSpConfigImportRequest, axiosOptions?: AxiosRequestConfig) {
        return SPConfigBetaApiFp(this.configuration).getSpConfigImport(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets the status of the import job identified by the `id` parameter. For more information about the object types that currently support import functionality, refer to [SaaS Configuration](https://developer.sailpoint.com/idn/docs/saas-configuration/#supported-objects). The request will need the following security scope: - sp:config:manage
     * @summary Get import job status
     * @param {SPConfigBetaApiGetSpConfigImportStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SPConfigBetaApi
     */
    public getSpConfigImportStatus(requestParameters: SPConfigBetaApiGetSpConfigImportStatusRequest, axiosOptions?: AxiosRequestConfig) {
        return SPConfigBetaApiFp(this.configuration).getSpConfigImportStatus(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This post will import objects from a JSON configuration file into a tenant. By default, every import will first export all existing objects supported by sp-config as a backup before the import is attempted. The backup is provided so that the state of the configuration prior to the import is available for inspection or restore if needed. The backup can be skipped by setting \"excludeBackup\" to true in the import options. If a backup is performed, the id of the backup will be provided in the ImportResult as the \"exportJobId\". This can be downloaded  using the /sp-config/export/{exportJobId}/download endpoint. You cannot currently import from the Non-Employee Lifecycle Management (NELM) source. You cannot use this endpoint to back up or store NELM data.  For more information about the object types that currently support import functionality, refer to [SaaS Configuration](https://developer.sailpoint.com/idn/docs/saas-configuration/#supported-objects). The request will need the following security scope: - sp:config:manage
     * @summary Initiates configuration objects import job
     * @param {SPConfigBetaApiImportSpConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SPConfigBetaApi
     */
    public importSpConfig(requestParameters: SPConfigBetaApiImportSpConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return SPConfigBetaApiFp(this.configuration).importSpConfig(requestParameters.data, requestParameters.preview, requestParameters.options, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets the list of object configurations which are known to the tenant export/import service. Object configurations that contain \"importUrl\" and \"exportUrl\" are available for export/import.
     * @summary Get config object details
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SPConfigBetaApi
     */
    public listSpConfigObjects(axiosOptions?: AxiosRequestConfig) {
        return SPConfigBetaApiFp(this.configuration).listSpConfigObjects(axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SearchAttributeConfigurationBetaApi - axios parameter creator
 * @export
 */
export const SearchAttributeConfigurationBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API accepts an attribute name, an attribute display name and a list of name/value pair associates of application IDs to attribute names.  It will then validate the inputs and configure/create and attribute promotion configuration in the Link ObjectConfig. A token with ORG_ADMIN authority is required to call this API.
         * @summary Configure/create extended search attributes in IdentityNow.
         * @param {SearchAttributeConfigBeta} searchAttributeConfigBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSearchAttributeConfig: async (searchAttributeConfigBeta: SearchAttributeConfigBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchAttributeConfigBeta' is not null or undefined
            assertParamExists('createSearchAttributeConfig', 'searchAttributeConfigBeta', searchAttributeConfigBeta)
            const localVarPath = `/accounts/search-attribute-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchAttributeConfigBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API accepts an extended attribute name and deletes the corresponding extended attribute configuration. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete an extended search attribute in IdentityNow.
         * @param {string} name Name of the extended search attribute configuration to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSearchAttributeConfig: async (name: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteSearchAttributeConfig', 'name', name)
            const localVarPath = `/accounts/search-attribute-config/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API retrieves a list of attribute/application associates currently configured in IdentityNow. A token with ORG_ADMIN authority is required to call this API.
         * @summary Retrieve a list of extended search attributes in IdentityNow.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSearchAttributeConfig: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts/search-attribute-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API accepts an extended attribute name and retrieves the corresponding extended attribute configuration. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get the details of a specific extended search attribute in IdentityNow.
         * @param {string} name Name of the extended search attribute configuration to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSingleSearchAttributeConfig: async (name: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getSingleSearchAttributeConfig', 'name', name)
            const localVarPath = `/accounts/search-attribute-config/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates an existing Search Attribute Configuration. The following fields are patchable: **name**, **displayName**, **applicationAttributes** A token with ORG_ADMIN authority is required to call this API.
         * @summary Update the details of a specific extended search attribute in IdentityNow.
         * @param {string} name Name of the Search Attribute Configuration to patch.
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSearchAttributeConfig: async (name: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('patchSearchAttributeConfig', 'name', name)
            // verify required parameter 'jsonPatchOperationBeta' is not null or undefined
            assertParamExists('patchSearchAttributeConfig', 'jsonPatchOperationBeta', jsonPatchOperationBeta)
            const localVarPath = `/accounts/search-attribute-config/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperationBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchAttributeConfigurationBetaApi - functional programming interface
 * @export
 */
export const SearchAttributeConfigurationBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchAttributeConfigurationBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This API accepts an attribute name, an attribute display name and a list of name/value pair associates of application IDs to attribute names.  It will then validate the inputs and configure/create and attribute promotion configuration in the Link ObjectConfig. A token with ORG_ADMIN authority is required to call this API.
         * @summary Configure/create extended search attributes in IdentityNow.
         * @param {SearchAttributeConfigBeta} searchAttributeConfigBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSearchAttributeConfig(searchAttributeConfigBeta: SearchAttributeConfigBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSearchAttributeConfig(searchAttributeConfigBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API accepts an extended attribute name and deletes the corresponding extended attribute configuration. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete an extended search attribute in IdentityNow.
         * @param {string} name Name of the extended search attribute configuration to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSearchAttributeConfig(name: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSearchAttributeConfig(name, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API retrieves a list of attribute/application associates currently configured in IdentityNow. A token with ORG_ADMIN authority is required to call this API.
         * @summary Retrieve a list of extended search attributes in IdentityNow.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSearchAttributeConfig(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SearchAttributeConfigBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSearchAttributeConfig(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API accepts an extended attribute name and retrieves the corresponding extended attribute configuration. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get the details of a specific extended search attribute in IdentityNow.
         * @param {string} name Name of the extended search attribute configuration to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleSearchAttributeConfig(name: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SearchAttributeConfigBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleSearchAttributeConfig(name, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API updates an existing Search Attribute Configuration. The following fields are patchable: **name**, **displayName**, **applicationAttributes** A token with ORG_ADMIN authority is required to call this API.
         * @summary Update the details of a specific extended search attribute in IdentityNow.
         * @param {string} name Name of the Search Attribute Configuration to patch.
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchSearchAttributeConfig(name: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchAttributeConfigBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchSearchAttributeConfig(name, jsonPatchOperationBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SearchAttributeConfigurationBetaApi - factory interface
 * @export
 */
export const SearchAttributeConfigurationBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchAttributeConfigurationBetaApiFp(configuration)
    return {
        /**
         * This API accepts an attribute name, an attribute display name and a list of name/value pair associates of application IDs to attribute names.  It will then validate the inputs and configure/create and attribute promotion configuration in the Link ObjectConfig. A token with ORG_ADMIN authority is required to call this API.
         * @summary Configure/create extended search attributes in IdentityNow.
         * @param {SearchAttributeConfigBeta} searchAttributeConfigBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSearchAttributeConfig(searchAttributeConfigBeta: SearchAttributeConfigBeta, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.createSearchAttributeConfig(searchAttributeConfigBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API accepts an extended attribute name and deletes the corresponding extended attribute configuration. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete an extended search attribute in IdentityNow.
         * @param {string} name Name of the extended search attribute configuration to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSearchAttributeConfig(name: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteSearchAttributeConfig(name, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API retrieves a list of attribute/application associates currently configured in IdentityNow. A token with ORG_ADMIN authority is required to call this API.
         * @summary Retrieve a list of extended search attributes in IdentityNow.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSearchAttributeConfig(axiosOptions?: any): AxiosPromise<Array<SearchAttributeConfigBeta>> {
            return localVarFp.getSearchAttributeConfig(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API accepts an extended attribute name and retrieves the corresponding extended attribute configuration. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get the details of a specific extended search attribute in IdentityNow.
         * @param {string} name Name of the extended search attribute configuration to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSingleSearchAttributeConfig(name: string, axiosOptions?: any): AxiosPromise<Array<SearchAttributeConfigBeta>> {
            return localVarFp.getSingleSearchAttributeConfig(name, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates an existing Search Attribute Configuration. The following fields are patchable: **name**, **displayName**, **applicationAttributes** A token with ORG_ADMIN authority is required to call this API.
         * @summary Update the details of a specific extended search attribute in IdentityNow.
         * @param {string} name Name of the Search Attribute Configuration to patch.
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSearchAttributeConfig(name: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: any): AxiosPromise<SearchAttributeConfigBeta> {
            return localVarFp.patchSearchAttributeConfig(name, jsonPatchOperationBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSearchAttributeConfig operation in SearchAttributeConfigurationBetaApi.
 * @export
 * @interface SearchAttributeConfigurationBetaApiCreateSearchAttributeConfigRequest
 */
export interface SearchAttributeConfigurationBetaApiCreateSearchAttributeConfigRequest {
    /**
     * 
     * @type {SearchAttributeConfigBeta}
     * @memberof SearchAttributeConfigurationBetaApiCreateSearchAttributeConfig
     */
    readonly searchAttributeConfigBeta: SearchAttributeConfigBeta
}

/**
 * Request parameters for deleteSearchAttributeConfig operation in SearchAttributeConfigurationBetaApi.
 * @export
 * @interface SearchAttributeConfigurationBetaApiDeleteSearchAttributeConfigRequest
 */
export interface SearchAttributeConfigurationBetaApiDeleteSearchAttributeConfigRequest {
    /**
     * Name of the extended search attribute configuration to delete.
     * @type {string}
     * @memberof SearchAttributeConfigurationBetaApiDeleteSearchAttributeConfig
     */
    readonly name: string
}

/**
 * Request parameters for getSingleSearchAttributeConfig operation in SearchAttributeConfigurationBetaApi.
 * @export
 * @interface SearchAttributeConfigurationBetaApiGetSingleSearchAttributeConfigRequest
 */
export interface SearchAttributeConfigurationBetaApiGetSingleSearchAttributeConfigRequest {
    /**
     * Name of the extended search attribute configuration to delete.
     * @type {string}
     * @memberof SearchAttributeConfigurationBetaApiGetSingleSearchAttributeConfig
     */
    readonly name: string
}

/**
 * Request parameters for patchSearchAttributeConfig operation in SearchAttributeConfigurationBetaApi.
 * @export
 * @interface SearchAttributeConfigurationBetaApiPatchSearchAttributeConfigRequest
 */
export interface SearchAttributeConfigurationBetaApiPatchSearchAttributeConfigRequest {
    /**
     * Name of the Search Attribute Configuration to patch.
     * @type {string}
     * @memberof SearchAttributeConfigurationBetaApiPatchSearchAttributeConfig
     */
    readonly name: string

    /**
     * 
     * @type {Array<JsonPatchOperationBeta>}
     * @memberof SearchAttributeConfigurationBetaApiPatchSearchAttributeConfig
     */
    readonly jsonPatchOperationBeta: Array<JsonPatchOperationBeta>
}

/**
 * SearchAttributeConfigurationBetaApi - object-oriented interface
 * @export
 * @class SearchAttributeConfigurationBetaApi
 * @extends {BaseAPI}
 */
export class SearchAttributeConfigurationBetaApi extends BaseAPI {
    /**
     * This API accepts an attribute name, an attribute display name and a list of name/value pair associates of application IDs to attribute names.  It will then validate the inputs and configure/create and attribute promotion configuration in the Link ObjectConfig. A token with ORG_ADMIN authority is required to call this API.
     * @summary Configure/create extended search attributes in IdentityNow.
     * @param {SearchAttributeConfigurationBetaApiCreateSearchAttributeConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchAttributeConfigurationBetaApi
     */
    public createSearchAttributeConfig(requestParameters: SearchAttributeConfigurationBetaApiCreateSearchAttributeConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return SearchAttributeConfigurationBetaApiFp(this.configuration).createSearchAttributeConfig(requestParameters.searchAttributeConfigBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API accepts an extended attribute name and deletes the corresponding extended attribute configuration. A token with ORG_ADMIN authority is required to call this API.
     * @summary Delete an extended search attribute in IdentityNow.
     * @param {SearchAttributeConfigurationBetaApiDeleteSearchAttributeConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchAttributeConfigurationBetaApi
     */
    public deleteSearchAttributeConfig(requestParameters: SearchAttributeConfigurationBetaApiDeleteSearchAttributeConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return SearchAttributeConfigurationBetaApiFp(this.configuration).deleteSearchAttributeConfig(requestParameters.name, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API retrieves a list of attribute/application associates currently configured in IdentityNow. A token with ORG_ADMIN authority is required to call this API.
     * @summary Retrieve a list of extended search attributes in IdentityNow.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchAttributeConfigurationBetaApi
     */
    public getSearchAttributeConfig(axiosOptions?: AxiosRequestConfig) {
        return SearchAttributeConfigurationBetaApiFp(this.configuration).getSearchAttributeConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API accepts an extended attribute name and retrieves the corresponding extended attribute configuration. A token with ORG_ADMIN authority is required to call this API.
     * @summary Get the details of a specific extended search attribute in IdentityNow.
     * @param {SearchAttributeConfigurationBetaApiGetSingleSearchAttributeConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchAttributeConfigurationBetaApi
     */
    public getSingleSearchAttributeConfig(requestParameters: SearchAttributeConfigurationBetaApiGetSingleSearchAttributeConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return SearchAttributeConfigurationBetaApiFp(this.configuration).getSingleSearchAttributeConfig(requestParameters.name, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates an existing Search Attribute Configuration. The following fields are patchable: **name**, **displayName**, **applicationAttributes** A token with ORG_ADMIN authority is required to call this API.
     * @summary Update the details of a specific extended search attribute in IdentityNow.
     * @param {SearchAttributeConfigurationBetaApiPatchSearchAttributeConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchAttributeConfigurationBetaApi
     */
    public patchSearchAttributeConfig(requestParameters: SearchAttributeConfigurationBetaApiPatchSearchAttributeConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return SearchAttributeConfigurationBetaApiFp(this.configuration).patchSearchAttributeConfig(requestParameters.name, requestParameters.jsonPatchOperationBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SegmentsBetaApi - axios parameter creator
 * @export
 */
export const SegmentsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates a segment.  Note that segment definitions may take time to propagate to all identities.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Create Segment
         * @param {SegmentBeta} segmentBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSegment: async (segmentBeta: SegmentBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'segmentBeta' is not null or undefined
            assertParamExists('createSegment', 'segmentBeta', segmentBeta)
            const localVarPath = `/segments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(segmentBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API deletes the segment specified by the given ID.  Note that segment deletion may take some time to become effective.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Delete Segment by ID
         * @param {string} id The ID of the Segment to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSegment: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSegment', 'id', id)
            const localVarPath = `/segments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the segment specified by the given ID.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get a Segment by its ID
         * @param {string} id The ID of the Segment to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSegment: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSegment', 'id', id)
            const localVarPath = `/segments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of all segments. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary List Segments
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSegments: async (limit?: number, offset?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/segments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Allows updating Segment fields using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Note that changes to a segment may take some time to propagate to all identities, and that segments will have no effect if segmentation is not enabled for your org.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Update a Segment
         * @param {string} id The ID of the Segment being modified.
         * @param {Array<object>} requestBody A list of Segment update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.   The following fields are patchable: * name * description * owner * visibilityCriteria * active 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSegment: async (id: string, requestBody: Array<object>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchSegment', 'id', id)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('patchSegment', 'requestBody', requestBody)
            const localVarPath = `/segments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SegmentsBetaApi - functional programming interface
 * @export
 */
export const SegmentsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SegmentsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates a segment.  Note that segment definitions may take time to propagate to all identities.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Create Segment
         * @param {SegmentBeta} segmentBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSegment(segmentBeta: SegmentBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SegmentBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSegment(segmentBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API deletes the segment specified by the given ID.  Note that segment deletion may take some time to become effective.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Delete Segment by ID
         * @param {string} id The ID of the Segment to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSegment(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSegment(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the segment specified by the given ID.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get a Segment by its ID
         * @param {string} id The ID of the Segment to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSegment(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SegmentBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSegment(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of all segments. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary List Segments
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listSegments(limit?: number, offset?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SegmentBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSegments(limit, offset, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allows updating Segment fields using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Note that changes to a segment may take some time to propagate to all identities, and that segments will have no effect if segmentation is not enabled for your org.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Update a Segment
         * @param {string} id The ID of the Segment being modified.
         * @param {Array<object>} requestBody A list of Segment update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.   The following fields are patchable: * name * description * owner * visibilityCriteria * active 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchSegment(id: string, requestBody: Array<object>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SegmentBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchSegment(id, requestBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SegmentsBetaApi - factory interface
 * @export
 */
export const SegmentsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SegmentsBetaApiFp(configuration)
    return {
        /**
         * This API creates a segment.  Note that segment definitions may take time to propagate to all identities.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Create Segment
         * @param {SegmentBeta} segmentBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSegment(segmentBeta: SegmentBeta, axiosOptions?: any): AxiosPromise<SegmentBeta> {
            return localVarFp.createSegment(segmentBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API deletes the segment specified by the given ID.  Note that segment deletion may take some time to become effective.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Delete Segment by ID
         * @param {string} id The ID of the Segment to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSegment(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteSegment(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the segment specified by the given ID.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get a Segment by its ID
         * @param {string} id The ID of the Segment to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSegment(id: string, axiosOptions?: any): AxiosPromise<SegmentBeta> {
            return localVarFp.getSegment(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of all segments. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary List Segments
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSegments(limit?: number, offset?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<SegmentBeta>> {
            return localVarFp.listSegments(limit, offset, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Allows updating Segment fields using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Note that changes to a segment may take some time to propagate to all identities, and that segments will have no effect if segmentation is not enabled for your org.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Update a Segment
         * @param {string} id The ID of the Segment being modified.
         * @param {Array<object>} requestBody A list of Segment update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.   The following fields are patchable: * name * description * owner * visibilityCriteria * active 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSegment(id: string, requestBody: Array<object>, axiosOptions?: any): AxiosPromise<SegmentBeta> {
            return localVarFp.patchSegment(id, requestBody, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSegment operation in SegmentsBetaApi.
 * @export
 * @interface SegmentsBetaApiCreateSegmentRequest
 */
export interface SegmentsBetaApiCreateSegmentRequest {
    /**
     * 
     * @type {SegmentBeta}
     * @memberof SegmentsBetaApiCreateSegment
     */
    readonly segmentBeta: SegmentBeta
}

/**
 * Request parameters for deleteSegment operation in SegmentsBetaApi.
 * @export
 * @interface SegmentsBetaApiDeleteSegmentRequest
 */
export interface SegmentsBetaApiDeleteSegmentRequest {
    /**
     * The ID of the Segment to delete.
     * @type {string}
     * @memberof SegmentsBetaApiDeleteSegment
     */
    readonly id: string
}

/**
 * Request parameters for getSegment operation in SegmentsBetaApi.
 * @export
 * @interface SegmentsBetaApiGetSegmentRequest
 */
export interface SegmentsBetaApiGetSegmentRequest {
    /**
     * The ID of the Segment to retrieve.
     * @type {string}
     * @memberof SegmentsBetaApiGetSegment
     */
    readonly id: string
}

/**
 * Request parameters for listSegments operation in SegmentsBetaApi.
 * @export
 * @interface SegmentsBetaApiListSegmentsRequest
 */
export interface SegmentsBetaApiListSegmentsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SegmentsBetaApiListSegments
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SegmentsBetaApiListSegments
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SegmentsBetaApiListSegments
     */
    readonly count?: boolean
}

/**
 * Request parameters for patchSegment operation in SegmentsBetaApi.
 * @export
 * @interface SegmentsBetaApiPatchSegmentRequest
 */
export interface SegmentsBetaApiPatchSegmentRequest {
    /**
     * The ID of the Segment being modified.
     * @type {string}
     * @memberof SegmentsBetaApiPatchSegment
     */
    readonly id: string

    /**
     * A list of Segment update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.   The following fields are patchable: * name * description * owner * visibilityCriteria * active 
     * @type {Array<object>}
     * @memberof SegmentsBetaApiPatchSegment
     */
    readonly requestBody: Array<object>
}

/**
 * SegmentsBetaApi - object-oriented interface
 * @export
 * @class SegmentsBetaApi
 * @extends {BaseAPI}
 */
export class SegmentsBetaApi extends BaseAPI {
    /**
     * This API creates a segment.  Note that segment definitions may take time to propagate to all identities.  A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Create Segment
     * @param {SegmentsBetaApiCreateSegmentRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsBetaApi
     */
    public createSegment(requestParameters: SegmentsBetaApiCreateSegmentRequest, axiosOptions?: AxiosRequestConfig) {
        return SegmentsBetaApiFp(this.configuration).createSegment(requestParameters.segmentBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API deletes the segment specified by the given ID.  Note that segment deletion may take some time to become effective.  A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Delete Segment by ID
     * @param {SegmentsBetaApiDeleteSegmentRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsBetaApi
     */
    public deleteSegment(requestParameters: SegmentsBetaApiDeleteSegmentRequest, axiosOptions?: AxiosRequestConfig) {
        return SegmentsBetaApiFp(this.configuration).deleteSegment(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the segment specified by the given ID.  A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Get a Segment by its ID
     * @param {SegmentsBetaApiGetSegmentRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsBetaApi
     */
    public getSegment(requestParameters: SegmentsBetaApiGetSegmentRequest, axiosOptions?: AxiosRequestConfig) {
        return SegmentsBetaApiFp(this.configuration).getSegment(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of all segments. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary List Segments
     * @param {SegmentsBetaApiListSegmentsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsBetaApi
     */
    public listSegments(requestParameters: SegmentsBetaApiListSegmentsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return SegmentsBetaApiFp(this.configuration).listSegments(requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows updating Segment fields using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Note that changes to a segment may take some time to propagate to all identities, and that segments will have no effect if segmentation is not enabled for your org.  A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Update a Segment
     * @param {SegmentsBetaApiPatchSegmentRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsBetaApi
     */
    public patchSegment(requestParameters: SegmentsBetaApiPatchSegmentRequest, axiosOptions?: AxiosRequestConfig) {
        return SegmentsBetaApiFp(this.configuration).patchSegment(requestParameters.id, requestParameters.requestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServiceDeskIntegrationBetaApi - axios parameter creator
 * @export
 */
export const ServiceDeskIntegrationBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Create new Service Desk integration
         * @param {ServiceDeskIntegrationDtoBeta} serviceDeskIntegrationDtoBeta The specifics of a new integration to create
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createServiceDeskIntegration: async (serviceDeskIntegrationDtoBeta: ServiceDeskIntegrationDtoBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceDeskIntegrationDtoBeta' is not null or undefined
            assertParamExists('createServiceDeskIntegration', 'serviceDeskIntegrationDtoBeta', serviceDeskIntegrationDtoBeta)
            const localVarPath = `/service-desk-integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceDeskIntegrationDtoBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Delete a Service Desk integration
         * @param {string} id ID of Service Desk integration to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceDeskIntegration: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteServiceDeskIntegration', 'id', id)
            const localVarPath = `/service-desk-integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get a Service Desk integration
         * @param {string} id ID of the Service Desk integration to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegration: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getServiceDeskIntegration', 'id', id)
            const localVarPath = `/service-desk-integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get a list of ServiceDeskIntegrationDto for existing Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary List existing Service Desk Integrations
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq*  **type**: *eq, in*  **cluster**: *eq, in*
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationList: async (offset?: number, limit?: number, sorters?: string, filters?: string, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/service-desk-integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API endpoint returns an existing Service Desk integration template by scriptName.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk integration template by scriptName.
         * @param {string} scriptName The scriptName value of the Service Desk integration template to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationTemplate: async (scriptName: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptName' is not null or undefined
            assertParamExists('getServiceDeskIntegrationTemplate', 'scriptName', scriptName)
            const localVarPath = `/service-desk-integrations/templates/{scriptName}`
                .replace(`{${"scriptName"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API endpoint returns the current list of supported Service Desk integration types.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk Integration Types List.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationTypes: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/service-desk-integrations/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get the time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getStatusCheckDetails: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/service-desk-integrations/status-check-configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update an existing ServiceDeskIntegration by ID with a PATCH request.
         * @summary Service Desk Integration Update PATCH
         * @param {string} id ID of the Service Desk integration to update
         * @param {JsonPatchBeta} jsonPatchBeta A list of SDIM update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  PATCH can only be applied to the following fields:   * &#x60;beforeProvisioningRule&#x60;   * &#x60;description&#x60;   * &#x60;ownerRef&#x60;  A 403 Forbidden Error indicates that you attempted to PATCH a field that is not allowed. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchServiceDeskIntegration: async (id: string, jsonPatchBeta: JsonPatchBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchServiceDeskIntegration', 'id', id)
            // verify required parameter 'jsonPatchBeta' is not null or undefined
            assertParamExists('patchServiceDeskIntegration', 'jsonPatchBeta', jsonPatchBeta)
            const localVarPath = `/service-desk-integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update an existing Service Desk integration by ID with updated value in JSON form as the request body.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update a Service Desk integration
         * @param {string} id ID of the Service Desk integration to update
         * @param {ServiceDeskIntegrationDtoBeta} serviceDeskIntegrationDtoBeta The specifics of the integration to update
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putServiceDeskIntegration: async (id: string, serviceDeskIntegrationDtoBeta: ServiceDeskIntegrationDtoBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putServiceDeskIntegration', 'id', id)
            // verify required parameter 'serviceDeskIntegrationDtoBeta' is not null or undefined
            assertParamExists('putServiceDeskIntegration', 'serviceDeskIntegrationDtoBeta', serviceDeskIntegrationDtoBeta)
            const localVarPath = `/service-desk-integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceDeskIntegrationDtoBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update the time check configuration
         * @param {QueuedCheckConfigDetailsBeta} queuedCheckConfigDetailsBeta the modified time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateStatusCheckDetails: async (queuedCheckConfigDetailsBeta: QueuedCheckConfigDetailsBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queuedCheckConfigDetailsBeta' is not null or undefined
            assertParamExists('updateStatusCheckDetails', 'queuedCheckConfigDetailsBeta', queuedCheckConfigDetailsBeta)
            const localVarPath = `/service-desk-integrations/status-check-configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queuedCheckConfigDetailsBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceDeskIntegrationBetaApi - functional programming interface
 * @export
 */
export const ServiceDeskIntegrationBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceDeskIntegrationBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Create new Service Desk integration
         * @param {ServiceDeskIntegrationDtoBeta} serviceDeskIntegrationDtoBeta The specifics of a new integration to create
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createServiceDeskIntegration(serviceDeskIntegrationDtoBeta: ServiceDeskIntegrationDtoBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDeskIntegrationDtoBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createServiceDeskIntegration(serviceDeskIntegrationDtoBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Delete a Service Desk integration
         * @param {string} id ID of Service Desk integration to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteServiceDeskIntegration(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteServiceDeskIntegration(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get a Service Desk integration
         * @param {string} id ID of the Service Desk integration to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDeskIntegration(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDeskIntegrationDtoBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDeskIntegration(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of ServiceDeskIntegrationDto for existing Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary List existing Service Desk Integrations
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq*  **type**: *eq, in*  **cluster**: *eq, in*
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDeskIntegrationList(offset?: number, limit?: number, sorters?: string, filters?: string, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceDeskIntegrationDtoBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDeskIntegrationList(offset, limit, sorters, filters, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API endpoint returns an existing Service Desk integration template by scriptName.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk integration template by scriptName.
         * @param {string} scriptName The scriptName value of the Service Desk integration template to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDeskIntegrationTemplate(scriptName: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDeskIntegrationTemplateDtoBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDeskIntegrationTemplate(scriptName, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API endpoint returns the current list of supported Service Desk integration types.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk Integration Types List.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDeskIntegrationTypes(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceDeskIntegrationTemplateTypeBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDeskIntegrationTypes(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get the time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusCheckDetails(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedCheckConfigDetailsBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusCheckDetails(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing ServiceDeskIntegration by ID with a PATCH request.
         * @summary Service Desk Integration Update PATCH
         * @param {string} id ID of the Service Desk integration to update
         * @param {JsonPatchBeta} jsonPatchBeta A list of SDIM update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  PATCH can only be applied to the following fields:   * &#x60;beforeProvisioningRule&#x60;   * &#x60;description&#x60;   * &#x60;ownerRef&#x60;  A 403 Forbidden Error indicates that you attempted to PATCH a field that is not allowed. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchServiceDeskIntegration(id: string, jsonPatchBeta: JsonPatchBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDeskIntegrationDtoBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchServiceDeskIntegration(id, jsonPatchBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing Service Desk integration by ID with updated value in JSON form as the request body.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update a Service Desk integration
         * @param {string} id ID of the Service Desk integration to update
         * @param {ServiceDeskIntegrationDtoBeta} serviceDeskIntegrationDtoBeta The specifics of the integration to update
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putServiceDeskIntegration(id: string, serviceDeskIntegrationDtoBeta: ServiceDeskIntegrationDtoBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDeskIntegrationDtoBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putServiceDeskIntegration(id, serviceDeskIntegrationDtoBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update the time check configuration
         * @param {QueuedCheckConfigDetailsBeta} queuedCheckConfigDetailsBeta the modified time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateStatusCheckDetails(queuedCheckConfigDetailsBeta: QueuedCheckConfigDetailsBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedCheckConfigDetailsBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStatusCheckDetails(queuedCheckConfigDetailsBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServiceDeskIntegrationBetaApi - factory interface
 * @export
 */
export const ServiceDeskIntegrationBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceDeskIntegrationBetaApiFp(configuration)
    return {
        /**
         * Create a new Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Create new Service Desk integration
         * @param {ServiceDeskIntegrationDtoBeta} serviceDeskIntegrationDtoBeta The specifics of a new integration to create
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createServiceDeskIntegration(serviceDeskIntegrationDtoBeta: ServiceDeskIntegrationDtoBeta, axiosOptions?: any): AxiosPromise<ServiceDeskIntegrationDtoBeta> {
            return localVarFp.createServiceDeskIntegration(serviceDeskIntegrationDtoBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Delete a Service Desk integration
         * @param {string} id ID of Service Desk integration to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceDeskIntegration(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteServiceDeskIntegration(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get a Service Desk integration
         * @param {string} id ID of the Service Desk integration to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegration(id: string, axiosOptions?: any): AxiosPromise<ServiceDeskIntegrationDtoBeta> {
            return localVarFp.getServiceDeskIntegration(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of ServiceDeskIntegrationDto for existing Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary List existing Service Desk Integrations
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq*  **type**: *eq, in*  **cluster**: *eq, in*
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationList(offset?: number, limit?: number, sorters?: string, filters?: string, count?: boolean, axiosOptions?: any): AxiosPromise<Array<ServiceDeskIntegrationDtoBeta>> {
            return localVarFp.getServiceDeskIntegrationList(offset, limit, sorters, filters, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API endpoint returns an existing Service Desk integration template by scriptName.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk integration template by scriptName.
         * @param {string} scriptName The scriptName value of the Service Desk integration template to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationTemplate(scriptName: string, axiosOptions?: any): AxiosPromise<ServiceDeskIntegrationTemplateDtoBeta> {
            return localVarFp.getServiceDeskIntegrationTemplate(scriptName, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API endpoint returns the current list of supported Service Desk integration types.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk Integration Types List.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationTypes(axiosOptions?: any): AxiosPromise<Array<ServiceDeskIntegrationTemplateTypeBeta>> {
            return localVarFp.getServiceDeskIntegrationTypes(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get the time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getStatusCheckDetails(axiosOptions?: any): AxiosPromise<QueuedCheckConfigDetailsBeta> {
            return localVarFp.getStatusCheckDetails(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing ServiceDeskIntegration by ID with a PATCH request.
         * @summary Service Desk Integration Update PATCH
         * @param {string} id ID of the Service Desk integration to update
         * @param {JsonPatchBeta} jsonPatchBeta A list of SDIM update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  PATCH can only be applied to the following fields:   * &#x60;beforeProvisioningRule&#x60;   * &#x60;description&#x60;   * &#x60;ownerRef&#x60;  A 403 Forbidden Error indicates that you attempted to PATCH a field that is not allowed. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchServiceDeskIntegration(id: string, jsonPatchBeta: JsonPatchBeta, axiosOptions?: any): AxiosPromise<ServiceDeskIntegrationDtoBeta> {
            return localVarFp.patchServiceDeskIntegration(id, jsonPatchBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing Service Desk integration by ID with updated value in JSON form as the request body.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update a Service Desk integration
         * @param {string} id ID of the Service Desk integration to update
         * @param {ServiceDeskIntegrationDtoBeta} serviceDeskIntegrationDtoBeta The specifics of the integration to update
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putServiceDeskIntegration(id: string, serviceDeskIntegrationDtoBeta: ServiceDeskIntegrationDtoBeta, axiosOptions?: any): AxiosPromise<ServiceDeskIntegrationDtoBeta> {
            return localVarFp.putServiceDeskIntegration(id, serviceDeskIntegrationDtoBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Update the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update the time check configuration
         * @param {QueuedCheckConfigDetailsBeta} queuedCheckConfigDetailsBeta the modified time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateStatusCheckDetails(queuedCheckConfigDetailsBeta: QueuedCheckConfigDetailsBeta, axiosOptions?: any): AxiosPromise<QueuedCheckConfigDetailsBeta> {
            return localVarFp.updateStatusCheckDetails(queuedCheckConfigDetailsBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createServiceDeskIntegration operation in ServiceDeskIntegrationBetaApi.
 * @export
 * @interface ServiceDeskIntegrationBetaApiCreateServiceDeskIntegrationRequest
 */
export interface ServiceDeskIntegrationBetaApiCreateServiceDeskIntegrationRequest {
    /**
     * The specifics of a new integration to create
     * @type {ServiceDeskIntegrationDtoBeta}
     * @memberof ServiceDeskIntegrationBetaApiCreateServiceDeskIntegration
     */
    readonly serviceDeskIntegrationDtoBeta: ServiceDeskIntegrationDtoBeta
}

/**
 * Request parameters for deleteServiceDeskIntegration operation in ServiceDeskIntegrationBetaApi.
 * @export
 * @interface ServiceDeskIntegrationBetaApiDeleteServiceDeskIntegrationRequest
 */
export interface ServiceDeskIntegrationBetaApiDeleteServiceDeskIntegrationRequest {
    /**
     * ID of Service Desk integration to delete
     * @type {string}
     * @memberof ServiceDeskIntegrationBetaApiDeleteServiceDeskIntegration
     */
    readonly id: string
}

/**
 * Request parameters for getServiceDeskIntegration operation in ServiceDeskIntegrationBetaApi.
 * @export
 * @interface ServiceDeskIntegrationBetaApiGetServiceDeskIntegrationRequest
 */
export interface ServiceDeskIntegrationBetaApiGetServiceDeskIntegrationRequest {
    /**
     * ID of the Service Desk integration to get
     * @type {string}
     * @memberof ServiceDeskIntegrationBetaApiGetServiceDeskIntegration
     */
    readonly id: string
}

/**
 * Request parameters for getServiceDeskIntegrationList operation in ServiceDeskIntegrationBetaApi.
 * @export
 * @interface ServiceDeskIntegrationBetaApiGetServiceDeskIntegrationListRequest
 */
export interface ServiceDeskIntegrationBetaApiGetServiceDeskIntegrationListRequest {
    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ServiceDeskIntegrationBetaApiGetServiceDeskIntegrationList
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ServiceDeskIntegrationBetaApiGetServiceDeskIntegrationList
     */
    readonly limit?: number

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
     * @type {string}
     * @memberof ServiceDeskIntegrationBetaApiGetServiceDeskIntegrationList
     */
    readonly sorters?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq*  **type**: *eq, in*  **cluster**: *eq, in*
     * @type {string}
     * @memberof ServiceDeskIntegrationBetaApiGetServiceDeskIntegrationList
     */
    readonly filters?: string

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof ServiceDeskIntegrationBetaApiGetServiceDeskIntegrationList
     */
    readonly count?: boolean
}

/**
 * Request parameters for getServiceDeskIntegrationTemplate operation in ServiceDeskIntegrationBetaApi.
 * @export
 * @interface ServiceDeskIntegrationBetaApiGetServiceDeskIntegrationTemplateRequest
 */
export interface ServiceDeskIntegrationBetaApiGetServiceDeskIntegrationTemplateRequest {
    /**
     * The scriptName value of the Service Desk integration template to get
     * @type {string}
     * @memberof ServiceDeskIntegrationBetaApiGetServiceDeskIntegrationTemplate
     */
    readonly scriptName: string
}

/**
 * Request parameters for patchServiceDeskIntegration operation in ServiceDeskIntegrationBetaApi.
 * @export
 * @interface ServiceDeskIntegrationBetaApiPatchServiceDeskIntegrationRequest
 */
export interface ServiceDeskIntegrationBetaApiPatchServiceDeskIntegrationRequest {
    /**
     * ID of the Service Desk integration to update
     * @type {string}
     * @memberof ServiceDeskIntegrationBetaApiPatchServiceDeskIntegration
     */
    readonly id: string

    /**
     * A list of SDIM update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  PATCH can only be applied to the following fields:   * &#x60;beforeProvisioningRule&#x60;   * &#x60;description&#x60;   * &#x60;ownerRef&#x60;  A 403 Forbidden Error indicates that you attempted to PATCH a field that is not allowed. 
     * @type {JsonPatchBeta}
     * @memberof ServiceDeskIntegrationBetaApiPatchServiceDeskIntegration
     */
    readonly jsonPatchBeta: JsonPatchBeta
}

/**
 * Request parameters for putServiceDeskIntegration operation in ServiceDeskIntegrationBetaApi.
 * @export
 * @interface ServiceDeskIntegrationBetaApiPutServiceDeskIntegrationRequest
 */
export interface ServiceDeskIntegrationBetaApiPutServiceDeskIntegrationRequest {
    /**
     * ID of the Service Desk integration to update
     * @type {string}
     * @memberof ServiceDeskIntegrationBetaApiPutServiceDeskIntegration
     */
    readonly id: string

    /**
     * The specifics of the integration to update
     * @type {ServiceDeskIntegrationDtoBeta}
     * @memberof ServiceDeskIntegrationBetaApiPutServiceDeskIntegration
     */
    readonly serviceDeskIntegrationDtoBeta: ServiceDeskIntegrationDtoBeta
}

/**
 * Request parameters for updateStatusCheckDetails operation in ServiceDeskIntegrationBetaApi.
 * @export
 * @interface ServiceDeskIntegrationBetaApiUpdateStatusCheckDetailsRequest
 */
export interface ServiceDeskIntegrationBetaApiUpdateStatusCheckDetailsRequest {
    /**
     * the modified time check configuration
     * @type {QueuedCheckConfigDetailsBeta}
     * @memberof ServiceDeskIntegrationBetaApiUpdateStatusCheckDetails
     */
    readonly queuedCheckConfigDetailsBeta: QueuedCheckConfigDetailsBeta
}

/**
 * ServiceDeskIntegrationBetaApi - object-oriented interface
 * @export
 * @class ServiceDeskIntegrationBetaApi
 * @extends {BaseAPI}
 */
export class ServiceDeskIntegrationBetaApi extends BaseAPI {
    /**
     * Create a new Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Create new Service Desk integration
     * @param {ServiceDeskIntegrationBetaApiCreateServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationBetaApi
     */
    public createServiceDeskIntegration(requestParameters: ServiceDeskIntegrationBetaApiCreateServiceDeskIntegrationRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationBetaApiFp(this.configuration).createServiceDeskIntegration(requestParameters.serviceDeskIntegrationDtoBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Delete a Service Desk integration
     * @param {ServiceDeskIntegrationBetaApiDeleteServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationBetaApi
     */
    public deleteServiceDeskIntegration(requestParameters: ServiceDeskIntegrationBetaApiDeleteServiceDeskIntegrationRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationBetaApiFp(this.configuration).deleteServiceDeskIntegration(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Get a Service Desk integration
     * @param {ServiceDeskIntegrationBetaApiGetServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationBetaApi
     */
    public getServiceDeskIntegration(requestParameters: ServiceDeskIntegrationBetaApiGetServiceDeskIntegrationRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationBetaApiFp(this.configuration).getServiceDeskIntegration(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of ServiceDeskIntegrationDto for existing Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary List existing Service Desk Integrations
     * @param {ServiceDeskIntegrationBetaApiGetServiceDeskIntegrationListRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationBetaApi
     */
    public getServiceDeskIntegrationList(requestParameters: ServiceDeskIntegrationBetaApiGetServiceDeskIntegrationListRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationBetaApiFp(this.configuration).getServiceDeskIntegrationList(requestParameters.offset, requestParameters.limit, requestParameters.sorters, requestParameters.filters, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API endpoint returns an existing Service Desk integration template by scriptName.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Service Desk integration template by scriptName.
     * @param {ServiceDeskIntegrationBetaApiGetServiceDeskIntegrationTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationBetaApi
     */
    public getServiceDeskIntegrationTemplate(requestParameters: ServiceDeskIntegrationBetaApiGetServiceDeskIntegrationTemplateRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationBetaApiFp(this.configuration).getServiceDeskIntegrationTemplate(requestParameters.scriptName, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API endpoint returns the current list of supported Service Desk integration types.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Service Desk Integration Types List.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationBetaApi
     */
    public getServiceDeskIntegrationTypes(axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationBetaApiFp(this.configuration).getServiceDeskIntegrationTypes(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Get the time check configuration
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationBetaApi
     */
    public getStatusCheckDetails(axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationBetaApiFp(this.configuration).getStatusCheckDetails(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing ServiceDeskIntegration by ID with a PATCH request.
     * @summary Service Desk Integration Update PATCH
     * @param {ServiceDeskIntegrationBetaApiPatchServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationBetaApi
     */
    public patchServiceDeskIntegration(requestParameters: ServiceDeskIntegrationBetaApiPatchServiceDeskIntegrationRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationBetaApiFp(this.configuration).patchServiceDeskIntegration(requestParameters.id, requestParameters.jsonPatchBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing Service Desk integration by ID with updated value in JSON form as the request body.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Update a Service Desk integration
     * @param {ServiceDeskIntegrationBetaApiPutServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationBetaApi
     */
    public putServiceDeskIntegration(requestParameters: ServiceDeskIntegrationBetaApiPutServiceDeskIntegrationRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationBetaApiFp(this.configuration).putServiceDeskIntegration(requestParameters.id, requestParameters.serviceDeskIntegrationDtoBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Update the time check configuration
     * @param {ServiceDeskIntegrationBetaApiUpdateStatusCheckDetailsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationBetaApi
     */
    public updateStatusCheckDetails(requestParameters: ServiceDeskIntegrationBetaApiUpdateStatusCheckDetailsRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationBetaApiFp(this.configuration).updateStatusCheckDetails(requestParameters.queuedCheckConfigDetailsBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SourcesBetaApi - axios parameter creator
 * @export
 */
export const SourcesBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This end-point deletes a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. All of accounts on the source will be removed first, then the source will be deleted. Actual status of task execution can be retrieved via method GET `/task-status/{id}`
         * @summary Delete Source by ID
         * @param {string} id The Source ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('_delete', 'id', id)
            const localVarPath = `/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API generates a create policy/template based on field value transforms. This API is intended for use when setting up JDBC Provisioning type sources, but it will also work on other source types. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Provisioning Policy
         * @param {string} sourceId The Source id
         * @param {ProvisioningPolicyDtoBeta} provisioningPolicyDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createProvisioningPolicy: async (sourceId: string, provisioningPolicyDtoBeta: ProvisioningPolicyDtoBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('createProvisioningPolicy', 'sourceId', sourceId)
            // verify required parameter 'provisioningPolicyDtoBeta' is not null or undefined
            assertParamExists('createProvisioningPolicy', 'provisioningPolicyDtoBeta', provisioningPolicyDtoBeta)
            const localVarPath = `/sources/{sourceId}/provisioning-policies`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(provisioningPolicyDtoBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This creates a specific source with a full source JSON representation. Any passwords are submitted as plain-text and encrypted upon receipt in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Creates a source in IdentityNow.
         * @param {SourceBeta} sourceBeta 
         * @param {boolean} [provisionAsCsv] If this parameter is &#x60;true&#x60;, it configures the source as a Delimited File (CSV) source. Setting this to &#x60;true&#x60; will automatically set the &#x60;type&#x60; of the source to &#x60;DelimitedFile&#x60;.  You must use this query parameter to create a Delimited File source as you would in the UI.  If you don\&#39;t set this query parameter and you attempt to set the &#x60;type&#x60; attribute directly, the request won\&#39;t correctly generate the source.  
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSource: async (sourceBeta: SourceBeta, provisionAsCsv?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceBeta' is not null or undefined
            assertParamExists('createSource', 'sourceBeta', sourceBeta)
            const localVarPath = `/sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (provisionAsCsv !== undefined) {
                localVarQueryParameter['provisionAsCsv'] = provisionAsCsv;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new Schema on the specified Source in IdentityNow.
         * @param {string} sourceId The Source id.
         * @param {SchemaBeta} schemaBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSourceSchema: async (sourceId: string, schemaBeta: SchemaBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('createSourceSchema', 'sourceId', sourceId)
            // verify required parameter 'schemaBeta' is not null or undefined
            assertParamExists('createSourceSchema', 'schemaBeta', schemaBeta)
            const localVarPath = `/sources/{sourceId}/schemas`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schemaBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes the provisioning policy with the specified usage on an application. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageTypeBeta} usageType The type of ProvisioningPolicy usage.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteProvisioningPolicy: async (sourceId: string, usageType: UsageTypeBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteProvisioningPolicy', 'sourceId', sourceId)
            // verify required parameter 'usageType' is not null or undefined
            assertParamExists('deleteProvisioningPolicy', 'usageType', usageType)
            const localVarPath = `/sources/{sourceId}/provisioning-policies/{usageType}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"usageType"}}`, encodeURIComponent(String(usageType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Source Schema by ID
         * @param {string} sourceId The Source ID.
         * @param {string} schemaId The Schema ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSourceSchema: async (sourceId: string, schemaId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteSourceSchema', 'sourceId', sourceId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('deleteSourceSchema', 'schemaId', schemaId)
            const localVarPath = `/sources/{sourceId}/schemas/{schemaId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"schemaId"}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point retrieves the ProvisioningPolicy with the specified usage on the specified Source in IdentityNow. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageTypeBeta} usageType The type of ProvisioningPolicy usage.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getProvisioningPolicy: async (sourceId: string, usageType: UsageTypeBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getProvisioningPolicy', 'sourceId', sourceId)
            // verify required parameter 'usageType' is not null or undefined
            assertParamExists('getProvisioningPolicy', 'usageType', usageType)
            const localVarPath = `/sources/{sourceId}/provisioning-policies/{usageType}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"usageType"}}`, encodeURIComponent(String(usageType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point gets a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Source by ID
         * @param {string} id The Source ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSource: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSource', 'id', id)
            const localVarPath = `/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Downloads source accounts schema template
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceAccountsSchema: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSourceAccountsSchema', 'id', id)
            const localVarPath = `/sources/{id}/schemas/accounts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the existing attribute synchronization configuration for a source specified by the given ID. The response contains all attributes, regardless of whether they enabled or not. A token with ORG_ADMIN authority is required to call this API.
         * @summary Attribute Sync Config
         * @param {string} id The source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceAttrSyncConfig: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSourceAttrSyncConfig', 'id', id)
            const localVarPath = `/sources/{id}/attribute-sync-config`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Looks up and returns the source config for the requested source id after populating the source config values and applying language translations. A token with ORG_ADMIN authority is required to call this API.
         * @summary Gets source config with language translations
         * @param {string} id The Source id
         * @param {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'} [locale] The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceConfig: async (id: string, locale?: 'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl', axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSourceConfig', 'id', id)
            const localVarPath = `/sources/{id}/connectors/source-config`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API gets the current entitlement request configuration for a source. This source-level configuration should apply for all the entitlements in the source.  Access request to any entitlements in the source should follow this configuration unless a separate entitlement-level configuration is defined. - During access request, this source-level entitlement request configuration overrides the global organization-level configuration. - However, the entitlement-level configuration (if defined) overrides this source-level configuration.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Source Entitlement Request Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceEntitlementRequestConfig: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sources/{id}/entitlement-request-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Downloads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceEntitlementsSchema: async (id: string, schemaName?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSourceEntitlementsSchema', 'id', id)
            const localVarPath = `/sources/{id}/schemas/entitlements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (schemaName !== undefined) {
                localVarQueryParameter['schemaName'] = schemaName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get the Source Schema by ID in IdentityNow. 
         * @summary Get Source Schema by ID
         * @param {string} sourceId The Source ID.
         * @param {string} schemaId The Schema ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceSchema: async (sourceId: string, schemaId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getSourceSchema', 'sourceId', sourceId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('getSourceSchema', 'schemaId', schemaId)
            const localVarPath = `/sources/{sourceId}/schemas/{schemaId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"schemaId"}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API uploads a source schema template file to configure a source\'s account attributes.
         * @summary Uploads source accounts schema template
         * @param {string} id The Source id
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importSourceAccountsSchema: async (id: string, file?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('importSourceAccountsSchema', 'id', id)
            const localVarPath = `/sources/{id}/schemas/accounts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This uploads a supplemental source connector file (like jdbc driver jars) to a source\'s S3 bucket. This also sends ETS and Audit events. A token with ORG_ADMIN authority is required to call this API.
         * @summary Upload connector file to source
         * @param {string} sourceId The Source id
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importSourceConnectorFile: async (sourceId: string, file?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('importSourceConnectorFile', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}/upload-connector-file`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API uploads a source schema template file to configure a source\'s entitlement attributes.
         * @summary Uploads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importSourceEntitlementsSchema: async (id: string, schemaName?: string, file?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('importSourceEntitlementsSchema', 'id', id)
            const localVarPath = `/sources/{id}/schemas/entitlements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (schemaName !== undefined) {
                localVarQueryParameter['schemaName'] = schemaName;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point lists all the ProvisioningPolicies in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists ProvisioningPolicies
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listProvisioningPolicies: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('listProvisioningPolicies', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}/provisioning-policies`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists the Schemas that exist on the specified Source in IdentityNow.
         * @param {string} sourceId The Source id.
         * @param {string} [includeTypes] If set to \&#39;group\&#39;, then the account schema is filtered and only group schemas are returned. Only a value of \&#39;group\&#39; is recognized.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSourceSchemas: async (sourceId: string, includeTypes?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('listSourceSchemas', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}/schemas`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (includeTypes !== undefined) {
                localVarQueryParameter['include-types'] = includeTypes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point lists all the sources in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary Lists all sources in IdentityNow.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators:   **id**: *eq, in*   **name**: *co, eq, in, sw*   **type**: *eq, in*   **owner.id**: *eq, in*   **features**: *ca, co*   **created**: *eq*   **modified**: *eq*   **managementWorkgroup.id**: *eq*   **description**: *eq*   **authoritative**: *eq*   **healthy**: *eq*   **status**: *eq, in*   **connectionType**: *eq*   **connectorName**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **type, created, modified, name, owner.name, healthy, status**
         * @param {string} [forSubadmin] Filter the returned list of sources for the identity specified by the parameter, which is the id of an identity with the role SOURCE_SUBADMIN. By convention, the value **me** indicates the identity id of the current user. Subadmins may only view Sources which they are able to administer; all other Sources will be filtered out when this parameter is set. If the current user is a SOURCE_SUBADMIN but fails to pass a valid value for this parameter, a 403 Forbidden is returned.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSources: async (limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSubadmin?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (forSubadmin !== undefined) {
                localVarQueryParameter['for-subadmin'] = forSubadmin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a sample of data returned from account and group aggregation requests. A token with ORG_ADMIN authority is required to call this API.
         * @summary Peek source connector\'s resource objects
         * @param {string} sourceId The ID of the Source
         * @param {ResourceObjectsRequestBeta} resourceObjectsRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        peekResourceObjects: async (sourceId: string, resourceObjectsRequestBeta: ResourceObjectsRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('peekResourceObjects', 'sourceId', sourceId)
            // verify required parameter 'resourceObjectsRequestBeta' is not null or undefined
            assertParamExists('peekResourceObjects', 'resourceObjectsRequestBeta', resourceObjectsRequestBeta)
            const localVarPath = `/sources/{sourceId}/connector/peek-resource-objects`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resourceObjectsRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint validates that the cluster being used by the source is reachable from IdentityNow. A token with ORG_ADMIN authority is required to call this API.
         * @summary Ping cluster for source connector
         * @param {string} sourceId The ID of the Source
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        pingCluster: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('pingCluster', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}/connector/ping-cluster`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point updates the provisioning policy with the specified usage on the specified source in IdentityNow. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Update Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageTypeBeta} usageType The type of ProvisioningPolicy usage.
         * @param {ProvisioningPolicyDtoBeta} provisioningPolicyDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putProvisioningPolicy: async (sourceId: string, usageType: UsageTypeBeta, provisioningPolicyDtoBeta: ProvisioningPolicyDtoBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('putProvisioningPolicy', 'sourceId', sourceId)
            // verify required parameter 'usageType' is not null or undefined
            assertParamExists('putProvisioningPolicy', 'usageType', usageType)
            // verify required parameter 'provisioningPolicyDtoBeta' is not null or undefined
            assertParamExists('putProvisioningPolicy', 'provisioningPolicyDtoBeta', provisioningPolicyDtoBeta)
            const localVarPath = `/sources/{sourceId}/provisioning-policies/{usageType}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"usageType"}}`, encodeURIComponent(String(usageType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(provisioningPolicyDtoBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates a source in IdentityNow, using a full object representation. In other words, the existing Source configuration is completely replaced.  Some fields are immutable and cannot be changed, such as:  * id * type * authoritative * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. 
         * @summary Update Source (Full)
         * @param {string} id The Source id
         * @param {SourceBeta} sourceBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSource: async (id: string, sourceBeta: SourceBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putSource', 'id', id)
            // verify required parameter 'sourceBeta' is not null or undefined
            assertParamExists('putSource', 'sourceBeta', sourceBeta)
            const localVarPath = `/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Replaces the attribute synchronization configuration for the source specified by the given ID with the configuration provided in the request body. Only the \"enabled\" field of the values in the \"attributes\" array is mutable. Attempting to change other attributes or add new values to the \"attributes\" array will result in an error.      A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Attribute Sync Config
         * @param {string} id The source id
         * @param {AttrSyncSourceConfigBeta} attrSyncSourceConfigBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSourceAttrSyncConfig: async (id: string, attrSyncSourceConfigBeta: AttrSyncSourceConfigBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putSourceAttrSyncConfig', 'id', id)
            // verify required parameter 'attrSyncSourceConfigBeta' is not null or undefined
            assertParamExists('putSourceAttrSyncConfig', 'attrSyncSourceConfigBeta', attrSyncSourceConfigBeta)
            const localVarPath = `/sources/{id}/attribute-sync-config`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attrSyncSourceConfigBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API will completely replace an existing Schema with the submitted payload. Some fields of the Schema cannot be updated. These fields are listed below. * id * name * created * modified Any attempt to modify these fields will result in an error response with a status code of 400.
         * @summary Update Source Schema (Full)
         * @param {string} sourceId The Source ID.
         * @param {string} schemaId The Schema ID.
         * @param {SchemaBeta} schemaBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSourceSchema: async (sourceId: string, schemaId: string, schemaBeta: SchemaBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('putSourceSchema', 'sourceId', sourceId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('putSourceSchema', 'schemaId', schemaId)
            // verify required parameter 'schemaBeta' is not null or undefined
            assertParamExists('putSourceSchema', 'schemaBeta', schemaBeta)
            const localVarPath = `/sources/{sourceId}/schemas/{schemaId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"schemaId"}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schemaBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point performs attribute synchronization for a selected source. A token with ORG_ADMIN or SOURCE_ADMIN authority is required to call this API.
         * @summary Synchronize single source attributes.
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        syncAttributesForSource: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('syncAttributesForSource', 'id', id)
            const localVarPath = `/sources/{id}/synchronize-attributes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint performs a more detailed validation of the source\'s configuration that can take longer than the lighter weight credential validation performed by the checkConnection API. A token with ORG_ADMIN authority is required to call this API.
         * @summary Test configuration for source connector
         * @param {string} sourceId The ID of the Source
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testSourceConfiguration: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('testSourceConfiguration', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}/connector/test-configuration`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint validates that the configured credentials are valid and will properly authenticate with the source identified by the sourceId path parameter. A token with ORG_ADMIN authority is required to call this API.
         * @summary Check connection for source connector.
         * @param {string} sourceId The ID of the Source.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testSourceConnection: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('testSourceConnection', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}/connector/check-connection`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point updates a list of provisioning policies on the specified source in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Bulk Update Provisioning Policies
         * @param {string} sourceId The Source id.
         * @param {Array<ProvisioningPolicyDtoBeta>} provisioningPolicyDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateProvisioningPoliciesInBulk: async (sourceId: string, provisioningPolicyDtoBeta: Array<ProvisioningPolicyDtoBeta>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('updateProvisioningPoliciesInBulk', 'sourceId', sourceId)
            // verify required parameter 'provisioningPolicyDtoBeta' is not null or undefined
            assertParamExists('updateProvisioningPoliciesInBulk', 'provisioningPolicyDtoBeta', provisioningPolicyDtoBeta)
            const localVarPath = `/sources/{sourceId}/provisioning-policies/bulk-update`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(provisioningPolicyDtoBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API selectively updates an existing Provisioning Policy using a JSONPatch payload. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Partial update of Provisioning Policy
         * @param {string} sourceId The Source id.
         * @param {UsageTypeBeta} usageType The type of ProvisioningPolicy usage.
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateProvisioningPolicy: async (sourceId: string, usageType: UsageTypeBeta, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('updateProvisioningPolicy', 'sourceId', sourceId)
            // verify required parameter 'usageType' is not null or undefined
            assertParamExists('updateProvisioningPolicy', 'usageType', usageType)
            // verify required parameter 'jsonPatchOperationBeta' is not null or undefined
            assertParamExists('updateProvisioningPolicy', 'jsonPatchOperationBeta', jsonPatchOperationBeta)
            const localVarPath = `/sources/{sourceId}/provisioning-policies/{usageType}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"usageType"}}`, encodeURIComponent(String(usageType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperationBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API partially updates a source in IdentityNow, using a list of patch operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Some fields are immutable and cannot be changed, such as: * id * type * authoritative * created * modified * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or API authority is required to call this API. 
         * @summary Update Source (Partial)
         * @param {string} id The Source id
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Any password changes are submitted as plain-text and encrypted upon receipt in IdentityNow.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSource: async (id: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSource', 'id', id)
            // verify required parameter 'jsonPatchOperationBeta' is not null or undefined
            assertParamExists('updateSource', 'jsonPatchOperationBeta', jsonPatchOperationBeta)
            const localVarPath = `/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperationBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API replaces the current entitlement request configuration for a source. This source-level configuration should apply for all the entitlements in the source.  Access request to any entitlements in the source should follow this configuration unless a separate entitlement-level configuration is defined. - During access request, this source-level entitlement request configuration overrides the global organization-level configuration. - However, the entitlement-level configuration (if defined) overrides this source-level configuration.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Update Source Entitlement Request Configuration
         * @param {SourceEntitlementRequestConfigBeta} sourceEntitlementRequestConfigBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSourceEntitlementRequestConfig: async (sourceEntitlementRequestConfigBeta: SourceEntitlementRequestConfigBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceEntitlementRequestConfigBeta' is not null or undefined
            assertParamExists('updateSourceEntitlementRequestConfig', 'sourceEntitlementRequestConfigBeta', sourceEntitlementRequestConfigBeta)
            const localVarPath = `/sources/{id}/entitlement-request-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceEntitlementRequestConfigBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to selectively update an existing Schema using a JSONPatch payload.   The following schema fields are immutable and cannot be updated:  - id - name - created - modified   To switch an account attribute to a group entitlement, you need to have the following in place:  - `isEntitlement: true` - Must define a schema for the group and [add it to the source](https://developer.sailpoint.com/idn/api/beta/create-source-schema) before updating the `isGroup` flag.  For example, here is the `group` account attribute referencing a schema that defines the group: ```json {     \"name\": \"groups\",     \"type\": \"STRING\",     \"schema\": {         \"type\": \"CONNECTOR_SCHEMA\",         \"id\": \"2c9180887671ff8c01767b4671fc7d60\",         \"name\": \"group\"     },     \"description\": \"The groups, roles etc. that reference account group objects\",     \"isMulti\": true,     \"isEntitlement\": true,     \"isGroup\": true } ``` 
         * @summary Update Source Schema (Partial)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSourceSchema: async (sourceId: string, schemaId: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('updateSourceSchema', 'sourceId', sourceId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('updateSourceSchema', 'schemaId', schemaId)
            // verify required parameter 'jsonPatchOperationBeta' is not null or undefined
            assertParamExists('updateSourceSchema', 'jsonPatchOperationBeta', jsonPatchOperationBeta)
            const localVarPath = `/sources/{sourceId}/schemas/{schemaId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"schemaId"}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperationBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SourcesBetaApi - functional programming interface
 * @export
 */
export const SourcesBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SourcesBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This end-point deletes a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. All of accounts on the source will be removed first, then the source will be deleted. Actual status of task execution can be retrieved via method GET `/task-status/{id}`
         * @summary Delete Source by ID
         * @param {string} id The Source ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Delete202ResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API generates a create policy/template based on field value transforms. This API is intended for use when setting up JDBC Provisioning type sources, but it will also work on other source types. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Provisioning Policy
         * @param {string} sourceId The Source id
         * @param {ProvisioningPolicyDtoBeta} provisioningPolicyDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createProvisioningPolicy(sourceId: string, provisioningPolicyDtoBeta: ProvisioningPolicyDtoBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisioningPolicyDtoBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProvisioningPolicy(sourceId, provisioningPolicyDtoBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This creates a specific source with a full source JSON representation. Any passwords are submitted as plain-text and encrypted upon receipt in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Creates a source in IdentityNow.
         * @param {SourceBeta} sourceBeta 
         * @param {boolean} [provisionAsCsv] If this parameter is &#x60;true&#x60;, it configures the source as a Delimited File (CSV) source. Setting this to &#x60;true&#x60; will automatically set the &#x60;type&#x60; of the source to &#x60;DelimitedFile&#x60;.  You must use this query parameter to create a Delimited File source as you would in the UI.  If you don\&#39;t set this query parameter and you attempt to set the &#x60;type&#x60; attribute directly, the request won\&#39;t correctly generate the source.  
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSource(sourceBeta: SourceBeta, provisionAsCsv?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSource(sourceBeta, provisionAsCsv, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a new Schema on the specified Source in IdentityNow.
         * @param {string} sourceId The Source id.
         * @param {SchemaBeta} schemaBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSourceSchema(sourceId: string, schemaBeta: SchemaBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchemaBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSourceSchema(sourceId, schemaBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the provisioning policy with the specified usage on an application. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageTypeBeta} usageType The type of ProvisioningPolicy usage.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProvisioningPolicy(sourceId: string, usageType: UsageTypeBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProvisioningPolicy(sourceId, usageType, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Source Schema by ID
         * @param {string} sourceId The Source ID.
         * @param {string} schemaId The Schema ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSourceSchema(sourceId: string, schemaId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSourceSchema(sourceId, schemaId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point retrieves the ProvisioningPolicy with the specified usage on the specified Source in IdentityNow. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageTypeBeta} usageType The type of ProvisioningPolicy usage.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getProvisioningPolicy(sourceId: string, usageType: UsageTypeBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisioningPolicyDtoBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProvisioningPolicy(sourceId, usageType, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point gets a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Source by ID
         * @param {string} id The Source ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSource(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSource(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Downloads source accounts schema template
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSourceAccountsSchema(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSourceAccountsSchema(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the existing attribute synchronization configuration for a source specified by the given ID. The response contains all attributes, regardless of whether they enabled or not. A token with ORG_ADMIN authority is required to call this API.
         * @summary Attribute Sync Config
         * @param {string} id The source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSourceAttrSyncConfig(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttrSyncSourceConfigBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSourceAttrSyncConfig(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Looks up and returns the source config for the requested source id after populating the source config values and applying language translations. A token with ORG_ADMIN authority is required to call this API.
         * @summary Gets source config with language translations
         * @param {string} id The Source id
         * @param {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'} [locale] The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSourceConfig(id: string, locale?: 'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl', axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorDetailBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSourceConfig(id, locale, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API gets the current entitlement request configuration for a source. This source-level configuration should apply for all the entitlements in the source.  Access request to any entitlements in the source should follow this configuration unless a separate entitlement-level configuration is defined. - During access request, this source-level entitlement request configuration overrides the global organization-level configuration. - However, the entitlement-level configuration (if defined) overrides this source-level configuration.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Source Entitlement Request Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSourceEntitlementRequestConfig(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceEntitlementRequestConfigBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSourceEntitlementRequestConfig(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Downloads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSourceEntitlementsSchema(id: string, schemaName?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSourceEntitlementsSchema(id, schemaName, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the Source Schema by ID in IdentityNow. 
         * @summary Get Source Schema by ID
         * @param {string} sourceId The Source ID.
         * @param {string} schemaId The Schema ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSourceSchema(sourceId: string, schemaId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchemaBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSourceSchema(sourceId, schemaId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API uploads a source schema template file to configure a source\'s account attributes.
         * @summary Uploads source accounts schema template
         * @param {string} id The Source id
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async importSourceAccountsSchema(id: string, file?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchemaBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importSourceAccountsSchema(id, file, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This uploads a supplemental source connector file (like jdbc driver jars) to a source\'s S3 bucket. This also sends ETS and Audit events. A token with ORG_ADMIN authority is required to call this API.
         * @summary Upload connector file to source
         * @param {string} sourceId The Source id
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async importSourceConnectorFile(sourceId: string, file?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importSourceConnectorFile(sourceId, file, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API uploads a source schema template file to configure a source\'s entitlement attributes.
         * @summary Uploads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async importSourceEntitlementsSchema(id: string, schemaName?: string, file?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchemaBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importSourceEntitlementsSchema(id, schemaName, file, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point lists all the ProvisioningPolicies in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists ProvisioningPolicies
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listProvisioningPolicies(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProvisioningPolicyDtoBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProvisioningPolicies(sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Lists the Schemas that exist on the specified Source in IdentityNow.
         * @param {string} sourceId The Source id.
         * @param {string} [includeTypes] If set to \&#39;group\&#39;, then the account schema is filtered and only group schemas are returned. Only a value of \&#39;group\&#39; is recognized.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceSchemas(sourceId: string, includeTypes?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SchemaBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSourceSchemas(sourceId, includeTypes, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point lists all the sources in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary Lists all sources in IdentityNow.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators:   **id**: *eq, in*   **name**: *co, eq, in, sw*   **type**: *eq, in*   **owner.id**: *eq, in*   **features**: *ca, co*   **created**: *eq*   **modified**: *eq*   **managementWorkgroup.id**: *eq*   **description**: *eq*   **authoritative**: *eq*   **healthy**: *eq*   **status**: *eq, in*   **connectionType**: *eq*   **connectorName**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **type, created, modified, name, owner.name, healthy, status**
         * @param {string} [forSubadmin] Filter the returned list of sources for the identity specified by the parameter, which is the id of an identity with the role SOURCE_SUBADMIN. By convention, the value **me** indicates the identity id of the current user. Subadmins may only view Sources which they are able to administer; all other Sources will be filtered out when this parameter is set. If the current user is a SOURCE_SUBADMIN but fails to pass a valid value for this parameter, a 403 Forbidden is returned.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listSources(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSubadmin?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SourceBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSources(limit, offset, count, filters, sorters, forSubadmin, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a sample of data returned from account and group aggregation requests. A token with ORG_ADMIN authority is required to call this API.
         * @summary Peek source connector\'s resource objects
         * @param {string} sourceId The ID of the Source
         * @param {ResourceObjectsRequestBeta} resourceObjectsRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async peekResourceObjects(sourceId: string, resourceObjectsRequestBeta: ResourceObjectsRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceObjectsResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.peekResourceObjects(sourceId, resourceObjectsRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint validates that the cluster being used by the source is reachable from IdentityNow. A token with ORG_ADMIN authority is required to call this API.
         * @summary Ping cluster for source connector
         * @param {string} sourceId The ID of the Source
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async pingCluster(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pingCluster(sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point updates the provisioning policy with the specified usage on the specified source in IdentityNow. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Update Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageTypeBeta} usageType The type of ProvisioningPolicy usage.
         * @param {ProvisioningPolicyDtoBeta} provisioningPolicyDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putProvisioningPolicy(sourceId: string, usageType: UsageTypeBeta, provisioningPolicyDtoBeta: ProvisioningPolicyDtoBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisioningPolicyDtoBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putProvisioningPolicy(sourceId, usageType, provisioningPolicyDtoBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API updates a source in IdentityNow, using a full object representation. In other words, the existing Source configuration is completely replaced.  Some fields are immutable and cannot be changed, such as:  * id * type * authoritative * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. 
         * @summary Update Source (Full)
         * @param {string} id The Source id
         * @param {SourceBeta} sourceBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putSource(id: string, sourceBeta: SourceBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putSource(id, sourceBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replaces the attribute synchronization configuration for the source specified by the given ID with the configuration provided in the request body. Only the \"enabled\" field of the values in the \"attributes\" array is mutable. Attempting to change other attributes or add new values to the \"attributes\" array will result in an error.      A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Attribute Sync Config
         * @param {string} id The source id
         * @param {AttrSyncSourceConfigBeta} attrSyncSourceConfigBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putSourceAttrSyncConfig(id: string, attrSyncSourceConfigBeta: AttrSyncSourceConfigBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttrSyncSourceConfigBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putSourceAttrSyncConfig(id, attrSyncSourceConfigBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API will completely replace an existing Schema with the submitted payload. Some fields of the Schema cannot be updated. These fields are listed below. * id * name * created * modified Any attempt to modify these fields will result in an error response with a status code of 400.
         * @summary Update Source Schema (Full)
         * @param {string} sourceId The Source ID.
         * @param {string} schemaId The Schema ID.
         * @param {SchemaBeta} schemaBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putSourceSchema(sourceId: string, schemaId: string, schemaBeta: SchemaBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchemaBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putSourceSchema(sourceId, schemaId, schemaBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point performs attribute synchronization for a selected source. A token with ORG_ADMIN or SOURCE_ADMIN authority is required to call this API.
         * @summary Synchronize single source attributes.
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async syncAttributesForSource(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceSyncJobBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncAttributesForSource(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint performs a more detailed validation of the source\'s configuration that can take longer than the lighter weight credential validation performed by the checkConnection API. A token with ORG_ADMIN authority is required to call this API.
         * @summary Test configuration for source connector
         * @param {string} sourceId The ID of the Source
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async testSourceConfiguration(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testSourceConfiguration(sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint validates that the configured credentials are valid and will properly authenticate with the source identified by the sourceId path parameter. A token with ORG_ADMIN authority is required to call this API.
         * @summary Check connection for source connector.
         * @param {string} sourceId The ID of the Source.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async testSourceConnection(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testSourceConnection(sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point updates a list of provisioning policies on the specified source in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Bulk Update Provisioning Policies
         * @param {string} sourceId The Source id.
         * @param {Array<ProvisioningPolicyDtoBeta>} provisioningPolicyDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateProvisioningPoliciesInBulk(sourceId: string, provisioningPolicyDtoBeta: Array<ProvisioningPolicyDtoBeta>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProvisioningPolicyDtoBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProvisioningPoliciesInBulk(sourceId, provisioningPolicyDtoBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API selectively updates an existing Provisioning Policy using a JSONPatch payload. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Partial update of Provisioning Policy
         * @param {string} sourceId The Source id.
         * @param {UsageTypeBeta} usageType The type of ProvisioningPolicy usage.
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateProvisioningPolicy(sourceId: string, usageType: UsageTypeBeta, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisioningPolicyDtoBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProvisioningPolicy(sourceId, usageType, jsonPatchOperationBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API partially updates a source in IdentityNow, using a list of patch operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Some fields are immutable and cannot be changed, such as: * id * type * authoritative * created * modified * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or API authority is required to call this API. 
         * @summary Update Source (Partial)
         * @param {string} id The Source id
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Any password changes are submitted as plain-text and encrypted upon receipt in IdentityNow.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateSource(id: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSource(id, jsonPatchOperationBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API replaces the current entitlement request configuration for a source. This source-level configuration should apply for all the entitlements in the source.  Access request to any entitlements in the source should follow this configuration unless a separate entitlement-level configuration is defined. - During access request, this source-level entitlement request configuration overrides the global organization-level configuration. - However, the entitlement-level configuration (if defined) overrides this source-level configuration.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Update Source Entitlement Request Configuration
         * @param {SourceEntitlementRequestConfigBeta} sourceEntitlementRequestConfigBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateSourceEntitlementRequestConfig(sourceEntitlementRequestConfigBeta: SourceEntitlementRequestConfigBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceEntitlementRequestConfigBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSourceEntitlementRequestConfig(sourceEntitlementRequestConfigBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to selectively update an existing Schema using a JSONPatch payload.   The following schema fields are immutable and cannot be updated:  - id - name - created - modified   To switch an account attribute to a group entitlement, you need to have the following in place:  - `isEntitlement: true` - Must define a schema for the group and [add it to the source](https://developer.sailpoint.com/idn/api/beta/create-source-schema) before updating the `isGroup` flag.  For example, here is the `group` account attribute referencing a schema that defines the group: ```json {     \"name\": \"groups\",     \"type\": \"STRING\",     \"schema\": {         \"type\": \"CONNECTOR_SCHEMA\",         \"id\": \"2c9180887671ff8c01767b4671fc7d60\",         \"name\": \"group\"     },     \"description\": \"The groups, roles etc. that reference account group objects\",     \"isMulti\": true,     \"isEntitlement\": true,     \"isGroup\": true } ``` 
         * @summary Update Source Schema (Partial)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateSourceSchema(sourceId: string, schemaId: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchemaBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSourceSchema(sourceId, schemaId, jsonPatchOperationBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SourcesBetaApi - factory interface
 * @export
 */
export const SourcesBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SourcesBetaApiFp(configuration)
    return {
        /**
         * This end-point deletes a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. All of accounts on the source will be removed first, then the source will be deleted. Actual status of task execution can be retrieved via method GET `/task-status/{id}`
         * @summary Delete Source by ID
         * @param {string} id The Source ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: string, axiosOptions?: any): AxiosPromise<Delete202ResponseBeta> {
            return localVarFp._delete(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API generates a create policy/template based on field value transforms. This API is intended for use when setting up JDBC Provisioning type sources, but it will also work on other source types. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Provisioning Policy
         * @param {string} sourceId The Source id
         * @param {ProvisioningPolicyDtoBeta} provisioningPolicyDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createProvisioningPolicy(sourceId: string, provisioningPolicyDtoBeta: ProvisioningPolicyDtoBeta, axiosOptions?: any): AxiosPromise<ProvisioningPolicyDtoBeta> {
            return localVarFp.createProvisioningPolicy(sourceId, provisioningPolicyDtoBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This creates a specific source with a full source JSON representation. Any passwords are submitted as plain-text and encrypted upon receipt in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Creates a source in IdentityNow.
         * @param {SourceBeta} sourceBeta 
         * @param {boolean} [provisionAsCsv] If this parameter is &#x60;true&#x60;, it configures the source as a Delimited File (CSV) source. Setting this to &#x60;true&#x60; will automatically set the &#x60;type&#x60; of the source to &#x60;DelimitedFile&#x60;.  You must use this query parameter to create a Delimited File source as you would in the UI.  If you don\&#39;t set this query parameter and you attempt to set the &#x60;type&#x60; attribute directly, the request won\&#39;t correctly generate the source.  
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSource(sourceBeta: SourceBeta, provisionAsCsv?: boolean, axiosOptions?: any): AxiosPromise<SourceBeta> {
            return localVarFp.createSource(sourceBeta, provisionAsCsv, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new Schema on the specified Source in IdentityNow.
         * @param {string} sourceId The Source id.
         * @param {SchemaBeta} schemaBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSourceSchema(sourceId: string, schemaBeta: SchemaBeta, axiosOptions?: any): AxiosPromise<SchemaBeta> {
            return localVarFp.createSourceSchema(sourceId, schemaBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the provisioning policy with the specified usage on an application. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageTypeBeta} usageType The type of ProvisioningPolicy usage.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteProvisioningPolicy(sourceId: string, usageType: UsageTypeBeta, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteProvisioningPolicy(sourceId, usageType, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Source Schema by ID
         * @param {string} sourceId The Source ID.
         * @param {string} schemaId The Schema ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSourceSchema(sourceId: string, schemaId: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteSourceSchema(sourceId, schemaId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point retrieves the ProvisioningPolicy with the specified usage on the specified Source in IdentityNow. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageTypeBeta} usageType The type of ProvisioningPolicy usage.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getProvisioningPolicy(sourceId: string, usageType: UsageTypeBeta, axiosOptions?: any): AxiosPromise<ProvisioningPolicyDtoBeta> {
            return localVarFp.getProvisioningPolicy(sourceId, usageType, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point gets a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Source by ID
         * @param {string} id The Source ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSource(id: string, axiosOptions?: any): AxiosPromise<SourceBeta> {
            return localVarFp.getSource(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Downloads source accounts schema template
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceAccountsSchema(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getSourceAccountsSchema(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the existing attribute synchronization configuration for a source specified by the given ID. The response contains all attributes, regardless of whether they enabled or not. A token with ORG_ADMIN authority is required to call this API.
         * @summary Attribute Sync Config
         * @param {string} id The source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceAttrSyncConfig(id: string, axiosOptions?: any): AxiosPromise<AttrSyncSourceConfigBeta> {
            return localVarFp.getSourceAttrSyncConfig(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Looks up and returns the source config for the requested source id after populating the source config values and applying language translations. A token with ORG_ADMIN authority is required to call this API.
         * @summary Gets source config with language translations
         * @param {string} id The Source id
         * @param {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'} [locale] The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceConfig(id: string, locale?: 'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl', axiosOptions?: any): AxiosPromise<ConnectorDetailBeta> {
            return localVarFp.getSourceConfig(id, locale, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API gets the current entitlement request configuration for a source. This source-level configuration should apply for all the entitlements in the source.  Access request to any entitlements in the source should follow this configuration unless a separate entitlement-level configuration is defined. - During access request, this source-level entitlement request configuration overrides the global organization-level configuration. - However, the entitlement-level configuration (if defined) overrides this source-level configuration.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Source Entitlement Request Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceEntitlementRequestConfig(axiosOptions?: any): AxiosPromise<SourceEntitlementRequestConfigBeta> {
            return localVarFp.getSourceEntitlementRequestConfig(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Downloads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceEntitlementsSchema(id: string, schemaName?: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getSourceEntitlementsSchema(id, schemaName, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get the Source Schema by ID in IdentityNow. 
         * @summary Get Source Schema by ID
         * @param {string} sourceId The Source ID.
         * @param {string} schemaId The Schema ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceSchema(sourceId: string, schemaId: string, axiosOptions?: any): AxiosPromise<SchemaBeta> {
            return localVarFp.getSourceSchema(sourceId, schemaId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API uploads a source schema template file to configure a source\'s account attributes.
         * @summary Uploads source accounts schema template
         * @param {string} id The Source id
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importSourceAccountsSchema(id: string, file?: any, axiosOptions?: any): AxiosPromise<SchemaBeta> {
            return localVarFp.importSourceAccountsSchema(id, file, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This uploads a supplemental source connector file (like jdbc driver jars) to a source\'s S3 bucket. This also sends ETS and Audit events. A token with ORG_ADMIN authority is required to call this API.
         * @summary Upload connector file to source
         * @param {string} sourceId The Source id
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importSourceConnectorFile(sourceId: string, file?: any, axiosOptions?: any): AxiosPromise<SourceBeta> {
            return localVarFp.importSourceConnectorFile(sourceId, file, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API uploads a source schema template file to configure a source\'s entitlement attributes.
         * @summary Uploads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importSourceEntitlementsSchema(id: string, schemaName?: string, file?: any, axiosOptions?: any): AxiosPromise<SchemaBeta> {
            return localVarFp.importSourceEntitlementsSchema(id, schemaName, file, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point lists all the ProvisioningPolicies in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists ProvisioningPolicies
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listProvisioningPolicies(sourceId: string, axiosOptions?: any): AxiosPromise<Array<ProvisioningPolicyDtoBeta>> {
            return localVarFp.listProvisioningPolicies(sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists the Schemas that exist on the specified Source in IdentityNow.
         * @param {string} sourceId The Source id.
         * @param {string} [includeTypes] If set to \&#39;group\&#39;, then the account schema is filtered and only group schemas are returned. Only a value of \&#39;group\&#39; is recognized.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSourceSchemas(sourceId: string, includeTypes?: string, axiosOptions?: any): AxiosPromise<Array<SchemaBeta>> {
            return localVarFp.listSourceSchemas(sourceId, includeTypes, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point lists all the sources in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary Lists all sources in IdentityNow.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators:   **id**: *eq, in*   **name**: *co, eq, in, sw*   **type**: *eq, in*   **owner.id**: *eq, in*   **features**: *ca, co*   **created**: *eq*   **modified**: *eq*   **managementWorkgroup.id**: *eq*   **description**: *eq*   **authoritative**: *eq*   **healthy**: *eq*   **status**: *eq, in*   **connectionType**: *eq*   **connectorName**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **type, created, modified, name, owner.name, healthy, status**
         * @param {string} [forSubadmin] Filter the returned list of sources for the identity specified by the parameter, which is the id of an identity with the role SOURCE_SUBADMIN. By convention, the value **me** indicates the identity id of the current user. Subadmins may only view Sources which they are able to administer; all other Sources will be filtered out when this parameter is set. If the current user is a SOURCE_SUBADMIN but fails to pass a valid value for this parameter, a 403 Forbidden is returned.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSources(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSubadmin?: string, axiosOptions?: any): AxiosPromise<Array<SourceBeta>> {
            return localVarFp.listSources(limit, offset, count, filters, sorters, forSubadmin, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a sample of data returned from account and group aggregation requests. A token with ORG_ADMIN authority is required to call this API.
         * @summary Peek source connector\'s resource objects
         * @param {string} sourceId The ID of the Source
         * @param {ResourceObjectsRequestBeta} resourceObjectsRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        peekResourceObjects(sourceId: string, resourceObjectsRequestBeta: ResourceObjectsRequestBeta, axiosOptions?: any): AxiosPromise<ResourceObjectsResponseBeta> {
            return localVarFp.peekResourceObjects(sourceId, resourceObjectsRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint validates that the cluster being used by the source is reachable from IdentityNow. A token with ORG_ADMIN authority is required to call this API.
         * @summary Ping cluster for source connector
         * @param {string} sourceId The ID of the Source
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        pingCluster(sourceId: string, axiosOptions?: any): AxiosPromise<StatusResponseBeta> {
            return localVarFp.pingCluster(sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point updates the provisioning policy with the specified usage on the specified source in IdentityNow. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Update Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageTypeBeta} usageType The type of ProvisioningPolicy usage.
         * @param {ProvisioningPolicyDtoBeta} provisioningPolicyDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putProvisioningPolicy(sourceId: string, usageType: UsageTypeBeta, provisioningPolicyDtoBeta: ProvisioningPolicyDtoBeta, axiosOptions?: any): AxiosPromise<ProvisioningPolicyDtoBeta> {
            return localVarFp.putProvisioningPolicy(sourceId, usageType, provisioningPolicyDtoBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates a source in IdentityNow, using a full object representation. In other words, the existing Source configuration is completely replaced.  Some fields are immutable and cannot be changed, such as:  * id * type * authoritative * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. 
         * @summary Update Source (Full)
         * @param {string} id The Source id
         * @param {SourceBeta} sourceBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSource(id: string, sourceBeta: SourceBeta, axiosOptions?: any): AxiosPromise<SourceBeta> {
            return localVarFp.putSource(id, sourceBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Replaces the attribute synchronization configuration for the source specified by the given ID with the configuration provided in the request body. Only the \"enabled\" field of the values in the \"attributes\" array is mutable. Attempting to change other attributes or add new values to the \"attributes\" array will result in an error.      A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Attribute Sync Config
         * @param {string} id The source id
         * @param {AttrSyncSourceConfigBeta} attrSyncSourceConfigBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSourceAttrSyncConfig(id: string, attrSyncSourceConfigBeta: AttrSyncSourceConfigBeta, axiosOptions?: any): AxiosPromise<AttrSyncSourceConfigBeta> {
            return localVarFp.putSourceAttrSyncConfig(id, attrSyncSourceConfigBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API will completely replace an existing Schema with the submitted payload. Some fields of the Schema cannot be updated. These fields are listed below. * id * name * created * modified Any attempt to modify these fields will result in an error response with a status code of 400.
         * @summary Update Source Schema (Full)
         * @param {string} sourceId The Source ID.
         * @param {string} schemaId The Schema ID.
         * @param {SchemaBeta} schemaBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSourceSchema(sourceId: string, schemaId: string, schemaBeta: SchemaBeta, axiosOptions?: any): AxiosPromise<SchemaBeta> {
            return localVarFp.putSourceSchema(sourceId, schemaId, schemaBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point performs attribute synchronization for a selected source. A token with ORG_ADMIN or SOURCE_ADMIN authority is required to call this API.
         * @summary Synchronize single source attributes.
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        syncAttributesForSource(id: string, axiosOptions?: any): AxiosPromise<SourceSyncJobBeta> {
            return localVarFp.syncAttributesForSource(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint performs a more detailed validation of the source\'s configuration that can take longer than the lighter weight credential validation performed by the checkConnection API. A token with ORG_ADMIN authority is required to call this API.
         * @summary Test configuration for source connector
         * @param {string} sourceId The ID of the Source
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testSourceConfiguration(sourceId: string, axiosOptions?: any): AxiosPromise<StatusResponseBeta> {
            return localVarFp.testSourceConfiguration(sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint validates that the configured credentials are valid and will properly authenticate with the source identified by the sourceId path parameter. A token with ORG_ADMIN authority is required to call this API.
         * @summary Check connection for source connector.
         * @param {string} sourceId The ID of the Source.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testSourceConnection(sourceId: string, axiosOptions?: any): AxiosPromise<StatusResponseBeta> {
            return localVarFp.testSourceConnection(sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point updates a list of provisioning policies on the specified source in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Bulk Update Provisioning Policies
         * @param {string} sourceId The Source id.
         * @param {Array<ProvisioningPolicyDtoBeta>} provisioningPolicyDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateProvisioningPoliciesInBulk(sourceId: string, provisioningPolicyDtoBeta: Array<ProvisioningPolicyDtoBeta>, axiosOptions?: any): AxiosPromise<Array<ProvisioningPolicyDtoBeta>> {
            return localVarFp.updateProvisioningPoliciesInBulk(sourceId, provisioningPolicyDtoBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API selectively updates an existing Provisioning Policy using a JSONPatch payload. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Partial update of Provisioning Policy
         * @param {string} sourceId The Source id.
         * @param {UsageTypeBeta} usageType The type of ProvisioningPolicy usage.
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateProvisioningPolicy(sourceId: string, usageType: UsageTypeBeta, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: any): AxiosPromise<ProvisioningPolicyDtoBeta> {
            return localVarFp.updateProvisioningPolicy(sourceId, usageType, jsonPatchOperationBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API partially updates a source in IdentityNow, using a list of patch operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Some fields are immutable and cannot be changed, such as: * id * type * authoritative * created * modified * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or API authority is required to call this API. 
         * @summary Update Source (Partial)
         * @param {string} id The Source id
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Any password changes are submitted as plain-text and encrypted upon receipt in IdentityNow.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSource(id: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: any): AxiosPromise<SourceBeta> {
            return localVarFp.updateSource(id, jsonPatchOperationBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API replaces the current entitlement request configuration for a source. This source-level configuration should apply for all the entitlements in the source.  Access request to any entitlements in the source should follow this configuration unless a separate entitlement-level configuration is defined. - During access request, this source-level entitlement request configuration overrides the global organization-level configuration. - However, the entitlement-level configuration (if defined) overrides this source-level configuration.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Update Source Entitlement Request Configuration
         * @param {SourceEntitlementRequestConfigBeta} sourceEntitlementRequestConfigBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSourceEntitlementRequestConfig(sourceEntitlementRequestConfigBeta: SourceEntitlementRequestConfigBeta, axiosOptions?: any): AxiosPromise<SourceEntitlementRequestConfigBeta> {
            return localVarFp.updateSourceEntitlementRequestConfig(sourceEntitlementRequestConfigBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to selectively update an existing Schema using a JSONPatch payload.   The following schema fields are immutable and cannot be updated:  - id - name - created - modified   To switch an account attribute to a group entitlement, you need to have the following in place:  - `isEntitlement: true` - Must define a schema for the group and [add it to the source](https://developer.sailpoint.com/idn/api/beta/create-source-schema) before updating the `isGroup` flag.  For example, here is the `group` account attribute referencing a schema that defines the group: ```json {     \"name\": \"groups\",     \"type\": \"STRING\",     \"schema\": {         \"type\": \"CONNECTOR_SCHEMA\",         \"id\": \"2c9180887671ff8c01767b4671fc7d60\",         \"name\": \"group\"     },     \"description\": \"The groups, roles etc. that reference account group objects\",     \"isMulti\": true,     \"isEntitlement\": true,     \"isGroup\": true } ``` 
         * @summary Update Source Schema (Partial)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSourceSchema(sourceId: string, schemaId: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: any): AxiosPromise<SchemaBeta> {
            return localVarFp.updateSourceSchema(sourceId, schemaId, jsonPatchOperationBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for _delete operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiDeleteRequest
 */
export interface SourcesBetaApiDeleteRequest {
    /**
     * The Source ID
     * @type {string}
     * @memberof SourcesBetaApiDelete
     */
    readonly id: string
}

/**
 * Request parameters for createProvisioningPolicy operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiCreateProvisioningPolicyRequest
 */
export interface SourcesBetaApiCreateProvisioningPolicyRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesBetaApiCreateProvisioningPolicy
     */
    readonly sourceId: string

    /**
     * 
     * @type {ProvisioningPolicyDtoBeta}
     * @memberof SourcesBetaApiCreateProvisioningPolicy
     */
    readonly provisioningPolicyDtoBeta: ProvisioningPolicyDtoBeta
}

/**
 * Request parameters for createSource operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiCreateSourceRequest
 */
export interface SourcesBetaApiCreateSourceRequest {
    /**
     * 
     * @type {SourceBeta}
     * @memberof SourcesBetaApiCreateSource
     */
    readonly sourceBeta: SourceBeta

    /**
     * If this parameter is &#x60;true&#x60;, it configures the source as a Delimited File (CSV) source. Setting this to &#x60;true&#x60; will automatically set the &#x60;type&#x60; of the source to &#x60;DelimitedFile&#x60;.  You must use this query parameter to create a Delimited File source as you would in the UI.  If you don\&#39;t set this query parameter and you attempt to set the &#x60;type&#x60; attribute directly, the request won\&#39;t correctly generate the source.  
     * @type {boolean}
     * @memberof SourcesBetaApiCreateSource
     */
    readonly provisionAsCsv?: boolean
}

/**
 * Request parameters for createSourceSchema operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiCreateSourceSchemaRequest
 */
export interface SourcesBetaApiCreateSourceSchemaRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesBetaApiCreateSourceSchema
     */
    readonly sourceId: string

    /**
     * 
     * @type {SchemaBeta}
     * @memberof SourcesBetaApiCreateSourceSchema
     */
    readonly schemaBeta: SchemaBeta
}

/**
 * Request parameters for deleteProvisioningPolicy operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiDeleteProvisioningPolicyRequest
 */
export interface SourcesBetaApiDeleteProvisioningPolicyRequest {
    /**
     * The Source ID.
     * @type {string}
     * @memberof SourcesBetaApiDeleteProvisioningPolicy
     */
    readonly sourceId: string

    /**
     * The type of ProvisioningPolicy usage.
     * @type {UsageTypeBeta}
     * @memberof SourcesBetaApiDeleteProvisioningPolicy
     */
    readonly usageType: UsageTypeBeta
}

/**
 * Request parameters for deleteSourceSchema operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiDeleteSourceSchemaRequest
 */
export interface SourcesBetaApiDeleteSourceSchemaRequest {
    /**
     * The Source ID.
     * @type {string}
     * @memberof SourcesBetaApiDeleteSourceSchema
     */
    readonly sourceId: string

    /**
     * The Schema ID.
     * @type {string}
     * @memberof SourcesBetaApiDeleteSourceSchema
     */
    readonly schemaId: string
}

/**
 * Request parameters for getProvisioningPolicy operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiGetProvisioningPolicyRequest
 */
export interface SourcesBetaApiGetProvisioningPolicyRequest {
    /**
     * The Source ID.
     * @type {string}
     * @memberof SourcesBetaApiGetProvisioningPolicy
     */
    readonly sourceId: string

    /**
     * The type of ProvisioningPolicy usage.
     * @type {UsageTypeBeta}
     * @memberof SourcesBetaApiGetProvisioningPolicy
     */
    readonly usageType: UsageTypeBeta
}

/**
 * Request parameters for getSource operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiGetSourceRequest
 */
export interface SourcesBetaApiGetSourceRequest {
    /**
     * The Source ID
     * @type {string}
     * @memberof SourcesBetaApiGetSource
     */
    readonly id: string
}

/**
 * Request parameters for getSourceAccountsSchema operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiGetSourceAccountsSchemaRequest
 */
export interface SourcesBetaApiGetSourceAccountsSchemaRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesBetaApiGetSourceAccountsSchema
     */
    readonly id: string
}

/**
 * Request parameters for getSourceAttrSyncConfig operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiGetSourceAttrSyncConfigRequest
 */
export interface SourcesBetaApiGetSourceAttrSyncConfigRequest {
    /**
     * The source id
     * @type {string}
     * @memberof SourcesBetaApiGetSourceAttrSyncConfig
     */
    readonly id: string
}

/**
 * Request parameters for getSourceConfig operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiGetSourceConfigRequest
 */
export interface SourcesBetaApiGetSourceConfigRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesBetaApiGetSourceConfig
     */
    readonly id: string

    /**
     * The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
     * @type {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'}
     * @memberof SourcesBetaApiGetSourceConfig
     */
    readonly locale?: 'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'
}

/**
 * Request parameters for getSourceEntitlementsSchema operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiGetSourceEntitlementsSchemaRequest
 */
export interface SourcesBetaApiGetSourceEntitlementsSchemaRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesBetaApiGetSourceEntitlementsSchema
     */
    readonly id: string

    /**
     * Name of entitlement schema
     * @type {string}
     * @memberof SourcesBetaApiGetSourceEntitlementsSchema
     */
    readonly schemaName?: string
}

/**
 * Request parameters for getSourceSchema operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiGetSourceSchemaRequest
 */
export interface SourcesBetaApiGetSourceSchemaRequest {
    /**
     * The Source ID.
     * @type {string}
     * @memberof SourcesBetaApiGetSourceSchema
     */
    readonly sourceId: string

    /**
     * The Schema ID.
     * @type {string}
     * @memberof SourcesBetaApiGetSourceSchema
     */
    readonly schemaId: string
}

/**
 * Request parameters for importSourceAccountsSchema operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiImportSourceAccountsSchemaRequest
 */
export interface SourcesBetaApiImportSourceAccountsSchemaRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesBetaApiImportSourceAccountsSchema
     */
    readonly id: string

    /**
     * 
     * @type {any}
     * @memberof SourcesBetaApiImportSourceAccountsSchema
     */
    readonly file?: any
}

/**
 * Request parameters for importSourceConnectorFile operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiImportSourceConnectorFileRequest
 */
export interface SourcesBetaApiImportSourceConnectorFileRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesBetaApiImportSourceConnectorFile
     */
    readonly sourceId: string

    /**
     * 
     * @type {any}
     * @memberof SourcesBetaApiImportSourceConnectorFile
     */
    readonly file?: any
}

/**
 * Request parameters for importSourceEntitlementsSchema operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiImportSourceEntitlementsSchemaRequest
 */
export interface SourcesBetaApiImportSourceEntitlementsSchemaRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesBetaApiImportSourceEntitlementsSchema
     */
    readonly id: string

    /**
     * Name of entitlement schema
     * @type {string}
     * @memberof SourcesBetaApiImportSourceEntitlementsSchema
     */
    readonly schemaName?: string

    /**
     * 
     * @type {any}
     * @memberof SourcesBetaApiImportSourceEntitlementsSchema
     */
    readonly file?: any
}

/**
 * Request parameters for listProvisioningPolicies operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiListProvisioningPoliciesRequest
 */
export interface SourcesBetaApiListProvisioningPoliciesRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesBetaApiListProvisioningPolicies
     */
    readonly sourceId: string
}

/**
 * Request parameters for listSourceSchemas operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiListSourceSchemasRequest
 */
export interface SourcesBetaApiListSourceSchemasRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesBetaApiListSourceSchemas
     */
    readonly sourceId: string

    /**
     * If set to \&#39;group\&#39;, then the account schema is filtered and only group schemas are returned. Only a value of \&#39;group\&#39; is recognized.
     * @type {string}
     * @memberof SourcesBetaApiListSourceSchemas
     */
    readonly includeTypes?: string
}

/**
 * Request parameters for listSources operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiListSourcesRequest
 */
export interface SourcesBetaApiListSourcesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SourcesBetaApiListSources
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SourcesBetaApiListSources
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SourcesBetaApiListSources
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators:   **id**: *eq, in*   **name**: *co, eq, in, sw*   **type**: *eq, in*   **owner.id**: *eq, in*   **features**: *ca, co*   **created**: *eq*   **modified**: *eq*   **managementWorkgroup.id**: *eq*   **description**: *eq*   **authoritative**: *eq*   **healthy**: *eq*   **status**: *eq, in*   **connectionType**: *eq*   **connectorName**: *eq*
     * @type {string}
     * @memberof SourcesBetaApiListSources
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **type, created, modified, name, owner.name, healthy, status**
     * @type {string}
     * @memberof SourcesBetaApiListSources
     */
    readonly sorters?: string

    /**
     * Filter the returned list of sources for the identity specified by the parameter, which is the id of an identity with the role SOURCE_SUBADMIN. By convention, the value **me** indicates the identity id of the current user. Subadmins may only view Sources which they are able to administer; all other Sources will be filtered out when this parameter is set. If the current user is a SOURCE_SUBADMIN but fails to pass a valid value for this parameter, a 403 Forbidden is returned.
     * @type {string}
     * @memberof SourcesBetaApiListSources
     */
    readonly forSubadmin?: string
}

/**
 * Request parameters for peekResourceObjects operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiPeekResourceObjectsRequest
 */
export interface SourcesBetaApiPeekResourceObjectsRequest {
    /**
     * The ID of the Source
     * @type {string}
     * @memberof SourcesBetaApiPeekResourceObjects
     */
    readonly sourceId: string

    /**
     * 
     * @type {ResourceObjectsRequestBeta}
     * @memberof SourcesBetaApiPeekResourceObjects
     */
    readonly resourceObjectsRequestBeta: ResourceObjectsRequestBeta
}

/**
 * Request parameters for pingCluster operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiPingClusterRequest
 */
export interface SourcesBetaApiPingClusterRequest {
    /**
     * The ID of the Source
     * @type {string}
     * @memberof SourcesBetaApiPingCluster
     */
    readonly sourceId: string
}

/**
 * Request parameters for putProvisioningPolicy operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiPutProvisioningPolicyRequest
 */
export interface SourcesBetaApiPutProvisioningPolicyRequest {
    /**
     * The Source ID.
     * @type {string}
     * @memberof SourcesBetaApiPutProvisioningPolicy
     */
    readonly sourceId: string

    /**
     * The type of ProvisioningPolicy usage.
     * @type {UsageTypeBeta}
     * @memberof SourcesBetaApiPutProvisioningPolicy
     */
    readonly usageType: UsageTypeBeta

    /**
     * 
     * @type {ProvisioningPolicyDtoBeta}
     * @memberof SourcesBetaApiPutProvisioningPolicy
     */
    readonly provisioningPolicyDtoBeta: ProvisioningPolicyDtoBeta
}

/**
 * Request parameters for putSource operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiPutSourceRequest
 */
export interface SourcesBetaApiPutSourceRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesBetaApiPutSource
     */
    readonly id: string

    /**
     * 
     * @type {SourceBeta}
     * @memberof SourcesBetaApiPutSource
     */
    readonly sourceBeta: SourceBeta
}

/**
 * Request parameters for putSourceAttrSyncConfig operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiPutSourceAttrSyncConfigRequest
 */
export interface SourcesBetaApiPutSourceAttrSyncConfigRequest {
    /**
     * The source id
     * @type {string}
     * @memberof SourcesBetaApiPutSourceAttrSyncConfig
     */
    readonly id: string

    /**
     * 
     * @type {AttrSyncSourceConfigBeta}
     * @memberof SourcesBetaApiPutSourceAttrSyncConfig
     */
    readonly attrSyncSourceConfigBeta: AttrSyncSourceConfigBeta
}

/**
 * Request parameters for putSourceSchema operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiPutSourceSchemaRequest
 */
export interface SourcesBetaApiPutSourceSchemaRequest {
    /**
     * The Source ID.
     * @type {string}
     * @memberof SourcesBetaApiPutSourceSchema
     */
    readonly sourceId: string

    /**
     * The Schema ID.
     * @type {string}
     * @memberof SourcesBetaApiPutSourceSchema
     */
    readonly schemaId: string

    /**
     * 
     * @type {SchemaBeta}
     * @memberof SourcesBetaApiPutSourceSchema
     */
    readonly schemaBeta: SchemaBeta
}

/**
 * Request parameters for syncAttributesForSource operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiSyncAttributesForSourceRequest
 */
export interface SourcesBetaApiSyncAttributesForSourceRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesBetaApiSyncAttributesForSource
     */
    readonly id: string
}

/**
 * Request parameters for testSourceConfiguration operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiTestSourceConfigurationRequest
 */
export interface SourcesBetaApiTestSourceConfigurationRequest {
    /**
     * The ID of the Source
     * @type {string}
     * @memberof SourcesBetaApiTestSourceConfiguration
     */
    readonly sourceId: string
}

/**
 * Request parameters for testSourceConnection operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiTestSourceConnectionRequest
 */
export interface SourcesBetaApiTestSourceConnectionRequest {
    /**
     * The ID of the Source.
     * @type {string}
     * @memberof SourcesBetaApiTestSourceConnection
     */
    readonly sourceId: string
}

/**
 * Request parameters for updateProvisioningPoliciesInBulk operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiUpdateProvisioningPoliciesInBulkRequest
 */
export interface SourcesBetaApiUpdateProvisioningPoliciesInBulkRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesBetaApiUpdateProvisioningPoliciesInBulk
     */
    readonly sourceId: string

    /**
     * 
     * @type {Array<ProvisioningPolicyDtoBeta>}
     * @memberof SourcesBetaApiUpdateProvisioningPoliciesInBulk
     */
    readonly provisioningPolicyDtoBeta: Array<ProvisioningPolicyDtoBeta>
}

/**
 * Request parameters for updateProvisioningPolicy operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiUpdateProvisioningPolicyRequest
 */
export interface SourcesBetaApiUpdateProvisioningPolicyRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesBetaApiUpdateProvisioningPolicy
     */
    readonly sourceId: string

    /**
     * The type of ProvisioningPolicy usage.
     * @type {UsageTypeBeta}
     * @memberof SourcesBetaApiUpdateProvisioningPolicy
     */
    readonly usageType: UsageTypeBeta

    /**
     * The JSONPatch payload used to update the schema.
     * @type {Array<JsonPatchOperationBeta>}
     * @memberof SourcesBetaApiUpdateProvisioningPolicy
     */
    readonly jsonPatchOperationBeta: Array<JsonPatchOperationBeta>
}

/**
 * Request parameters for updateSource operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiUpdateSourceRequest
 */
export interface SourcesBetaApiUpdateSourceRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesBetaApiUpdateSource
     */
    readonly id: string

    /**
     * A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Any password changes are submitted as plain-text and encrypted upon receipt in IdentityNow.
     * @type {Array<JsonPatchOperationBeta>}
     * @memberof SourcesBetaApiUpdateSource
     */
    readonly jsonPatchOperationBeta: Array<JsonPatchOperationBeta>
}

/**
 * Request parameters for updateSourceEntitlementRequestConfig operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiUpdateSourceEntitlementRequestConfigRequest
 */
export interface SourcesBetaApiUpdateSourceEntitlementRequestConfigRequest {
    /**
     * 
     * @type {SourceEntitlementRequestConfigBeta}
     * @memberof SourcesBetaApiUpdateSourceEntitlementRequestConfig
     */
    readonly sourceEntitlementRequestConfigBeta: SourceEntitlementRequestConfigBeta
}

/**
 * Request parameters for updateSourceSchema operation in SourcesBetaApi.
 * @export
 * @interface SourcesBetaApiUpdateSourceSchemaRequest
 */
export interface SourcesBetaApiUpdateSourceSchemaRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesBetaApiUpdateSourceSchema
     */
    readonly sourceId: string

    /**
     * The Schema id.
     * @type {string}
     * @memberof SourcesBetaApiUpdateSourceSchema
     */
    readonly schemaId: string

    /**
     * The JSONPatch payload used to update the schema.
     * @type {Array<JsonPatchOperationBeta>}
     * @memberof SourcesBetaApiUpdateSourceSchema
     */
    readonly jsonPatchOperationBeta: Array<JsonPatchOperationBeta>
}

/**
 * SourcesBetaApi - object-oriented interface
 * @export
 * @class SourcesBetaApi
 * @extends {BaseAPI}
 */
export class SourcesBetaApi extends BaseAPI {
    /**
     * This end-point deletes a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. All of accounts on the source will be removed first, then the source will be deleted. Actual status of task execution can be retrieved via method GET `/task-status/{id}`
     * @summary Delete Source by ID
     * @param {SourcesBetaApiDeleteRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public _delete(requestParameters: SourcesBetaApiDeleteRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration)._delete(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API generates a create policy/template based on field value transforms. This API is intended for use when setting up JDBC Provisioning type sources, but it will also work on other source types. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with ORG_ADMIN authority is required to call this API.
     * @summary Create Provisioning Policy
     * @param {SourcesBetaApiCreateProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public createProvisioningPolicy(requestParameters: SourcesBetaApiCreateProvisioningPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).createProvisioningPolicy(requestParameters.sourceId, requestParameters.provisioningPolicyDtoBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This creates a specific source with a full source JSON representation. Any passwords are submitted as plain-text and encrypted upon receipt in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Creates a source in IdentityNow.
     * @param {SourcesBetaApiCreateSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public createSource(requestParameters: SourcesBetaApiCreateSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).createSource(requestParameters.sourceBeta, requestParameters.provisionAsCsv, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new Schema on the specified Source in IdentityNow.
     * @param {SourcesBetaApiCreateSourceSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public createSourceSchema(requestParameters: SourcesBetaApiCreateSourceSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).createSourceSchema(requestParameters.sourceId, requestParameters.schemaBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the provisioning policy with the specified usage on an application. A token with API, or ORG_ADMIN authority is required to call this API.
     * @summary Delete Provisioning Policy by UsageType
     * @param {SourcesBetaApiDeleteProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public deleteProvisioningPolicy(requestParameters: SourcesBetaApiDeleteProvisioningPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).deleteProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Source Schema by ID
     * @param {SourcesBetaApiDeleteSourceSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public deleteSourceSchema(requestParameters: SourcesBetaApiDeleteSourceSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).deleteSourceSchema(requestParameters.sourceId, requestParameters.schemaId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point retrieves the ProvisioningPolicy with the specified usage on the specified Source in IdentityNow. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Get Provisioning Policy by UsageType
     * @param {SourcesBetaApiGetProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public getProvisioningPolicy(requestParameters: SourcesBetaApiGetProvisioningPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).getProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point gets a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Get Source by ID
     * @param {SourcesBetaApiGetSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public getSource(requestParameters: SourcesBetaApiGetSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).getSource(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Downloads source accounts schema template
     * @param {SourcesBetaApiGetSourceAccountsSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public getSourceAccountsSchema(requestParameters: SourcesBetaApiGetSourceAccountsSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).getSourceAccountsSchema(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the existing attribute synchronization configuration for a source specified by the given ID. The response contains all attributes, regardless of whether they enabled or not. A token with ORG_ADMIN authority is required to call this API.
     * @summary Attribute Sync Config
     * @param {SourcesBetaApiGetSourceAttrSyncConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public getSourceAttrSyncConfig(requestParameters: SourcesBetaApiGetSourceAttrSyncConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).getSourceAttrSyncConfig(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Looks up and returns the source config for the requested source id after populating the source config values and applying language translations. A token with ORG_ADMIN authority is required to call this API.
     * @summary Gets source config with language translations
     * @param {SourcesBetaApiGetSourceConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public getSourceConfig(requestParameters: SourcesBetaApiGetSourceConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).getSourceConfig(requestParameters.id, requestParameters.locale, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API gets the current entitlement request configuration for a source. This source-level configuration should apply for all the entitlements in the source.  Access request to any entitlements in the source should follow this configuration unless a separate entitlement-level configuration is defined. - During access request, this source-level entitlement request configuration overrides the global organization-level configuration. - However, the entitlement-level configuration (if defined) overrides this source-level configuration.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Get Source Entitlement Request Configuration
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public getSourceEntitlementRequestConfig(axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).getSourceEntitlementRequestConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Downloads source entitlements schema template
     * @param {SourcesBetaApiGetSourceEntitlementsSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public getSourceEntitlementsSchema(requestParameters: SourcesBetaApiGetSourceEntitlementsSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).getSourceEntitlementsSchema(requestParameters.id, requestParameters.schemaName, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the Source Schema by ID in IdentityNow. 
     * @summary Get Source Schema by ID
     * @param {SourcesBetaApiGetSourceSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public getSourceSchema(requestParameters: SourcesBetaApiGetSourceSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).getSourceSchema(requestParameters.sourceId, requestParameters.schemaId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API uploads a source schema template file to configure a source\'s account attributes.
     * @summary Uploads source accounts schema template
     * @param {SourcesBetaApiImportSourceAccountsSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public importSourceAccountsSchema(requestParameters: SourcesBetaApiImportSourceAccountsSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).importSourceAccountsSchema(requestParameters.id, requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This uploads a supplemental source connector file (like jdbc driver jars) to a source\'s S3 bucket. This also sends ETS and Audit events. A token with ORG_ADMIN authority is required to call this API.
     * @summary Upload connector file to source
     * @param {SourcesBetaApiImportSourceConnectorFileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public importSourceConnectorFile(requestParameters: SourcesBetaApiImportSourceConnectorFileRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).importSourceConnectorFile(requestParameters.sourceId, requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API uploads a source schema template file to configure a source\'s entitlement attributes.
     * @summary Uploads source entitlements schema template
     * @param {SourcesBetaApiImportSourceEntitlementsSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public importSourceEntitlementsSchema(requestParameters: SourcesBetaApiImportSourceEntitlementsSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).importSourceEntitlementsSchema(requestParameters.id, requestParameters.schemaName, requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point lists all the ProvisioningPolicies in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
     * @summary Lists ProvisioningPolicies
     * @param {SourcesBetaApiListProvisioningPoliciesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public listProvisioningPolicies(requestParameters: SourcesBetaApiListProvisioningPoliciesRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).listProvisioningPolicies(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists the Schemas that exist on the specified Source in IdentityNow.
     * @param {SourcesBetaApiListSourceSchemasRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public listSourceSchemas(requestParameters: SourcesBetaApiListSourceSchemasRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).listSourceSchemas(requestParameters.sourceId, requestParameters.includeTypes, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point lists all the sources in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or ROLE_SUBADMIN authority is required to call this API.
     * @summary Lists all sources in IdentityNow.
     * @param {SourcesBetaApiListSourcesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public listSources(requestParameters: SourcesBetaApiListSourcesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).listSources(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.forSubadmin, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a sample of data returned from account and group aggregation requests. A token with ORG_ADMIN authority is required to call this API.
     * @summary Peek source connector\'s resource objects
     * @param {SourcesBetaApiPeekResourceObjectsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public peekResourceObjects(requestParameters: SourcesBetaApiPeekResourceObjectsRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).peekResourceObjects(requestParameters.sourceId, requestParameters.resourceObjectsRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint validates that the cluster being used by the source is reachable from IdentityNow. A token with ORG_ADMIN authority is required to call this API.
     * @summary Ping cluster for source connector
     * @param {SourcesBetaApiPingClusterRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public pingCluster(requestParameters: SourcesBetaApiPingClusterRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).pingCluster(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point updates the provisioning policy with the specified usage on the specified source in IdentityNow. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Update Provisioning Policy by UsageType
     * @param {SourcesBetaApiPutProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public putProvisioningPolicy(requestParameters: SourcesBetaApiPutProvisioningPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).putProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, requestParameters.provisioningPolicyDtoBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates a source in IdentityNow, using a full object representation. In other words, the existing Source configuration is completely replaced.  Some fields are immutable and cannot be changed, such as:  * id * type * authoritative * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. 
     * @summary Update Source (Full)
     * @param {SourcesBetaApiPutSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public putSource(requestParameters: SourcesBetaApiPutSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).putSource(requestParameters.id, requestParameters.sourceBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replaces the attribute synchronization configuration for the source specified by the given ID with the configuration provided in the request body. Only the \"enabled\" field of the values in the \"attributes\" array is mutable. Attempting to change other attributes or add new values to the \"attributes\" array will result in an error.      A token with ORG_ADMIN authority is required to call this API.
     * @summary Update Attribute Sync Config
     * @param {SourcesBetaApiPutSourceAttrSyncConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public putSourceAttrSyncConfig(requestParameters: SourcesBetaApiPutSourceAttrSyncConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).putSourceAttrSyncConfig(requestParameters.id, requestParameters.attrSyncSourceConfigBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API will completely replace an existing Schema with the submitted payload. Some fields of the Schema cannot be updated. These fields are listed below. * id * name * created * modified Any attempt to modify these fields will result in an error response with a status code of 400.
     * @summary Update Source Schema (Full)
     * @param {SourcesBetaApiPutSourceSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public putSourceSchema(requestParameters: SourcesBetaApiPutSourceSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).putSourceSchema(requestParameters.sourceId, requestParameters.schemaId, requestParameters.schemaBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point performs attribute synchronization for a selected source. A token with ORG_ADMIN or SOURCE_ADMIN authority is required to call this API.
     * @summary Synchronize single source attributes.
     * @param {SourcesBetaApiSyncAttributesForSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public syncAttributesForSource(requestParameters: SourcesBetaApiSyncAttributesForSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).syncAttributesForSource(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint performs a more detailed validation of the source\'s configuration that can take longer than the lighter weight credential validation performed by the checkConnection API. A token with ORG_ADMIN authority is required to call this API.
     * @summary Test configuration for source connector
     * @param {SourcesBetaApiTestSourceConfigurationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public testSourceConfiguration(requestParameters: SourcesBetaApiTestSourceConfigurationRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).testSourceConfiguration(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint validates that the configured credentials are valid and will properly authenticate with the source identified by the sourceId path parameter. A token with ORG_ADMIN authority is required to call this API.
     * @summary Check connection for source connector.
     * @param {SourcesBetaApiTestSourceConnectionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public testSourceConnection(requestParameters: SourcesBetaApiTestSourceConnectionRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).testSourceConnection(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point updates a list of provisioning policies on the specified source in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
     * @summary Bulk Update Provisioning Policies
     * @param {SourcesBetaApiUpdateProvisioningPoliciesInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public updateProvisioningPoliciesInBulk(requestParameters: SourcesBetaApiUpdateProvisioningPoliciesInBulkRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).updateProvisioningPoliciesInBulk(requestParameters.sourceId, requestParameters.provisioningPolicyDtoBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API selectively updates an existing Provisioning Policy using a JSONPatch payload. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Partial update of Provisioning Policy
     * @param {SourcesBetaApiUpdateProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public updateProvisioningPolicy(requestParameters: SourcesBetaApiUpdateProvisioningPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).updateProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, requestParameters.jsonPatchOperationBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API partially updates a source in IdentityNow, using a list of patch operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Some fields are immutable and cannot be changed, such as: * id * type * authoritative * created * modified * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or API authority is required to call this API. 
     * @summary Update Source (Partial)
     * @param {SourcesBetaApiUpdateSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public updateSource(requestParameters: SourcesBetaApiUpdateSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).updateSource(requestParameters.id, requestParameters.jsonPatchOperationBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API replaces the current entitlement request configuration for a source. This source-level configuration should apply for all the entitlements in the source.  Access request to any entitlements in the source should follow this configuration unless a separate entitlement-level configuration is defined. - During access request, this source-level entitlement request configuration overrides the global organization-level configuration. - However, the entitlement-level configuration (if defined) overrides this source-level configuration.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Update Source Entitlement Request Configuration
     * @param {SourcesBetaApiUpdateSourceEntitlementRequestConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public updateSourceEntitlementRequestConfig(requestParameters: SourcesBetaApiUpdateSourceEntitlementRequestConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).updateSourceEntitlementRequestConfig(requestParameters.sourceEntitlementRequestConfigBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to selectively update an existing Schema using a JSONPatch payload.   The following schema fields are immutable and cannot be updated:  - id - name - created - modified   To switch an account attribute to a group entitlement, you need to have the following in place:  - `isEntitlement: true` - Must define a schema for the group and [add it to the source](https://developer.sailpoint.com/idn/api/beta/create-source-schema) before updating the `isGroup` flag.  For example, here is the `group` account attribute referencing a schema that defines the group: ```json {     \"name\": \"groups\",     \"type\": \"STRING\",     \"schema\": {         \"type\": \"CONNECTOR_SCHEMA\",         \"id\": \"2c9180887671ff8c01767b4671fc7d60\",         \"name\": \"group\"     },     \"description\": \"The groups, roles etc. that reference account group objects\",     \"isMulti\": true,     \"isEntitlement\": true,     \"isGroup\": true } ``` 
     * @summary Update Source Schema (Partial)
     * @param {SourcesBetaApiUpdateSourceSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesBetaApi
     */
    public updateSourceSchema(requestParameters: SourcesBetaApiUpdateSourceSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesBetaApiFp(this.configuration).updateSourceSchema(requestParameters.sourceId, requestParameters.schemaId, requestParameters.jsonPatchOperationBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TaggedObjectsBetaApi - axios parameter creator
 * @export
 */
export const TaggedObjectsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API adds tags to multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Tag Multiple Objects
         * @param {BulkTaggedObjectBeta} bulkTaggedObjectBeta Supported object types are ROLE, IDENTITY and SOD_POLICY.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        addTagsToManyObjects: async (bulkTaggedObjectBeta: BulkTaggedObjectBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkTaggedObjectBeta' is not null or undefined
            assertParamExists('addTagsToManyObjects', 'bulkTaggedObjectBeta', bulkTaggedObjectBeta)
            const localVarPath = `/tagged-objects/bulk-add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkTaggedObjectBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This deletes a tagged object for the specified type.
         * @summary Delete Tagged Object
         * @param {'ROLE' | 'IDENTITY' | 'SOD_POLICY'} type The type of tagged object to delete.
         * @param {string} id The ID of the object reference to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaggedObject: async (type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY', id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('deleteTaggedObject', 'type', type)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTaggedObject', 'id', id)
            const localVarPath = `/tagged-objects/{type}/{id}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a tagged object for the specified type.
         * @summary Get Tagged Object
         * @param {'ROLE' | 'IDENTITY' | 'SOD_POLICY'} type The type of tagged object to retrieve.
         * @param {string} id The ID of the object reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTaggedObject: async (type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY', id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getTaggedObject', 'type', type)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTaggedObject', 'id', id)
            const localVarPath = `/tagged-objects/{type}/{id}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of all tagged objects.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq, in*  **objectRef.type**: *eq, in*  **tagName**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTaggedObjects: async (limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tagged-objects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of all tagged objects by type.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects
         * @param {'ROLE' | 'IDENTITY' | 'SOD_POLICY'} type The type of tagged object to retrieve.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq*  **objectRef.type**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTaggedObjectsByType: async (type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY', limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('listTaggedObjectsByType', 'type', type)
            const localVarPath = `/tagged-objects/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API removes tags from multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Remove Tags from Multiple Objects
         * @param {BulkTaggedObjectBeta} bulkTaggedObjectBeta Supported object types are ROLE, IDENTITY and SOD_POLICY.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        removeTagsToManyObject: async (bulkTaggedObjectBeta: BulkTaggedObjectBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkTaggedObjectBeta' is not null or undefined
            assertParamExists('removeTagsToManyObject', 'bulkTaggedObjectBeta', bulkTaggedObjectBeta)
            const localVarPath = `/tagged-objects/bulk-remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkTaggedObjectBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This adds a tag to an object.  Any authenticated token may be used to call this API.
         * @summary Add Tag to Object
         * @param {TaggedObjectBeta} taggedObjectBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setTagToObject: async (taggedObjectBeta: TaggedObjectBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taggedObjectBeta' is not null or undefined
            assertParamExists('setTagToObject', 'taggedObjectBeta', taggedObjectBeta)
            const localVarPath = `/tagged-objects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taggedObjectBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This updates a tagged object for the specified type.
         * @summary Update Tagged Object
         * @param {'ROLE' | 'IDENTITY' | 'SOD_POLICY'} type The type of tagged object to update.
         * @param {string} id The ID of the object reference to update.
         * @param {TaggedObjectBeta} taggedObjectBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateTaggedObject: async (type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY', id: string, taggedObjectBeta: TaggedObjectBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('updateTaggedObject', 'type', type)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTaggedObject', 'id', id)
            // verify required parameter 'taggedObjectBeta' is not null or undefined
            assertParamExists('updateTaggedObject', 'taggedObjectBeta', taggedObjectBeta)
            const localVarPath = `/tagged-objects/{type}/{id}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taggedObjectBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaggedObjectsBetaApi - functional programming interface
 * @export
 */
export const TaggedObjectsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaggedObjectsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This API adds tags to multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Tag Multiple Objects
         * @param {BulkTaggedObjectBeta} bulkTaggedObjectBeta Supported object types are ROLE, IDENTITY and SOD_POLICY.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async addTagsToManyObjects(bulkTaggedObjectBeta: BulkTaggedObjectBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkTaggedObjectBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTagsToManyObjects(bulkTaggedObjectBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This deletes a tagged object for the specified type.
         * @summary Delete Tagged Object
         * @param {'ROLE' | 'IDENTITY' | 'SOD_POLICY'} type The type of tagged object to delete.
         * @param {string} id The ID of the object reference to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTaggedObject(type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY', id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTaggedObject(type, id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a tagged object for the specified type.
         * @summary Get Tagged Object
         * @param {'ROLE' | 'IDENTITY' | 'SOD_POLICY'} type The type of tagged object to retrieve.
         * @param {string} id The ID of the object reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getTaggedObject(type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY', id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaggedObjectBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaggedObject(type, id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of all tagged objects.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq, in*  **objectRef.type**: *eq, in*  **tagName**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listTaggedObjects(limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaggedObjectBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTaggedObjects(limit, offset, count, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of all tagged objects by type.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects
         * @param {'ROLE' | 'IDENTITY' | 'SOD_POLICY'} type The type of tagged object to retrieve.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq*  **objectRef.type**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listTaggedObjectsByType(type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY', limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaggedObjectBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTaggedObjectsByType(type, limit, offset, count, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API removes tags from multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Remove Tags from Multiple Objects
         * @param {BulkTaggedObjectBeta} bulkTaggedObjectBeta Supported object types are ROLE, IDENTITY and SOD_POLICY.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async removeTagsToManyObject(bulkTaggedObjectBeta: BulkTaggedObjectBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTagsToManyObject(bulkTaggedObjectBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This adds a tag to an object.  Any authenticated token may be used to call this API.
         * @summary Add Tag to Object
         * @param {TaggedObjectBeta} taggedObjectBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setTagToObject(taggedObjectBeta: TaggedObjectBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTagToObject(taggedObjectBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This updates a tagged object for the specified type.
         * @summary Update Tagged Object
         * @param {'ROLE' | 'IDENTITY' | 'SOD_POLICY'} type The type of tagged object to update.
         * @param {string} id The ID of the object reference to update.
         * @param {TaggedObjectBeta} taggedObjectBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateTaggedObject(type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY', id: string, taggedObjectBeta: TaggedObjectBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaggedObjectBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTaggedObject(type, id, taggedObjectBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TaggedObjectsBetaApi - factory interface
 * @export
 */
export const TaggedObjectsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaggedObjectsBetaApiFp(configuration)
    return {
        /**
         * This API adds tags to multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Tag Multiple Objects
         * @param {BulkTaggedObjectBeta} bulkTaggedObjectBeta Supported object types are ROLE, IDENTITY and SOD_POLICY.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        addTagsToManyObjects(bulkTaggedObjectBeta: BulkTaggedObjectBeta, axiosOptions?: any): AxiosPromise<BulkTaggedObjectBeta> {
            return localVarFp.addTagsToManyObjects(bulkTaggedObjectBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This deletes a tagged object for the specified type.
         * @summary Delete Tagged Object
         * @param {'ROLE' | 'IDENTITY' | 'SOD_POLICY'} type The type of tagged object to delete.
         * @param {string} id The ID of the object reference to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaggedObject(type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY', id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteTaggedObject(type, id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a tagged object for the specified type.
         * @summary Get Tagged Object
         * @param {'ROLE' | 'IDENTITY' | 'SOD_POLICY'} type The type of tagged object to retrieve.
         * @param {string} id The ID of the object reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTaggedObject(type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY', id: string, axiosOptions?: any): AxiosPromise<TaggedObjectBeta> {
            return localVarFp.getTaggedObject(type, id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of all tagged objects.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq, in*  **objectRef.type**: *eq, in*  **tagName**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTaggedObjects(limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: any): AxiosPromise<Array<TaggedObjectBeta>> {
            return localVarFp.listTaggedObjects(limit, offset, count, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of all tagged objects by type.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects
         * @param {'ROLE' | 'IDENTITY' | 'SOD_POLICY'} type The type of tagged object to retrieve.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq*  **objectRef.type**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTaggedObjectsByType(type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY', limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: any): AxiosPromise<Array<TaggedObjectBeta>> {
            return localVarFp.listTaggedObjectsByType(type, limit, offset, count, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API removes tags from multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Remove Tags from Multiple Objects
         * @param {BulkTaggedObjectBeta} bulkTaggedObjectBeta Supported object types are ROLE, IDENTITY and SOD_POLICY.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        removeTagsToManyObject(bulkTaggedObjectBeta: BulkTaggedObjectBeta, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.removeTagsToManyObject(bulkTaggedObjectBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This adds a tag to an object.  Any authenticated token may be used to call this API.
         * @summary Add Tag to Object
         * @param {TaggedObjectBeta} taggedObjectBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setTagToObject(taggedObjectBeta: TaggedObjectBeta, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.setTagToObject(taggedObjectBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This updates a tagged object for the specified type.
         * @summary Update Tagged Object
         * @param {'ROLE' | 'IDENTITY' | 'SOD_POLICY'} type The type of tagged object to update.
         * @param {string} id The ID of the object reference to update.
         * @param {TaggedObjectBeta} taggedObjectBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateTaggedObject(type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY', id: string, taggedObjectBeta: TaggedObjectBeta, axiosOptions?: any): AxiosPromise<TaggedObjectBeta> {
            return localVarFp.updateTaggedObject(type, id, taggedObjectBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addTagsToManyObjects operation in TaggedObjectsBetaApi.
 * @export
 * @interface TaggedObjectsBetaApiAddTagsToManyObjectsRequest
 */
export interface TaggedObjectsBetaApiAddTagsToManyObjectsRequest {
    /**
     * Supported object types are ROLE, IDENTITY and SOD_POLICY.
     * @type {BulkTaggedObjectBeta}
     * @memberof TaggedObjectsBetaApiAddTagsToManyObjects
     */
    readonly bulkTaggedObjectBeta: BulkTaggedObjectBeta
}

/**
 * Request parameters for deleteTaggedObject operation in TaggedObjectsBetaApi.
 * @export
 * @interface TaggedObjectsBetaApiDeleteTaggedObjectRequest
 */
export interface TaggedObjectsBetaApiDeleteTaggedObjectRequest {
    /**
     * The type of tagged object to delete.
     * @type {'ROLE' | 'IDENTITY' | 'SOD_POLICY'}
     * @memberof TaggedObjectsBetaApiDeleteTaggedObject
     */
    readonly type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY'

    /**
     * The ID of the object reference to delete.
     * @type {string}
     * @memberof TaggedObjectsBetaApiDeleteTaggedObject
     */
    readonly id: string
}

/**
 * Request parameters for getTaggedObject operation in TaggedObjectsBetaApi.
 * @export
 * @interface TaggedObjectsBetaApiGetTaggedObjectRequest
 */
export interface TaggedObjectsBetaApiGetTaggedObjectRequest {
    /**
     * The type of tagged object to retrieve.
     * @type {'ROLE' | 'IDENTITY' | 'SOD_POLICY'}
     * @memberof TaggedObjectsBetaApiGetTaggedObject
     */
    readonly type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY'

    /**
     * The ID of the object reference to retrieve.
     * @type {string}
     * @memberof TaggedObjectsBetaApiGetTaggedObject
     */
    readonly id: string
}

/**
 * Request parameters for listTaggedObjects operation in TaggedObjectsBetaApi.
 * @export
 * @interface TaggedObjectsBetaApiListTaggedObjectsRequest
 */
export interface TaggedObjectsBetaApiListTaggedObjectsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TaggedObjectsBetaApiListTaggedObjects
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TaggedObjectsBetaApiListTaggedObjects
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof TaggedObjectsBetaApiListTaggedObjects
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq, in*  **objectRef.type**: *eq, in*  **tagName**: *eq, in*
     * @type {string}
     * @memberof TaggedObjectsBetaApiListTaggedObjects
     */
    readonly filters?: string
}

/**
 * Request parameters for listTaggedObjectsByType operation in TaggedObjectsBetaApi.
 * @export
 * @interface TaggedObjectsBetaApiListTaggedObjectsByTypeRequest
 */
export interface TaggedObjectsBetaApiListTaggedObjectsByTypeRequest {
    /**
     * The type of tagged object to retrieve.
     * @type {'ROLE' | 'IDENTITY' | 'SOD_POLICY'}
     * @memberof TaggedObjectsBetaApiListTaggedObjectsByType
     */
    readonly type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY'

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TaggedObjectsBetaApiListTaggedObjectsByType
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TaggedObjectsBetaApiListTaggedObjectsByType
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof TaggedObjectsBetaApiListTaggedObjectsByType
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq*  **objectRef.type**: *eq*
     * @type {string}
     * @memberof TaggedObjectsBetaApiListTaggedObjectsByType
     */
    readonly filters?: string
}

/**
 * Request parameters for removeTagsToManyObject operation in TaggedObjectsBetaApi.
 * @export
 * @interface TaggedObjectsBetaApiRemoveTagsToManyObjectRequest
 */
export interface TaggedObjectsBetaApiRemoveTagsToManyObjectRequest {
    /**
     * Supported object types are ROLE, IDENTITY and SOD_POLICY.
     * @type {BulkTaggedObjectBeta}
     * @memberof TaggedObjectsBetaApiRemoveTagsToManyObject
     */
    readonly bulkTaggedObjectBeta: BulkTaggedObjectBeta
}

/**
 * Request parameters for setTagToObject operation in TaggedObjectsBetaApi.
 * @export
 * @interface TaggedObjectsBetaApiSetTagToObjectRequest
 */
export interface TaggedObjectsBetaApiSetTagToObjectRequest {
    /**
     * 
     * @type {TaggedObjectBeta}
     * @memberof TaggedObjectsBetaApiSetTagToObject
     */
    readonly taggedObjectBeta: TaggedObjectBeta
}

/**
 * Request parameters for updateTaggedObject operation in TaggedObjectsBetaApi.
 * @export
 * @interface TaggedObjectsBetaApiUpdateTaggedObjectRequest
 */
export interface TaggedObjectsBetaApiUpdateTaggedObjectRequest {
    /**
     * The type of tagged object to update.
     * @type {'ROLE' | 'IDENTITY' | 'SOD_POLICY'}
     * @memberof TaggedObjectsBetaApiUpdateTaggedObject
     */
    readonly type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY'

    /**
     * The ID of the object reference to update.
     * @type {string}
     * @memberof TaggedObjectsBetaApiUpdateTaggedObject
     */
    readonly id: string

    /**
     * 
     * @type {TaggedObjectBeta}
     * @memberof TaggedObjectsBetaApiUpdateTaggedObject
     */
    readonly taggedObjectBeta: TaggedObjectBeta
}

/**
 * TaggedObjectsBetaApi - object-oriented interface
 * @export
 * @class TaggedObjectsBetaApi
 * @extends {BaseAPI}
 */
export class TaggedObjectsBetaApi extends BaseAPI {
    /**
     * This API adds tags to multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Tag Multiple Objects
     * @param {TaggedObjectsBetaApiAddTagsToManyObjectsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsBetaApi
     */
    public addTagsToManyObjects(requestParameters: TaggedObjectsBetaApiAddTagsToManyObjectsRequest, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsBetaApiFp(this.configuration).addTagsToManyObjects(requestParameters.bulkTaggedObjectBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes a tagged object for the specified type.
     * @summary Delete Tagged Object
     * @param {TaggedObjectsBetaApiDeleteTaggedObjectRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsBetaApi
     */
    public deleteTaggedObject(requestParameters: TaggedObjectsBetaApiDeleteTaggedObjectRequest, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsBetaApiFp(this.configuration).deleteTaggedObject(requestParameters.type, requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a tagged object for the specified type.
     * @summary Get Tagged Object
     * @param {TaggedObjectsBetaApiGetTaggedObjectRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsBetaApi
     */
    public getTaggedObject(requestParameters: TaggedObjectsBetaApiGetTaggedObjectRequest, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsBetaApiFp(this.configuration).getTaggedObject(requestParameters.type, requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of all tagged objects.  Any authenticated token may be used to call this API.
     * @summary List Tagged Objects
     * @param {TaggedObjectsBetaApiListTaggedObjectsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsBetaApi
     */
    public listTaggedObjects(requestParameters: TaggedObjectsBetaApiListTaggedObjectsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsBetaApiFp(this.configuration).listTaggedObjects(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of all tagged objects by type.  Any authenticated token may be used to call this API.
     * @summary List Tagged Objects
     * @param {TaggedObjectsBetaApiListTaggedObjectsByTypeRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsBetaApi
     */
    public listTaggedObjectsByType(requestParameters: TaggedObjectsBetaApiListTaggedObjectsByTypeRequest, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsBetaApiFp(this.configuration).listTaggedObjectsByType(requestParameters.type, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API removes tags from multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Remove Tags from Multiple Objects
     * @param {TaggedObjectsBetaApiRemoveTagsToManyObjectRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsBetaApi
     */
    public removeTagsToManyObject(requestParameters: TaggedObjectsBetaApiRemoveTagsToManyObjectRequest, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsBetaApiFp(this.configuration).removeTagsToManyObject(requestParameters.bulkTaggedObjectBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This adds a tag to an object.  Any authenticated token may be used to call this API.
     * @summary Add Tag to Object
     * @param {TaggedObjectsBetaApiSetTagToObjectRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsBetaApi
     */
    public setTagToObject(requestParameters: TaggedObjectsBetaApiSetTagToObjectRequest, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsBetaApiFp(this.configuration).setTagToObject(requestParameters.taggedObjectBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This updates a tagged object for the specified type.
     * @summary Update Tagged Object
     * @param {TaggedObjectsBetaApiUpdateTaggedObjectRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsBetaApi
     */
    public updateTaggedObject(requestParameters: TaggedObjectsBetaApiUpdateTaggedObjectRequest, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsBetaApiFp(this.configuration).updateTaggedObject(requestParameters.type, requestParameters.id, requestParameters.taggedObjectBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransformsBetaApi - axios parameter creator
 * @export
 */
export const TransformsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new transform object. Request body must include name, type, and attributes. A token with transform write authority is required to call this API.
         * @summary Create transform
         * @param {TransformBeta} transformBeta The transform to be created.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createTransform: async (transformBeta: TransformBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transformBeta' is not null or undefined
            assertParamExists('createTransform', 'transformBeta', transformBeta)
            const localVarPath = `/transforms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transformBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes the transform specified by the given ID. A token with transform delete authority is required to call this API.
         * @summary Delete a transform
         * @param {string} id ID of the transform to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransform: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTransform', 'id', id)
            const localVarPath = `/transforms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the transform specified by the given ID. A token with transform read authority is required to call this API.
         * @summary Transform by ID
         * @param {string} id ID of the transform to retrieve
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTransform: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTransform', 'id', id)
            const localVarPath = `/transforms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of all saved transform objects. A token with transforms-list read authority is required to call this API.
         * @summary List transforms
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [name] Name of the transform to retrieve from the list.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **internal**: *eq* **name**: *eq*, *sw*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTransforms: async (offset?: number, limit?: number, count?: boolean, name?: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transforms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Replaces the transform specified by the given ID with the transform provided in the request body. Only the \"attributes\" field is mutable. Attempting to change other attributes will result in an error. A token with transform write authority is required to call this API.
         * @summary Update a transform
         * @param {string} id ID of the transform to update
         * @param {TransformBeta} [transformBeta] The updated transform object (must include \&quot;name\&quot;, \&quot;type\&quot;, and \&quot;attributes\&quot; fields).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateTransform: async (id: string, transformBeta?: TransformBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTransform', 'id', id)
            const localVarPath = `/transforms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transformBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransformsBetaApi - functional programming interface
 * @export
 */
export const TransformsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransformsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new transform object. Request body must include name, type, and attributes. A token with transform write authority is required to call this API.
         * @summary Create transform
         * @param {TransformBeta} transformBeta The transform to be created.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createTransform(transformBeta: TransformBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransformBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransform(transformBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the transform specified by the given ID. A token with transform delete authority is required to call this API.
         * @summary Delete a transform
         * @param {string} id ID of the transform to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTransform(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTransform(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the transform specified by the given ID. A token with transform read authority is required to call this API.
         * @summary Transform by ID
         * @param {string} id ID of the transform to retrieve
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getTransform(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransformBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransform(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a list of all saved transform objects. A token with transforms-list read authority is required to call this API.
         * @summary List transforms
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [name] Name of the transform to retrieve from the list.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **internal**: *eq* **name**: *eq*, *sw*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listTransforms(offset?: number, limit?: number, count?: boolean, name?: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransformBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransforms(offset, limit, count, name, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replaces the transform specified by the given ID with the transform provided in the request body. Only the \"attributes\" field is mutable. Attempting to change other attributes will result in an error. A token with transform write authority is required to call this API.
         * @summary Update a transform
         * @param {string} id ID of the transform to update
         * @param {TransformBeta} [transformBeta] The updated transform object (must include \&quot;name\&quot;, \&quot;type\&quot;, and \&quot;attributes\&quot; fields).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateTransform(id: string, transformBeta?: TransformBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransformBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTransform(id, transformBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransformsBetaApi - factory interface
 * @export
 */
export const TransformsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransformsBetaApiFp(configuration)
    return {
        /**
         * Creates a new transform object. Request body must include name, type, and attributes. A token with transform write authority is required to call this API.
         * @summary Create transform
         * @param {TransformBeta} transformBeta The transform to be created.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createTransform(transformBeta: TransformBeta, axiosOptions?: any): AxiosPromise<TransformBeta> {
            return localVarFp.createTransform(transformBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the transform specified by the given ID. A token with transform delete authority is required to call this API.
         * @summary Delete a transform
         * @param {string} id ID of the transform to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransform(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteTransform(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the transform specified by the given ID. A token with transform read authority is required to call this API.
         * @summary Transform by ID
         * @param {string} id ID of the transform to retrieve
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTransform(id: string, axiosOptions?: any): AxiosPromise<TransformBeta> {
            return localVarFp.getTransform(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of all saved transform objects. A token with transforms-list read authority is required to call this API.
         * @summary List transforms
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [name] Name of the transform to retrieve from the list.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **internal**: *eq* **name**: *eq*, *sw*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTransforms(offset?: number, limit?: number, count?: boolean, name?: string, filters?: string, axiosOptions?: any): AxiosPromise<Array<TransformBeta>> {
            return localVarFp.listTransforms(offset, limit, count, name, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Replaces the transform specified by the given ID with the transform provided in the request body. Only the \"attributes\" field is mutable. Attempting to change other attributes will result in an error. A token with transform write authority is required to call this API.
         * @summary Update a transform
         * @param {string} id ID of the transform to update
         * @param {TransformBeta} [transformBeta] The updated transform object (must include \&quot;name\&quot;, \&quot;type\&quot;, and \&quot;attributes\&quot; fields).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateTransform(id: string, transformBeta?: TransformBeta, axiosOptions?: any): AxiosPromise<TransformBeta> {
            return localVarFp.updateTransform(id, transformBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createTransform operation in TransformsBetaApi.
 * @export
 * @interface TransformsBetaApiCreateTransformRequest
 */
export interface TransformsBetaApiCreateTransformRequest {
    /**
     * The transform to be created.
     * @type {TransformBeta}
     * @memberof TransformsBetaApiCreateTransform
     */
    readonly transformBeta: TransformBeta
}

/**
 * Request parameters for deleteTransform operation in TransformsBetaApi.
 * @export
 * @interface TransformsBetaApiDeleteTransformRequest
 */
export interface TransformsBetaApiDeleteTransformRequest {
    /**
     * ID of the transform to delete
     * @type {string}
     * @memberof TransformsBetaApiDeleteTransform
     */
    readonly id: string
}

/**
 * Request parameters for getTransform operation in TransformsBetaApi.
 * @export
 * @interface TransformsBetaApiGetTransformRequest
 */
export interface TransformsBetaApiGetTransformRequest {
    /**
     * ID of the transform to retrieve
     * @type {string}
     * @memberof TransformsBetaApiGetTransform
     */
    readonly id: string
}

/**
 * Request parameters for listTransforms operation in TransformsBetaApi.
 * @export
 * @interface TransformsBetaApiListTransformsRequest
 */
export interface TransformsBetaApiListTransformsRequest {
    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TransformsBetaApiListTransforms
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TransformsBetaApiListTransforms
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof TransformsBetaApiListTransforms
     */
    readonly count?: boolean

    /**
     * Name of the transform to retrieve from the list.
     * @type {string}
     * @memberof TransformsBetaApiListTransforms
     */
    readonly name?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **internal**: *eq* **name**: *eq*, *sw*
     * @type {string}
     * @memberof TransformsBetaApiListTransforms
     */
    readonly filters?: string
}

/**
 * Request parameters for updateTransform operation in TransformsBetaApi.
 * @export
 * @interface TransformsBetaApiUpdateTransformRequest
 */
export interface TransformsBetaApiUpdateTransformRequest {
    /**
     * ID of the transform to update
     * @type {string}
     * @memberof TransformsBetaApiUpdateTransform
     */
    readonly id: string

    /**
     * The updated transform object (must include \&quot;name\&quot;, \&quot;type\&quot;, and \&quot;attributes\&quot; fields).
     * @type {TransformBeta}
     * @memberof TransformsBetaApiUpdateTransform
     */
    readonly transformBeta?: TransformBeta
}

/**
 * TransformsBetaApi - object-oriented interface
 * @export
 * @class TransformsBetaApi
 * @extends {BaseAPI}
 */
export class TransformsBetaApi extends BaseAPI {
    /**
     * Creates a new transform object. Request body must include name, type, and attributes. A token with transform write authority is required to call this API.
     * @summary Create transform
     * @param {TransformsBetaApiCreateTransformRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsBetaApi
     */
    public createTransform(requestParameters: TransformsBetaApiCreateTransformRequest, axiosOptions?: AxiosRequestConfig) {
        return TransformsBetaApiFp(this.configuration).createTransform(requestParameters.transformBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the transform specified by the given ID. A token with transform delete authority is required to call this API.
     * @summary Delete a transform
     * @param {TransformsBetaApiDeleteTransformRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsBetaApi
     */
    public deleteTransform(requestParameters: TransformsBetaApiDeleteTransformRequest, axiosOptions?: AxiosRequestConfig) {
        return TransformsBetaApiFp(this.configuration).deleteTransform(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the transform specified by the given ID. A token with transform read authority is required to call this API.
     * @summary Transform by ID
     * @param {TransformsBetaApiGetTransformRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsBetaApi
     */
    public getTransform(requestParameters: TransformsBetaApiGetTransformRequest, axiosOptions?: AxiosRequestConfig) {
        return TransformsBetaApiFp(this.configuration).getTransform(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of all saved transform objects. A token with transforms-list read authority is required to call this API.
     * @summary List transforms
     * @param {TransformsBetaApiListTransformsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsBetaApi
     */
    public listTransforms(requestParameters: TransformsBetaApiListTransformsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return TransformsBetaApiFp(this.configuration).listTransforms(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.name, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replaces the transform specified by the given ID with the transform provided in the request body. Only the \"attributes\" field is mutable. Attempting to change other attributes will result in an error. A token with transform write authority is required to call this API.
     * @summary Update a transform
     * @param {TransformsBetaApiUpdateTransformRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsBetaApi
     */
    public updateTransform(requestParameters: TransformsBetaApiUpdateTransformRequest, axiosOptions?: AxiosRequestConfig) {
        return TransformsBetaApiFp(this.configuration).updateTransform(requestParameters.id, requestParameters.transformBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TriggersBetaApi - axios parameter creator
 * @export
 */
export const TriggersBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Completes an invocation to a REQUEST_RESPONSE type trigger.
         * @summary Complete Trigger Invocation
         * @param {string} id The ID of the invocation to complete.
         * @param {CompleteInvocationBeta} completeInvocationBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        completeTriggerInvocation: async (id: string, completeInvocationBeta: CompleteInvocationBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('completeTriggerInvocation', 'id', id)
            // verify required parameter 'completeInvocationBeta' is not null or undefined
            assertParamExists('completeTriggerInvocation', 'completeInvocationBeta', completeInvocationBeta)
            const localVarPath = `/trigger-invocations/{id}/complete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completeInvocationBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API creates a new subscription to a trigger and defines trigger invocation details. The type of subscription determines which config object is required: * HTTP subscriptions require httpConfig * EventBridge subscriptions require eventBridgeConfig
         * @summary Create a Subscription
         * @param {SubscriptionPostRequestBeta} subscriptionPostRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription: async (subscriptionPostRequestBeta: SubscriptionPostRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionPostRequestBeta' is not null or undefined
            assertParamExists('createSubscription', 'subscriptionPostRequestBeta', subscriptionPostRequestBeta)
            const localVarPath = `/trigger-subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionPostRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes an existing subscription to a trigger.
         * @summary Delete a Subscription
         * @param {string} id Subscription ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscription: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSubscription', 'id', id)
            const localVarPath = `/trigger-subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of all trigger subscriptions.
         * @summary List Subscriptions
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*  **triggerId**: *eq*  **type**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields:  **triggerId** **triggerName**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptions: async (limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/trigger-subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of latest invocation statuses. Statuses of successful invocations are available for up to 24 hours. Statuses of failed invocations are available for up to 48 hours. This endpoint may only fetch up to 2000 invocations, and should not be treated as a representation of the full history of invocations.
         * @summary List Latest Invocation Statuses
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **triggerId**: *eq* **subscriptionId**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields:  **triggerId** **subscriptionName** **created** **completed**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTriggerInvocationStatus: async (limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/trigger-invocations/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of triggers that are available in the tenant.
         * @summary List Triggers
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields:  **id** **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTriggers: async (limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/triggers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates a trigger subscription in IdentityNow, using a set of instructions to modify a subscription partially. The following fields are patchable:  **name**, **description**, **enabled**, **type**, **filter**, **responseDeadline**, **httpConfig**, **eventBridgeConfig**, **workflowConfig**
         * @summary Patch a Subscription
         * @param {string} id ID of the Subscription to patch
         * @param {Array<SubscriptionPatchRequestInnerBeta>} subscriptionPatchRequestInnerBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSubscription: async (id: string, subscriptionPatchRequestInnerBeta: Array<SubscriptionPatchRequestInnerBeta>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchSubscription', 'id', id)
            // verify required parameter 'subscriptionPatchRequestInnerBeta' is not null or undefined
            assertParamExists('patchSubscription', 'subscriptionPatchRequestInnerBeta', subscriptionPatchRequestInnerBeta)
            const localVarPath = `/trigger-subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionPatchRequestInnerBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Initiate a test event for all subscribers of the specified event trigger.  If there are no subscribers to the specified trigger in the tenant, then no test event will be sent.
         * @summary Start a Test Invocation
         * @param {TestInvocationBeta} testInvocationBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startTestTriggerInvocation: async (testInvocationBeta: TestInvocationBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testInvocationBeta' is not null or undefined
            assertParamExists('startTestTriggerInvocation', 'testInvocationBeta', testInvocationBeta)
            const localVarPath = `/trigger-invocations/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testInvocationBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Validates a JSONPath filter expression against a provided mock input. Request requires a security scope of: 
         * @summary Validate a Subscription Filter
         * @param {ValidateFilterInputDtoBeta} validateFilterInputDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testSubscriptionFilter: async (validateFilterInputDtoBeta: ValidateFilterInputDtoBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'validateFilterInputDtoBeta' is not null or undefined
            assertParamExists('testSubscriptionFilter', 'validateFilterInputDtoBeta', validateFilterInputDtoBeta)
            const localVarPath = `/trigger-subscriptions/validate-filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validateFilterInputDtoBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates a trigger subscription in IdentityNow, using a full object representation. In other words, the existing   Subscription is completely replaced. The following fields are immutable:     * id    * triggerId     Attempts to modify these fields result in 400.
         * @summary Update a Subscription
         * @param {string} id Subscription ID
         * @param {SubscriptionPutRequestBeta} subscriptionPutRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscription: async (id: string, subscriptionPutRequestBeta: SubscriptionPutRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSubscription', 'id', id)
            // verify required parameter 'subscriptionPutRequestBeta' is not null or undefined
            assertParamExists('updateSubscription', 'subscriptionPutRequestBeta', subscriptionPutRequestBeta)
            const localVarPath = `/trigger-subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionPutRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * TriggersBetaApi - functional programming interface
 * @export
 */
export const TriggersBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TriggersBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Completes an invocation to a REQUEST_RESPONSE type trigger.
         * @summary Complete Trigger Invocation
         * @param {string} id The ID of the invocation to complete.
         * @param {CompleteInvocationBeta} completeInvocationBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async completeTriggerInvocation(id: string, completeInvocationBeta: CompleteInvocationBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeTriggerInvocation(id, completeInvocationBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API creates a new subscription to a trigger and defines trigger invocation details. The type of subscription determines which config object is required: * HTTP subscriptions require httpConfig * EventBridge subscriptions require eventBridgeConfig
         * @summary Create a Subscription
         * @param {SubscriptionPostRequestBeta} subscriptionPostRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscription(subscriptionPostRequestBeta: SubscriptionPostRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubscription(subscriptionPostRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes an existing subscription to a trigger.
         * @summary Delete a Subscription
         * @param {string} id Subscription ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSubscription(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSubscription(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a list of all trigger subscriptions.
         * @summary List Subscriptions
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*  **triggerId**: *eq*  **type**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields:  **triggerId** **triggerName**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listSubscriptions(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SubscriptionBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSubscriptions(limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a list of latest invocation statuses. Statuses of successful invocations are available for up to 24 hours. Statuses of failed invocations are available for up to 48 hours. This endpoint may only fetch up to 2000 invocations, and should not be treated as a representation of the full history of invocations.
         * @summary List Latest Invocation Statuses
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **triggerId**: *eq* **subscriptionId**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields:  **triggerId** **subscriptionName** **created** **completed**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listTriggerInvocationStatus(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InvocationStatusBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTriggerInvocationStatus(limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a list of triggers that are available in the tenant.
         * @summary List Triggers
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields:  **id** **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listTriggers(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TriggerBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTriggers(limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API updates a trigger subscription in IdentityNow, using a set of instructions to modify a subscription partially. The following fields are patchable:  **name**, **description**, **enabled**, **type**, **filter**, **responseDeadline**, **httpConfig**, **eventBridgeConfig**, **workflowConfig**
         * @summary Patch a Subscription
         * @param {string} id ID of the Subscription to patch
         * @param {Array<SubscriptionPatchRequestInnerBeta>} subscriptionPatchRequestInnerBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchSubscription(id: string, subscriptionPatchRequestInnerBeta: Array<SubscriptionPatchRequestInnerBeta>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchSubscription(id, subscriptionPatchRequestInnerBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Initiate a test event for all subscribers of the specified event trigger.  If there are no subscribers to the specified trigger in the tenant, then no test event will be sent.
         * @summary Start a Test Invocation
         * @param {TestInvocationBeta} testInvocationBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startTestTriggerInvocation(testInvocationBeta: TestInvocationBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InvocationBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startTestTriggerInvocation(testInvocationBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validates a JSONPath filter expression against a provided mock input. Request requires a security scope of: 
         * @summary Validate a Subscription Filter
         * @param {ValidateFilterInputDtoBeta} validateFilterInputDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async testSubscriptionFilter(validateFilterInputDtoBeta: ValidateFilterInputDtoBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateFilterOutputDtoBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testSubscriptionFilter(validateFilterInputDtoBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API updates a trigger subscription in IdentityNow, using a full object representation. In other words, the existing   Subscription is completely replaced. The following fields are immutable:     * id    * triggerId     Attempts to modify these fields result in 400.
         * @summary Update a Subscription
         * @param {string} id Subscription ID
         * @param {SubscriptionPutRequestBeta} subscriptionPutRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateSubscription(id: string, subscriptionPutRequestBeta: SubscriptionPutRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSubscription(id, subscriptionPutRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TriggersBetaApi - factory interface
 * @export
 */
export const TriggersBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TriggersBetaApiFp(configuration)
    return {
        /**
         * Completes an invocation to a REQUEST_RESPONSE type trigger.
         * @summary Complete Trigger Invocation
         * @param {string} id The ID of the invocation to complete.
         * @param {CompleteInvocationBeta} completeInvocationBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        completeTriggerInvocation(id: string, completeInvocationBeta: CompleteInvocationBeta, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.completeTriggerInvocation(id, completeInvocationBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API creates a new subscription to a trigger and defines trigger invocation details. The type of subscription determines which config object is required: * HTTP subscriptions require httpConfig * EventBridge subscriptions require eventBridgeConfig
         * @summary Create a Subscription
         * @param {SubscriptionPostRequestBeta} subscriptionPostRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription(subscriptionPostRequestBeta: SubscriptionPostRequestBeta, axiosOptions?: any): AxiosPromise<SubscriptionBeta> {
            return localVarFp.createSubscription(subscriptionPostRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an existing subscription to a trigger.
         * @summary Delete a Subscription
         * @param {string} id Subscription ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscription(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteSubscription(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of all trigger subscriptions.
         * @summary List Subscriptions
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*  **triggerId**: *eq*  **type**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields:  **triggerId** **triggerName**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptions(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<SubscriptionBeta>> {
            return localVarFp.listSubscriptions(limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of latest invocation statuses. Statuses of successful invocations are available for up to 24 hours. Statuses of failed invocations are available for up to 48 hours. This endpoint may only fetch up to 2000 invocations, and should not be treated as a representation of the full history of invocations.
         * @summary List Latest Invocation Statuses
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **triggerId**: *eq* **subscriptionId**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields:  **triggerId** **subscriptionName** **created** **completed**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTriggerInvocationStatus(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<InvocationStatusBeta>> {
            return localVarFp.listTriggerInvocationStatus(limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of triggers that are available in the tenant.
         * @summary List Triggers
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields:  **id** **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTriggers(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<TriggerBeta>> {
            return localVarFp.listTriggers(limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates a trigger subscription in IdentityNow, using a set of instructions to modify a subscription partially. The following fields are patchable:  **name**, **description**, **enabled**, **type**, **filter**, **responseDeadline**, **httpConfig**, **eventBridgeConfig**, **workflowConfig**
         * @summary Patch a Subscription
         * @param {string} id ID of the Subscription to patch
         * @param {Array<SubscriptionPatchRequestInnerBeta>} subscriptionPatchRequestInnerBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSubscription(id: string, subscriptionPatchRequestInnerBeta: Array<SubscriptionPatchRequestInnerBeta>, axiosOptions?: any): AxiosPromise<SubscriptionBeta> {
            return localVarFp.patchSubscription(id, subscriptionPatchRequestInnerBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Initiate a test event for all subscribers of the specified event trigger.  If there are no subscribers to the specified trigger in the tenant, then no test event will be sent.
         * @summary Start a Test Invocation
         * @param {TestInvocationBeta} testInvocationBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startTestTriggerInvocation(testInvocationBeta: TestInvocationBeta, axiosOptions?: any): AxiosPromise<Array<InvocationBeta>> {
            return localVarFp.startTestTriggerInvocation(testInvocationBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Validates a JSONPath filter expression against a provided mock input. Request requires a security scope of: 
         * @summary Validate a Subscription Filter
         * @param {ValidateFilterInputDtoBeta} validateFilterInputDtoBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testSubscriptionFilter(validateFilterInputDtoBeta: ValidateFilterInputDtoBeta, axiosOptions?: any): AxiosPromise<ValidateFilterOutputDtoBeta> {
            return localVarFp.testSubscriptionFilter(validateFilterInputDtoBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates a trigger subscription in IdentityNow, using a full object representation. In other words, the existing   Subscription is completely replaced. The following fields are immutable:     * id    * triggerId     Attempts to modify these fields result in 400.
         * @summary Update a Subscription
         * @param {string} id Subscription ID
         * @param {SubscriptionPutRequestBeta} subscriptionPutRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscription(id: string, subscriptionPutRequestBeta: SubscriptionPutRequestBeta, axiosOptions?: any): AxiosPromise<SubscriptionBeta> {
            return localVarFp.updateSubscription(id, subscriptionPutRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for completeTriggerInvocation operation in TriggersBetaApi.
 * @export
 * @interface TriggersBetaApiCompleteTriggerInvocationRequest
 */
export interface TriggersBetaApiCompleteTriggerInvocationRequest {
    /**
     * The ID of the invocation to complete.
     * @type {string}
     * @memberof TriggersBetaApiCompleteTriggerInvocation
     */
    readonly id: string

    /**
     * 
     * @type {CompleteInvocationBeta}
     * @memberof TriggersBetaApiCompleteTriggerInvocation
     */
    readonly completeInvocationBeta: CompleteInvocationBeta
}

/**
 * Request parameters for createSubscription operation in TriggersBetaApi.
 * @export
 * @interface TriggersBetaApiCreateSubscriptionRequest
 */
export interface TriggersBetaApiCreateSubscriptionRequest {
    /**
     * 
     * @type {SubscriptionPostRequestBeta}
     * @memberof TriggersBetaApiCreateSubscription
     */
    readonly subscriptionPostRequestBeta: SubscriptionPostRequestBeta
}

/**
 * Request parameters for deleteSubscription operation in TriggersBetaApi.
 * @export
 * @interface TriggersBetaApiDeleteSubscriptionRequest
 */
export interface TriggersBetaApiDeleteSubscriptionRequest {
    /**
     * Subscription ID
     * @type {string}
     * @memberof TriggersBetaApiDeleteSubscription
     */
    readonly id: string
}

/**
 * Request parameters for listSubscriptions operation in TriggersBetaApi.
 * @export
 * @interface TriggersBetaApiListSubscriptionsRequest
 */
export interface TriggersBetaApiListSubscriptionsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TriggersBetaApiListSubscriptions
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TriggersBetaApiListSubscriptions
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof TriggersBetaApiListSubscriptions
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*  **triggerId**: *eq*  **type**: *eq*
     * @type {string}
     * @memberof TriggersBetaApiListSubscriptions
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields:  **triggerId** **triggerName**
     * @type {string}
     * @memberof TriggersBetaApiListSubscriptions
     */
    readonly sorters?: string
}

/**
 * Request parameters for listTriggerInvocationStatus operation in TriggersBetaApi.
 * @export
 * @interface TriggersBetaApiListTriggerInvocationStatusRequest
 */
export interface TriggersBetaApiListTriggerInvocationStatusRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TriggersBetaApiListTriggerInvocationStatus
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TriggersBetaApiListTriggerInvocationStatus
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof TriggersBetaApiListTriggerInvocationStatus
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **triggerId**: *eq* **subscriptionId**: *eq*
     * @type {string}
     * @memberof TriggersBetaApiListTriggerInvocationStatus
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields:  **triggerId** **subscriptionName** **created** **completed**
     * @type {string}
     * @memberof TriggersBetaApiListTriggerInvocationStatus
     */
    readonly sorters?: string
}

/**
 * Request parameters for listTriggers operation in TriggersBetaApi.
 * @export
 * @interface TriggersBetaApiListTriggersRequest
 */
export interface TriggersBetaApiListTriggersRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TriggersBetaApiListTriggers
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TriggersBetaApiListTriggers
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof TriggersBetaApiListTriggers
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
     * @type {string}
     * @memberof TriggersBetaApiListTriggers
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields:  **id** **name**
     * @type {string}
     * @memberof TriggersBetaApiListTriggers
     */
    readonly sorters?: string
}

/**
 * Request parameters for patchSubscription operation in TriggersBetaApi.
 * @export
 * @interface TriggersBetaApiPatchSubscriptionRequest
 */
export interface TriggersBetaApiPatchSubscriptionRequest {
    /**
     * ID of the Subscription to patch
     * @type {string}
     * @memberof TriggersBetaApiPatchSubscription
     */
    readonly id: string

    /**
     * 
     * @type {Array<SubscriptionPatchRequestInnerBeta>}
     * @memberof TriggersBetaApiPatchSubscription
     */
    readonly subscriptionPatchRequestInnerBeta: Array<SubscriptionPatchRequestInnerBeta>
}

/**
 * Request parameters for startTestTriggerInvocation operation in TriggersBetaApi.
 * @export
 * @interface TriggersBetaApiStartTestTriggerInvocationRequest
 */
export interface TriggersBetaApiStartTestTriggerInvocationRequest {
    /**
     * 
     * @type {TestInvocationBeta}
     * @memberof TriggersBetaApiStartTestTriggerInvocation
     */
    readonly testInvocationBeta: TestInvocationBeta
}

/**
 * Request parameters for testSubscriptionFilter operation in TriggersBetaApi.
 * @export
 * @interface TriggersBetaApiTestSubscriptionFilterRequest
 */
export interface TriggersBetaApiTestSubscriptionFilterRequest {
    /**
     * 
     * @type {ValidateFilterInputDtoBeta}
     * @memberof TriggersBetaApiTestSubscriptionFilter
     */
    readonly validateFilterInputDtoBeta: ValidateFilterInputDtoBeta
}

/**
 * Request parameters for updateSubscription operation in TriggersBetaApi.
 * @export
 * @interface TriggersBetaApiUpdateSubscriptionRequest
 */
export interface TriggersBetaApiUpdateSubscriptionRequest {
    /**
     * Subscription ID
     * @type {string}
     * @memberof TriggersBetaApiUpdateSubscription
     */
    readonly id: string

    /**
     * 
     * @type {SubscriptionPutRequestBeta}
     * @memberof TriggersBetaApiUpdateSubscription
     */
    readonly subscriptionPutRequestBeta: SubscriptionPutRequestBeta
}

/**
 * TriggersBetaApi - object-oriented interface
 * @export
 * @class TriggersBetaApi
 * @extends {BaseAPI}
 */
export class TriggersBetaApi extends BaseAPI {
    /**
     * Completes an invocation to a REQUEST_RESPONSE type trigger.
     * @summary Complete Trigger Invocation
     * @param {TriggersBetaApiCompleteTriggerInvocationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TriggersBetaApi
     */
    public completeTriggerInvocation(requestParameters: TriggersBetaApiCompleteTriggerInvocationRequest, axiosOptions?: AxiosRequestConfig) {
        return TriggersBetaApiFp(this.configuration).completeTriggerInvocation(requestParameters.id, requestParameters.completeInvocationBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API creates a new subscription to a trigger and defines trigger invocation details. The type of subscription determines which config object is required: * HTTP subscriptions require httpConfig * EventBridge subscriptions require eventBridgeConfig
     * @summary Create a Subscription
     * @param {TriggersBetaApiCreateSubscriptionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TriggersBetaApi
     */
    public createSubscription(requestParameters: TriggersBetaApiCreateSubscriptionRequest, axiosOptions?: AxiosRequestConfig) {
        return TriggersBetaApiFp(this.configuration).createSubscription(requestParameters.subscriptionPostRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an existing subscription to a trigger.
     * @summary Delete a Subscription
     * @param {TriggersBetaApiDeleteSubscriptionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TriggersBetaApi
     */
    public deleteSubscription(requestParameters: TriggersBetaApiDeleteSubscriptionRequest, axiosOptions?: AxiosRequestConfig) {
        return TriggersBetaApiFp(this.configuration).deleteSubscription(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of all trigger subscriptions.
     * @summary List Subscriptions
     * @param {TriggersBetaApiListSubscriptionsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TriggersBetaApi
     */
    public listSubscriptions(requestParameters: TriggersBetaApiListSubscriptionsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return TriggersBetaApiFp(this.configuration).listSubscriptions(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of latest invocation statuses. Statuses of successful invocations are available for up to 24 hours. Statuses of failed invocations are available for up to 48 hours. This endpoint may only fetch up to 2000 invocations, and should not be treated as a representation of the full history of invocations.
     * @summary List Latest Invocation Statuses
     * @param {TriggersBetaApiListTriggerInvocationStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TriggersBetaApi
     */
    public listTriggerInvocationStatus(requestParameters: TriggersBetaApiListTriggerInvocationStatusRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return TriggersBetaApiFp(this.configuration).listTriggerInvocationStatus(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of triggers that are available in the tenant.
     * @summary List Triggers
     * @param {TriggersBetaApiListTriggersRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TriggersBetaApi
     */
    public listTriggers(requestParameters: TriggersBetaApiListTriggersRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return TriggersBetaApiFp(this.configuration).listTriggers(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates a trigger subscription in IdentityNow, using a set of instructions to modify a subscription partially. The following fields are patchable:  **name**, **description**, **enabled**, **type**, **filter**, **responseDeadline**, **httpConfig**, **eventBridgeConfig**, **workflowConfig**
     * @summary Patch a Subscription
     * @param {TriggersBetaApiPatchSubscriptionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TriggersBetaApi
     */
    public patchSubscription(requestParameters: TriggersBetaApiPatchSubscriptionRequest, axiosOptions?: AxiosRequestConfig) {
        return TriggersBetaApiFp(this.configuration).patchSubscription(requestParameters.id, requestParameters.subscriptionPatchRequestInnerBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiate a test event for all subscribers of the specified event trigger.  If there are no subscribers to the specified trigger in the tenant, then no test event will be sent.
     * @summary Start a Test Invocation
     * @param {TriggersBetaApiStartTestTriggerInvocationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TriggersBetaApi
     */
    public startTestTriggerInvocation(requestParameters: TriggersBetaApiStartTestTriggerInvocationRequest, axiosOptions?: AxiosRequestConfig) {
        return TriggersBetaApiFp(this.configuration).startTestTriggerInvocation(requestParameters.testInvocationBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates a JSONPath filter expression against a provided mock input. Request requires a security scope of: 
     * @summary Validate a Subscription Filter
     * @param {TriggersBetaApiTestSubscriptionFilterRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TriggersBetaApi
     */
    public testSubscriptionFilter(requestParameters: TriggersBetaApiTestSubscriptionFilterRequest, axiosOptions?: AxiosRequestConfig) {
        return TriggersBetaApiFp(this.configuration).testSubscriptionFilter(requestParameters.validateFilterInputDtoBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates a trigger subscription in IdentityNow, using a full object representation. In other words, the existing   Subscription is completely replaced. The following fields are immutable:     * id    * triggerId     Attempts to modify these fields result in 400.
     * @summary Update a Subscription
     * @param {TriggersBetaApiUpdateSubscriptionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TriggersBetaApi
     */
    public updateSubscription(requestParameters: TriggersBetaApiUpdateSubscriptionRequest, axiosOptions?: AxiosRequestConfig) {
        return TriggersBetaApiFp(this.configuration).updateSubscription(requestParameters.id, requestParameters.subscriptionPutRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkItemsBetaApi - axios parameter creator
 * @export
 */
export const WorkItemsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API approves an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Approve an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveApprovalItem: async (id: string, approvalItemId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('approveApprovalItem', 'id', id)
            // verify required parameter 'approvalItemId' is not null or undefined
            assertParamExists('approveApprovalItem', 'approvalItemId', approvalItemId)
            const localVarPath = `/work-items/{id}/approve/{approvalItemId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"approvalItemId"}}`, encodeURIComponent(String(approvalItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API bulk approves Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk approve Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveApprovalItemsInBulk: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('approveApprovalItemsInBulk', 'id', id)
            const localVarPath = `/work-items/bulk-approve/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API completes a work item. Either an admin, or the owning/current user must make this request.
         * @summary Complete a Work Item
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        completeWorkItem: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('completeWorkItem', 'id', id)
            const localVarPath = `/work-items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API forwards a work item to a new owner. Either an admin, or the owning/current user must make this request.
         * @summary Forward a Work Item
         * @param {string} id The ID of the work item
         * @param {WorkItemForwardBeta} workItemForwardBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        forwardWorkItem: async (id: string, workItemForwardBeta: WorkItemForwardBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('forwardWorkItem', 'id', id)
            // verify required parameter 'workItemForwardBeta' is not null or undefined
            assertParamExists('forwardWorkItem', 'workItemForwardBeta', workItemForwardBeta)
            const localVarPath = `/work-items/{id}/forward`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workItemForwardBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a collection of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Completed Work Items
         * @param {string} [ownerId] The id of the owner of the work item list being requested.  Either an admin, or the owning/current user must make this request.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCompletedWorkItems: async (ownerId?: string, limit?: number, offset?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work-items/completed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a count of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Completed Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCountCompletedWorkItems: async (ownerId?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work-items/count/completed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a count of work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCountWorkItems: async (ownerId?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work-items/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets the details of a Work Item belonging to either the specified user(admin required), or the current user.
         * @summary Get a Work Item
         * @param {string} id ID of the work item.
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItem: async (id: string, ownerId?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWorkItem', 'id', id)
            const localVarPath = `/work-items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a summary of work items belonging to either the specified user(admin required), or the current user.
         * @summary Work Items Summary
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItemsSummary: async (ownerId?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work-items/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a collection of work items belonging to either the specified user(admin required), or the current user.
         * @summary List Work Items
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkItems: async (limit?: number, offset?: number, count?: boolean, ownerId?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work-items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API rejects an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Reject an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectApprovalItem: async (id: string, approvalItemId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rejectApprovalItem', 'id', id)
            // verify required parameter 'approvalItemId' is not null or undefined
            assertParamExists('rejectApprovalItem', 'approvalItemId', approvalItemId)
            const localVarPath = `/work-items/{id}/reject/{approvalItemId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"approvalItemId"}}`, encodeURIComponent(String(approvalItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API bulk rejects Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk reject Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectApprovalItemsInBulk: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rejectApprovalItemsInBulk', 'id', id)
            const localVarPath = `/work-items/bulk-reject/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits account selections. Either an admin, or the owning/current user must make this request.
         * @summary Submit Account Selections
         * @param {string} id The ID of the work item
         * @param {{ [key: string]: any; }} requestBody Account Selection Data map, keyed on fieldName
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        submitAccountSelection: async (id: string, requestBody: { [key: string]: any; }, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submitAccountSelection', 'id', id)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('submitAccountSelection', 'requestBody', requestBody)
            const localVarPath = `/work-items/{id}/submit-account-selection`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkItemsBetaApi - functional programming interface
 * @export
 */
export const WorkItemsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkItemsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * This API approves an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Approve an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async approveApprovalItem(id: string, approvalItemId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItemsBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveApprovalItem(id, approvalItemId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API bulk approves Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk approve Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async approveApprovalItemsInBulk(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItemsBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveApprovalItemsInBulk(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API completes a work item. Either an admin, or the owning/current user must make this request.
         * @summary Complete a Work Item
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async completeWorkItem(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItemsBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeWorkItem(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API forwards a work item to a new owner. Either an admin, or the owning/current user must make this request.
         * @summary Forward a Work Item
         * @param {string} id The ID of the work item
         * @param {WorkItemForwardBeta} workItemForwardBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async forwardWorkItem(id: string, workItemForwardBeta: WorkItemForwardBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forwardWorkItem(id, workItemForwardBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a collection of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Completed Work Items
         * @param {string} [ownerId] The id of the owner of the work item list being requested.  Either an admin, or the owning/current user must make this request.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCompletedWorkItems(ownerId?: string, limit?: number, offset?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkItemsBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompletedWorkItems(ownerId, limit, offset, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a count of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Completed Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCountCompletedWorkItems(ownerId?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkItemsCountBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCountCompletedWorkItems(ownerId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a count of work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCountWorkItems(ownerId?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkItemsCountBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCountWorkItems(ownerId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets the details of a Work Item belonging to either the specified user(admin required), or the current user.
         * @summary Get a Work Item
         * @param {string} id ID of the work item.
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkItem(id: string, ownerId?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkItemsBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkItem(id, ownerId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a summary of work items belonging to either the specified user(admin required), or the current user.
         * @summary Work Items Summary
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkItemsSummary(ownerId?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkItemsSummaryBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkItemsSummary(ownerId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a collection of work items belonging to either the specified user(admin required), or the current user.
         * @summary List Work Items
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkItems(limit?: number, offset?: number, count?: boolean, ownerId?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkItemsBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkItems(limit, offset, count, ownerId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API rejects an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Reject an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async rejectApprovalItem(id: string, approvalItemId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItemsBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectApprovalItem(id, approvalItemId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API bulk rejects Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk reject Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async rejectApprovalItemsInBulk(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItemsBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectApprovalItemsInBulk(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API submits account selections. Either an admin, or the owning/current user must make this request.
         * @summary Submit Account Selections
         * @param {string} id The ID of the work item
         * @param {{ [key: string]: any; }} requestBody Account Selection Data map, keyed on fieldName
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async submitAccountSelection(id: string, requestBody: { [key: string]: any; }, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItemsBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitAccountSelection(id, requestBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkItemsBetaApi - factory interface
 * @export
 */
export const WorkItemsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkItemsBetaApiFp(configuration)
    return {
        /**
         * This API approves an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Approve an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveApprovalItem(id: string, approvalItemId: string, axiosOptions?: any): AxiosPromise<WorkItemsBeta> {
            return localVarFp.approveApprovalItem(id, approvalItemId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API bulk approves Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk approve Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveApprovalItemsInBulk(id: string, axiosOptions?: any): AxiosPromise<WorkItemsBeta> {
            return localVarFp.approveApprovalItemsInBulk(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API completes a work item. Either an admin, or the owning/current user must make this request.
         * @summary Complete a Work Item
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        completeWorkItem(id: string, axiosOptions?: any): AxiosPromise<WorkItemsBeta> {
            return localVarFp.completeWorkItem(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API forwards a work item to a new owner. Either an admin, or the owning/current user must make this request.
         * @summary Forward a Work Item
         * @param {string} id The ID of the work item
         * @param {WorkItemForwardBeta} workItemForwardBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        forwardWorkItem(id: string, workItemForwardBeta: WorkItemForwardBeta, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.forwardWorkItem(id, workItemForwardBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a collection of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Completed Work Items
         * @param {string} [ownerId] The id of the owner of the work item list being requested.  Either an admin, or the owning/current user must make this request.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCompletedWorkItems(ownerId?: string, limit?: number, offset?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<WorkItemsBeta>> {
            return localVarFp.getCompletedWorkItems(ownerId, limit, offset, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a count of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Completed Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCountCompletedWorkItems(ownerId?: string, axiosOptions?: any): AxiosPromise<Array<WorkItemsCountBeta>> {
            return localVarFp.getCountCompletedWorkItems(ownerId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a count of work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCountWorkItems(ownerId?: string, axiosOptions?: any): AxiosPromise<Array<WorkItemsCountBeta>> {
            return localVarFp.getCountWorkItems(ownerId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets the details of a Work Item belonging to either the specified user(admin required), or the current user.
         * @summary Get a Work Item
         * @param {string} id ID of the work item.
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItem(id: string, ownerId?: string, axiosOptions?: any): AxiosPromise<Array<WorkItemsBeta>> {
            return localVarFp.getWorkItem(id, ownerId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a summary of work items belonging to either the specified user(admin required), or the current user.
         * @summary Work Items Summary
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItemsSummary(ownerId?: string, axiosOptions?: any): AxiosPromise<Array<WorkItemsSummaryBeta>> {
            return localVarFp.getWorkItemsSummary(ownerId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a collection of work items belonging to either the specified user(admin required), or the current user.
         * @summary List Work Items
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkItems(limit?: number, offset?: number, count?: boolean, ownerId?: string, axiosOptions?: any): AxiosPromise<Array<WorkItemsBeta>> {
            return localVarFp.listWorkItems(limit, offset, count, ownerId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API rejects an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Reject an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectApprovalItem(id: string, approvalItemId: string, axiosOptions?: any): AxiosPromise<WorkItemsBeta> {
            return localVarFp.rejectApprovalItem(id, approvalItemId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API bulk rejects Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk reject Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectApprovalItemsInBulk(id: string, axiosOptions?: any): AxiosPromise<WorkItemsBeta> {
            return localVarFp.rejectApprovalItemsInBulk(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API submits account selections. Either an admin, or the owning/current user must make this request.
         * @summary Submit Account Selections
         * @param {string} id The ID of the work item
         * @param {{ [key: string]: any; }} requestBody Account Selection Data map, keyed on fieldName
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        submitAccountSelection(id: string, requestBody: { [key: string]: any; }, axiosOptions?: any): AxiosPromise<WorkItemsBeta> {
            return localVarFp.submitAccountSelection(id, requestBody, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for approveApprovalItem operation in WorkItemsBetaApi.
 * @export
 * @interface WorkItemsBetaApiApproveApprovalItemRequest
 */
export interface WorkItemsBetaApiApproveApprovalItemRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsBetaApiApproveApprovalItem
     */
    readonly id: string

    /**
     * The ID of the approval item.
     * @type {string}
     * @memberof WorkItemsBetaApiApproveApprovalItem
     */
    readonly approvalItemId: string
}

/**
 * Request parameters for approveApprovalItemsInBulk operation in WorkItemsBetaApi.
 * @export
 * @interface WorkItemsBetaApiApproveApprovalItemsInBulkRequest
 */
export interface WorkItemsBetaApiApproveApprovalItemsInBulkRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsBetaApiApproveApprovalItemsInBulk
     */
    readonly id: string
}

/**
 * Request parameters for completeWorkItem operation in WorkItemsBetaApi.
 * @export
 * @interface WorkItemsBetaApiCompleteWorkItemRequest
 */
export interface WorkItemsBetaApiCompleteWorkItemRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsBetaApiCompleteWorkItem
     */
    readonly id: string
}

/**
 * Request parameters for forwardWorkItem operation in WorkItemsBetaApi.
 * @export
 * @interface WorkItemsBetaApiForwardWorkItemRequest
 */
export interface WorkItemsBetaApiForwardWorkItemRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsBetaApiForwardWorkItem
     */
    readonly id: string

    /**
     * 
     * @type {WorkItemForwardBeta}
     * @memberof WorkItemsBetaApiForwardWorkItem
     */
    readonly workItemForwardBeta: WorkItemForwardBeta
}

/**
 * Request parameters for getCompletedWorkItems operation in WorkItemsBetaApi.
 * @export
 * @interface WorkItemsBetaApiGetCompletedWorkItemsRequest
 */
export interface WorkItemsBetaApiGetCompletedWorkItemsRequest {
    /**
     * The id of the owner of the work item list being requested.  Either an admin, or the owning/current user must make this request.
     * @type {string}
     * @memberof WorkItemsBetaApiGetCompletedWorkItems
     */
    readonly ownerId?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkItemsBetaApiGetCompletedWorkItems
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkItemsBetaApiGetCompletedWorkItems
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof WorkItemsBetaApiGetCompletedWorkItems
     */
    readonly count?: boolean
}

/**
 * Request parameters for getCountCompletedWorkItems operation in WorkItemsBetaApi.
 * @export
 * @interface WorkItemsBetaApiGetCountCompletedWorkItemsRequest
 */
export interface WorkItemsBetaApiGetCountCompletedWorkItemsRequest {
    /**
     * ID of the work item owner.
     * @type {string}
     * @memberof WorkItemsBetaApiGetCountCompletedWorkItems
     */
    readonly ownerId?: string
}

/**
 * Request parameters for getCountWorkItems operation in WorkItemsBetaApi.
 * @export
 * @interface WorkItemsBetaApiGetCountWorkItemsRequest
 */
export interface WorkItemsBetaApiGetCountWorkItemsRequest {
    /**
     * ID of the work item owner.
     * @type {string}
     * @memberof WorkItemsBetaApiGetCountWorkItems
     */
    readonly ownerId?: string
}

/**
 * Request parameters for getWorkItem operation in WorkItemsBetaApi.
 * @export
 * @interface WorkItemsBetaApiGetWorkItemRequest
 */
export interface WorkItemsBetaApiGetWorkItemRequest {
    /**
     * ID of the work item.
     * @type {string}
     * @memberof WorkItemsBetaApiGetWorkItem
     */
    readonly id: string

    /**
     * ID of the work item owner.
     * @type {string}
     * @memberof WorkItemsBetaApiGetWorkItem
     */
    readonly ownerId?: string
}

/**
 * Request parameters for getWorkItemsSummary operation in WorkItemsBetaApi.
 * @export
 * @interface WorkItemsBetaApiGetWorkItemsSummaryRequest
 */
export interface WorkItemsBetaApiGetWorkItemsSummaryRequest {
    /**
     * ID of the work item owner.
     * @type {string}
     * @memberof WorkItemsBetaApiGetWorkItemsSummary
     */
    readonly ownerId?: string
}

/**
 * Request parameters for listWorkItems operation in WorkItemsBetaApi.
 * @export
 * @interface WorkItemsBetaApiListWorkItemsRequest
 */
export interface WorkItemsBetaApiListWorkItemsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkItemsBetaApiListWorkItems
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkItemsBetaApiListWorkItems
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof WorkItemsBetaApiListWorkItems
     */
    readonly count?: boolean

    /**
     * ID of the work item owner.
     * @type {string}
     * @memberof WorkItemsBetaApiListWorkItems
     */
    readonly ownerId?: string
}

/**
 * Request parameters for rejectApprovalItem operation in WorkItemsBetaApi.
 * @export
 * @interface WorkItemsBetaApiRejectApprovalItemRequest
 */
export interface WorkItemsBetaApiRejectApprovalItemRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsBetaApiRejectApprovalItem
     */
    readonly id: string

    /**
     * The ID of the approval item.
     * @type {string}
     * @memberof WorkItemsBetaApiRejectApprovalItem
     */
    readonly approvalItemId: string
}

/**
 * Request parameters for rejectApprovalItemsInBulk operation in WorkItemsBetaApi.
 * @export
 * @interface WorkItemsBetaApiRejectApprovalItemsInBulkRequest
 */
export interface WorkItemsBetaApiRejectApprovalItemsInBulkRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsBetaApiRejectApprovalItemsInBulk
     */
    readonly id: string
}

/**
 * Request parameters for submitAccountSelection operation in WorkItemsBetaApi.
 * @export
 * @interface WorkItemsBetaApiSubmitAccountSelectionRequest
 */
export interface WorkItemsBetaApiSubmitAccountSelectionRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsBetaApiSubmitAccountSelection
     */
    readonly id: string

    /**
     * Account Selection Data map, keyed on fieldName
     * @type {{ [key: string]: any; }}
     * @memberof WorkItemsBetaApiSubmitAccountSelection
     */
    readonly requestBody: { [key: string]: any; }
}

/**
 * WorkItemsBetaApi - object-oriented interface
 * @export
 * @class WorkItemsBetaApi
 * @extends {BaseAPI}
 */
export class WorkItemsBetaApi extends BaseAPI {
    /**
     * This API approves an Approval Item. Either an admin, or the owning/current user must make this request.
     * @summary Approve an Approval Item
     * @param {WorkItemsBetaApiApproveApprovalItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsBetaApi
     */
    public approveApprovalItem(requestParameters: WorkItemsBetaApiApproveApprovalItemRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsBetaApiFp(this.configuration).approveApprovalItem(requestParameters.id, requestParameters.approvalItemId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API bulk approves Approval Items. Either an admin, or the owning/current user must make this request.
     * @summary Bulk approve Approval Items
     * @param {WorkItemsBetaApiApproveApprovalItemsInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsBetaApi
     */
    public approveApprovalItemsInBulk(requestParameters: WorkItemsBetaApiApproveApprovalItemsInBulkRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsBetaApiFp(this.configuration).approveApprovalItemsInBulk(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API completes a work item. Either an admin, or the owning/current user must make this request.
     * @summary Complete a Work Item
     * @param {WorkItemsBetaApiCompleteWorkItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsBetaApi
     */
    public completeWorkItem(requestParameters: WorkItemsBetaApiCompleteWorkItemRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsBetaApiFp(this.configuration).completeWorkItem(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API forwards a work item to a new owner. Either an admin, or the owning/current user must make this request.
     * @summary Forward a Work Item
     * @param {WorkItemsBetaApiForwardWorkItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsBetaApi
     */
    public forwardWorkItem(requestParameters: WorkItemsBetaApiForwardWorkItemRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsBetaApiFp(this.configuration).forwardWorkItem(requestParameters.id, requestParameters.workItemForwardBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a collection of completed work items belonging to either the specified user(admin required), or the current user.
     * @summary Completed Work Items
     * @param {WorkItemsBetaApiGetCompletedWorkItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsBetaApi
     */
    public getCompletedWorkItems(requestParameters: WorkItemsBetaApiGetCompletedWorkItemsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsBetaApiFp(this.configuration).getCompletedWorkItems(requestParameters.ownerId, requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a count of completed work items belonging to either the specified user(admin required), or the current user.
     * @summary Count Completed Work Items
     * @param {WorkItemsBetaApiGetCountCompletedWorkItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsBetaApi
     */
    public getCountCompletedWorkItems(requestParameters: WorkItemsBetaApiGetCountCompletedWorkItemsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsBetaApiFp(this.configuration).getCountCompletedWorkItems(requestParameters.ownerId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a count of work items belonging to either the specified user(admin required), or the current user.
     * @summary Count Work Items
     * @param {WorkItemsBetaApiGetCountWorkItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsBetaApi
     */
    public getCountWorkItems(requestParameters: WorkItemsBetaApiGetCountWorkItemsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsBetaApiFp(this.configuration).getCountWorkItems(requestParameters.ownerId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets the details of a Work Item belonging to either the specified user(admin required), or the current user.
     * @summary Get a Work Item
     * @param {WorkItemsBetaApiGetWorkItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsBetaApi
     */
    public getWorkItem(requestParameters: WorkItemsBetaApiGetWorkItemRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsBetaApiFp(this.configuration).getWorkItem(requestParameters.id, requestParameters.ownerId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a summary of work items belonging to either the specified user(admin required), or the current user.
     * @summary Work Items Summary
     * @param {WorkItemsBetaApiGetWorkItemsSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsBetaApi
     */
    public getWorkItemsSummary(requestParameters: WorkItemsBetaApiGetWorkItemsSummaryRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsBetaApiFp(this.configuration).getWorkItemsSummary(requestParameters.ownerId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a collection of work items belonging to either the specified user(admin required), or the current user.
     * @summary List Work Items
     * @param {WorkItemsBetaApiListWorkItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsBetaApi
     */
    public listWorkItems(requestParameters: WorkItemsBetaApiListWorkItemsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsBetaApiFp(this.configuration).listWorkItems(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.ownerId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API rejects an Approval Item. Either an admin, or the owning/current user must make this request.
     * @summary Reject an Approval Item
     * @param {WorkItemsBetaApiRejectApprovalItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsBetaApi
     */
    public rejectApprovalItem(requestParameters: WorkItemsBetaApiRejectApprovalItemRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsBetaApiFp(this.configuration).rejectApprovalItem(requestParameters.id, requestParameters.approvalItemId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API bulk rejects Approval Items. Either an admin, or the owning/current user must make this request.
     * @summary Bulk reject Approval Items
     * @param {WorkItemsBetaApiRejectApprovalItemsInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsBetaApi
     */
    public rejectApprovalItemsInBulk(requestParameters: WorkItemsBetaApiRejectApprovalItemsInBulkRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsBetaApiFp(this.configuration).rejectApprovalItemsInBulk(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits account selections. Either an admin, or the owning/current user must make this request.
     * @summary Submit Account Selections
     * @param {WorkItemsBetaApiSubmitAccountSelectionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsBetaApi
     */
    public submitAccountSelection(requestParameters: WorkItemsBetaApiSubmitAccountSelectionRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsBetaApiFp(this.configuration).submitAccountSelection(requestParameters.id, requestParameters.requestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkReassignmentBetaApi - axios parameter creator
 * @export
 */
export const WorkReassignmentBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new Reassignment Configuration for the specified identity.
         * @summary Create a Reassignment Configuration
         * @param {ConfigurationItemRequestBeta} configurationItemRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createReassignmentConfiguration: async (configurationItemRequestBeta: ConfigurationItemRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'configurationItemRequestBeta' is not null or undefined
            assertParamExists('createReassignmentConfiguration', 'configurationItemRequestBeta', configurationItemRequestBeta)
            const localVarPath = `/reassignment-configurations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(configurationItemRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes all Reassignment Configuration for the specified identity
         * @summary Delete Reassignment Configuration
         * @param {string} identityId unique identity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteReassignmentConfiguration: async (identityId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('deleteReassignmentConfiguration', 'identityId', identityId)
            const localVarPath = `/reassignment-configurations/{identityId}`
                .replace(`{${"identityId"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Evaluates the Reassignment Configuration for an `Identity` to determine if work items for the specified type should be reassigned. If a valid Reassignment Configuration is found for the identity & work type, then a lookup is initiated which recursively fetches the Reassignment Configuration for the next `TargetIdentity` until no more results are found or a max depth of 5. That lookup trail is provided in the response and the final reassigned identity in the lookup list is returned as the `reassignToId` property. If no Reassignment Configuration is found for the specified identity & config type then the requested Identity ID will be used as the `reassignToId` value and the lookupTrail node will be empty.
         * @summary Evaluate Reassignment Configuration
         * @param {string} identityId unique identity id
         * @param {ConfigTypeEnumBeta} configType Reassignment work type
         * @param {Array<string>} [exclusionFilters] Exclusion filters that disable parts of the reassignment evaluation. Possible values are listed below: - &#x60;SELF_REVIEW_DELEGATION&#x60;: This will exclude delegations of self-review reassignments
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluateReassignmentConfiguration: async (identityId: string, configType: ConfigTypeEnumBeta, exclusionFilters?: Array<string>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getEvaluateReassignmentConfiguration', 'identityId', identityId)
            // verify required parameter 'configType' is not null or undefined
            assertParamExists('getEvaluateReassignmentConfiguration', 'configType', configType)
            const localVarPath = `/reassignment-configurations/{identityId}/evaluate/{configType}`
                .replace(`{${"identityId"}}`, encodeURIComponent(String(identityId)))
                .replace(`{${"configType"}}`, encodeURIComponent(String(configType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (exclusionFilters) {
                localVarQueryParameter['exclusionFilters'] = exclusionFilters.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Gets a collection of types which are available in the Reassignment Configuration UI.
         * @summary List Reassignment Config Types
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getReassignmentConfigTypes: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reassignment-configurations/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Gets the Reassignment Configuration for an identity.
         * @summary Get Reassignment Configuration
         * @param {string} identityId unique identity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getReassignmentConfiguration: async (identityId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getReassignmentConfiguration', 'identityId', identityId)
            const localVarPath = `/reassignment-configurations/{identityId}`
                .replace(`{${"identityId"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Gets the global Reassignment Configuration settings for the requestor\'s tenant.
         * @summary Get Tenant-wide Reassignment Configuration settings
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTenantConfigConfiguration: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reassignment-configurations/tenant-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Gets all Reassignment configuration for the current org.
         * @summary List Reassignment Configurations
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listReassignmentConfigurations: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reassignment-configurations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Replaces existing Reassignment configuration for an identity with the newly provided configuration.
         * @summary Update Reassignment Configuration
         * @param {string} identityId unique identity id
         * @param {ConfigurationItemRequestBeta} configurationItemRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putReassignmentConfig: async (identityId: string, configurationItemRequestBeta: ConfigurationItemRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('putReassignmentConfig', 'identityId', identityId)
            // verify required parameter 'configurationItemRequestBeta' is not null or undefined
            assertParamExists('putReassignmentConfig', 'configurationItemRequestBeta', configurationItemRequestBeta)
            const localVarPath = `/reassignment-configurations/{identityId}`
                .replace(`{${"identityId"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(configurationItemRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Replaces existing Tenant-wide Reassignment Configuration settings with the newly provided settings.
         * @summary Update Tenant-wide Reassignment Configuration settings
         * @param {TenantConfigurationRequestBeta} tenantConfigurationRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putTenantConfiguration: async (tenantConfigurationRequestBeta: TenantConfigurationRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantConfigurationRequestBeta' is not null or undefined
            assertParamExists('putTenantConfiguration', 'tenantConfigurationRequestBeta', tenantConfigurationRequestBeta)
            const localVarPath = `/reassignment-configurations/tenant-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tenantConfigurationRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkReassignmentBetaApi - functional programming interface
 * @export
 */
export const WorkReassignmentBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkReassignmentBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new Reassignment Configuration for the specified identity.
         * @summary Create a Reassignment Configuration
         * @param {ConfigurationItemRequestBeta} configurationItemRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createReassignmentConfiguration(configurationItemRequestBeta: ConfigurationItemRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigurationItemResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReassignmentConfiguration(configurationItemRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes all Reassignment Configuration for the specified identity
         * @summary Delete Reassignment Configuration
         * @param {string} identityId unique identity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReassignmentConfiguration(identityId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReassignmentConfiguration(identityId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Evaluates the Reassignment Configuration for an `Identity` to determine if work items for the specified type should be reassigned. If a valid Reassignment Configuration is found for the identity & work type, then a lookup is initiated which recursively fetches the Reassignment Configuration for the next `TargetIdentity` until no more results are found or a max depth of 5. That lookup trail is provided in the response and the final reassigned identity in the lookup list is returned as the `reassignToId` property. If no Reassignment Configuration is found for the specified identity & config type then the requested Identity ID will be used as the `reassignToId` value and the lookupTrail node will be empty.
         * @summary Evaluate Reassignment Configuration
         * @param {string} identityId unique identity id
         * @param {ConfigTypeEnumBeta} configType Reassignment work type
         * @param {Array<string>} [exclusionFilters] Exclusion filters that disable parts of the reassignment evaluation. Possible values are listed below: - &#x60;SELF_REVIEW_DELEGATION&#x60;: This will exclude delegations of self-review reassignments
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getEvaluateReassignmentConfiguration(identityId: string, configType: ConfigTypeEnumBeta, exclusionFilters?: Array<string>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EvaluateResponseBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvaluateReassignmentConfiguration(identityId, configType, exclusionFilters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a collection of types which are available in the Reassignment Configuration UI.
         * @summary List Reassignment Config Types
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getReassignmentConfigTypes(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConfigTypeBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReassignmentConfigTypes(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the Reassignment Configuration for an identity.
         * @summary Get Reassignment Configuration
         * @param {string} identityId unique identity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getReassignmentConfiguration(identityId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigurationResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReassignmentConfiguration(identityId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the global Reassignment Configuration settings for the requestor\'s tenant.
         * @summary Get Tenant-wide Reassignment Configuration settings
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getTenantConfigConfiguration(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantConfigurationResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTenantConfigConfiguration(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets all Reassignment configuration for the current org.
         * @summary List Reassignment Configurations
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listReassignmentConfigurations(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConfigurationResponseBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listReassignmentConfigurations(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replaces existing Reassignment configuration for an identity with the newly provided configuration.
         * @summary Update Reassignment Configuration
         * @param {string} identityId unique identity id
         * @param {ConfigurationItemRequestBeta} configurationItemRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putReassignmentConfig(identityId: string, configurationItemRequestBeta: ConfigurationItemRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigurationItemResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putReassignmentConfig(identityId, configurationItemRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replaces existing Tenant-wide Reassignment Configuration settings with the newly provided settings.
         * @summary Update Tenant-wide Reassignment Configuration settings
         * @param {TenantConfigurationRequestBeta} tenantConfigurationRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putTenantConfiguration(tenantConfigurationRequestBeta: TenantConfigurationRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantConfigurationResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putTenantConfiguration(tenantConfigurationRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkReassignmentBetaApi - factory interface
 * @export
 */
export const WorkReassignmentBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkReassignmentBetaApiFp(configuration)
    return {
        /**
         * Creates a new Reassignment Configuration for the specified identity.
         * @summary Create a Reassignment Configuration
         * @param {ConfigurationItemRequestBeta} configurationItemRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createReassignmentConfiguration(configurationItemRequestBeta: ConfigurationItemRequestBeta, axiosOptions?: any): AxiosPromise<ConfigurationItemResponseBeta> {
            return localVarFp.createReassignmentConfiguration(configurationItemRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Deletes all Reassignment Configuration for the specified identity
         * @summary Delete Reassignment Configuration
         * @param {string} identityId unique identity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteReassignmentConfiguration(identityId: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteReassignmentConfiguration(identityId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Evaluates the Reassignment Configuration for an `Identity` to determine if work items for the specified type should be reassigned. If a valid Reassignment Configuration is found for the identity & work type, then a lookup is initiated which recursively fetches the Reassignment Configuration for the next `TargetIdentity` until no more results are found or a max depth of 5. That lookup trail is provided in the response and the final reassigned identity in the lookup list is returned as the `reassignToId` property. If no Reassignment Configuration is found for the specified identity & config type then the requested Identity ID will be used as the `reassignToId` value and the lookupTrail node will be empty.
         * @summary Evaluate Reassignment Configuration
         * @param {string} identityId unique identity id
         * @param {ConfigTypeEnumBeta} configType Reassignment work type
         * @param {Array<string>} [exclusionFilters] Exclusion filters that disable parts of the reassignment evaluation. Possible values are listed below: - &#x60;SELF_REVIEW_DELEGATION&#x60;: This will exclude delegations of self-review reassignments
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluateReassignmentConfiguration(identityId: string, configType: ConfigTypeEnumBeta, exclusionFilters?: Array<string>, axiosOptions?: any): AxiosPromise<Array<EvaluateResponseBeta>> {
            return localVarFp.getEvaluateReassignmentConfiguration(identityId, configType, exclusionFilters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Gets a collection of types which are available in the Reassignment Configuration UI.
         * @summary List Reassignment Config Types
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getReassignmentConfigTypes(axiosOptions?: any): AxiosPromise<Array<ConfigTypeBeta>> {
            return localVarFp.getReassignmentConfigTypes(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Gets the Reassignment Configuration for an identity.
         * @summary Get Reassignment Configuration
         * @param {string} identityId unique identity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getReassignmentConfiguration(identityId: string, axiosOptions?: any): AxiosPromise<ConfigurationResponseBeta> {
            return localVarFp.getReassignmentConfiguration(identityId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Gets the global Reassignment Configuration settings for the requestor\'s tenant.
         * @summary Get Tenant-wide Reassignment Configuration settings
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTenantConfigConfiguration(axiosOptions?: any): AxiosPromise<TenantConfigurationResponseBeta> {
            return localVarFp.getTenantConfigConfiguration(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Gets all Reassignment configuration for the current org.
         * @summary List Reassignment Configurations
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listReassignmentConfigurations(axiosOptions?: any): AxiosPromise<Array<ConfigurationResponseBeta>> {
            return localVarFp.listReassignmentConfigurations(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Replaces existing Reassignment configuration for an identity with the newly provided configuration.
         * @summary Update Reassignment Configuration
         * @param {string} identityId unique identity id
         * @param {ConfigurationItemRequestBeta} configurationItemRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putReassignmentConfig(identityId: string, configurationItemRequestBeta: ConfigurationItemRequestBeta, axiosOptions?: any): AxiosPromise<ConfigurationItemResponseBeta> {
            return localVarFp.putReassignmentConfig(identityId, configurationItemRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Replaces existing Tenant-wide Reassignment Configuration settings with the newly provided settings.
         * @summary Update Tenant-wide Reassignment Configuration settings
         * @param {TenantConfigurationRequestBeta} tenantConfigurationRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putTenantConfiguration(tenantConfigurationRequestBeta: TenantConfigurationRequestBeta, axiosOptions?: any): AxiosPromise<TenantConfigurationResponseBeta> {
            return localVarFp.putTenantConfiguration(tenantConfigurationRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createReassignmentConfiguration operation in WorkReassignmentBetaApi.
 * @export
 * @interface WorkReassignmentBetaApiCreateReassignmentConfigurationRequest
 */
export interface WorkReassignmentBetaApiCreateReassignmentConfigurationRequest {
    /**
     * 
     * @type {ConfigurationItemRequestBeta}
     * @memberof WorkReassignmentBetaApiCreateReassignmentConfiguration
     */
    readonly configurationItemRequestBeta: ConfigurationItemRequestBeta
}

/**
 * Request parameters for deleteReassignmentConfiguration operation in WorkReassignmentBetaApi.
 * @export
 * @interface WorkReassignmentBetaApiDeleteReassignmentConfigurationRequest
 */
export interface WorkReassignmentBetaApiDeleteReassignmentConfigurationRequest {
    /**
     * unique identity id
     * @type {string}
     * @memberof WorkReassignmentBetaApiDeleteReassignmentConfiguration
     */
    readonly identityId: string
}

/**
 * Request parameters for getEvaluateReassignmentConfiguration operation in WorkReassignmentBetaApi.
 * @export
 * @interface WorkReassignmentBetaApiGetEvaluateReassignmentConfigurationRequest
 */
export interface WorkReassignmentBetaApiGetEvaluateReassignmentConfigurationRequest {
    /**
     * unique identity id
     * @type {string}
     * @memberof WorkReassignmentBetaApiGetEvaluateReassignmentConfiguration
     */
    readonly identityId: string

    /**
     * Reassignment work type
     * @type {ConfigTypeEnumBeta}
     * @memberof WorkReassignmentBetaApiGetEvaluateReassignmentConfiguration
     */
    readonly configType: ConfigTypeEnumBeta

    /**
     * Exclusion filters that disable parts of the reassignment evaluation. Possible values are listed below: - &#x60;SELF_REVIEW_DELEGATION&#x60;: This will exclude delegations of self-review reassignments
     * @type {Array<string>}
     * @memberof WorkReassignmentBetaApiGetEvaluateReassignmentConfiguration
     */
    readonly exclusionFilters?: Array<string>
}

/**
 * Request parameters for getReassignmentConfiguration operation in WorkReassignmentBetaApi.
 * @export
 * @interface WorkReassignmentBetaApiGetReassignmentConfigurationRequest
 */
export interface WorkReassignmentBetaApiGetReassignmentConfigurationRequest {
    /**
     * unique identity id
     * @type {string}
     * @memberof WorkReassignmentBetaApiGetReassignmentConfiguration
     */
    readonly identityId: string
}

/**
 * Request parameters for putReassignmentConfig operation in WorkReassignmentBetaApi.
 * @export
 * @interface WorkReassignmentBetaApiPutReassignmentConfigRequest
 */
export interface WorkReassignmentBetaApiPutReassignmentConfigRequest {
    /**
     * unique identity id
     * @type {string}
     * @memberof WorkReassignmentBetaApiPutReassignmentConfig
     */
    readonly identityId: string

    /**
     * 
     * @type {ConfigurationItemRequestBeta}
     * @memberof WorkReassignmentBetaApiPutReassignmentConfig
     */
    readonly configurationItemRequestBeta: ConfigurationItemRequestBeta
}

/**
 * Request parameters for putTenantConfiguration operation in WorkReassignmentBetaApi.
 * @export
 * @interface WorkReassignmentBetaApiPutTenantConfigurationRequest
 */
export interface WorkReassignmentBetaApiPutTenantConfigurationRequest {
    /**
     * 
     * @type {TenantConfigurationRequestBeta}
     * @memberof WorkReassignmentBetaApiPutTenantConfiguration
     */
    readonly tenantConfigurationRequestBeta: TenantConfigurationRequestBeta
}

/**
 * WorkReassignmentBetaApi - object-oriented interface
 * @export
 * @class WorkReassignmentBetaApi
 * @extends {BaseAPI}
 */
export class WorkReassignmentBetaApi extends BaseAPI {
    /**
     * Creates a new Reassignment Configuration for the specified identity.
     * @summary Create a Reassignment Configuration
     * @param {WorkReassignmentBetaApiCreateReassignmentConfigurationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkReassignmentBetaApi
     */
    public createReassignmentConfiguration(requestParameters: WorkReassignmentBetaApiCreateReassignmentConfigurationRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkReassignmentBetaApiFp(this.configuration).createReassignmentConfiguration(requestParameters.configurationItemRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes all Reassignment Configuration for the specified identity
     * @summary Delete Reassignment Configuration
     * @param {WorkReassignmentBetaApiDeleteReassignmentConfigurationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkReassignmentBetaApi
     */
    public deleteReassignmentConfiguration(requestParameters: WorkReassignmentBetaApiDeleteReassignmentConfigurationRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkReassignmentBetaApiFp(this.configuration).deleteReassignmentConfiguration(requestParameters.identityId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Evaluates the Reassignment Configuration for an `Identity` to determine if work items for the specified type should be reassigned. If a valid Reassignment Configuration is found for the identity & work type, then a lookup is initiated which recursively fetches the Reassignment Configuration for the next `TargetIdentity` until no more results are found or a max depth of 5. That lookup trail is provided in the response and the final reassigned identity in the lookup list is returned as the `reassignToId` property. If no Reassignment Configuration is found for the specified identity & config type then the requested Identity ID will be used as the `reassignToId` value and the lookupTrail node will be empty.
     * @summary Evaluate Reassignment Configuration
     * @param {WorkReassignmentBetaApiGetEvaluateReassignmentConfigurationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkReassignmentBetaApi
     */
    public getEvaluateReassignmentConfiguration(requestParameters: WorkReassignmentBetaApiGetEvaluateReassignmentConfigurationRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkReassignmentBetaApiFp(this.configuration).getEvaluateReassignmentConfiguration(requestParameters.identityId, requestParameters.configType, requestParameters.exclusionFilters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a collection of types which are available in the Reassignment Configuration UI.
     * @summary List Reassignment Config Types
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkReassignmentBetaApi
     */
    public getReassignmentConfigTypes(axiosOptions?: AxiosRequestConfig) {
        return WorkReassignmentBetaApiFp(this.configuration).getReassignmentConfigTypes(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the Reassignment Configuration for an identity.
     * @summary Get Reassignment Configuration
     * @param {WorkReassignmentBetaApiGetReassignmentConfigurationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkReassignmentBetaApi
     */
    public getReassignmentConfiguration(requestParameters: WorkReassignmentBetaApiGetReassignmentConfigurationRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkReassignmentBetaApiFp(this.configuration).getReassignmentConfiguration(requestParameters.identityId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the global Reassignment Configuration settings for the requestor\'s tenant.
     * @summary Get Tenant-wide Reassignment Configuration settings
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkReassignmentBetaApi
     */
    public getTenantConfigConfiguration(axiosOptions?: AxiosRequestConfig) {
        return WorkReassignmentBetaApiFp(this.configuration).getTenantConfigConfiguration(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets all Reassignment configuration for the current org.
     * @summary List Reassignment Configurations
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkReassignmentBetaApi
     */
    public listReassignmentConfigurations(axiosOptions?: AxiosRequestConfig) {
        return WorkReassignmentBetaApiFp(this.configuration).listReassignmentConfigurations(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replaces existing Reassignment configuration for an identity with the newly provided configuration.
     * @summary Update Reassignment Configuration
     * @param {WorkReassignmentBetaApiPutReassignmentConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkReassignmentBetaApi
     */
    public putReassignmentConfig(requestParameters: WorkReassignmentBetaApiPutReassignmentConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkReassignmentBetaApiFp(this.configuration).putReassignmentConfig(requestParameters.identityId, requestParameters.configurationItemRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replaces existing Tenant-wide Reassignment Configuration settings with the newly provided settings.
     * @summary Update Tenant-wide Reassignment Configuration settings
     * @param {WorkReassignmentBetaApiPutTenantConfigurationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkReassignmentBetaApi
     */
    public putTenantConfiguration(requestParameters: WorkReassignmentBetaApiPutTenantConfigurationRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkReassignmentBetaApiFp(this.configuration).putTenantConfiguration(requestParameters.tenantConfigurationRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkflowsBetaApi - axios parameter creator
 * @export
 */
export const WorkflowsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this API to cancel a running workflow execution.
         * @summary Cancel Workflow Execution by ID
         * @param {string} id The workflow execution ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelWorkflowExecution: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelWorkflowExecution', 'id', id)
            const localVarPath = `/workflow-executions/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Create a new workflow with the desired trigger and steps specified in the request body.
         * @summary Create Workflow
         * @param {CreateWorkflowRequestBeta} createWorkflowRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflow: async (createWorkflowRequestBeta: CreateWorkflowRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWorkflowRequestBeta' is not null or undefined
            assertParamExists('createWorkflow', 'createWorkflowRequestBeta', createWorkflowRequestBeta)
            const localVarPath = `/workflows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWorkflowRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Delete a workflow.  **Enabled workflows cannot be deleted**.  They must first be disabled.
         * @summary Delete Workflow By Id
         * @param {string} id Id of the Workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteWorkflow', 'id', id)
            const localVarPath = `/workflows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get a single workflow by id.
         * @summary Get Workflow By Id
         * @param {string} id Id of the workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflow: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWorkflow', 'id', id)
            const localVarPath = `/workflows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get a single workflow execution.  Workflow executions are available for up to 90 days before being archived.  If you attempt to access a workflow execution that has been archived, you will receive a 404 Not Found.
         * @summary Get a Workflow Execution
         * @param {string} id Id of the workflow execution
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowExecution: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWorkflowExecution', 'id', id)
            const localVarPath = `/workflow-executions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get a detailed history of a single workflow execution.  Workflow executions are available for up to 90 days before being archived.  If you attempt to access a workflow execution that has been archived, you will receive a 404 Not Found.
         * @summary Get Workflow Execution History
         * @param {string} id Id of the workflow execution
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowExecutionHistory: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWorkflowExecutionHistory', 'id', id)
            const localVarPath = `/workflow-executions/{id}/history`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This lists all triggers, actions, and operators in the library
         * @summary List Complete Workflow Library
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCompleteWorkflowLibrary: async (limit?: number, offset?: number, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/workflow-library`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This lists the executions for a given workflow. Workflow executions are available for up to 90 days before being archived. By default, you can get a maximum of 250 executions.  To get executions past the first 250 records, you can do the following:  1. Use the [Get Workflows](https://developer.sailpoint.com/idn/api/beta/list-workflows) endpoint to get your workflows.  2. Get your workflow ID from the response.  3. You can then do either of the following:     - Filter to find relevant workflow executions.   For example, you can filter for failed workflow executions: `GET /workflows/:workflowID/executions?filters=status eq \"Failed\"`    - You can paginate through results with the `offset` parameter.    For example, you can page through 50 executions per page and use that as a way to get to the records past the first 250.    Refer to [Paginating Results](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results) for more information about the query parameters you can use to achieve pagination. 
         * @summary List Workflow Executions
         * @param {string} id Id of the workflow
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **start_time**: *eq, lt, lte, gt, gte*  **status**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowExecutions: async (id: string, limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listWorkflowExecutions', 'id', id)
            const localVarPath = `/workflows/{id}/executions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This lists the workflow actions available to you.
         * @summary List Workflow Library Actions
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowLibraryActions: async (limit?: number, offset?: number, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/workflow-library/actions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This lists the workflow operators available to you
         * @summary List Workflow Library Operators
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowLibraryOperators: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/workflow-library/operators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This lists the workflow triggers available to you
         * @summary List Workflow Library Triggers
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowLibraryTriggers: async (limit?: number, offset?: number, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/workflow-library/triggers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * List all workflows in the tenant.
         * @summary List Workflows
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflows: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/workflows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Partially update an existing Workflow using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.
         * @summary Patch Workflow
         * @param {string} id Id of the Workflow
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchWorkflow: async (id: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchWorkflow', 'id', id)
            // verify required parameter 'jsonPatchOperationBeta' is not null or undefined
            assertParamExists('patchWorkflow', 'jsonPatchOperationBeta', jsonPatchOperationBeta)
            const localVarPath = `/workflows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperationBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows a service outside of IdentityNow to initiate a workflow that uses the \"External Trigger\" step.  The external service will invoke this endpoint with the input data it wants to send to the workflow in the body.
         * @summary Execute Workflow via External Trigger
         * @param {string} id Id of the workflow
         * @param {PostExternalExecuteWorkflowRequestBeta} [postExternalExecuteWorkflowRequestBeta] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        postExternalExecuteWorkflow: async (id: string, postExternalExecuteWorkflowRequestBeta?: PostExternalExecuteWorkflowRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postExternalExecuteWorkflow', 'id', id)
            const localVarPath = `/workflows/execute/external/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postExternalExecuteWorkflowRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Create OAuth client ID, client secret, and callback URL for use in an external trigger.  External triggers will need this information to generate an access token to authenticate to the callback URL and submit a trigger payload that will initiate the workflow.
         * @summary Generate External Trigger OAuth Client
         * @param {string} id Id of the workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        postWorkflowExternalTrigger: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postWorkflowExternalTrigger', 'id', id)
            const localVarPath = `/workflows/{id}/external/oauth-clients`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Validate a workflow with an \"External Trigger\" can receive input.  The response includes the input that the workflow received, which can be used to validate that the input is intact when it reaches the workflow.
         * @summary Test Workflow via External Trigger
         * @param {string} id Id of the workflow
         * @param {TestExternalExecuteWorkflowRequestBeta} [testExternalExecuteWorkflowRequestBeta] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testExternalExecuteWorkflow: async (id: string, testExternalExecuteWorkflowRequestBeta?: TestExternalExecuteWorkflowRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('testExternalExecuteWorkflow', 'id', id)
            const localVarPath = `/workflows/execute/external/{id}/test`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testExternalExecuteWorkflowRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Test a workflow with the provided input data.  The input data should resemble the input that the trigger will send the workflow.  See the [event trigger documentation](https://developer.sailpoint.com/idn/docs/event-triggers/available) for an example input for the trigger that initiates this workflow. This endpoint will return an execution ID, which can be used to lookup more information about the execution using the `Get a Workflow Execution` endpoint. **This will cause a live run of the workflow, which could result in unintended modifications to your IDN tenant.**
         * @summary Test Workflow By Id
         * @param {string} id Id of the workflow
         * @param {TestWorkflowRequestBeta} testWorkflowRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testWorkflow: async (id: string, testWorkflowRequestBeta: TestWorkflowRequestBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('testWorkflow', 'id', id)
            // verify required parameter 'testWorkflowRequestBeta' is not null or undefined
            assertParamExists('testWorkflow', 'testWorkflowRequestBeta', testWorkflowRequestBeta)
            const localVarPath = `/workflows/{id}/test`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testWorkflowRequestBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Perform a full update of a workflow.  The updated workflow object is returned in the response.
         * @summary Update Workflow
         * @param {string} id Id of the Workflow
         * @param {WorkflowBodyBeta} workflowBodyBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflow: async (id: string, workflowBodyBeta: WorkflowBodyBeta, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateWorkflow', 'id', id)
            // verify required parameter 'workflowBodyBeta' is not null or undefined
            assertParamExists('updateWorkflow', 'workflowBodyBeta', workflowBodyBeta)
            const localVarPath = `/workflows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowBodyBeta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsBetaApi - functional programming interface
 * @export
 */
export const WorkflowsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkflowsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this API to cancel a running workflow execution.
         * @summary Cancel Workflow Execution by ID
         * @param {string} id The workflow execution ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async cancelWorkflowExecution(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelWorkflowExecution(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new workflow with the desired trigger and steps specified in the request body.
         * @summary Create Workflow
         * @param {CreateWorkflowRequestBeta} createWorkflowRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkflow(createWorkflowRequestBeta: CreateWorkflowRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkflow(createWorkflowRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a workflow.  **Enabled workflows cannot be deleted**.  They must first be disabled.
         * @summary Delete Workflow By Id
         * @param {string} id Id of the Workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkflow(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkflow(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single workflow by id.
         * @summary Get Workflow By Id
         * @param {string} id Id of the workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflow(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflow(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single workflow execution.  Workflow executions are available for up to 90 days before being archived.  If you attempt to access a workflow execution that has been archived, you will receive a 404 Not Found.
         * @summary Get a Workflow Execution
         * @param {string} id Id of the workflow execution
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowExecution(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowExecution(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a detailed history of a single workflow execution.  Workflow executions are available for up to 90 days before being archived.  If you attempt to access a workflow execution that has been archived, you will receive a 404 Not Found.
         * @summary Get Workflow Execution History
         * @param {string} id Id of the workflow execution
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowExecutionHistory(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowExecutionEventBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowExecutionHistory(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This lists all triggers, actions, and operators in the library
         * @summary List Complete Workflow Library
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listCompleteWorkflowLibrary(limit?: number, offset?: number, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListCompleteWorkflowLibrary200ResponseInnerBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCompleteWorkflowLibrary(limit, offset, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This lists the executions for a given workflow. Workflow executions are available for up to 90 days before being archived. By default, you can get a maximum of 250 executions.  To get executions past the first 250 records, you can do the following:  1. Use the [Get Workflows](https://developer.sailpoint.com/idn/api/beta/list-workflows) endpoint to get your workflows.  2. Get your workflow ID from the response.  3. You can then do either of the following:     - Filter to find relevant workflow executions.   For example, you can filter for failed workflow executions: `GET /workflows/:workflowID/executions?filters=status eq \"Failed\"`    - You can paginate through results with the `offset` parameter.    For example, you can page through 50 executions per page and use that as a way to get to the records past the first 250.    Refer to [Paginating Results](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results) for more information about the query parameters you can use to achieve pagination. 
         * @summary List Workflow Executions
         * @param {string} id Id of the workflow
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **start_time**: *eq, lt, lte, gt, gte*  **status**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkflowExecutions(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowExecutionBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkflowExecutions(id, limit, offset, count, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This lists the workflow actions available to you.
         * @summary List Workflow Library Actions
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkflowLibraryActions(limit?: number, offset?: number, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowLibraryActionBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkflowLibraryActions(limit, offset, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This lists the workflow operators available to you
         * @summary List Workflow Library Operators
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkflowLibraryOperators(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowLibraryOperatorBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkflowLibraryOperators(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This lists the workflow triggers available to you
         * @summary List Workflow Library Triggers
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkflowLibraryTriggers(limit?: number, offset?: number, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowLibraryTriggerBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkflowLibraryTriggers(limit, offset, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all workflows in the tenant.
         * @summary List Workflows
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkflows(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowBeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkflows(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Partially update an existing Workflow using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.
         * @summary Patch Workflow
         * @param {string} id Id of the Workflow
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchWorkflow(id: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchWorkflow(id, jsonPatchOperationBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows a service outside of IdentityNow to initiate a workflow that uses the \"External Trigger\" step.  The external service will invoke this endpoint with the input data it wants to send to the workflow in the body.
         * @summary Execute Workflow via External Trigger
         * @param {string} id Id of the workflow
         * @param {PostExternalExecuteWorkflowRequestBeta} [postExternalExecuteWorkflowRequestBeta] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async postExternalExecuteWorkflow(id: string, postExternalExecuteWorkflowRequestBeta?: PostExternalExecuteWorkflowRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostExternalExecuteWorkflow200ResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postExternalExecuteWorkflow(id, postExternalExecuteWorkflowRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create OAuth client ID, client secret, and callback URL for use in an external trigger.  External triggers will need this information to generate an access token to authenticate to the callback URL and submit a trigger payload that will initiate the workflow.
         * @summary Generate External Trigger OAuth Client
         * @param {string} id Id of the workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async postWorkflowExternalTrigger(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowOAuthClientBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postWorkflowExternalTrigger(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validate a workflow with an \"External Trigger\" can receive input.  The response includes the input that the workflow received, which can be used to validate that the input is intact when it reaches the workflow.
         * @summary Test Workflow via External Trigger
         * @param {string} id Id of the workflow
         * @param {TestExternalExecuteWorkflowRequestBeta} [testExternalExecuteWorkflowRequestBeta] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async testExternalExecuteWorkflow(id: string, testExternalExecuteWorkflowRequestBeta?: TestExternalExecuteWorkflowRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestExternalExecuteWorkflow200ResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testExternalExecuteWorkflow(id, testExternalExecuteWorkflowRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Test a workflow with the provided input data.  The input data should resemble the input that the trigger will send the workflow.  See the [event trigger documentation](https://developer.sailpoint.com/idn/docs/event-triggers/available) for an example input for the trigger that initiates this workflow. This endpoint will return an execution ID, which can be used to lookup more information about the execution using the `Get a Workflow Execution` endpoint. **This will cause a live run of the workflow, which could result in unintended modifications to your IDN tenant.**
         * @summary Test Workflow By Id
         * @param {string} id Id of the workflow
         * @param {TestWorkflowRequestBeta} testWorkflowRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async testWorkflow(id: string, testWorkflowRequestBeta: TestWorkflowRequestBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestWorkflow200ResponseBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testWorkflow(id, testWorkflowRequestBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Perform a full update of a workflow.  The updated workflow object is returned in the response.
         * @summary Update Workflow
         * @param {string} id Id of the Workflow
         * @param {WorkflowBodyBeta} workflowBodyBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkflow(id: string, workflowBodyBeta: WorkflowBodyBeta, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowBeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkflow(id, workflowBodyBeta, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkflowsBetaApi - factory interface
 * @export
 */
export const WorkflowsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkflowsBetaApiFp(configuration)
    return {
        /**
         * Use this API to cancel a running workflow execution.
         * @summary Cancel Workflow Execution by ID
         * @param {string} id The workflow execution ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelWorkflowExecution(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.cancelWorkflowExecution(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Create a new workflow with the desired trigger and steps specified in the request body.
         * @summary Create Workflow
         * @param {CreateWorkflowRequestBeta} createWorkflowRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflow(createWorkflowRequestBeta: CreateWorkflowRequestBeta, axiosOptions?: any): AxiosPromise<WorkflowBeta> {
            return localVarFp.createWorkflow(createWorkflowRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Delete a workflow.  **Enabled workflows cannot be deleted**.  They must first be disabled.
         * @summary Delete Workflow By Id
         * @param {string} id Id of the Workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteWorkflow(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get a single workflow by id.
         * @summary Get Workflow By Id
         * @param {string} id Id of the workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflow(id: string, axiosOptions?: any): AxiosPromise<WorkflowBeta> {
            return localVarFp.getWorkflow(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get a single workflow execution.  Workflow executions are available for up to 90 days before being archived.  If you attempt to access a workflow execution that has been archived, you will receive a 404 Not Found.
         * @summary Get a Workflow Execution
         * @param {string} id Id of the workflow execution
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowExecution(id: string, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.getWorkflowExecution(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get a detailed history of a single workflow execution.  Workflow executions are available for up to 90 days before being archived.  If you attempt to access a workflow execution that has been archived, you will receive a 404 Not Found.
         * @summary Get Workflow Execution History
         * @param {string} id Id of the workflow execution
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowExecutionHistory(id: string, axiosOptions?: any): AxiosPromise<Array<WorkflowExecutionEventBeta>> {
            return localVarFp.getWorkflowExecutionHistory(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This lists all triggers, actions, and operators in the library
         * @summary List Complete Workflow Library
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCompleteWorkflowLibrary(limit?: number, offset?: number, axiosOptions?: any): AxiosPromise<Array<ListCompleteWorkflowLibrary200ResponseInnerBeta>> {
            return localVarFp.listCompleteWorkflowLibrary(limit, offset, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This lists the executions for a given workflow. Workflow executions are available for up to 90 days before being archived. By default, you can get a maximum of 250 executions.  To get executions past the first 250 records, you can do the following:  1. Use the [Get Workflows](https://developer.sailpoint.com/idn/api/beta/list-workflows) endpoint to get your workflows.  2. Get your workflow ID from the response.  3. You can then do either of the following:     - Filter to find relevant workflow executions.   For example, you can filter for failed workflow executions: `GET /workflows/:workflowID/executions?filters=status eq \"Failed\"`    - You can paginate through results with the `offset` parameter.    For example, you can page through 50 executions per page and use that as a way to get to the records past the first 250.    Refer to [Paginating Results](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results) for more information about the query parameters you can use to achieve pagination. 
         * @summary List Workflow Executions
         * @param {string} id Id of the workflow
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **start_time**: *eq, lt, lte, gt, gte*  **status**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowExecutions(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: any): AxiosPromise<Array<WorkflowExecutionBeta>> {
            return localVarFp.listWorkflowExecutions(id, limit, offset, count, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This lists the workflow actions available to you.
         * @summary List Workflow Library Actions
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowLibraryActions(limit?: number, offset?: number, filters?: string, axiosOptions?: any): AxiosPromise<Array<WorkflowLibraryActionBeta>> {
            return localVarFp.listWorkflowLibraryActions(limit, offset, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This lists the workflow operators available to you
         * @summary List Workflow Library Operators
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowLibraryOperators(axiosOptions?: any): AxiosPromise<Array<WorkflowLibraryOperatorBeta>> {
            return localVarFp.listWorkflowLibraryOperators(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This lists the workflow triggers available to you
         * @summary List Workflow Library Triggers
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowLibraryTriggers(limit?: number, offset?: number, filters?: string, axiosOptions?: any): AxiosPromise<Array<WorkflowLibraryTriggerBeta>> {
            return localVarFp.listWorkflowLibraryTriggers(limit, offset, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * List all workflows in the tenant.
         * @summary List Workflows
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflows(axiosOptions?: any): AxiosPromise<Array<WorkflowBeta>> {
            return localVarFp.listWorkflows(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Partially update an existing Workflow using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.
         * @summary Patch Workflow
         * @param {string} id Id of the Workflow
         * @param {Array<JsonPatchOperationBeta>} jsonPatchOperationBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchWorkflow(id: string, jsonPatchOperationBeta: Array<JsonPatchOperationBeta>, axiosOptions?: any): AxiosPromise<WorkflowBeta> {
            return localVarFp.patchWorkflow(id, jsonPatchOperationBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows a service outside of IdentityNow to initiate a workflow that uses the \"External Trigger\" step.  The external service will invoke this endpoint with the input data it wants to send to the workflow in the body.
         * @summary Execute Workflow via External Trigger
         * @param {string} id Id of the workflow
         * @param {PostExternalExecuteWorkflowRequestBeta} [postExternalExecuteWorkflowRequestBeta] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        postExternalExecuteWorkflow(id: string, postExternalExecuteWorkflowRequestBeta?: PostExternalExecuteWorkflowRequestBeta, axiosOptions?: any): AxiosPromise<PostExternalExecuteWorkflow200ResponseBeta> {
            return localVarFp.postExternalExecuteWorkflow(id, postExternalExecuteWorkflowRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Create OAuth client ID, client secret, and callback URL for use in an external trigger.  External triggers will need this information to generate an access token to authenticate to the callback URL and submit a trigger payload that will initiate the workflow.
         * @summary Generate External Trigger OAuth Client
         * @param {string} id Id of the workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        postWorkflowExternalTrigger(id: string, axiosOptions?: any): AxiosPromise<WorkflowOAuthClientBeta> {
            return localVarFp.postWorkflowExternalTrigger(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Validate a workflow with an \"External Trigger\" can receive input.  The response includes the input that the workflow received, which can be used to validate that the input is intact when it reaches the workflow.
         * @summary Test Workflow via External Trigger
         * @param {string} id Id of the workflow
         * @param {TestExternalExecuteWorkflowRequestBeta} [testExternalExecuteWorkflowRequestBeta] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testExternalExecuteWorkflow(id: string, testExternalExecuteWorkflowRequestBeta?: TestExternalExecuteWorkflowRequestBeta, axiosOptions?: any): AxiosPromise<TestExternalExecuteWorkflow200ResponseBeta> {
            return localVarFp.testExternalExecuteWorkflow(id, testExternalExecuteWorkflowRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Test a workflow with the provided input data.  The input data should resemble the input that the trigger will send the workflow.  See the [event trigger documentation](https://developer.sailpoint.com/idn/docs/event-triggers/available) for an example input for the trigger that initiates this workflow. This endpoint will return an execution ID, which can be used to lookup more information about the execution using the `Get a Workflow Execution` endpoint. **This will cause a live run of the workflow, which could result in unintended modifications to your IDN tenant.**
         * @summary Test Workflow By Id
         * @param {string} id Id of the workflow
         * @param {TestWorkflowRequestBeta} testWorkflowRequestBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testWorkflow(id: string, testWorkflowRequestBeta: TestWorkflowRequestBeta, axiosOptions?: any): AxiosPromise<TestWorkflow200ResponseBeta> {
            return localVarFp.testWorkflow(id, testWorkflowRequestBeta, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Perform a full update of a workflow.  The updated workflow object is returned in the response.
         * @summary Update Workflow
         * @param {string} id Id of the Workflow
         * @param {WorkflowBodyBeta} workflowBodyBeta 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflow(id: string, workflowBodyBeta: WorkflowBodyBeta, axiosOptions?: any): AxiosPromise<WorkflowBeta> {
            return localVarFp.updateWorkflow(id, workflowBodyBeta, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancelWorkflowExecution operation in WorkflowsBetaApi.
 * @export
 * @interface WorkflowsBetaApiCancelWorkflowExecutionRequest
 */
export interface WorkflowsBetaApiCancelWorkflowExecutionRequest {
    /**
     * The workflow execution ID
     * @type {string}
     * @memberof WorkflowsBetaApiCancelWorkflowExecution
     */
    readonly id: string
}

/**
 * Request parameters for createWorkflow operation in WorkflowsBetaApi.
 * @export
 * @interface WorkflowsBetaApiCreateWorkflowRequest
 */
export interface WorkflowsBetaApiCreateWorkflowRequest {
    /**
     * 
     * @type {CreateWorkflowRequestBeta}
     * @memberof WorkflowsBetaApiCreateWorkflow
     */
    readonly createWorkflowRequestBeta: CreateWorkflowRequestBeta
}

/**
 * Request parameters for deleteWorkflow operation in WorkflowsBetaApi.
 * @export
 * @interface WorkflowsBetaApiDeleteWorkflowRequest
 */
export interface WorkflowsBetaApiDeleteWorkflowRequest {
    /**
     * Id of the Workflow
     * @type {string}
     * @memberof WorkflowsBetaApiDeleteWorkflow
     */
    readonly id: string
}

/**
 * Request parameters for getWorkflow operation in WorkflowsBetaApi.
 * @export
 * @interface WorkflowsBetaApiGetWorkflowRequest
 */
export interface WorkflowsBetaApiGetWorkflowRequest {
    /**
     * Id of the workflow
     * @type {string}
     * @memberof WorkflowsBetaApiGetWorkflow
     */
    readonly id: string
}

/**
 * Request parameters for getWorkflowExecution operation in WorkflowsBetaApi.
 * @export
 * @interface WorkflowsBetaApiGetWorkflowExecutionRequest
 */
export interface WorkflowsBetaApiGetWorkflowExecutionRequest {
    /**
     * Id of the workflow execution
     * @type {string}
     * @memberof WorkflowsBetaApiGetWorkflowExecution
     */
    readonly id: string
}

/**
 * Request parameters for getWorkflowExecutionHistory operation in WorkflowsBetaApi.
 * @export
 * @interface WorkflowsBetaApiGetWorkflowExecutionHistoryRequest
 */
export interface WorkflowsBetaApiGetWorkflowExecutionHistoryRequest {
    /**
     * Id of the workflow execution
     * @type {string}
     * @memberof WorkflowsBetaApiGetWorkflowExecutionHistory
     */
    readonly id: string
}

/**
 * Request parameters for listCompleteWorkflowLibrary operation in WorkflowsBetaApi.
 * @export
 * @interface WorkflowsBetaApiListCompleteWorkflowLibraryRequest
 */
export interface WorkflowsBetaApiListCompleteWorkflowLibraryRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkflowsBetaApiListCompleteWorkflowLibrary
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkflowsBetaApiListCompleteWorkflowLibrary
     */
    readonly offset?: number
}

/**
 * Request parameters for listWorkflowExecutions operation in WorkflowsBetaApi.
 * @export
 * @interface WorkflowsBetaApiListWorkflowExecutionsRequest
 */
export interface WorkflowsBetaApiListWorkflowExecutionsRequest {
    /**
     * Id of the workflow
     * @type {string}
     * @memberof WorkflowsBetaApiListWorkflowExecutions
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkflowsBetaApiListWorkflowExecutions
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkflowsBetaApiListWorkflowExecutions
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof WorkflowsBetaApiListWorkflowExecutions
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **start_time**: *eq, lt, lte, gt, gte*  **status**: *eq*
     * @type {string}
     * @memberof WorkflowsBetaApiListWorkflowExecutions
     */
    readonly filters?: string
}

/**
 * Request parameters for listWorkflowLibraryActions operation in WorkflowsBetaApi.
 * @export
 * @interface WorkflowsBetaApiListWorkflowLibraryActionsRequest
 */
export interface WorkflowsBetaApiListWorkflowLibraryActionsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkflowsBetaApiListWorkflowLibraryActions
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkflowsBetaApiListWorkflowLibraryActions
     */
    readonly offset?: number

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
     * @type {string}
     * @memberof WorkflowsBetaApiListWorkflowLibraryActions
     */
    readonly filters?: string
}

/**
 * Request parameters for listWorkflowLibraryTriggers operation in WorkflowsBetaApi.
 * @export
 * @interface WorkflowsBetaApiListWorkflowLibraryTriggersRequest
 */
export interface WorkflowsBetaApiListWorkflowLibraryTriggersRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkflowsBetaApiListWorkflowLibraryTriggers
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkflowsBetaApiListWorkflowLibraryTriggers
     */
    readonly offset?: number

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
     * @type {string}
     * @memberof WorkflowsBetaApiListWorkflowLibraryTriggers
     */
    readonly filters?: string
}

/**
 * Request parameters for patchWorkflow operation in WorkflowsBetaApi.
 * @export
 * @interface WorkflowsBetaApiPatchWorkflowRequest
 */
export interface WorkflowsBetaApiPatchWorkflowRequest {
    /**
     * Id of the Workflow
     * @type {string}
     * @memberof WorkflowsBetaApiPatchWorkflow
     */
    readonly id: string

    /**
     * 
     * @type {Array<JsonPatchOperationBeta>}
     * @memberof WorkflowsBetaApiPatchWorkflow
     */
    readonly jsonPatchOperationBeta: Array<JsonPatchOperationBeta>
}

/**
 * Request parameters for postExternalExecuteWorkflow operation in WorkflowsBetaApi.
 * @export
 * @interface WorkflowsBetaApiPostExternalExecuteWorkflowRequest
 */
export interface WorkflowsBetaApiPostExternalExecuteWorkflowRequest {
    /**
     * Id of the workflow
     * @type {string}
     * @memberof WorkflowsBetaApiPostExternalExecuteWorkflow
     */
    readonly id: string

    /**
     * 
     * @type {PostExternalExecuteWorkflowRequestBeta}
     * @memberof WorkflowsBetaApiPostExternalExecuteWorkflow
     */
    readonly postExternalExecuteWorkflowRequestBeta?: PostExternalExecuteWorkflowRequestBeta
}

/**
 * Request parameters for postWorkflowExternalTrigger operation in WorkflowsBetaApi.
 * @export
 * @interface WorkflowsBetaApiPostWorkflowExternalTriggerRequest
 */
export interface WorkflowsBetaApiPostWorkflowExternalTriggerRequest {
    /**
     * Id of the workflow
     * @type {string}
     * @memberof WorkflowsBetaApiPostWorkflowExternalTrigger
     */
    readonly id: string
}

/**
 * Request parameters for testExternalExecuteWorkflow operation in WorkflowsBetaApi.
 * @export
 * @interface WorkflowsBetaApiTestExternalExecuteWorkflowRequest
 */
export interface WorkflowsBetaApiTestExternalExecuteWorkflowRequest {
    /**
     * Id of the workflow
     * @type {string}
     * @memberof WorkflowsBetaApiTestExternalExecuteWorkflow
     */
    readonly id: string

    /**
     * 
     * @type {TestExternalExecuteWorkflowRequestBeta}
     * @memberof WorkflowsBetaApiTestExternalExecuteWorkflow
     */
    readonly testExternalExecuteWorkflowRequestBeta?: TestExternalExecuteWorkflowRequestBeta
}

/**
 * Request parameters for testWorkflow operation in WorkflowsBetaApi.
 * @export
 * @interface WorkflowsBetaApiTestWorkflowRequest
 */
export interface WorkflowsBetaApiTestWorkflowRequest {
    /**
     * Id of the workflow
     * @type {string}
     * @memberof WorkflowsBetaApiTestWorkflow
     */
    readonly id: string

    /**
     * 
     * @type {TestWorkflowRequestBeta}
     * @memberof WorkflowsBetaApiTestWorkflow
     */
    readonly testWorkflowRequestBeta: TestWorkflowRequestBeta
}

/**
 * Request parameters for updateWorkflow operation in WorkflowsBetaApi.
 * @export
 * @interface WorkflowsBetaApiUpdateWorkflowRequest
 */
export interface WorkflowsBetaApiUpdateWorkflowRequest {
    /**
     * Id of the Workflow
     * @type {string}
     * @memberof WorkflowsBetaApiUpdateWorkflow
     */
    readonly id: string

    /**
     * 
     * @type {WorkflowBodyBeta}
     * @memberof WorkflowsBetaApiUpdateWorkflow
     */
    readonly workflowBodyBeta: WorkflowBodyBeta
}

/**
 * WorkflowsBetaApi - object-oriented interface
 * @export
 * @class WorkflowsBetaApi
 * @extends {BaseAPI}
 */
export class WorkflowsBetaApi extends BaseAPI {
    /**
     * Use this API to cancel a running workflow execution.
     * @summary Cancel Workflow Execution by ID
     * @param {WorkflowsBetaApiCancelWorkflowExecutionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsBetaApi
     */
    public cancelWorkflowExecution(requestParameters: WorkflowsBetaApiCancelWorkflowExecutionRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsBetaApiFp(this.configuration).cancelWorkflowExecution(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new workflow with the desired trigger and steps specified in the request body.
     * @summary Create Workflow
     * @param {WorkflowsBetaApiCreateWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsBetaApi
     */
    public createWorkflow(requestParameters: WorkflowsBetaApiCreateWorkflowRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsBetaApiFp(this.configuration).createWorkflow(requestParameters.createWorkflowRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a workflow.  **Enabled workflows cannot be deleted**.  They must first be disabled.
     * @summary Delete Workflow By Id
     * @param {WorkflowsBetaApiDeleteWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsBetaApi
     */
    public deleteWorkflow(requestParameters: WorkflowsBetaApiDeleteWorkflowRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsBetaApiFp(this.configuration).deleteWorkflow(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single workflow by id.
     * @summary Get Workflow By Id
     * @param {WorkflowsBetaApiGetWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsBetaApi
     */
    public getWorkflow(requestParameters: WorkflowsBetaApiGetWorkflowRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsBetaApiFp(this.configuration).getWorkflow(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single workflow execution.  Workflow executions are available for up to 90 days before being archived.  If you attempt to access a workflow execution that has been archived, you will receive a 404 Not Found.
     * @summary Get a Workflow Execution
     * @param {WorkflowsBetaApiGetWorkflowExecutionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsBetaApi
     */
    public getWorkflowExecution(requestParameters: WorkflowsBetaApiGetWorkflowExecutionRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsBetaApiFp(this.configuration).getWorkflowExecution(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a detailed history of a single workflow execution.  Workflow executions are available for up to 90 days before being archived.  If you attempt to access a workflow execution that has been archived, you will receive a 404 Not Found.
     * @summary Get Workflow Execution History
     * @param {WorkflowsBetaApiGetWorkflowExecutionHistoryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsBetaApi
     */
    public getWorkflowExecutionHistory(requestParameters: WorkflowsBetaApiGetWorkflowExecutionHistoryRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsBetaApiFp(this.configuration).getWorkflowExecutionHistory(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This lists all triggers, actions, and operators in the library
     * @summary List Complete Workflow Library
     * @param {WorkflowsBetaApiListCompleteWorkflowLibraryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsBetaApi
     */
    public listCompleteWorkflowLibrary(requestParameters: WorkflowsBetaApiListCompleteWorkflowLibraryRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsBetaApiFp(this.configuration).listCompleteWorkflowLibrary(requestParameters.limit, requestParameters.offset, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This lists the executions for a given workflow. Workflow executions are available for up to 90 days before being archived. By default, you can get a maximum of 250 executions.  To get executions past the first 250 records, you can do the following:  1. Use the [Get Workflows](https://developer.sailpoint.com/idn/api/beta/list-workflows) endpoint to get your workflows.  2. Get your workflow ID from the response.  3. You can then do either of the following:     - Filter to find relevant workflow executions.   For example, you can filter for failed workflow executions: `GET /workflows/:workflowID/executions?filters=status eq \"Failed\"`    - You can paginate through results with the `offset` parameter.    For example, you can page through 50 executions per page and use that as a way to get to the records past the first 250.    Refer to [Paginating Results](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results) for more information about the query parameters you can use to achieve pagination. 
     * @summary List Workflow Executions
     * @param {WorkflowsBetaApiListWorkflowExecutionsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsBetaApi
     */
    public listWorkflowExecutions(requestParameters: WorkflowsBetaApiListWorkflowExecutionsRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsBetaApiFp(this.configuration).listWorkflowExecutions(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This lists the workflow actions available to you.
     * @summary List Workflow Library Actions
     * @param {WorkflowsBetaApiListWorkflowLibraryActionsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsBetaApi
     */
    public listWorkflowLibraryActions(requestParameters: WorkflowsBetaApiListWorkflowLibraryActionsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsBetaApiFp(this.configuration).listWorkflowLibraryActions(requestParameters.limit, requestParameters.offset, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This lists the workflow operators available to you
     * @summary List Workflow Library Operators
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsBetaApi
     */
    public listWorkflowLibraryOperators(axiosOptions?: AxiosRequestConfig) {
        return WorkflowsBetaApiFp(this.configuration).listWorkflowLibraryOperators(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This lists the workflow triggers available to you
     * @summary List Workflow Library Triggers
     * @param {WorkflowsBetaApiListWorkflowLibraryTriggersRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsBetaApi
     */
    public listWorkflowLibraryTriggers(requestParameters: WorkflowsBetaApiListWorkflowLibraryTriggersRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsBetaApiFp(this.configuration).listWorkflowLibraryTriggers(requestParameters.limit, requestParameters.offset, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all workflows in the tenant.
     * @summary List Workflows
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsBetaApi
     */
    public listWorkflows(axiosOptions?: AxiosRequestConfig) {
        return WorkflowsBetaApiFp(this.configuration).listWorkflows(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Partially update an existing Workflow using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.
     * @summary Patch Workflow
     * @param {WorkflowsBetaApiPatchWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsBetaApi
     */
    public patchWorkflow(requestParameters: WorkflowsBetaApiPatchWorkflowRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsBetaApiFp(this.configuration).patchWorkflow(requestParameters.id, requestParameters.jsonPatchOperationBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows a service outside of IdentityNow to initiate a workflow that uses the \"External Trigger\" step.  The external service will invoke this endpoint with the input data it wants to send to the workflow in the body.
     * @summary Execute Workflow via External Trigger
     * @param {WorkflowsBetaApiPostExternalExecuteWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsBetaApi
     */
    public postExternalExecuteWorkflow(requestParameters: WorkflowsBetaApiPostExternalExecuteWorkflowRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsBetaApiFp(this.configuration).postExternalExecuteWorkflow(requestParameters.id, requestParameters.postExternalExecuteWorkflowRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create OAuth client ID, client secret, and callback URL for use in an external trigger.  External triggers will need this information to generate an access token to authenticate to the callback URL and submit a trigger payload that will initiate the workflow.
     * @summary Generate External Trigger OAuth Client
     * @param {WorkflowsBetaApiPostWorkflowExternalTriggerRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsBetaApi
     */
    public postWorkflowExternalTrigger(requestParameters: WorkflowsBetaApiPostWorkflowExternalTriggerRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsBetaApiFp(this.configuration).postWorkflowExternalTrigger(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate a workflow with an \"External Trigger\" can receive input.  The response includes the input that the workflow received, which can be used to validate that the input is intact when it reaches the workflow.
     * @summary Test Workflow via External Trigger
     * @param {WorkflowsBetaApiTestExternalExecuteWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsBetaApi
     */
    public testExternalExecuteWorkflow(requestParameters: WorkflowsBetaApiTestExternalExecuteWorkflowRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsBetaApiFp(this.configuration).testExternalExecuteWorkflow(requestParameters.id, requestParameters.testExternalExecuteWorkflowRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test a workflow with the provided input data.  The input data should resemble the input that the trigger will send the workflow.  See the [event trigger documentation](https://developer.sailpoint.com/idn/docs/event-triggers/available) for an example input for the trigger that initiates this workflow. This endpoint will return an execution ID, which can be used to lookup more information about the execution using the `Get a Workflow Execution` endpoint. **This will cause a live run of the workflow, which could result in unintended modifications to your IDN tenant.**
     * @summary Test Workflow By Id
     * @param {WorkflowsBetaApiTestWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsBetaApi
     */
    public testWorkflow(requestParameters: WorkflowsBetaApiTestWorkflowRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsBetaApiFp(this.configuration).testWorkflow(requestParameters.id, requestParameters.testWorkflowRequestBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Perform a full update of a workflow.  The updated workflow object is returned in the response.
     * @summary Update Workflow
     * @param {WorkflowsBetaApiUpdateWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsBetaApi
     */
    public updateWorkflow(requestParameters: WorkflowsBetaApiUpdateWorkflowRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsBetaApiFp(this.configuration).updateWorkflow(requestParameters.id, requestParameters.workflowBodyBeta, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


